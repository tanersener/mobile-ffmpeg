<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This manual is last updated 27 June 2019 for version
3.6.10 of GnuTLS.

Copyright (C) 2001-2019 Free Software Foundation, Inc.\\
Copyright (C) 2001-2019 Nikos Mavrogiannopoulos

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included in the section entitled "GNU Free
Documentation License". -->
<!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>GnuTLS 3.6.10</title>

<meta name="description" content="GnuTLS 3.6.10">
<meta name="keywords" content="GnuTLS 3.6.10">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="#Top" rel="start" title="Top">
<link href="#Function-and-Data-Index" rel="index" title="Function and Data Index">
<link href="#SEC_Contents" rel="contents" title="Table of Contents">
<link href="dir.html#Top" rel="up" title="(dir)">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
body { 
	margin: 2%;
	padding: 0 5%;
	background: #ffffff;
}
h1,h2,h3,h4,h5 {
    font-weight: bold;
    padding: 5px 5px 5px 5px;
    background-color: #c2e0ff;
    color: #336699;
}
h1 {
    padding: 2em 2em 2em 5%;
    color: white;
    background: #336699;
    text-align: center;
    letter-spacing: 3px;
}
h2 { text-decoration: underline; }
pre {
  margin: 0 5%;
  padding: 0.5em;
}
pre.example,pre.verbatim {
  padding-bottom: 1em;

  border: solid #c2e0ff;
  background: #f0faff;
  border-width: 1px 1px 1px 5px;
  margin: 1em auto;
  width: 90%;
}

div.node {
  margin: 0 -5% 0 -2%;
  padding: 0.5em 0.5em;
  margin-top: 0.5em;
  margin-bottom: 0.5em;
  font-weight: bold;
}
dd, li {
  padding-top: 0.1em;
  padding-bottom: 0.1em;
}
div.float {

  margin-bottom: 0.5em;
  text-align: center;
}

table {
  text-align: left;
  margin-left:auto;
  margin-right:auto;
  border-spacing: 7px;
  width: 50%;
}

th {
  padding: 0;
  color: #336699;
  background-color: #c2e0ff;
  border: solid #000000;
  border-width: 0px;
  margin: 1em auto;
  text-align: center;
  margin-left:auto;
  margin-right:auto;
}

td {
  padding: 0;
  border: solid #000000;
  background-color: #f0faff;
  border-width: 0px;
  margin: 1em auto;
  text-align: left;
  margin-left:auto;
  margin-right:auto;
  padding-left: 1em;
}

dl {
  text-align: left;
  margin-left:auto;
  margin-right:auto;
  width: 50%;

  padding-left: 1em;
  border: solid #c2e0ff;
  background: #f0faff;
  border-width: 5px 1px 1px 1px;
  margin: 1em auto;
}

-->
</style>


</head>

<body lang="en">
<h1 class="settitle" align="center">GnuTLS 3.6.10</h1>


















<span id="SEC_Contents"></span>
<h2 class="contents-heading">Table of Contents</h2>

<div class="contents">

<ul class="no-bullet">
  <li><a id="toc-Preface-1" href="#Preface">1 Preface</a></li>
  <li><a id="toc-Introduction-to-GnuTLS-1" href="#Introduction-to-GnuTLS">2 Introduction to GnuTLS</a>
  <ul class="no-bullet">
    <li><a id="toc-Downloading-and-installing-1" href="#Downloading-and-installing">2.1 Downloading and installing</a></li>
    <li><a id="toc-Installing-for-a-software-distribution-1" href="#Installing-for-a-software-distribution">2.2 Installing for a software distribution</a></li>
    <li><a id="toc-Overview" href="#Document-overview">2.3 Overview</a></li>
  </ul></li>
  <li><a id="toc-Introduction-to-TLS-and-DTLS" href="#Introduction-to-TLS">3 Introduction to <acronym>TLS</acronym> and <acronym>DTLS</acronym></a>
  <ul class="no-bullet">
    <li><a id="toc-TLS-Layers" href="#TLS-layers">3.1 TLS Layers</a></li>
    <li><a id="toc-The-Transport-Layer" href="#The-transport-layer">3.2 The Transport Layer</a></li>
    <li><a id="toc-The-TLS-record-protocol-1" href="#The-TLS-record-protocol">3.3 The TLS record protocol</a>
    <ul class="no-bullet">
      <li><a id="toc-Encryption-algorithms-used-in-the-record-layer-1" href="#Encryption-algorithms-used-in-the-record-layer">3.3.1 Encryption algorithms used in the record layer</a></li>
      <li><a id="toc-Compression-algorithms-and-the-record-layer-1" href="#Compression-algorithms-and-the-record-layer">3.3.2 Compression algorithms and the record layer</a></li>
      <li><a id="toc-On-record-padding" href="#On-Record-Padding">3.3.3 On record padding</a></li>
    </ul></li>
    <li><a id="toc-The-TLS-alert-protocol" href="#The-TLS-Alert-Protocol">3.4 The TLS alert protocol</a></li>
    <li><a id="toc-The-TLS-handshake-protocol" href="#The-TLS-Handshake-Protocol">3.5 The TLS handshake protocol</a>
    <ul class="no-bullet">
      <li><a id="toc-TLS-ciphersuites" href="#TLS-Cipher-Suites">3.5.1 TLS ciphersuites</a></li>
      <li><a id="toc-Authentication-1" href="#Authentication">3.5.2 Authentication</a></li>
      <li><a id="toc-Client-authentication" href="#Client-Authentication">3.5.3 Client authentication</a></li>
      <li><a id="toc-Resuming-sessions" href="#Resuming-Sessions">3.5.4 Resuming sessions</a></li>
    </ul></li>
    <li><a id="toc-TLS-extensions" href="#TLS-Extensions">3.6 TLS extensions</a>
    <ul class="no-bullet">
      <li><a id="toc-Maximum-fragment-length-negotiation-1" href="#Maximum-fragment-length-negotiation">3.6.1 Maximum fragment length negotiation</a></li>
      <li><a id="toc-Server-name-indication-1" href="#Server-name-indication">3.6.2 Server name indication</a></li>
      <li><a id="toc-Session-tickets-1" href="#Session-tickets">3.6.3 Session tickets</a></li>
      <li><a id="toc-HeartBeat-1" href="#HeartBeat">3.6.4 HeartBeat</a></li>
      <li><a id="toc-Safe-renegotiation-1" href="#Safe-renegotiation">3.6.5 Safe renegotiation</a></li>
      <li><a id="toc-OCSP-status-request-1" href="#OCSP-status-request">3.6.6 OCSP status request</a></li>
      <li><a id="toc-SRTP-1" href="#SRTP">3.6.7 SRTP</a></li>
      <li><a id="toc-False-Start-1" href="#False-Start">3.6.8 False Start</a></li>
      <li><a id="toc-Application-Layer-Protocol-Negotiation-_0028ALPN_0029-1" href="#Application-Layer-Protocol-Negotiation-_0028ALPN_0029">3.6.9 Application Layer Protocol Negotiation (ALPN)</a></li>
      <li><a id="toc-Extensions-and-Supplemental-Data-1" href="#Extensions-and-Supplemental-Data">3.6.10 Extensions and Supplemental Data</a></li>
    </ul></li>
    <li><a id="toc-How-to-use-TLS-in-application-protocols-1" href="#How-to-use-TLS-in-application-protocols">3.7 How to use <acronym>TLS</acronym> in application protocols</a>
    <ul class="no-bullet">
      <li><a id="toc-Separate-ports-1" href="#Separate-ports">3.7.1 Separate ports</a></li>
      <li><a id="toc-Upward-negotiation-1" href="#Upward-negotiation">3.7.2 Upward negotiation</a></li>
    </ul></li>
    <li><a id="toc-On-SSL-2-and-older-protocols-1" href="#On-SSL-2-and-older-protocols">3.8 On SSL 2 and older protocols</a></li>
  </ul></li>
  <li><a id="toc-Authentication-methods-1" href="#Authentication-methods">4 Authentication methods</a>
  <ul class="no-bullet">
    <li><a id="toc-Certificate-authentication-1" href="#Certificate-authentication">4.1 Certificate authentication</a>
    <ul class="no-bullet">
      <li><a id="toc-X_002e509-certificates-1" href="#X_002e509-certificates">4.1.1 <acronym>X.509</acronym> certificates</a>
      <ul class="no-bullet">
        <li><a id="toc-X_002e509-certificate-structure-1" href="#X_002e509-certificate-structure">4.1.1.1 <acronym>X.509</acronym> certificate structure</a></li>
        <li><a id="toc-Importing-an-X_002e509-certificate-1" href="#Importing-an-X_002e509-certificate">4.1.1.2 Importing an X.509 certificate</a></li>
        <li><a id="toc-X_002e509-certificate-names-1" href="#X_002e509-certificate-names">4.1.1.3 X.509 certificate names</a></li>
        <li><a id="toc-X_002e509-distinguished-names-1" href="#X_002e509-distinguished-names">4.1.1.4 X.509 distinguished names</a></li>
        <li><a id="toc-X_002e509-extensions-1" href="#X_002e509-extensions">4.1.1.5 X.509 extensions</a></li>
        <li><a id="toc-Accessing-public-and-private-keys" href="#X_002e509-public-and-private-keys">4.1.1.6 Accessing public and private keys</a></li>
        <li><a id="toc-Verifying-X_002e509-certificate-paths-1" href="#Verifying-X_002e509-certificate-paths">4.1.1.7 Verifying <acronym>X.509</acronym> certificate paths</a></li>
        <li><a id="toc-Verifying-a-certificate-in-the-context-of-TLS-session-1" href="#Verifying-a-certificate-in-the-context-of-TLS-session">4.1.1.8 Verifying a certificate in the context of TLS session</a></li>
        <li><a id="toc-Verifying-a-certificate-using-PKCS-_002311" href="#Verification-using-PKCS11">4.1.1.9 Verifying a certificate using PKCS #11</a></li>
      </ul></li>
      <li><a id="toc-OpenPGP-certificates-1" href="#OpenPGP-certificates">4.1.2 <acronym>OpenPGP</acronym> certificates</a></li>
      <li><a id="toc-Raw-public_002dkeys-1" href="#Raw-public_002dkeys">4.1.3 Raw public-keys</a>
      <ul class="no-bullet">
        <li><a id="toc-Importing-raw-public_002dkeys-1" href="#Importing-raw-public_002dkeys">4.1.3.1 Importing raw public-keys</a></li>
      </ul></li>
      <li><a id="toc-Advanced-certificate-verification-1" href="#Advanced-certificate-verification">4.1.4 Advanced certificate verification</a>
      <ul class="no-bullet">
        <li><a id="toc-Verifying-a-certificate-using-trust-on-first-use-authentication-1" href="#Verifying-a-certificate-using-trust-on-first-use-authentication">4.1.4.1 Verifying a certificate using trust on first use authentication</a></li>
        <li><a id="toc-Verifying-a-certificate-using-DANE-_0028DNSSEC_0029" href="#Verifying-a-certificate-using-DANE">4.1.4.2 Verifying a certificate using DANE (DNSSEC)</a></li>
      </ul></li>
      <li><a id="toc-Digital-signatures-1" href="#Digital-signatures">4.1.5 Digital signatures</a>
      <ul class="no-bullet">
        <li><a id="toc-Trading-security-for-interoperability" href="#Trading-security-for-interoperability">4.1.5.1 Trading security for interoperability</a></li>
      </ul></li>
    </ul></li>
    <li><a id="toc-More-on-certificate-authentication-1" href="#More-on-certificate-authentication">4.2 More on certificate authentication</a>
    <ul class="no-bullet">
      <li><a id="toc-PKCS-_002310-certificate-requests" href="#PKCS-10-certificate-requests">4.2.1 <acronym>PKCS</acronym> #10 certificate requests</a></li>
      <li><a id="toc-PKIX-certificate-revocation-lists-1" href="#PKIX-certificate-revocation-lists">4.2.2 PKIX certificate revocation lists</a></li>
      <li><a id="toc-OCSP-certificate-status-checking-1" href="#OCSP-certificate-status-checking">4.2.3 <acronym>OCSP</acronym> certificate status checking</a></li>
      <li><a id="toc-OCSP-stapling-1" href="#OCSP-stapling">4.2.4 OCSP stapling</a></li>
      <li><a id="toc-Managing-encrypted-keys-1" href="#Managing-encrypted-keys">4.2.5 Managing encrypted keys</a></li>
      <li><a id="toc-Invoking-certtool" href="#certtool-Invocation">4.2.6 Invoking certtool</a></li>
      <li><a id="toc-Invoking-ocsptool" href="#ocsptool-Invocation">4.2.7 Invoking ocsptool</a></li>
      <li><a id="toc-Invoking-danetool" href="#danetool-Invocation">4.2.8 Invoking danetool</a></li>
    </ul></li>
    <li><a id="toc-Shared_002dkey-and-anonymous-authentication-1" href="#Shared_002dkey-and-anonymous-authentication">4.3 Shared-key and anonymous authentication</a>
    <ul class="no-bullet">
      <li><a id="toc-PSK-authentication-1" href="#PSK-authentication">4.3.1 PSK authentication</a>
      <ul class="no-bullet">
        <li><a id="toc-Authentication-using-PSK-1" href="#Authentication-using-PSK">4.3.1.1 Authentication using <acronym>PSK</acronym></a></li>
        <li><a id="toc-Invoking-psktool" href="#psktool-Invocation">4.3.1.2 Invoking psktool</a></li>
      </ul></li>
      <li><a id="toc-SRP-authentication-1" href="#SRP-authentication">4.3.2 SRP authentication</a>
      <ul class="no-bullet">
        <li><a id="toc-Authentication-using-SRP-1" href="#Authentication-using-SRP">4.3.2.1 Authentication using <acronym>SRP</acronym></a></li>
        <li><a id="toc-Invoking-srptool" href="#srptool-Invocation">4.3.2.2 Invoking srptool</a></li>
      </ul></li>
      <li><a id="toc-Anonymous-authentication-1" href="#Anonymous-authentication">4.3.3 Anonymous authentication</a></li>
    </ul></li>
    <li><a id="toc-Selecting-an-appropriate-authentication-method-1" href="#Selecting-an-appropriate-authentication-method">4.4 Selecting an appropriate authentication method</a>
    <ul class="no-bullet">
      <li><a id="toc-Two-peers-with-an-out_002dof_002dband-channel" href="#Two-peers-with-an-out_002dof_002dband-channel">4.4.1 Two peers with an out-of-band channel</a></li>
      <li><a id="toc-Two-peers-without-an-out_002dof_002dband-channel" href="#Two-peers-without-an-out_002dof_002dband-channel">4.4.2 Two peers without an out-of-band channel</a></li>
      <li><a id="toc-Two-peers-and-a-trusted-third-party" href="#Two-peers-and-a-trusted-third-party">4.4.3 Two peers and a trusted third party</a></li>
    </ul></li>
  </ul></li>
  <li><a id="toc-Abstract-key-types-and-Hardware-security-modules" href="#Hardware-security-modules-and-abstract-key-types">5 Abstract key types and Hardware security modules</a>
  <ul class="no-bullet">
    <li><a id="toc-Abstract-key-types-1" href="#Abstract-key-types">5.1 Abstract key types</a>
    <ul class="no-bullet">
      <li><a id="toc-Public-keys" href="#Abstract-public-keys">5.1.1 Public keys</a></li>
      <li><a id="toc-Private-keys" href="#Abstract-private-keys">5.1.2 Private keys</a></li>
      <li><a id="toc-Operations-1" href="#Operations">5.1.3 Operations</a></li>
    </ul></li>
    <li><a id="toc-System-and-application_002dspecific-keys" href="#Application_002dspecific-keys">5.2 System and application-specific keys</a>
    <ul class="no-bullet">
      <li><a id="toc-System_002dspecific-keys" href="#System_002dspecific-keys">5.2.1 System-specific keys</a></li>
      <li><a id="toc-Application_002dspecific-keys-1" href="#Application_002dspecific-keys-1">5.2.2 Application-specific keys</a></li>
    </ul></li>
    <li><a id="toc-Smart-cards-and-HSMs-1" href="#Smart-cards-and-HSMs">5.3 Smart cards and HSMs</a>
    <ul class="no-bullet">
      <li><a id="toc-Initialization-1" href="#PKCS11-Initialization">5.3.1 Initialization</a></li>
      <li><a id="toc-Manual-initialization-of-user_002dspecific-modules" href="#PKCS11-Manual-Initialization">5.3.2 Manual initialization of user-specific modules</a></li>
      <li><a id="toc-Accessing-objects-that-require-a-PIN-1" href="#Accessing-objects-that-require-a-PIN">5.3.3 Accessing objects that require a PIN</a></li>
      <li><a id="toc-Reading-objects-1" href="#Reading-objects">5.3.4 Reading objects</a></li>
      <li><a id="toc-Writing-objects-1" href="#Writing-objects">5.3.5 Writing objects</a></li>
      <li><a id="toc-Low-Level-Access" href="#PKCS11-Low-Level-Access">5.3.6 Low Level Access</a></li>
      <li><a id="toc-Using-a-PKCS-_002311-token-with-TLS" href="#Using-a-PKCS11-token-with-TLS">5.3.7 Using a <acronym>PKCS</acronym> #11 token with TLS</a></li>
      <li><a id="toc-Verifying-certificates-over-PKCS-_002311" href="#Verifying-certificates-over-PKCS11">5.3.8 Verifying certificates over <acronym>PKCS</acronym> #11</a></li>
      <li><a id="toc-Invoking-p11tool" href="#p11tool-Invocation">5.3.9 Invoking p11tool</a></li>
    </ul></li>
    <li><a id="toc-Trusted-Platform-Module-_0028TPM_0029" href="#Trusted-Platform-Module">5.4 Trusted Platform Module (TPM)</a>
    <ul class="no-bullet">
      <li><a id="toc-Keys-in-TPM-1" href="#Keys-in-TPM">5.4.1 Keys in TPM</a></li>
      <li><a id="toc-Key-generation-1" href="#Key-generation">5.4.2 Key generation</a></li>
      <li><a id="toc-Using-keys-1" href="#Using-keys">5.4.3 Using keys</a></li>
      <li><a id="toc-Invoking-tpmtool" href="#tpmtool-Invocation">5.4.4 Invoking tpmtool</a></li>
    </ul></li>
  </ul></li>
  <li><a id="toc-How-to-use-GnuTLS-in-applications-1" href="#How-to-use-GnuTLS-in-applications">6 How to use <acronym>GnuTLS</acronym> in applications</a>
  <ul class="no-bullet">
    <li><a id="toc-Introduction" href="#Introduction-to-the-library">6.1 Introduction</a>
    <ul class="no-bullet">
      <li><a id="toc-General-idea-1" href="#General-idea">6.1.1 General idea</a></li>
      <li><a id="toc-Error-handling-1" href="#Error-handling">6.1.2 Error handling</a></li>
      <li><a id="toc-Common-types-1" href="#Common-types">6.1.3 Common types</a></li>
      <li><a id="toc-Debugging-and-auditing-1" href="#Debugging-and-auditing">6.1.4 Debugging and auditing</a></li>
      <li><a id="toc-Thread-safety-1" href="#Thread-safety">6.1.5 Thread safety</a></li>
      <li><a id="toc-Running-in-a-sandbox-1" href="#Running-in-a-sandbox">6.1.6 Running in a sandbox</a></li>
      <li><a id="toc-Sessions-and-fork-1" href="#Sessions-and-fork">6.1.7 Sessions and fork</a></li>
      <li><a id="toc-Callback-functions-1" href="#Callback-functions">6.1.8 Callback functions</a></li>
    </ul></li>
    <li><a id="toc-Preparation-1" href="#Preparation">6.2 Preparation</a>
    <ul class="no-bullet">
      <li><a id="toc-Headers-1" href="#Headers">6.2.1 Headers</a></li>
      <li><a id="toc-Initialization-2" href="#Initialization">6.2.2 Initialization</a></li>
      <li><a id="toc-Version-check-1" href="#Version-check">6.2.3 Version check</a></li>
      <li><a id="toc-Building-the-source-1" href="#Building-the-source">6.2.4 Building the source</a></li>
    </ul></li>
    <li><a id="toc-Session-initialization-1" href="#Session-initialization">6.3 Session initialization</a></li>
    <li><a id="toc-Associating-the-credentials-1" href="#Associating-the-credentials">6.4 Associating the credentials</a>
    <ul class="no-bullet">
      <li><a id="toc-Certificates" href="#Certificate-credentials">6.4.1 Certificates</a></li>
      <li><a id="toc-Raw-public_002dkeys-2" href="#Raw-public_002dkey-credentials">6.4.2 Raw public-keys</a></li>
      <li><a id="toc-SRP" href="#SRP-credentials">6.4.3 SRP</a></li>
      <li><a id="toc-PSK" href="#PSK-credentials">6.4.4 PSK</a></li>
      <li><a id="toc-Anonymous" href="#Anonymous-credentials">6.4.5 Anonymous</a></li>
    </ul></li>
    <li><a id="toc-Setting-up-the-transport-layer-1" href="#Setting-up-the-transport-layer">6.5 Setting up the transport layer</a>
    <ul class="no-bullet">
      <li><a id="toc-Asynchronous-operation-1" href="#Asynchronous-operation">6.5.1 Asynchronous operation</a>
      <ul class="no-bullet">
        <li><a id="toc-TLS-protocol" href="#TLS-protocol">6.5.1.1 TLS protocol</a></li>
        <li><a id="toc-Datagram-TLS-protocol" href="#Datagram-TLS-protocol">6.5.1.2 Datagram TLS protocol</a></li>
      </ul></li>
      <li><a id="toc-Reducing-round_002dtrips-1" href="#Reducing-round_002dtrips">6.5.2 Reducing round-trips</a></li>
      <li><a id="toc-Zero_002droundtrip-mode-1" href="#Zero_002droundtrip-mode">6.5.3 Zero-roundtrip mode</a></li>
      <li><a id="toc-Anti_002dreplay-protection-1" href="#Anti_002dreplay-protection">6.5.4 Anti-replay protection</a></li>
      <li><a id="toc-DTLS-sessions-1" href="#DTLS-sessions">6.5.5 DTLS sessions</a></li>
      <li><a id="toc-DTLS-and-SCTP-1" href="#DTLS-and-SCTP">6.5.6 DTLS and SCTP</a></li>
    </ul></li>
    <li><a id="toc-TLS-handshake-1" href="#TLS-handshake">6.6 TLS handshake</a></li>
    <li><a id="toc-Data-transfer-and-termination-1" href="#Data-transfer-and-termination">6.7 Data transfer and termination</a></li>
    <li><a id="toc-Buffered-data-transfer-1" href="#Buffered-data-transfer">6.8 Buffered data transfer</a></li>
    <li><a id="toc-Handling-alerts-1" href="#Handling-alerts">6.9 Handling alerts</a></li>
    <li><a id="toc-Priority-strings" href="#Priority-Strings">6.10 Priority strings</a></li>
    <li><a id="toc-Selecting-cryptographic-key-sizes-1" href="#Selecting-cryptographic-key-sizes">6.11 Selecting cryptographic key sizes</a></li>
    <li><a id="toc-Advanced-topics-1" href="#Advanced-topics">6.12 Advanced topics</a>
    <ul class="no-bullet">
      <li><a id="toc-Virtual-hosts-and-credentials-1" href="#Virtual-hosts-and-credentials">6.12.1 Virtual hosts and credentials</a></li>
      <li><a id="toc-Session-resumption-1" href="#Session-resumption">6.12.2 Session resumption</a></li>
      <li><a id="toc-Certificate-verification-1" href="#Certificate-verification">6.12.3 Certificate verification</a>
      <ul class="no-bullet">
        <li><a id="toc-Trust-on-first-use" href="#Trust-on-first-use">6.12.3.1 Trust on first use</a></li>
        <li><a id="toc-DANE-verification" href="#DANE-verification">6.12.3.2 DANE verification</a></li>
      </ul></li>
      <li><a id="toc-TLS-1_002e2-re_002dauthentication-1" href="#TLS-1_002e2-re_002dauthentication">6.12.4 TLS 1.2 re-authentication</a>
      <ul class="no-bullet">
        <li><a id="toc-Client-side" href="#Client-side">6.12.4.1 Client side</a></li>
        <li><a id="toc-Server-side" href="#Server-side">6.12.4.2 Server side</a></li>
      </ul></li>
      <li><a id="toc-TLS-1_002e3-re_002dauthentication-and-re_002dkey-1" href="#TLS-1_002e3-re_002dauthentication-and-re_002dkey">6.12.5 TLS 1.3 re-authentication and re-key</a></li>
      <li><a id="toc-Parameter-generation-1" href="#Parameter-generation">6.12.6 Parameter generation</a>
      <ul class="no-bullet">
        <li><a id="toc-Legacy-parameter-generation" href="#Legacy-parameter-generation">6.12.6.1 Legacy parameter generation</a></li>
      </ul></li>
      <li><a id="toc-Deriving-keys-for-other-applications_002fprotocols-1" href="#Deriving-keys-for-other-applications_002fprotocols">6.12.7 Deriving keys for other applications/protocols</a></li>
      <li><a id="toc-Channel-bindings" href="#Channel-Bindings">6.12.8 Channel bindings</a></li>
      <li><a id="toc-Interoperability-1" href="#Interoperability">6.12.9 Interoperability</a></li>
      <li><a id="toc-Compatibility-with-the-OpenSSL-library-1" href="#Compatibility-with-the-OpenSSL-library">6.12.10 Compatibility with the OpenSSL library</a></li>
    </ul></li>
  </ul></li>
  <li><a id="toc-GnuTLS-application-examples-1" href="#GnuTLS-application-examples">7 GnuTLS application examples</a>
  <ul class="no-bullet">
    <li><a id="toc-Client-examples-1" href="#Client-examples">7.1 Client examples</a>
    <ul class="no-bullet">
      <li><a id="toc-Client-example-with-X_002e509-certificate-support-1" href="#Client-example-with-X_002e509-certificate-support">7.1.1 Client example with <acronym>X.509</acronym> certificate support</a></li>
      <li><a id="toc-Datagram-TLS-client-example-1" href="#Datagram-TLS-client-example">7.1.2 Datagram <acronym>TLS</acronym> client example</a></li>
      <li><a id="toc-Using-a-smart-card-with-TLS" href="#Client-using-a-smart-card-with-TLS">7.1.3 Using a smart card with TLS</a></li>
      <li><a id="toc-Client-with-resume-capability-example" href="#Client-with-Resume-capability-example">7.1.4 Client with resume capability example</a></li>
      <li><a id="toc-Client-example-with-SSH_002dstyle-certificate-verification-1" href="#Client-example-with-SSH_002dstyle-certificate-verification">7.1.5 Client example with SSH-style certificate verification</a></li>
    </ul></li>
    <li><a id="toc-Server-examples-1" href="#Server-examples">7.2 Server examples</a>
    <ul class="no-bullet">
      <li><a id="toc-Echo-server-with-X_002e509-authentication-1" href="#Echo-server-with-X_002e509-authentication">7.2.1 Echo server with <acronym>X.509</acronym> authentication</a></li>
      <li><a id="toc-DTLS-echo-server-with-X_002e509-authentication-1" href="#DTLS-echo-server-with-X_002e509-authentication">7.2.2 DTLS echo server with <acronym>X.509</acronym> authentication</a></li>
    </ul></li>
    <li><a id="toc-More-advanced-client-and-servers-1" href="#More-advanced-client-and-servers">7.3 More advanced client and servers</a>
    <ul class="no-bullet">
      <li><a id="toc-Client-example-with-anonymous-authentication-1" href="#Client-example-with-anonymous-authentication">7.3.1 Client example with anonymous authentication</a></li>
      <li><a id="toc-Using-a-callback-to-select-the-certificate-to-use-1" href="#Using-a-callback-to-select-the-certificate-to-use">7.3.2 Using a callback to select the certificate to use</a></li>
      <li><a id="toc-Obtaining-session-information-1" href="#Obtaining-session-information">7.3.3 Obtaining session information</a></li>
      <li><a id="toc-Advanced-certificate-verification-2" href="#Advanced-certificate-verification-example">7.3.4 Advanced certificate verification</a></li>
      <li><a id="toc-Client-example-with-PSK-authentication-1" href="#Client-example-with-PSK-authentication">7.3.5 Client example with <acronym>PSK</acronym> authentication</a></li>
      <li><a id="toc-Client-example-with-SRP-authentication-1" href="#Client-example-with-SRP-authentication">7.3.6 Client example with <acronym>SRP</acronym> authentication</a></li>
      <li><a id="toc-Legacy-client-example-with-X_002e509-certificate-support-1" href="#Legacy-client-example-with-X_002e509-certificate-support">7.3.7 Legacy client example with <acronym>X.509</acronym> certificate support</a></li>
      <li><a id="toc-Client-example-using-the-C_002b_002b-API" href="#Client-example-in-C_002b_002b">7.3.8 Client example using the C++ API</a></li>
      <li><a id="toc-Echo-server-with-PSK-authentication-1" href="#Echo-server-with-PSK-authentication">7.3.9 Echo server with <acronym>PSK</acronym> authentication</a></li>
      <li><a id="toc-Echo-server-with-SRP-authentication-1" href="#Echo-server-with-SRP-authentication">7.3.10 Echo server with <acronym>SRP</acronym> authentication</a></li>
      <li><a id="toc-Echo-server-with-anonymous-authentication-1" href="#Echo-server-with-anonymous-authentication">7.3.11 Echo server with anonymous authentication</a></li>
      <li><a id="toc-Helper-functions-for-TCP-connections-1" href="#Helper-functions-for-TCP-connections">7.3.12 Helper functions for TCP connections</a></li>
      <li><a id="toc-Helper-functions-for-UDP-connections-1" href="#Helper-functions-for-UDP-connections">7.3.13 Helper functions for UDP connections</a></li>
    </ul></li>
    <li><a id="toc-OCSP-example-1" href="#OCSP-example">7.4 OCSP example</a></li>
    <li><a id="toc-Miscellaneous-examples-1" href="#Miscellaneous-examples">7.5 Miscellaneous examples</a>
    <ul class="no-bullet">
      <li><a id="toc-Checking-for-an-alert-1" href="#Checking-for-an-alert">7.5.1 Checking for an alert</a></li>
      <li><a id="toc-X_002e509-certificate-parsing-example-1" href="#X_002e509-certificate-parsing-example">7.5.2 <acronym>X.509</acronym> certificate parsing example</a></li>
      <li><a id="toc-Listing-the-ciphersuites-in-a-priority-string-1" href="#Listing-the-ciphersuites-in-a-priority-string">7.5.3 Listing the ciphersuites in a priority string</a></li>
      <li><a id="toc-PKCS-_002312-structure-generation-example" href="#PKCS12-structure-generation-example">7.5.4 PKCS #12 structure generation example</a></li>
    </ul></li>
  </ul></li>
  <li><a id="toc-System_002dwide-configuration-of-the-library-1" href="#System_002dwide-configuration-of-the-library">8 System-wide configuration of the library</a>
  <ul class="no-bullet">
    <li><a id="toc-Application_002dspecific-priority-strings-1" href="#Application_002dspecific-priority-strings">8.1 Application-specific priority strings</a></li>
    <li><a id="toc-Disabling-algorithms-and-protocols-1" href="#Disabling-algorithms-and-protocols">8.2 Disabling algorithms and protocols</a>
    <ul class="no-bullet">
      <li><a id="toc-Examples" href="#Examples">8.2.1 Examples</a></li>
    </ul></li>
    <li><a id="toc-Querying-for-disabled-algorithms-and-protocols-1" href="#Querying-for-disabled-algorithms-and-protocols">8.3 Querying for disabled algorithms and protocols</a></li>
    <li><a id="toc-Overriding-the-parameter-verification-profile-1" href="#Overriding-the-parameter-verification-profile">8.4 Overriding the parameter verification profile</a></li>
  </ul></li>
  <li><a id="toc-Using-GnuTLS-as-a-cryptographic-library-1" href="#Using-GnuTLS-as-a-cryptographic-library">9 Using GnuTLS as a cryptographic library</a>
  <ul class="no-bullet">
    <li><a id="toc-Symmetric-algorithms-1" href="#Symmetric-algorithms">9.1 Symmetric algorithms</a></li>
    <li><a id="toc-Public-key-algorithms-1" href="#Public-key-algorithms">9.2 Public key algorithms</a>
    <ul class="no-bullet">
      <li><a id="toc-Key-generation-2" href="#Key-generation-2">9.2.1 Key generation</a></li>
    </ul></li>
    <li><a id="toc-Cryptographic-Message-Syntax-_002f-PKCS7-1" href="#Cryptographic-Message-Syntax-_002f-PKCS7">9.3 Cryptographic Message Syntax / PKCS7</a></li>
    <li><a id="toc-Hash-and-MAC-functions-1" href="#Hash-and-MAC-functions">9.4 Hash and MAC functions</a></li>
    <li><a id="toc-Random-number-generation-1" href="#Random-number-generation">9.5 Random number generation</a></li>
    <li><a id="toc-Overriding-algorithms-1" href="#Overriding-algorithms">9.6 Overriding algorithms</a></li>
  </ul></li>
  <li><a id="toc-Other-included-programs-1" href="#Other-included-programs">10 Other included programs</a>
  <ul class="no-bullet">
    <li><a id="toc-Invoking-gnutls_002dcli" href="#gnutls_002dcli-Invocation">10.1 Invoking gnutls-cli</a></li>
    <li><a id="toc-Invoking-gnutls_002dserv" href="#gnutls_002dserv-Invocation">10.2 Invoking gnutls-serv</a></li>
    <li><a id="toc-Invoking-gnutls_002dcli_002ddebug" href="#gnutls_002dcli_002ddebug-Invocation">10.3 Invoking gnutls-cli-debug</a></li>
  </ul></li>
  <li><a id="toc-Internal-Architecture-of-GnuTLS" href="#Internal-architecture-of-GnuTLS">11 Internal Architecture of GnuTLS</a>
  <ul class="no-bullet">
    <li><a id="toc-The-TLS-Protocol-1" href="#The-TLS-Protocol">11.1 The TLS Protocol</a></li>
    <li><a id="toc-TLS-Handshake-Protocol-1" href="#TLS-Handshake-Protocol">11.2 TLS Handshake Protocol</a></li>
    <li><a id="toc-TLS-Authentication-Methods-1" href="#TLS-Authentication-Methods">11.3 TLS Authentication Methods</a></li>
    <li><a id="toc-TLS-Extension-Handling" href="#TLS-Hello-Extension-Handling">11.4 TLS Extension Handling</a></li>
    <li><a id="toc-Cryptographic-Backend-1" href="#Cryptographic-Backend">11.5 Cryptographic Backend</a></li>
    <li><a id="toc-Random-Number-Generators" href="#Random-Number-Generators_002dinternals">11.6 Random Number Generators</a></li>
    <li><a id="toc-FIPS140_002d2-mode-1" href="#FIPS140_002d2-mode">11.7 FIPS140-2 mode</a></li>
  </ul></li>
  <li><a id="toc-Upgrading-from-previous-versions-1" href="#Upgrading-from-previous-versions">Appendix A Upgrading from previous versions</a></li>
  <li><a id="toc-Support-1" href="#Support">Appendix B Support</a>
  <ul class="no-bullet">
    <li><a id="toc-Getting-Help" href="#Getting-help">B.1 Getting Help</a></li>
    <li><a id="toc-Commercial-Support-1" href="#Commercial-Support">B.2 Commercial Support</a></li>
    <li><a id="toc-Bug-Reports-1" href="#Bug-Reports">B.3 Bug Reports</a></li>
    <li><a id="toc-Contributing-1" href="#Contributing">B.4 Contributing</a></li>
    <li><a id="toc-Certification-1" href="#Certification">B.5 Certification</a></li>
  </ul></li>
  <li><a id="toc-Error-Codes-and-Descriptions" href="#Error-codes">Appendix C Error Codes and Descriptions</a></li>
  <li><a id="toc-Supported-Ciphersuites" href="#Supported-ciphersuites">Appendix D Supported Ciphersuites</a></li>
  <li><a id="toc-API-reference-1" href="#API-reference">Appendix E API reference</a>
  <ul class="no-bullet">
    <li><a id="toc-Core-TLS-API-1" href="#Core-TLS-API">E.1 Core TLS API</a></li>
    <li><a id="toc-Datagram-TLS-API-1" href="#Datagram-TLS-API">E.2 Datagram TLS API</a></li>
    <li><a id="toc-X_002e509-certificate-API" href="#X509-certificate-API">E.3 <acronym>X.509</acronym> certificate API</a></li>
    <li><a id="toc-PKCS-7-API-1" href="#PKCS-7-API">E.4 <acronym>PKCS</acronym> 7 API</a></li>
    <li><a id="toc-OCSP-API-1" href="#OCSP-API">E.5 <acronym>OCSP</acronym> API</a></li>
    <li><a id="toc-PKCS-12-API-1" href="#PKCS-12-API">E.6 PKCS 12 API</a></li>
    <li><a id="toc-Hardware-token-via-PKCS-11-API" href="#PKCS-11-API">E.7 Hardware token via PKCS 11 API</a></li>
    <li><a id="toc-TPM-API-1" href="#TPM-API">E.8 TPM API</a></li>
    <li><a id="toc-Abstract-key-API-1" href="#Abstract-key-API">E.9 Abstract key API</a></li>
    <li><a id="toc-Socket-specific-API-1" href="#Socket-specific-API">E.10 Socket specific API</a></li>
    <li><a id="toc-DANE-API-1" href="#DANE-API">E.11 DANE API</a></li>
    <li><a id="toc-Cryptographic-API-1" href="#Cryptographic-API">E.12 Cryptographic API</a></li>
    <li><a id="toc-Compatibility-API-1" href="#Compatibility-API">E.13 Compatibility API</a></li>
  </ul></li>
  <li><a id="toc-Copying-Information-1" href="#Copying-Information">Appendix F Copying Information</a></li>
  <li><a id="toc-Bibliography-1" href="#Bibliography">Bibliography</a></li>
  <li><a id="toc-Function-and-Data-Index-1" href="#Function-and-Data-Index">Function and Data Index</a></li>
  <li><a id="toc-Concept-Index-1" href="#Concept-Index">Concept Index</a></li>
</ul>
</div>


<span id="Top"></span><div class="header">
<p>
Next: <a href="#Preface" accesskey="n" rel="next">Preface</a>, Up: <a href="dir.html#Top" accesskey="u" rel="up">(dir)</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="GnuTLS"></span><h1 class="top">GnuTLS</h1>

<p>This manual is last updated 27 June 2019 for version
3.6.10 of GnuTLS.
</p>
<p>Copyright &copy; 2001-2019 Free Software Foundation, Inc.\\
Copyright &copy; 2001-2019 Nikos Mavrogiannopoulos
</p>
<blockquote>
<p>Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included in the section entitled &ldquo;GNU Free
Documentation License&rdquo;.
</p></blockquote>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Preface" accesskey="1">Preface</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Introduction-to-GnuTLS" accesskey="2">Introduction to GnuTLS</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Introduction-to-TLS" accesskey="3">Introduction to TLS</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Authentication-methods" accesskey="4">Authentication methods</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Hardware-security-modules-and-abstract-key-types" accesskey="5">Hardware security modules and abstract key types</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#How-to-use-GnuTLS-in-applications" accesskey="6">How to use GnuTLS in applications</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#GnuTLS-application-examples" accesskey="7">GnuTLS application examples</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#System_002dwide-configuration-of-the-library" accesskey="8">System-wide configuration of the library</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Using-GnuTLS-as-a-cryptographic-library" accesskey="9">Using GnuTLS as a cryptographic library</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Other-included-programs">Other included programs</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Internal-architecture-of-GnuTLS">Internal architecture of GnuTLS</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Upgrading-from-previous-versions">Upgrading from previous versions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Support">Support</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Error-codes">Error codes</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Supported-ciphersuites">Supported ciphersuites</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#API-reference">API reference</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Copying-Information">Copying Information</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Bibliography">Bibliography</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Function-and-Data-Index">Function and Data Index</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Concept-Index">Concept Index</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Preface"></span><div class="header">
<p>
Next: <a href="#Introduction-to-GnuTLS" accesskey="n" rel="next">Introduction to GnuTLS</a>, Previous: <a href="#Top" accesskey="p" rel="prev">Top</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Preface-1"></span><h2 class="chapter">1 Preface</h2>

<p>This document demonstrates and explains the <acronym>GnuTLS</acronym>
library API.  A brief introduction to the protocols and the technology
involved is also included so that an application programmer can
better understand the <acronym>GnuTLS</acronym> purpose and actual offerings.
Even if <acronym>GnuTLS</acronym> is a typical library software, it operates
over several security and cryptographic protocols which require the
programmer to make careful and correct usage of them. Otherwise it
is likely to only obtain a false sense of security.
The term of security is very broad even if restricted to computer
software, and cannot be confined to a single cryptographic
library.  For that reason, do not consider any program secure just
because it uses <acronym>GnuTLS</acronym>; there are several ways to compromise
a program or a communication line and <acronym>GnuTLS</acronym> only helps with
some of them.
</p>
<p>Although this document tries to be self contained, basic network
programming and public key infrastructure (PKI) knowledge is assumed 
in most of it. A good introduction to networking can be found 
in [<a href="#STEVENS">STEVENS</a>], to public key infrastructure in [<a href="#GUTPKI">GUTPKI</a>]
and to security engineering in [<a href="#ANDERSON">ANDERSON</a>].
</p>
<p>Updated versions of the <acronym>GnuTLS</acronym> software and this document
will be available from <a href="https://www.gnutls.org/">https://www.gnutls.org/</a>.
</p>
<hr>
<span id="Introduction-to-GnuTLS"></span><div class="header">
<p>
Next: <a href="#Introduction-to-TLS" accesskey="n" rel="next">Introduction to TLS</a>, Previous: <a href="#Preface" accesskey="p" rel="prev">Preface</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Introduction-to-GnuTLS-1"></span><h2 class="chapter">2 Introduction to GnuTLS</h2>

<p>In brief <acronym>GnuTLS</acronym> can be described as a library which offers an API
to access secure communication protocols. These protocols provide
privacy over insecure lines, and were designed to prevent
eavesdropping, tampering, or message forgery.
</p>
<p>Technically <acronym>GnuTLS</acronym> is a portable ANSI C based library which
implements the protocols ranging from SSL 3.0 to TLS 1.3 (see <a href="#Introduction-to-TLS">Introduction to TLS</a>, 
for a detailed description of the protocols), accompanied
with the required framework for authentication and public key
infrastructure.  Important features of the <acronym>GnuTLS</acronym> library
include:
</p>
<ul>
<li> Support for TLS 1.3, TLS 1.2, TLS 1.1, TLS 1.0 and optionally SSL 3.0 protocols.

</li><li> Support for Datagram TLS 1.0 and 1.2.

</li><li> Support for handling and verification of <acronym>X.509</acronym> certificates.

</li><li> Support for password authentication using <acronym>TLS-SRP</acronym>.

</li><li> Support for keyed authentication using <acronym>TLS-PSK</acronym>.

</li><li> Support for TPM, <acronym>PKCS</acronym> #11 tokens and smart-cards.

</li></ul>

<p>The <acronym>GnuTLS</acronym> library consists of three independent parts, namely the &ldquo;TLS
protocol part&rdquo;, the &ldquo;Certificate part&rdquo;, and the &ldquo;Cryptographic
back-end&rdquo; part.  The &ldquo;TLS protocol part&rdquo; is the actual protocol
implementation, and is entirely implemented within the
<acronym>GnuTLS</acronym> library.  The &ldquo;Certificate part&rdquo; consists of the
certificate parsing, and verification functions and it uses
functionality from the
libtasn1 library.
The &ldquo;Cryptographic back-end&rdquo; is provided by the nettle
and gmplib libraries.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Downloading-and-installing" accesskey="1">Downloading and installing</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Installing-for-a-software-distribution" accesskey="2">Installing for a software distribution</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Document-overview" accesskey="3">Document overview</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Downloading-and-installing"></span><div class="header">
<p>
Next: <a href="#Installing-for-a-software-distribution" accesskey="n" rel="next">Installing for a software distribution</a>, Up: <a href="#Introduction-to-GnuTLS" accesskey="u" rel="up">Introduction to GnuTLS</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Downloading-and-installing-1"></span><h3 class="section">2.1 Downloading and installing</h3>
<span id="index-installation"></span>
<span id="index-download"></span>

<p>GnuTLS is available for download at:
<a href="https://www.gnutls.org/download.html">https://www.gnutls.org/download.html</a>
</p>
<p>GnuTLS uses a development cycle where even minor version numbers
indicate a stable release and a odd minor version number indicate a
development release.  For example, GnuTLS 1.6.3 denote a stable
release since 6 is even, and GnuTLS 1.7.11 denote a development
release since 7 is odd.
</p>
<p>GnuTLS depends on <code>nettle</code> and <code>gmplib</code>, and you will need to install it
before installing GnuTLS.  The <code>nettle</code> library is available from
<a href="https://www.lysator.liu.se/~nisse/nettle/">https://www.lysator.liu.se/~nisse/nettle/</a>, while <code>gmplib</code> is available
from <a href="https://www.gmplib.org/">https://www.gmplib.org/</a>.
Don&rsquo;t forget to verify the cryptographic signature after downloading
source code packages.
</p>
<p>The package is then extracted, configured and built like many other
packages that use Autoconf.  For detailed information on configuring
and building it, refer to the <samp>INSTALL</samp> file that is part of the
distribution archive.  Typically you invoke <code>./configure</code> and
then <code>make check install</code>.  There are a number of compile-time
parameters, as discussed below.
</p>
<p>Several parts of GnuTLS require ASN.1 functionality, which is provided by 
a library called libtasn1.  A copy of libtasn1 is included in GnuTLS.  If you
want to install it separately (e.g., to make it possibly to use
libtasn1 in other programs), you can get it from
<a href="https://www.gnu.org/software/libtasn1/">https://www.gnu.org/software/libtasn1/</a>.
</p>
<p>The compression library, <code>libz</code>, the PKCS #11 helper library <code>p11-kit</code>,
the TPM library <code>trousers</code>, as well as the IDN library <code>libidn</code><a id="DOCF1" href="#FOOT1"><sup>1</sup></a> are 
optional dependencies. Check the README file in the distribution on how
to obtain these libraries.
</p>
<p>A few <code>configure</code> options may be relevant, summarized below.
They disable or enable particular features,
to create a smaller library with only the required features.
Note however, that although a smaller library is generated, the
included programs are not guaranteed to compile if some of these
options are given.
</p>
<pre class="verbatim">--disable-srp-authentication
--disable-psk-authentication
--disable-anon-authentication
--disable-dhe
--disable-ecdhe
--disable-openssl-compatibility
--disable-dtls-srtp-support
--disable-alpn-support
--disable-heartbeat-support
--disable-libdane
--without-p11-kit
--without-tpm
--without-zlib

</pre>
<p>For the complete list, refer to the output from <code>configure --help</code>.
</p>
<hr>
<span id="Installing-for-a-software-distribution"></span><div class="header">
<p>
Next: <a href="#Document-overview" accesskey="n" rel="next">Document overview</a>, Previous: <a href="#Downloading-and-installing" accesskey="p" rel="prev">Downloading and installing</a>, Up: <a href="#Introduction-to-GnuTLS" accesskey="u" rel="up">Introduction to GnuTLS</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Installing-for-a-software-distribution-1"></span><h3 class="section">2.2 Installing for a software distribution</h3>
<span id="index-installation-1"></span>

<p>When installing for a software distribution, it is often desirable to preconfigure
GnuTLS with the system-wide paths and files. There two important configuration
options, one sets the trust store in system, which are the CA certificates
to be used by programs by default (if they don&rsquo;t override it), and the other sets
to DNSSEC root key file used by unbound for DNSSEC verification.
</p>
<p>For the latter the following configuration option is available, and if not specified
GnuTLS will try to auto-detect the location of that file.
</p><pre class="verbatim">--with-unbound-root-key-file

</pre>
<p>To set the trust store the following options are available.
</p><pre class="verbatim">--with-default-trust-store-file
--with-default-trust-store-dir
--with-default-trust-store-pkcs11

</pre><p>The first option is used to set a PEM file which contains a list of trusted certificates,
while the second will read all certificates in the given path. The recommended option is
the last, which allows to use a PKCS #11 trust policy module. That module not only
provides the trusted certificates, but allows the categorization of them using purpose,
e.g., CAs can be restricted for e-mail usage only, or administrative restrictions of CAs, for
examples by restricting a CA to only issue certificates for a given DNS domain using NameConstraints.
A publicly available PKCS #11 trust module is p11-kit&rsquo;s trust module<a id="DOCF2" href="#FOOT2"><sup>2</sup></a>.
</p>
<hr>
<span id="Document-overview"></span><div class="header">
<p>
Previous: <a href="#Installing-for-a-software-distribution" accesskey="p" rel="prev">Installing for a software distribution</a>, Up: <a href="#Introduction-to-GnuTLS" accesskey="u" rel="up">Introduction to GnuTLS</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Overview"></span><h3 class="section">2.3 Overview</h3>
<p>In this document we present an overview of the supported security protocols in <a href="#Introduction-to-TLS">Introduction to TLS</a>, and 
continue by providing more information on the certificate authentication in <a href="#Certificate-authentication">Certificate authentication</a>,
and shared-key as well anonymous authentication in <a href="#Shared_002dkey-and-anonymous-authentication">Shared-key and anonymous authentication</a>. We
elaborate on certificate authentication by demonstrating advanced usage of the API in <a href="#More-on-certificate-authentication">More on certificate authentication</a>.
The core of the TLS library is presented in <a href="#How-to-use-GnuTLS-in-applications">How to use GnuTLS in applications</a> and example
applications are listed in <a href="#GnuTLS-application-examples">GnuTLS application examples</a>.
In <a href="#Other-included-programs">Other included programs</a> the usage of few included programs that
may assist debugging is presented. The last chapter is <a href="#Internal-architecture-of-GnuTLS">Internal architecture of GnuTLS</a> that
provides a short introduction to GnuTLS&rsquo; internal architecture.
</p>
<hr>
<span id="Introduction-to-TLS"></span><div class="header">
<p>
Next: <a href="#Authentication-methods" accesskey="n" rel="next">Authentication methods</a>, Previous: <a href="#Introduction-to-GnuTLS" accesskey="p" rel="prev">Introduction to GnuTLS</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Introduction-to-TLS-and-DTLS"></span><h2 class="chapter">3 Introduction to <acronym>TLS</acronym> and <acronym>DTLS</acronym></h2>

<p><acronym>TLS</acronym> stands for &ldquo;Transport Layer Security&rdquo; and is the
successor of SSL, the Secure Sockets Layer protocol [<a href="#SSL3">SSL3</a>]
designed by Netscape.  <acronym>TLS</acronym> is an Internet protocol, defined
by <acronym>IETF</acronym><a id="DOCF3" href="#FOOT3"><sup>3</sup></a>, described in [<a href="#RFC5246">RFC5246</a>].
The protocol provides
confidentiality, and authentication layers over any reliable transport
layer.  The description, above, refers to <acronym>TLS</acronym> 1.0 but applies
to all other TLS versions as the differences between the protocols are not major.
</p>
<p>The <acronym>DTLS</acronym> protocol, or &ldquo;Datagram <acronym>TLS</acronym>&rdquo; [<a href="#RFC4347">RFC4347</a>] is a
protocol with identical goals as <acronym>TLS</acronym>, but can operate
under unreliable transport layers such as <acronym>UDP</acronym>. The
discussions below apply to this protocol as well, except when
noted otherwise.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#TLS-layers" accesskey="1">TLS layers</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#The-transport-layer" accesskey="2">The transport layer</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#The-TLS-record-protocol" accesskey="3">The TLS record protocol</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#The-TLS-Alert-Protocol" accesskey="4">The TLS Alert Protocol</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#The-TLS-Handshake-Protocol" accesskey="5">The TLS Handshake Protocol</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#TLS-Extensions" accesskey="6">TLS Extensions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#How-to-use-TLS-in-application-protocols" accesskey="7">How to use TLS in application protocols</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#On-SSL-2-and-older-protocols" accesskey="8">On SSL 2 and older protocols</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="TLS-layers"></span><div class="header">
<p>
Next: <a href="#The-transport-layer" accesskey="n" rel="next">The transport layer</a>, Up: <a href="#Introduction-to-TLS" accesskey="u" rel="up">Introduction to TLS</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="TLS-Layers"></span><h3 class="section">3.1 TLS Layers</h3>
<span id="index-TLS-layers"></span>

<p><acronym>TLS</acronym> is a layered protocol, and consists of the record
protocol, the handshake protocol and the alert protocol. The record
protocol is to serve all other protocols and is above the transport
layer.  The record protocol offers symmetric encryption, and data
authenticity<a id="DOCF4" href="#FOOT4"><sup>4</sup></a>.
The alert protocol offers some signaling to the other protocols. It
can help informing the peer for the cause of failures and other error
conditions.  See <a href="#The-Alert-Protocol">The Alert Protocol</a>, for more information.  The
alert protocol is above the record protocol.
</p>
<p>The handshake protocol is responsible for the security parameters&rsquo;
negotiation, the initial key exchange and authentication.
See <a href="#The-Handshake-Protocol">The Handshake Protocol</a>, for more information about the handshake
protocol.  The protocol layering in TLS is shown in <a href="#fig_002dtls_002dlayers">Figure 3.1</a>.
</p>
<div class="float"><span id="fig_002dtls_002dlayers"></span>
<img src="gnutls-layers.png" alt="gnutls-layers">

<div class="float-caption"><p><strong>Figure 3.1: </strong>The TLS protocol layers.</p></div></div>
<hr>
<span id="The-transport-layer"></span><div class="header">
<p>
Next: <a href="#The-TLS-record-protocol" accesskey="n" rel="next">The TLS record protocol</a>, Previous: <a href="#TLS-layers" accesskey="p" rel="prev">TLS layers</a>, Up: <a href="#Introduction-to-TLS" accesskey="u" rel="up">Introduction to TLS</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="The-Transport-Layer"></span><h3 class="section">3.2 The Transport Layer</h3>
<span id="index-transport-protocol"></span>
<span id="index-transport-layer"></span>

<p><acronym>TLS</acronym> is not limited to any transport layer and can be used
above any transport layer, as long as it is a reliable one.  <acronym>DTLS</acronym>
can be used over reliable and unreliable transport layers.
<acronym>GnuTLS</acronym> supports TCP and UDP layers transparently using
the Berkeley sockets API. However, any transport layer can be used
by providing callbacks for <acronym>GnuTLS</acronym> to access the transport layer
(for details see <a href="#Setting-up-the-transport-layer">Setting up the transport layer</a>).
</p>
<hr>
<span id="The-TLS-record-protocol"></span><div class="header">
<p>
Next: <a href="#The-TLS-Alert-Protocol" accesskey="n" rel="next">The TLS Alert Protocol</a>, Previous: <a href="#The-transport-layer" accesskey="p" rel="prev">The transport layer</a>, Up: <a href="#Introduction-to-TLS" accesskey="u" rel="up">Introduction to TLS</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="The-TLS-record-protocol-1"></span><h3 class="section">3.3 The TLS record protocol</h3>
<span id="index-record-protocol"></span>

<p>The record protocol is the secure communications provider. Its purpose
is to encrypt, and authenticate packets.
The record layer functions can be called at any time after
the handshake process is finished, when there is need to receive
or send data. In <acronym>DTLS</acronym> however, due to re-transmission
timers used in the handshake out-of-order handshake data might
be received for some time (maximum 60 seconds) after the handshake
process is finished.
</p>
<p>The functions to access the record protocol are limited to send
and receive functions, which might, given
the importance of this protocol in <acronym>TLS</acronym>, seem awkward.  This is because
the record protocol&rsquo;s parameters are all set by the handshake protocol.
The record protocol initially starts with NULL parameters, which means
no encryption, and no MAC is used. Encryption and authentication begin
just after the handshake protocol has finished.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Encryption-algorithms-used-in-the-record-layer" accesskey="1">Encryption algorithms used in the record layer</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Compression-algorithms-and-the-record-layer" accesskey="2">Compression algorithms and the record layer</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#On-Record-Padding" accesskey="3">On Record Padding</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Encryption-algorithms-used-in-the-record-layer"></span><div class="header">
<p>
Next: <a href="#Compression-algorithms-and-the-record-layer" accesskey="n" rel="next">Compression algorithms and the record layer</a>, Up: <a href="#The-TLS-record-protocol" accesskey="u" rel="up">The TLS record protocol</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Encryption-algorithms-used-in-the-record-layer-1"></span><h4 class="subsection">3.3.1 Encryption algorithms used in the record layer</h4>
<span id="index-symmetric-encryption-algorithms"></span>

<p>Confidentiality in the record layer is achieved by using symmetric
ciphers like <code>AES</code> or <code>CHACHA20</code>.  Ciphers are encryption algorithms
that use a single, secret, key to encrypt and decrypt data. Early
versions of TLS separated between block and stream ciphers and had
message authentication plugged in to them by the protocol, though later
versions switched to using authenticated-encryption (AEAD) ciphers. The AEAD
ciphers are defined to combine encryption and authentication, and as such
they are not only more efficient, as the primitives used are designed to
interoperate nicely, but they are also known to interoperate in a secure
way.
</p>
<p>The supported in <acronym>GnuTLS</acronym> ciphers and MAC algorithms are shown in <a href="#tab_003aciphers">Table 3.1</a> and
<a href="#tab_003amacs">Table 3.2</a>.
</p>
<div class="float"><span id="tab_003aciphers"></span>
<table>
<thead><tr><th width="20%">Algorithm</th><th width="10%">Type</th><th width="15%">Applicable Protocols</th><th width="55%">Description</th></tr></thead>
<tr><td width="20%">AES-128-GCM, AES-256-GCM</td><td width="10%">AEAD</td><td width="15%">TLS 1.2, TLS 1.3</td><td width="55%">This is the AES algorithm in the authenticated encryption GCM mode.
This mode combines message authentication and encryption and can
be extremely fast on CPUs that support hardware acceleration.</td></tr>
<tr><td width="20%">AES-128-CCM, AES-256-CCM</td><td width="10%">AEAD</td><td width="15%">TLS 1.2, TLS 1.3</td><td width="55%">This is the AES algorithm in the authenticated encryption CCM mode.
This mode combines message authentication and encryption and is
often used by systems without AES or GCM acceleration support.</td></tr>
<tr><td width="20%">CHACHA20-POLY1305</td><td width="10%">AEAD</td><td width="15%">TLS 1.2, TLS 1.3</td><td width="55%">CHACHA20-POLY1305 is an authenticated encryption algorithm based on CHACHA20 cipher and
POLY1305 MAC. CHACHA20 is a refinement of SALSA20 algorithm, an approved cipher by
the European ESTREAM project. POLY1305 is Wegman-Carter, one-time authenticator. The
combination provides a fast stream cipher suitable for systems where a hardware AES
accelerator is not available.</td></tr>
<tr><td width="20%">AES-128-CCM-8, AES-256-CCM-8</td><td width="10%">AEAD</td><td width="15%">TLS 1.2, TLS 1.3</td><td width="55%">This is the AES algorithm in the authenticated encryption CCM mode
with a truncated to 64-bit authentication tag. This mode is for
communication with restricted systems.</td></tr>
<tr><td width="20%">CAMELLIA-128-GCM, CAMELLIA-256-GCM</td><td width="10%">AEAD</td><td width="15%">TLS 1.2</td><td width="55%">This is the CAMELLIA algorithm in the authenticated encryption GCM mode.</td></tr>
<tr><td width="20%">AES-128-CBC, AES-256-CBC</td><td width="10%">Legacy (block)</td><td width="15%">TLS 1.0, TLS 1.1, TLS 1.2</td><td width="55%">AES or RIJNDAEL is the block cipher algorithm that replaces the old
DES algorithm.  It has 128 bits block size and is used in CBC mode.</td></tr>
<tr><td width="20%">CAMELLIA-128-CBC, CAMELLIA-256-CBC</td><td width="10%">Legacy (block)</td><td width="15%">TLS 1.0, TLS 1.1, TLS 1.2</td><td width="55%">This is an 128-bit block cipher developed by Mitsubishi and NTT. It
is one of the approved ciphers of the European NESSIE and Japanese
CRYPTREC projects.</td></tr>
<tr><td width="20%">3DES-CBC</td><td width="10%">Legacy (block)</td><td width="15%">TLS 1.0, TLS 1.1, TLS 1.2</td><td width="55%">This is the DES block cipher algorithm used with triple
encryption (EDE). Has 64 bits block size and is used in CBC mode.</td></tr>
<tr><td width="20%">ARCFOUR-128</td><td width="10%">Legacy (stream)</td><td width="15%">TLS 1.0, TLS 1.1, TLS 1.2</td><td width="55%">ARCFOUR-128 is a compatible algorithm with RSA&rsquo;s RC4 algorithm, which is considered to be a trade
secret. It is a considered to be broken, and is only used for compatibility
purposed. For this reason it is not enabled by default.</td></tr>
<tr><td width="20%">NULL</td><td width="10%">Legacy (stream)</td><td width="15%">TLS 1.0, TLS 1.1, TLS 1.2</td><td width="55%">NULL is the empty/identity cipher which doesn&rsquo;t encrypt any data. It can be
combined with data authentication under TLS 1.2 or earlier, but is only used
transiently under TLS 1.3 until encryption starts. This cipher cannot be negotiated
by default (need to be explicitly enabled) under TLS 1.2, and cannot be
negotiated at all under TLS 1.3. When enabled, TLS 1.3 (or later) support will be
implicitly disabled.</td></tr>
</table>

<div class="float-caption"><p><strong>Table 3.1: </strong>Supported ciphers in TLS.</p></div></div>

<div class="float"><span id="tab_003amacs"></span>
<table>
<thead><tr><th width="20%">Algorithm</th><th width="70%">Description</th></tr></thead>
<tr><td width="20%">MAC-MD5</td><td width="70%">This is an HMAC based on MD5 a cryptographic hash algorithm designed
by Ron Rivest. Outputs 128 bits of data.</td></tr>
<tr><td width="20%">MAC-SHA1</td><td width="70%">An HMAC based on the SHA1 cryptographic hash algorithm
designed by NSA. Outputs 160 bits of data.</td></tr>
<tr><td width="20%">MAC-SHA256</td><td width="70%">An HMAC based on SHA2-256. Outputs 256 bits of data.</td></tr>
<tr><td width="20%">MAC-SHA384</td><td width="70%">An HMAC based on SHA2-384. Outputs 384 bits of data.</td></tr>
<tr><td width="20%">MAC-AEAD</td><td width="70%">This indicates that an authenticated encryption algorithm, such as
GCM, is in use.</td></tr>
</table>

<div class="float-caption"><p><strong>Table 3.2: </strong>Supported MAC algorithms in TLS.</p></div></div>

<hr>
<span id="Compression-algorithms-and-the-record-layer"></span><div class="header">
<p>
Next: <a href="#On-Record-Padding" accesskey="n" rel="next">On Record Padding</a>, Previous: <a href="#Encryption-algorithms-used-in-the-record-layer" accesskey="p" rel="prev">Encryption algorithms used in the record layer</a>, Up: <a href="#The-TLS-record-protocol" accesskey="u" rel="up">The TLS record protocol</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Compression-algorithms-and-the-record-layer-1"></span><h4 class="subsection">3.3.2 Compression algorithms and the record layer</h4>
<span id="index-compression-algorithms"></span>

<p>In early versions of TLS the record layer supported compression. However,
that proved to be problematic in many ways, and enabled several attacks
based on traffic analysis on the transported data. For that newer versions of the protocol no longer
offer compression, and <acronym>GnuTLS</acronym> since 3.6.0 no longer implements any
support for compression.
</p>
<hr>
<span id="On-Record-Padding"></span><div class="header">
<p>
Previous: <a href="#Compression-algorithms-and-the-record-layer" accesskey="p" rel="prev">Compression algorithms and the record layer</a>, Up: <a href="#The-TLS-record-protocol" accesskey="u" rel="up">The TLS record protocol</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="On-record-padding"></span><h4 class="subsection">3.3.3 On record padding</h4>
<span id="index-record-padding"></span>
<span id="index-bad_005frecord_005fmac"></span>

<p>The TLS 1.3 protocol allows for extra padding of records to prevent
statistical analysis based on the length of exchanged messages.
GnuTLS takes advantage of this feature, by allowing the user
to specify the amount of padding for a particular message. The simplest
interface is provided by <a href="#gnutls_005frecord_005fsend2">gnutls_record_send2</a>, and is made
available when under TLS1.3; alternatively <a href="#gnutls_005frecord_005fcan_005fuse_005flength_005fhiding">gnutls_record_can_use_length_hiding</a>
can be queried.
</p>
<p>Note that this interface is not sufficient to completely hide the length of the
data. The application code may reveal the data transferred by leaking its
data processing time, or by leaking the TLS1.3 record processing time by
GnuTLS. That is because under TLS1.3 the padding removal time depends on the
padding data for an efficient implementation. To make that processing
constant time the <a href="#gnutls_005finit">gnutls_init</a> function must be called with
the flag <code>GNUTLS_SAFE_PADDING_CHECK</code>.
</p>




<dl>
<dt id="index-gnutls_005frecord_005fsend2">Function: <em>ssize_t</em> <strong>gnutls_record_send2</strong> <em>(gnutls_session_t <var>session</var>, const void * <var>data</var>, size_t <var>data_size</var>, size_t <var>pad</var>, unsigned <var>flags</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>data</var>: contains the data to send
</p>
<p><var>data_size</var>: is the length of the data
</p>
<p><var>pad</var>: padding to be added to the record
</p>
<p><var>flags</var>: must be zero
</p>
<p>This function is identical to <code>gnutls_record_send()</code>  except that it
takes an extra argument to specify padding to be added the record.
To determine the maximum size of padding, use
<code>gnutls_record_get_max_size()</code>  and <code>gnutls_record_overhead_size()</code> .
</p>
<p>Note that in order for GnuTLS to provide constant time processing
of padding and data in TLS1.3, the flag <code>GNUTLS_SAFE_PADDING_CHECK</code> 
must be used in <code>gnutls_init()</code> .
</p>
<p><strong>Returns:</strong> The number of bytes sent, or a negative error code.  The
number of bytes sent might be less than  <code>data_size</code> .  The maximum
number of bytes this function can send in a single call depends
on the negotiated maximum record size.
</p>
<p><strong>Since:</strong> 3.6.3
</p></dd></dl>

<p>Older GnuTLS versions provided an API suitable for cases where the sender
sends data that are always within a given range. That API is still
available, and consists of the following functions.
</p>
<dl compact="compact">
<dt><code><var>unsigned</var> <a href="#gnutls_005frecord_005fcan_005fuse_005flength_005fhiding">gnutls_record_can_use_length_hiding</a> (gnutls_session_t <var>session</var>)</code></dt>
<dt><code><var>ssize_t</var> <a href="#gnutls_005frecord_005fsend_005frange">gnutls_record_send_range</a> (gnutls_session_t <var>session</var>, const void * <var>data</var>, size_t <var>data_size</var>, const gnutls_range_st * <var>range</var>)</code></dt>
</dl>

<hr>
<span id="The-TLS-Alert-Protocol"></span><div class="header">
<p>
Next: <a href="#The-TLS-Handshake-Protocol" accesskey="n" rel="next">The TLS Handshake Protocol</a>, Previous: <a href="#The-TLS-record-protocol" accesskey="p" rel="prev">The TLS record protocol</a>, Up: <a href="#Introduction-to-TLS" accesskey="u" rel="up">Introduction to TLS</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="The-TLS-alert-protocol"></span><h3 class="section">3.4 The TLS alert protocol</h3>
<span id="The-Alert-Protocol"></span><span id="index-alert-protocol"></span>

<p>The alert protocol is there to allow signals to be sent between peers.
These signals are mostly used to inform the peer about the cause of a
protocol failure. Some of these signals are used internally by the
protocol and the application protocol does not have to cope with them
(e.g. <code>GNUTLS_A_CLOSE_NOTIFY</code>), and others refer to the
application protocol solely (e.g. <code>GNUTLS_A_USER_CANCELLED</code>).  An
alert signal includes a level indication which may be either fatal or
warning (under TLS1.3 all alerts are fatal). Fatal alerts always terminate
the current connection, and prevent future re-negotiations using the current
session ID. All supported alert messages are summarized in the table below.
</p>
<p>The alert messages are protected by the record protocol, thus the
information that is included does not leak. You must take extreme care
for the alert information not to leak to a possible attacker, via
public log files etc.
</p>
<table>
<tr><td><span id="tab_003aalerts"></span></td></tr>
<thead><tr><th width="55%">Alert</th><th width="10%">ID</th><th width="30%">Description</th></tr></thead>
<tr><td width="55%">GNUTLS_A_CLOSE_NOTIFY</td><td width="10%">0</td><td width="30%">Close notify</td></tr>
<tr><td width="55%">GNUTLS_A_UNEXPECTED_MESSAGE</td><td width="10%">10</td><td width="30%">Unexpected message</td></tr>
<tr><td width="55%">GNUTLS_A_BAD_RECORD_MAC</td><td width="10%">20</td><td width="30%">Bad record MAC</td></tr>
<tr><td width="55%">GNUTLS_A_DECRYPTION_FAILED</td><td width="10%">21</td><td width="30%">Decryption failed</td></tr>
<tr><td width="55%">GNUTLS_A_RECORD_OVERFLOW</td><td width="10%">22</td><td width="30%">Record overflow</td></tr>
<tr><td width="55%">GNUTLS_A_DECOMPRESSION_FAILURE</td><td width="10%">30</td><td width="30%">Decompression failed</td></tr>
<tr><td width="55%">GNUTLS_A_HANDSHAKE_FAILURE</td><td width="10%">40</td><td width="30%">Handshake failed</td></tr>
<tr><td width="55%">GNUTLS_A_SSL3_NO_CERTIFICATE</td><td width="10%">41</td><td width="30%">No certificate (SSL 3.0)</td></tr>
<tr><td width="55%">GNUTLS_A_BAD_CERTIFICATE</td><td width="10%">42</td><td width="30%">Certificate is bad</td></tr>
<tr><td width="55%">GNUTLS_A_UNSUPPORTED_CERTIFICATE</td><td width="10%">43</td><td width="30%">Certificate is not supported</td></tr>
<tr><td width="55%">GNUTLS_A_CERTIFICATE_REVOKED</td><td width="10%">44</td><td width="30%">Certificate was revoked</td></tr>
<tr><td width="55%">GNUTLS_A_CERTIFICATE_EXPIRED</td><td width="10%">45</td><td width="30%">Certificate is expired</td></tr>
<tr><td width="55%">GNUTLS_A_CERTIFICATE_UNKNOWN</td><td width="10%">46</td><td width="30%">Unknown certificate</td></tr>
<tr><td width="55%">GNUTLS_A_ILLEGAL_PARAMETER</td><td width="10%">47</td><td width="30%">Illegal parameter</td></tr>
<tr><td width="55%">GNUTLS_A_UNKNOWN_CA</td><td width="10%">48</td><td width="30%">CA is unknown</td></tr>
<tr><td width="55%">GNUTLS_A_ACCESS_DENIED</td><td width="10%">49</td><td width="30%">Access was denied</td></tr>
<tr><td width="55%">GNUTLS_A_DECODE_ERROR</td><td width="10%">50</td><td width="30%">Decode error</td></tr>
<tr><td width="55%">GNUTLS_A_DECRYPT_ERROR</td><td width="10%">51</td><td width="30%">Decrypt error</td></tr>
<tr><td width="55%">GNUTLS_A_EXPORT_RESTRICTION</td><td width="10%">60</td><td width="30%">Export restriction</td></tr>
<tr><td width="55%">GNUTLS_A_PROTOCOL_VERSION</td><td width="10%">70</td><td width="30%">Error in protocol version</td></tr>
<tr><td width="55%">GNUTLS_A_INSUFFICIENT_SECURITY</td><td width="10%">71</td><td width="30%">Insufficient security</td></tr>
<tr><td width="55%">GNUTLS_A_INTERNAL_ERROR</td><td width="10%">80</td><td width="30%">Internal error</td></tr>
<tr><td width="55%">GNUTLS_A_INAPPROPRIATE_FALLBACK</td><td width="10%">86</td><td width="30%">Inappropriate fallback</td></tr>
<tr><td width="55%">GNUTLS_A_USER_CANCELED</td><td width="10%">90</td><td width="30%">User canceled</td></tr>
<tr><td width="55%">GNUTLS_A_NO_RENEGOTIATION</td><td width="10%">100</td><td width="30%">No renegotiation is allowed</td></tr>
<tr><td width="55%">GNUTLS_A_MISSING_EXTENSION</td><td width="10%">109</td><td width="30%">An extension was expected but was not seen</td></tr>
<tr><td width="55%">GNUTLS_A_UNSUPPORTED_EXTENSION</td><td width="10%">110</td><td width="30%">An unsupported extension was sent</td></tr>
<tr><td width="55%">GNUTLS_A_CERTIFICATE_UNOBTAINABLE</td><td width="10%">111</td><td width="30%">Could not retrieve the specified certificate</td></tr>
<tr><td width="55%">GNUTLS_A_UNRECOGNIZED_NAME</td><td width="10%">112</td><td width="30%">The server name sent was not recognized</td></tr>
<tr><td width="55%">GNUTLS_A_UNKNOWN_PSK_IDENTITY</td><td width="10%">115</td><td width="30%">The SRP/PSK username is missing or not known</td></tr>
<tr><td width="55%">GNUTLS_A_CERTIFICATE_REQUIRED</td><td width="10%">116</td><td width="30%">Certificate is required</td></tr>
<tr><td width="55%">GNUTLS_A_NO_APPLICATION_PROTOCOL</td><td width="10%">120</td><td width="30%">No supported application protocol could be negotiated</td></tr>
</table>

<hr>
<span id="The-TLS-Handshake-Protocol"></span><div class="header">
<p>
Next: <a href="#TLS-Extensions" accesskey="n" rel="next">TLS Extensions</a>, Previous: <a href="#The-TLS-Alert-Protocol" accesskey="p" rel="prev">The TLS Alert Protocol</a>, Up: <a href="#Introduction-to-TLS" accesskey="u" rel="up">Introduction to TLS</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="The-TLS-handshake-protocol"></span><h3 class="section">3.5 The TLS handshake protocol</h3>
<span id="The-Handshake-Protocol"></span><span id="index-handshake-protocol"></span>

<p>The handshake protocol is responsible for the ciphersuite negotiation,
the initial key exchange, and the authentication of the two peers.
This is fully controlled by the application layer, thus your program
has to set up the required parameters. The main handshake function
is <a href="#gnutls_005fhandshake">gnutls_handshake</a>. In the next paragraphs we elaborate on
the handshake protocol, i.e., the ciphersuite negotiation.
</p>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#TLS-Cipher-Suites" accesskey="1">TLS Cipher Suites</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">TLS session parameters.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Authentication" accesskey="2">Authentication</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">TLS authentication.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Client-Authentication" accesskey="3">Client Authentication</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Requesting a certificate from the client.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Resuming-Sessions" accesskey="4">Resuming Sessions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Reusing previously established keys.
</td></tr>
</table>


<hr>
<span id="TLS-Cipher-Suites"></span><div class="header">
<p>
Next: <a href="#Authentication" accesskey="n" rel="next">Authentication</a>, Up: <a href="#The-TLS-Handshake-Protocol" accesskey="u" rel="up">The TLS Handshake Protocol</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="TLS-ciphersuites"></span><h4 class="subsection">3.5.1 TLS ciphersuites</h4>

<p>The TLS cipher suites have slightly different meaning under different
protocols. Under <acronym>TLS 1.3</acronym>, a cipher suite indicates the symmetric
encryption algorithm in use, as well as the pseudo-random function (PRF)
used in the TLS session.
</p>
<p>Under TLS 1.2 or early the handshake protocol negotiates cipher suites of
a special form illustrated by the <code>TLS_DHE_RSA_WITH_3DES_CBC_SHA</code> cipher suite name.
A typical cipher suite contains these parameters:
</p>
<ul>
<li> The key exchange algorithm.
<code>DHE_RSA</code> in the example.

</li><li> The Symmetric encryption algorithm and mode
<code>3DES_CBC</code> in this example.

</li><li> The MAC<a id="DOCF5" href="#FOOT5"><sup>5</sup></a> algorithm used for authentication.
<code>MAC_SHA</code> is used in the above example.

</li></ul>

<p>The cipher suite negotiated in the handshake protocol will affect the
record protocol, by enabling encryption and data authentication.  Note
that you should not over rely on <acronym>TLS</acronym> to negotiate the
strongest available cipher suite. Do not enable ciphers and algorithms
that you consider weak.
</p>
<p>All the supported ciphersuites are listed in <a href="#ciphersuites">ciphersuites</a>.
</p>
<hr>
<span id="Authentication"></span><div class="header">
<p>
Next: <a href="#Client-Authentication" accesskey="n" rel="next">Client Authentication</a>, Previous: <a href="#TLS-Cipher-Suites" accesskey="p" rel="prev">TLS Cipher Suites</a>, Up: <a href="#The-TLS-Handshake-Protocol" accesskey="u" rel="up">The TLS Handshake Protocol</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Authentication-1"></span><h4 class="subsection">3.5.2 Authentication</h4>

<p>The key exchange algorithms of the <acronym>TLS</acronym> protocol offer
authentication, which is a prerequisite for a secure connection.
The available authentication methods in <acronym>GnuTLS</acronym>, under
TLS 1.3 or earlier versions, follow.
</p>
<ul>
<li> Certificate authentication: Authenticated key exchange using public key infrastructure and X.509 certificates.
</li><li> <acronym>PSK</acronym> authentication: Authenticated key exchange using a pre-shared key.

</li></ul>

<p>Under TLS 1.2 or earlier versions, the following authentication methods
are also available.
</p>
<ul>
<li> <acronym>SRP</acronym> authentication: Authenticated key exchange using a password.
</li><li> Anonymous authentication: Key exchange without peer authentication.

</li></ul>

<hr>
<span id="Client-Authentication"></span><div class="header">
<p>
Next: <a href="#Resuming-Sessions" accesskey="n" rel="next">Resuming Sessions</a>, Previous: <a href="#Authentication" accesskey="p" rel="prev">Authentication</a>, Up: <a href="#The-TLS-Handshake-Protocol" accesskey="u" rel="up">The TLS Handshake Protocol</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Client-authentication"></span><h4 class="subsection">3.5.3 Client authentication</h4>
<span id="index-client-certificate-authentication"></span>

<p>In the case of ciphersuites that use certificate authentication, the
authentication of the client is optional in <acronym>TLS</acronym>.  A server
may request a certificate from the client using the
<a href="#gnutls_005fcertificate_005fserver_005fset_005frequest">gnutls_certificate_server_set_request</a> function. We elaborate
in <a href="#Certificate-credentials">Certificate credentials</a>.
</p>
<hr>
<span id="Resuming-Sessions"></span><div class="header">
<p>
Previous: <a href="#Client-Authentication" accesskey="p" rel="prev">Client Authentication</a>, Up: <a href="#The-TLS-Handshake-Protocol" accesskey="u" rel="up">The TLS Handshake Protocol</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Resuming-sessions"></span><h4 class="subsection">3.5.4 Resuming sessions</h4>
<span id="resume"></span><span id="index-resuming-sessions"></span>
<span id="index-session-resumption"></span>

<p>The TLS handshake process performs expensive calculations
and a busy server might easily be put under load. To
reduce the load, session resumption may be used. This
is a feature of the <acronym>TLS</acronym> protocol which allows a
client to connect to a server after a successful handshake, without
the expensive calculations.  This is achieved by re-using the previously
established keys, meaning the server needs to store the state of established
connections (unless session tickets are used &ndash; <a href="#Session-tickets">Session tickets</a>).
</p>
<p>Session resumption is an integral part of <acronym>GnuTLS</acronym>, and
<a href="#Session-resumption">Session resumption</a>, <a href="#ex_002dresume_002dclient">ex-resume-client</a> illustrate typical
uses of it.
</p>
<hr>
<span id="TLS-Extensions"></span><div class="header">
<p>
Next: <a href="#How-to-use-TLS-in-application-protocols" accesskey="n" rel="next">How to use TLS in application protocols</a>, Previous: <a href="#The-TLS-Handshake-Protocol" accesskey="p" rel="prev">The TLS Handshake Protocol</a>, Up: <a href="#Introduction-to-TLS" accesskey="u" rel="up">Introduction to TLS</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="TLS-extensions"></span><h3 class="section">3.6 TLS extensions</h3>
<span id="index-TLS-extensions"></span>

<p>A number of extensions to the <acronym>TLS</acronym> protocol have been
proposed mainly in [<a href="#TLSEXT">TLSEXT</a>]. The extensions supported
in <acronym>GnuTLS</acronym> are discussed in the subsections that follow.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Maximum-fragment-length-negotiation" accesskey="1">Maximum fragment length negotiation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Server-name-indication" accesskey="2">Server name indication</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Session-tickets" accesskey="3">Session tickets</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#HeartBeat" accesskey="4">HeartBeat</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Safe-renegotiation" accesskey="5">Safe renegotiation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#OCSP-status-request" accesskey="6">OCSP status request</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#SRTP" accesskey="7">SRTP</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#False-Start" accesskey="8">False Start</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Application-Layer-Protocol-Negotiation-_0028ALPN_0029" accesskey="9">Application Layer Protocol Negotiation (ALPN)</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Extensions-and-Supplemental-Data">Extensions and Supplemental Data</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Maximum-fragment-length-negotiation"></span><div class="header">
<p>
Next: <a href="#Server-name-indication" accesskey="n" rel="next">Server name indication</a>, Up: <a href="#TLS-Extensions" accesskey="u" rel="up">TLS Extensions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Maximum-fragment-length-negotiation-1"></span><h4 class="subsection">3.6.1 Maximum fragment length negotiation</h4>
<span id="index-TLS-extensions-1"></span>
<span id="index-maximum-fragment-length"></span>

<p>This extension allows a <acronym>TLS</acronym> implementation to negotiate a
smaller value for record packet maximum length. This extension may be
useful to clients with constrained capabilities. The functions shown
below can be used to control this extension.
</p>
<dl compact="compact">
<dt><code><var>size_t</var> <a href="#gnutls_005frecord_005fget_005fmax_005fsize">gnutls_record_get_max_size</a> (gnutls_session_t <var>session</var>)</code></dt>
<dt><code><var>ssize_t</var> <a href="#gnutls_005frecord_005fset_005fmax_005fsize">gnutls_record_set_max_size</a> (gnutls_session_t <var>session</var>, size_t <var>size</var>)</code></dt>
</dl>

<hr>
<span id="Server-name-indication"></span><div class="header">
<p>
Next: <a href="#Session-tickets" accesskey="n" rel="next">Session tickets</a>, Previous: <a href="#Maximum-fragment-length-negotiation" accesskey="p" rel="prev">Maximum fragment length negotiation</a>, Up: <a href="#TLS-Extensions" accesskey="u" rel="up">TLS Extensions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Server-name-indication-1"></span><h4 class="subsection">3.6.2 Server name indication</h4>
<span id="serverind"></span><span id="index-TLS-extensions-2"></span>
<span id="index-server-name-indication"></span>

<p>A common problem in <acronym>HTTPS</acronym> servers is the fact that the
<acronym>TLS</acronym> protocol is not aware of the hostname that a client
connects to, when the handshake procedure begins. For that reason the
<acronym>TLS</acronym> server has no way to know which certificate to send.
</p>
<p>This extension solves that problem within the <acronym>TLS</acronym> protocol,
and allows a client to send the HTTP hostname before the handshake
begins within the first handshake packet.  The functions
<a href="#gnutls_005fserver_005fname_005fset">gnutls_server_name_set</a> and <a href="#gnutls_005fserver_005fname_005fget">gnutls_server_name_get</a> can be
used to enable this extension, or to retrieve the name sent by a
client.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fserver_005fname_005fset">gnutls_server_name_set</a> (gnutls_session_t <var>session</var>, gnutls_server_name_type_t <var>type</var>, const void * <var>name</var>, size_t <var>name_length</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fserver_005fname_005fget">gnutls_server_name_get</a> (gnutls_session_t <var>session</var>, void * <var>data</var>, size_t * <var>data_length</var>, unsigned int * <var>type</var>, unsigned int <var>indx</var>)</code></dt>
</dl>

<hr>
<span id="Session-tickets"></span><div class="header">
<p>
Next: <a href="#HeartBeat" accesskey="n" rel="next">HeartBeat</a>, Previous: <a href="#Server-name-indication" accesskey="p" rel="prev">Server name indication</a>, Up: <a href="#TLS-Extensions" accesskey="u" rel="up">TLS Extensions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Session-tickets-1"></span><h4 class="subsection">3.6.3 Session tickets</h4>
<span id="index-TLS-extensions-3"></span>
<span id="index-session-tickets"></span>
<span id="index-tickets"></span>

<p>To resume a TLS session, the server normally stores session parameters.  This
complicates deployment, and can be avoided by delegating the storage
to the client. Because session parameters are sensitive they are encrypted
and authenticated with a key only known to the server and then sent to the
client. The Session Tickets extension is described in RFC 5077 [<a href="#TLSTKT">TLSTKT</a>].
</p>
<p>A disadvantage of session tickets is that they eliminate the effects of
forward secrecy when a server uses the same key for long time. That is,
the secrecy of all sessions on a server using tickets depends on the ticket
key being kept secret. For that reason server keys should be rotated and discarded
regularly.
</p>
<p>Since version 3.1.3 GnuTLS clients transparently support session tickets,
unless forward secrecy is explicitly requested (with the PFS priority string).
</p>
<p>Under TLS 1.3 session tickets are mandatory for session resumption, and they
do not share the forward secrecy concerns as with TLS 1.2 or earlier.
</p>
<hr>
<span id="HeartBeat"></span><div class="header">
<p>
Next: <a href="#Safe-renegotiation" accesskey="n" rel="next">Safe renegotiation</a>, Previous: <a href="#Session-tickets" accesskey="p" rel="prev">Session tickets</a>, Up: <a href="#TLS-Extensions" accesskey="u" rel="up">TLS Extensions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="HeartBeat-1"></span><h4 class="subsection">3.6.4 HeartBeat</h4>
<span id="index-TLS-extensions-4"></span>
<span id="index-heartbeat"></span>

<p>This is a TLS extension that allows to ping and receive confirmation from the peer,
and is described in [<a href="#RFC6520">RFC6520</a>]. The extension is disabled by default and
<a href="#gnutls_005fheartbeat_005fenable">gnutls_heartbeat_enable</a> can be used to enable it. A policy
may be negotiated to only allow sending heartbeat messages or sending and receiving.
The current session policy can be checked with <a href="#gnutls_005fheartbeat_005fallowed">gnutls_heartbeat_allowed</a>.
The requests coming from the peer result to <code>GNUTLS_E_HEARTBEAT_PING_RECEIVED</code>
being returned from the receive function. Ping requests to peer can be send via
<a href="#gnutls_005fheartbeat_005fping">gnutls_heartbeat_ping</a>.
</p>
<dl compact="compact">
<dt><code><var>unsigned</var> <a href="#gnutls_005fheartbeat_005fallowed">gnutls_heartbeat_allowed</a> (gnutls_session_t <var>session</var>, unsigned int <var>type</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005fheartbeat_005fenable">gnutls_heartbeat_enable</a> (gnutls_session_t <var>session</var>, unsigned int <var>type</var>)</code></dt>
</dl>

<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fheartbeat_005fping">gnutls_heartbeat_ping</a> (gnutls_session_t <var>session</var>, size_t <var>data_size</var>, unsigned int <var>max_tries</var>, unsigned int <var>flags</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fheartbeat_005fpong">gnutls_heartbeat_pong</a> (gnutls_session_t <var>session</var>, unsigned int <var>flags</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005fheartbeat_005fset_005ftimeouts">gnutls_heartbeat_set_timeouts</a> (gnutls_session_t <var>session</var>, unsigned int <var>retrans_timeout</var>, unsigned int <var>total_timeout</var>)</code></dt>
<dt><code><var>unsigned int</var> <a href="#gnutls_005fheartbeat_005fget_005ftimeout">gnutls_heartbeat_get_timeout</a> (gnutls_session_t <var>session</var>)</code></dt>
</dl>

<hr>
<span id="Safe-renegotiation"></span><div class="header">
<p>
Next: <a href="#OCSP-status-request" accesskey="n" rel="next">OCSP status request</a>, Previous: <a href="#HeartBeat" accesskey="p" rel="prev">HeartBeat</a>, Up: <a href="#TLS-Extensions" accesskey="u" rel="up">TLS Extensions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Safe-renegotiation-1"></span><h4 class="subsection">3.6.5 Safe renegotiation</h4>
<span id="index-renegotiation"></span>
<span id="index-safe-renegotiation"></span>

<p>TLS gives the option to two communicating parties to renegotiate
and update their security parameters. One useful example of this feature
was for a client to initially connect using anonymous negotiation to a
server, and the renegotiate using some authenticated ciphersuite. This occurred
to avoid having the client sending its credentials in the clear.
</p>
<p>However this renegotiation, as initially designed would not ensure that
the party one is renegotiating is the same as the one in the initial negotiation.
For example one server could forward all renegotiation traffic to an other
server who will see this traffic as an initial negotiation attempt.
</p>
<p>This might be seen as a valid design decision, but it seems it was
not widely known or understood, thus today some application protocols use the TLS
renegotiation feature in a manner that enables a malicious server to insert
content of his choice in the beginning of a TLS session.
</p>
<p>The most prominent vulnerability was with HTTPS. There servers request
a renegotiation to enforce an anonymous user to use a certificate in order
to access certain parts of a web site.  The
attack works by having the attacker simulate a client and connect to a
server, with server-only authentication, and send some data intended
to cause harm.  The server will then require renegotiation from him
in order to perform the request.
When the proper client attempts to contact the server,
the attacker hijacks that connection and forwards traffic to
the initial server that requested renegotiation.  The
attacker will not be able to read the data exchanged between the
client and the server.  However, the server will (incorrectly) assume
that the initial request sent by the attacker was sent by the now authenticated
client.  The result is a prefix plain-text injection attack.
</p>
<p>The above is just one example.  Other vulnerabilities exists that do
not rely on the TLS renegotiation to change the client&rsquo;s authenticated
status (either TLS or application layer).
</p>
<p>While fixing these application protocols and implementations would be
one natural reaction, an extension to TLS has been designed that
cryptographically binds together any renegotiated handshakes with the
initial negotiation.  When the extension is used, the attack is
detected and the session can be terminated.  The extension is
specified in [<a href="#RFC5746">RFC5746</a>].
</p>
<p>GnuTLS supports the safe renegotiation extension.  The default
behavior is as follows.  Clients will attempt to negotiate the safe
renegotiation extension when talking to servers.  Servers will accept
the extension when presented by clients.  Clients and servers will
permit an initial handshake to complete even when the other side does
not support the safe renegotiation extension.  Clients and servers
will refuse renegotiation attempts when the extension has not been
negotiated.
</p>
<p>Note that permitting clients to connect to servers when the safe
renegotiation extension is not enabled, is open up for attacks.
Changing this default behavior would prevent interoperability against
the majority of deployed servers out there.  We will reconsider this
default behavior in the future when more servers have been upgraded.
Note that it is easy to configure clients to always require the safe
renegotiation extension from servers.
</p>
<p>To modify the default behavior, we have introduced some new priority
strings (see <a href="#Priority-Strings">Priority Strings</a>).
The <code>%UNSAFE_RENEGOTIATION</code> priority string permits
(re-)handshakes even when the safe renegotiation extension was not
negotiated. The default behavior is <code>%PARTIAL_RENEGOTIATION</code> that will
prevent renegotiation with clients and servers not supporting the
extension. This is secure for servers but leaves clients vulnerable
to some attacks, but this is a trade-off between security and compatibility
with old servers. The <code>%SAFE_RENEGOTIATION</code> priority string makes
clients and servers require the extension for every handshake. The latter
is the most secure option for clients, at the cost of not being able
to connect to legacy servers. Servers will also deny clients that
do not support the extension from connecting.
</p>
<p>It is possible to disable use of the extension completely, in both
clients and servers, by using the <code>%DISABLE_SAFE_RENEGOTIATION</code>
priority string however we strongly recommend you to only do this for
debugging and test purposes.
</p>
<p>The default values if the flags above are not specified are:
</p><dl compact="compact">
<dt><code>Server:</code></dt>
<dd><p>%PARTIAL_RENEGOTIATION
</p>
</dd>
<dt><code>Client:</code></dt>
<dd><p>%PARTIAL_RENEGOTIATION
</p>
</dd>
</dl>

<p>For applications we have introduced a new API related to safe
renegotiation.  The <a href="#gnutls_005fsafe_005frenegotiation_005fstatus">gnutls_safe_renegotiation_status</a> function is
used to check if the extension has been negotiated on a session, and
can be used both by clients and servers.
</p>
<hr>
<span id="OCSP-status-request"></span><div class="header">
<p>
Next: <a href="#SRTP" accesskey="n" rel="next">SRTP</a>, Previous: <a href="#Safe-renegotiation" accesskey="p" rel="prev">Safe renegotiation</a>, Up: <a href="#TLS-Extensions" accesskey="u" rel="up">TLS Extensions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="OCSP-status-request-1"></span><h4 class="subsection">3.6.6 OCSP status request</h4>
<span id="index-OCSP-status-request"></span>
<span id="index-Certificate-status-request"></span>

<p>The Online Certificate Status Protocol (OCSP) is a protocol that allows the
client to verify the server certificate for revocation without messing with
certificate revocation lists. Its drawback is that it requires the client
to connect to the server&rsquo;s CA OCSP server and request the status of the
certificate. This extension however, enables a TLS server to include
its CA OCSP server response in the handshake. That is an HTTPS server
may periodically run <code>ocsptool</code> (see <a href="#ocsptool-Invocation">ocsptool Invocation</a>) to obtain
its certificate revocation status and serve it to the clients. That
way a client avoids an additional connection to the OCSP server.
</p>
<p>See <a href="#OCSP-stapling">OCSP stapling</a> for further information.
</p>
<p>Since version 3.1.3 GnuTLS clients transparently support the certificate status
request.
</p>
<hr>
<span id="SRTP"></span><div class="header">
<p>
Next: <a href="#False-Start" accesskey="n" rel="next">False Start</a>, Previous: <a href="#OCSP-status-request" accesskey="p" rel="prev">OCSP status request</a>, Up: <a href="#TLS-Extensions" accesskey="u" rel="up">TLS Extensions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="SRTP-1"></span><h4 class="subsection">3.6.7 SRTP</h4>
<span id="index-SRTP"></span>
<span id="index-Secure-RTP"></span>

<p>The TLS protocol was extended in [<a href="#RFC5764">RFC5764</a>] to provide keying material to the
Secure RTP (SRTP) protocol. The SRTP protocol provides an encapsulation of encrypted
data that is optimized for voice data. With the SRTP TLS extension two peers can
negotiate keys using TLS or DTLS and obtain keying material for use with SRTP. The
available SRTP profiles are listed below.
</p>
<div class="float"><span id="gnutls_005fsrtp_005fprofile_005ft"></span>


<dl compact="compact">
<dt><code>GNUTLS_SRTP_AES128_CM_HMAC_SHA1_80</code></dt>
<dd><p>128 bit AES with a 80 bit HMAC-SHA1
</p></dd>
<dt><code>GNUTLS_SRTP_AES128_CM_HMAC_SHA1_32</code></dt>
<dd><p>128 bit AES with a 32 bit HMAC-SHA1
</p></dd>
<dt><code>GNUTLS_SRTP_NULL_HMAC_SHA1_80</code></dt>
<dd><p>NULL cipher with a 80 bit HMAC-SHA1
</p></dd>
<dt><code>GNUTLS_SRTP_NULL_HMAC_SHA1_32</code></dt>
<dd><p>NULL cipher with a 32 bit HMAC-SHA1
</p></dd>
</dl>

<div class="float-caption"><p><strong>Figure 3.2: </strong>Supported SRTP profiles</p></div></div>
<p>To enable use the following functions.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fsrtp_005fset_005fprofile">gnutls_srtp_set_profile</a> (gnutls_session_t <var>session</var>, gnutls_srtp_profile_t <var>profile</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fsrtp_005fset_005fprofile_005fdirect">gnutls_srtp_set_profile_direct</a> (gnutls_session_t <var>session</var>, const char * <var>profiles</var>, const char ** <var>err_pos</var>)</code></dt>
</dl>

<p>To obtain the negotiated keys use the function below.
</p>




<dl>
<dt id="index-gnutls_005fsrtp_005fget_005fkeys">Function: <em>int</em> <strong>gnutls_srtp_get_keys</strong> <em>(gnutls_session_t <var>session</var>, void * <var>key_material</var>, unsigned int <var>key_material_size</var>, gnutls_datum_t * <var>client_key</var>, gnutls_datum_t * <var>client_salt</var>, gnutls_datum_t * <var>server_key</var>, gnutls_datum_t * <var>server_salt</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>key_material</var>: Space to hold the generated key material
</p>
<p><var>key_material_size</var>: The maximum size of the key material
</p>
<p><var>client_key</var>: The master client write key, pointing inside the key material
</p>
<p><var>client_salt</var>: The master client write salt, pointing inside the key material
</p>
<p><var>server_key</var>: The master server write key, pointing inside the key material
</p>
<p><var>server_salt</var>: The master server write salt, pointing inside the key material
</p>
<p>This is a helper function to generate the keying material for SRTP.
It requires the space of the key material to be pre-allocated (should be at least
2x the maximum key size and salt size). The  <code>client_key</code> ,  <code>client_salt</code> ,  <code>server_key</code> and  <code>server_salt</code> are convenience datums that point inside the key material. They may
be <code>NULL</code> .
</p>
<p><strong>Returns:</strong> On success the size of the key material is returned,
otherwise, <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if the buffer given is not 
sufficient, or a negative error code.
</p>
<p>Since 3.1.4
</p></dd></dl>

<p>Other helper functions are listed below.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fsrtp_005fget_005fselected_005fprofile">gnutls_srtp_get_selected_profile</a> (gnutls_session_t <var>session</var>, gnutls_srtp_profile_t * <var>profile</var>)</code></dt>
<dt><code><var>const char *</var> <a href="#gnutls_005fsrtp_005fget_005fprofile_005fname">gnutls_srtp_get_profile_name</a> (gnutls_srtp_profile_t <var>profile</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fsrtp_005fget_005fprofile_005fid">gnutls_srtp_get_profile_id</a> (const char * <var>name</var>, gnutls_srtp_profile_t * <var>profile</var>)</code></dt>
</dl>

<hr>
<span id="False-Start"></span><div class="header">
<p>
Next: <a href="#Application-Layer-Protocol-Negotiation-_0028ALPN_0029" accesskey="n" rel="next">Application Layer Protocol Negotiation (ALPN)</a>, Previous: <a href="#SRTP" accesskey="p" rel="prev">SRTP</a>, Up: <a href="#TLS-Extensions" accesskey="u" rel="up">TLS Extensions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="False-Start-1"></span><h4 class="subsection">3.6.8 False Start</h4>
<span id="index-False-Start"></span>
<span id="index-TLS-False-Start"></span>

<p>The TLS protocol was extended in [<a href="#RFC7918">RFC7918</a>] to allow the client
to send data to server in a single round trip. This change however operates on the borderline
of the TLS protocol security guarantees and should be used for the cases where the reduced
latency outperforms the risk of an adversary intercepting the transferred data. In GnuTLS
applications can use the <acronym>GNUTLS_ENABLE_FALSE_START</acronym> as option to <a href="#gnutls_005finit">gnutls_init</a>
to request an early return of the <a href="#gnutls_005fhandshake">gnutls_handshake</a> function. After that early
return the application is expected to transfer any data to be piggybacked on the last handshake
message.
</p>
<p>After handshake&rsquo;s early termination, the application is expected to transmit
data using <a href="#gnutls_005frecord_005fsend">gnutls_record_send</a>, and call <a href="#gnutls_005frecord_005frecv">gnutls_record_recv</a> on
any received data as soon, to ensure that handshake completes timely. That is, especially
relevant for applications which set an explicit time limit for the handshake process
via <a href="#gnutls_005fhandshake_005fset_005ftimeout">gnutls_handshake_set_timeout</a>.
</p>
<p>Note however, that the API ensures that the early return will not happen
if the false start requirements are not satisfied. That is, on ciphersuites which are not
whitelisted for false start or on insufficient key sizes, the handshake
process will complete properly (i.e., no early return). To verify that false start was used you
may use <a href="#gnutls_005fsession_005fget_005fflags">gnutls_session_get_flags</a> and check for the <acronym>GNUTLS_SFLAGS_FALSE_START</acronym>
flag. For GnuTLS the false start is whitelisted for the following
key exchange methods (see [<a href="#RFC7918">RFC7918</a>] for rationale)
</p><ul>
<li> DHE
</li><li> ECDHE
</li></ul>
<p>but only when the negotiated parameters exceed <code>GNUTLS_SEC_PARAM_HIGH</code>
&ndash;see <a href="#tab_003akey_002dsizes">Table 6.7</a>, and when under (D)TLS 1.2 or later.
</p>
<hr>
<span id="Application-Layer-Protocol-Negotiation-_0028ALPN_0029"></span><div class="header">
<p>
Next: <a href="#Extensions-and-Supplemental-Data" accesskey="n" rel="next">Extensions and Supplemental Data</a>, Previous: <a href="#False-Start" accesskey="p" rel="prev">False Start</a>, Up: <a href="#TLS-Extensions" accesskey="u" rel="up">TLS Extensions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Application-Layer-Protocol-Negotiation-_0028ALPN_0029-1"></span><h4 class="subsection">3.6.9 Application Layer Protocol Negotiation (ALPN)</h4>
<span id="index-ALPN"></span>
<span id="index-Application-Layer-Protocol-Negotiation"></span>

<p>The TLS protocol was extended in <code>RFC7301</code>
to provide the application layer a method of
negotiating the application protocol version. This allows for negotiation
of the application protocol during the TLS handshake, thus reducing
round-trips. The application protocol is described by an opaque
string. To enable, use the following functions.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005falpn_005fset_005fprotocols">gnutls_alpn_set_protocols</a> (gnutls_session_t <var>session</var>, const gnutls_datum_t * <var>protocols</var>, unsigned <var>protocols_size</var>, unsigned int <var>flags</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005falpn_005fget_005fselected_005fprotocol">gnutls_alpn_get_selected_protocol</a> (gnutls_session_t <var>session</var>, gnutls_datum_t * <var>protocol</var>)</code></dt>
</dl>

<p>Note that these functions are intended to be used with protocols that are
registered in the Application Layer Protocol Negotiation IANA registry. While
you can use them for other protocols (at the risk of collisions), it is preferable
to register them.
</p>
<hr>
<span id="Extensions-and-Supplemental-Data"></span><div class="header">
<p>
Previous: <a href="#Application-Layer-Protocol-Negotiation-_0028ALPN_0029" accesskey="p" rel="prev">Application Layer Protocol Negotiation (ALPN)</a>, Up: <a href="#TLS-Extensions" accesskey="u" rel="up">TLS Extensions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Extensions-and-Supplemental-Data-1"></span><h4 class="subsection">3.6.10 Extensions and Supplemental Data</h4>
<span id="index-Supplemental-data"></span>

<p>It is possible to transfer supplemental data during the TLS handshake, following
[<a href="#RFC4680">RFC4680</a>]. This is for &quot;custom&quot; protocol modifications for applications which
may want to transfer additional data (e.g. additional authentication messages). Such
an exchange requires a custom extension to be registered.
The provided API for this functionality is low-level and described in <a href="#TLS-Hello-Extension-Handling">TLS Hello Extension Handling</a>.
</p>
<hr>
<span id="How-to-use-TLS-in-application-protocols"></span><div class="header">
<p>
Next: <a href="#On-SSL-2-and-older-protocols" accesskey="n" rel="next">On SSL 2 and older protocols</a>, Previous: <a href="#TLS-Extensions" accesskey="p" rel="prev">TLS Extensions</a>, Up: <a href="#Introduction-to-TLS" accesskey="u" rel="up">Introduction to TLS</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="How-to-use-TLS-in-application-protocols-1"></span><h3 class="section">3.7 How to use <acronym>TLS</acronym> in application protocols</h3>

<p>This chapter is intended to provide some hints on how to use
<acronym>TLS</acronym> over simple custom made application protocols.  The
discussion below mainly refers to the <acronym>TCP/IP</acronym> transport layer
but may be extended to other ones too.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Separate-ports" accesskey="1">Separate ports</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Upward-negotiation" accesskey="2">Upward negotiation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Separate-ports"></span><div class="header">
<p>
Next: <a href="#Upward-negotiation" accesskey="n" rel="next">Upward negotiation</a>, Up: <a href="#How-to-use-TLS-in-application-protocols" accesskey="u" rel="up">How to use TLS in application protocols</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Separate-ports-1"></span><h4 class="subsection">3.7.1 Separate ports</h4>

<p>Traditionally <acronym>SSL</acronym> was used in application protocols by
assigning a new port number for the secure services. By doing this two
separate ports were assigned, one for the non-secure sessions, and one
for the secure sessions. This method ensures that if a user requests a
secure session then the client will attempt to connect to the secure port
and fail otherwise. The only possible attack with this method is to perform
a denial of service attack. The most famous example of this method is
&ldquo;HTTP over TLS&rdquo; or <acronym>HTTPS</acronym> protocol [<a href="#RFC2818">RFC2818</a>].
</p>
<p>Despite its wide use, this method has several issues. This
approach starts the <acronym>TLS</acronym> Handshake procedure just after the
client connects on the &mdash;so called&mdash; secure port.  That way the
<acronym>TLS</acronym> protocol does not know anything about the client, and
popular methods like the host advertising in HTTP do not
work<a id="DOCF6" href="#FOOT6"><sup>6</sup></a>.  There is no way for the client to say &ldquo;I
connected to YYY server&rdquo; before the Handshake starts, so the server
cannot possibly know which certificate to use.
</p>
<p>Other than that it requires two separate ports to run a single
service, which is unnecessary complication. Due to the fact that there
is a limitation on the available privileged ports, this approach was
soon deprecated in favor of upward negotiation.
</p>
<hr>
<span id="Upward-negotiation"></span><div class="header">
<p>
Previous: <a href="#Separate-ports" accesskey="p" rel="prev">Separate ports</a>, Up: <a href="#How-to-use-TLS-in-application-protocols" accesskey="u" rel="up">How to use TLS in application protocols</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Upward-negotiation-1"></span><h4 class="subsection">3.7.2 Upward negotiation</h4>

<p>Other application protocols<a id="DOCF7" href="#FOOT7"><sup>7</sup></a>  use a
different approach to enable the secure layer.  They use something
often called as the &ldquo;TLS upgrade&rdquo; method. This method is quite tricky but it
is more flexible. The idea is to extend the application protocol to
have a &ldquo;STARTTLS&rdquo; request, whose purpose it to start the TLS
protocols just after the client requests it.  This approach
does not require any extra port to be reserved.
There is even an extension to HTTP protocol to support 
this method [<a href="#RFC2817">RFC2817</a>].
</p>
<p>The tricky part, in this method, is that the &ldquo;STARTTLS&rdquo; request is
sent in the clear, thus is vulnerable to modifications.  A typical
attack is to modify the messages in a way that the client is fooled
and thinks that the server does not have the &ldquo;STARTTLS&rdquo; capability.
See a typical conversation of a hypothetical protocol:
</p>
<blockquote>
<p>(client connects to the server)
</p>
<p>CLIENT: HELLO I&rsquo;M MR. XXX
</p>
<p>SERVER: NICE TO MEET YOU XXX
</p>
<p>CLIENT: PLEASE START TLS
</p>
<p>SERVER: OK
</p>
<p>*** TLS STARTS
</p>
<p>CLIENT: HERE ARE SOME CONFIDENTIAL DATA
</p></blockquote>

<p>And an example of a conversation where someone is acting
in between:
</p>
<blockquote>
<p>(client connects to the server)
</p>
<p>CLIENT: HELLO I&rsquo;M MR. XXX
</p>
<p>SERVER: NICE TO MEET YOU XXX
</p>
<p>CLIENT: PLEASE START TLS
</p>
<p>(here someone inserts this message)
</p>
<p>SERVER: SORRY I DON&rsquo;T HAVE THIS CAPABILITY
</p>
<p>CLIENT: HERE ARE SOME CONFIDENTIAL DATA
</p></blockquote>

<p>As you can see above the client was fooled, and was na&iuml;ve enough to
send the confidential data in the clear, despite the server telling the
client that it does not support &ldquo;STARTTLS&rdquo;.
</p>
<p>How do we avoid the above attack? As you may have already noticed this
situation is easy to avoid.  The client has to ask the user before it
connects whether the user requests <acronym>TLS</acronym> or not.  If the user
answered that he certainly wants the secure layer the last
conversation should be:
</p>
<blockquote>
<p>(client connects to the server)
</p>
<p>CLIENT: HELLO I&rsquo;M MR. XXX
</p>
<p>SERVER: NICE TO MEET YOU XXX
</p>
<p>CLIENT: PLEASE START TLS
</p>
<p>(here someone inserts this message)
</p>
<p>SERVER: SORRY I DON&rsquo;T HAVE THIS CAPABILITY
</p>
<p>CLIENT: BYE
</p>
<p>(the client notifies the user that the secure connection was not possible)
</p></blockquote>

<p>This method, if implemented properly, is far better than the
traditional method, and the security properties remain the same, since
only denial of service is possible. The benefit is that the server may
request additional data before the <acronym>TLS</acronym> Handshake protocol
starts, in order to send the correct certificate, use the correct
password file, or anything else!
</p>
<hr>
<span id="On-SSL-2-and-older-protocols"></span><div class="header">
<p>
Previous: <a href="#How-to-use-TLS-in-application-protocols" accesskey="p" rel="prev">How to use TLS in application protocols</a>, Up: <a href="#Introduction-to-TLS" accesskey="u" rel="up">Introduction to TLS</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="On-SSL-2-and-older-protocols-1"></span><h3 class="section">3.8 On SSL 2 and older protocols</h3>
<span id="index-SSL-2"></span>

<p>One of the initial decisions in the <acronym>GnuTLS</acronym> development was
to implement the known security protocols for the transport layer.
Initially <acronym>TLS</acronym> 1.0 was implemented since it was the latest at
that time, and was considered to be the most advanced in security
properties.  Later the <acronym>SSL</acronym> 3.0 protocol was implemented
since it is still the only protocol supported by several servers and
there are no serious security vulnerabilities known.
</p>
<p>One question that may arise is why we didn&rsquo;t implement <acronym>SSL</acronym>
2.0 in the library.  There are several reasons, most important being
that it has serious security flaws, unacceptable for a modern security
library.  Other than that, this protocol is barely used by anyone
these days since it has been deprecated since 1996.  The security
problems in <acronym>SSL</acronym> 2.0 include:
</p>
<ul>
<li> Message integrity compromised.
The <acronym>SSLv2</acronym> message authentication uses the MD5 function, and
is insecure.

</li><li> Man-in-the-middle attack.
There is no protection of the handshake in <acronym>SSLv2</acronym>, which
permits a man-in-the-middle attack.

</li><li> Truncation attack.
<acronym>SSLv2</acronym> relies on TCP FIN to close the session, so the
attacker can forge a TCP FIN, and the peer cannot tell if it was a
legitimate end of data or not.

</li><li> Weak message integrity for export ciphers.
The cryptographic keys in <acronym>SSLv2</acronym> are used for both message
authentication and encryption, so if weak encryption schemes are
negotiated (say 40-bit keys) the message authentication code uses the
same weak key, which isn&rsquo;t necessary.

</li></ul>

<span id="index-PCT"></span>
<p>Other protocols such as Microsoft&rsquo;s <acronym>PCT</acronym> 1 and <acronym>PCT</acronym>
2 were not implemented because they were also abandoned and deprecated
by <acronym>SSL</acronym> 3.0 and later <acronym>TLS</acronym> 1.0.
</p>


<hr>
<span id="Authentication-methods"></span><div class="header">
<p>
Next: <a href="#Hardware-security-modules-and-abstract-key-types" accesskey="n" rel="next">Hardware security modules and abstract key types</a>, Previous: <a href="#Introduction-to-TLS" accesskey="p" rel="prev">Introduction to TLS</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Authentication-methods-1"></span><h2 class="chapter">4 Authentication methods</h2>
<span id="index-authentication-methods"></span>

<p>The initial key exchange of the TLS protocol performs authentication
of the peers. In typical scenarios the server is authenticated to
the client, and optionally the client to the server.
</p>
<p>While many associate TLS with X.509 certificates and public key
authentication, the protocol supports various authentication methods,
including pre-shared keys, and passwords. In this chapter a description
of the existing authentication methods is provided, as well as some
guidance on which use-cases each method can be used at.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Certificate-authentication" accesskey="1">Certificate authentication</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#More-on-certificate-authentication" accesskey="2">More on certificate authentication</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Shared_002dkey-and-anonymous-authentication" accesskey="3">Shared-key and anonymous authentication</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Selecting-an-appropriate-authentication-method" accesskey="4">Selecting an appropriate authentication method</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Certificate-authentication"></span><div class="header">
<p>
Next: <a href="#More-on-certificate-authentication" accesskey="n" rel="next">More on certificate authentication</a>, Up: <a href="#Authentication-methods" accesskey="u" rel="up">Authentication methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Certificate-authentication-1"></span><h3 class="section">4.1 Certificate authentication</h3>
<span id="index-certificate-authentication"></span>

<p>The most known authentication method of <acronym>TLS</acronym> are certificates.
The PKIX [<a href="#PKIX">PKIX</a>] public key infrastructure is daily used by anyone
using a browser today. <acronym>GnuTLS</acronym> provides a simple API to 
verify the <acronym>X.509</acronym> certificates as in [<a href="#PKIX">PKIX</a>].
</p>
<p>The key exchange algorithms supported by certificate authentication are
shown in <a href="#tab_003akey_002dexchange">Table 4.1</a>.
</p>
<div class="float"><span id="tab_003akey_002dexchange"></span>
<table>
<thead><tr><th width="20%">Key exchange</th><th width="70%">Description</th></tr></thead>
<tr><td width="20%">RSA</td><td width="70%">The RSA algorithm is used to encrypt a key and send it to the peer.
The certificate must allow the key to be used for encryption.</td></tr>
<tr><td width="20%">DHE_RSA</td><td width="70%">The RSA algorithm is used to sign ephemeral Diffie-Hellman parameters
which are sent to the peer. The key in the certificate must allow the
key to be used for signing. Note that key exchange algorithms which
use ephemeral Diffie-Hellman parameters, offer perfect forward
secrecy. That means that even if the private key used for signing is
compromised, it cannot be used to reveal past session data.</td></tr>
<tr><td width="20%">ECDHE_RSA</td><td width="70%">The RSA algorithm is used to sign ephemeral elliptic curve Diffie-Hellman 
parameters which are sent to the peer. The key in the certificate must allow 
the key to be used for signing. It also offers perfect forward
secrecy. That means that even if the private key used for signing is
compromised, it cannot be used to reveal past session data.</td></tr>
<tr><td width="20%">DHE_DSS</td><td width="70%">The DSA algorithm is used to sign ephemeral Diffie-Hellman parameters
which are sent to the peer. The certificate must contain DSA
parameters to use this key exchange algorithm. DSA is the algorithm
of the Digital Signature Standard (DSS).</td></tr>
<tr><td width="20%">ECDHE_ECDSA</td><td width="70%">The Elliptic curve DSA algorithm is used to sign ephemeral elliptic
curve Diffie-Hellman parameters which are sent to the peer. The 
certificate must contain ECDSA parameters (i.e., EC and marked for signing) 
to use this key exchange algorithm.</td></tr>
</table>

<div class="float-caption"><p><strong>Table 4.1: </strong>Supported key exchange algorithms.</p></div></div>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#X_002e509-certificates" accesskey="1">X.509 certificates</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#OpenPGP-certificates" accesskey="2">OpenPGP certificates</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Raw-public_002dkeys" accesskey="3">Raw public-keys</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Advanced-certificate-verification" accesskey="4">Advanced certificate verification</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Digital-signatures" accesskey="5">Digital signatures</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="X_002e509-certificates"></span><div class="header">
<p>
Next: <a href="#OpenPGP-certificates" accesskey="n" rel="next">OpenPGP certificates</a>, Up: <a href="#Certificate-authentication" accesskey="u" rel="up">Certificate authentication</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="X_002e509-certificates-1"></span><h4 class="subsection">4.1.1 <acronym>X.509</acronym> certificates</h4>
<span id="index-X_002e509-certificates"></span>

<p>The <acronym>X.509</acronym> protocols rely on a hierarchical trust model. In
this trust model Certification Authorities (CAs) are used to certify
entities.  Usually more than one certification authorities exist, and
certification authorities may certify other authorities to issue
certificates as well, following a hierarchical model.
</p>
<div class="float"><span id="fig_002dx509"></span>
<img src="gnutls-x509.png" alt="gnutls-x509">

<div class="float-caption"><p><strong>Figure 4.1: </strong>An example of the X.509 hierarchical trust model.</p></div></div>
<p>One needs to trust one or more CAs for his secure communications. In
that case only the certificates issued by the trusted authorities are
acceptable.  The framework is illustrated on <a href="#fig_002dx509">Figure 4.1</a>.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#X_002e509-certificate-structure" accesskey="1">X.509 certificate structure</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Importing-an-X_002e509-certificate" accesskey="2">Importing an X.509 certificate</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#X_002e509-certificate-names" accesskey="3">X.509 certificate names</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#X_002e509-distinguished-names" accesskey="4">X.509 distinguished names</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#X_002e509-extensions" accesskey="5">X.509 extensions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#X_002e509-public-and-private-keys" accesskey="6">X.509 public and private keys</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Verifying-X_002e509-certificate-paths" accesskey="7">Verifying X.509 certificate paths</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Verifying-a-certificate-in-the-context-of-TLS-session" accesskey="8">Verifying a certificate in the context of TLS session</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Verification-using-PKCS11" accesskey="9">Verification using PKCS11</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="X_002e509-certificate-structure"></span><div class="header">
<p>
Next: <a href="#Importing-an-X_002e509-certificate" accesskey="n" rel="next">Importing an X.509 certificate</a>, Up: <a href="#X_002e509-certificates" accesskey="u" rel="up">X.509 certificates</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="X_002e509-certificate-structure-1"></span><h4 class="subsubsection">4.1.1.1 <acronym>X.509</acronym> certificate structure</h4>

<p>An <acronym>X.509</acronym> certificate usually contains information about the
certificate holder, the signer, a unique serial number, expiration
dates and some other fields [<a href="#PKIX">PKIX</a>] as shown in <a href="#tab_003ax509">Table 4.2</a>.
</p>
<div class="float"><span id="tab_003ax509"></span>
<table>
<thead><tr><th width="20%">Field</th><th width="70%">Description</th></tr></thead>
<tr><td width="20%">version</td><td width="70%">The field that indicates the version of the certificate.</td></tr>
<tr><td width="20%">serialNumber</td><td width="70%">This field holds a unique serial number per certificate.</td></tr>
<tr><td width="20%">signature</td><td width="70%">The issuing authority&rsquo;s signature.</td></tr>
<tr><td width="20%">issuer</td><td width="70%">Holds the issuer&rsquo;s distinguished name.</td></tr>
<tr><td width="20%">validity</td><td width="70%">The activation and expiration dates.</td></tr>
<tr><td width="20%">subject</td><td width="70%">The subject&rsquo;s distinguished name of the certificate.</td></tr>
<tr><td width="20%">extensions</td><td width="70%">The extensions are fields only present in version 3 certificates.</td></tr>
</table>

<div class="float-caption"><p><strong>Table 4.2: </strong>X.509 certificate fields.</p></div></div>
<p>The certificate&rsquo;s <em>subject or issuer name</em> is not just a single
string.  It is a Distinguished name and in the <acronym>ASN.1</acronym>
notation is a sequence of several object identifiers with their corresponding
values. Some of available OIDs to be used in an <acronym>X.509</acronym>
distinguished name are defined in <samp>gnutls/x509.h</samp>.
</p>
<p>The <em>Version</em> field in a certificate has values either 1 or 3 for
version 3 certificates.  Version 1 certificates do not support the
extensions field so it is not possible to distinguish a CA from a
person, thus their usage should be avoided.
</p>
<p>The <em>validity</em> dates are there to indicate the date that the
specific certificate was activated and the date the certificate&rsquo;s key
would be considered invalid.
</p>

<p>In <acronym>GnuTLS</acronym> the <acronym>X.509</acronym> certificate structures are
handled using the <code>gnutls_x509_crt_t</code> type and the corresponding
private keys with the <code>gnutls_x509_privkey_t</code> type.  All the
available functions for <acronym>X.509</acronym> certificate handling have
their prototypes in <samp>gnutls/x509.h</samp>. An example program to
demonstrate the <acronym>X.509</acronym> parsing capabilities can be found in
<a href="#ex_002dx509_002dinfo">ex-x509-info</a>.
</p>
<hr>
<span id="Importing-an-X_002e509-certificate"></span><div class="header">
<p>
Next: <a href="#X_002e509-certificate-names" accesskey="n" rel="next">X.509 certificate names</a>, Previous: <a href="#X_002e509-certificate-structure" accesskey="p" rel="prev">X.509 certificate structure</a>, Up: <a href="#X_002e509-certificates" accesskey="u" rel="up">X.509 certificates</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Importing-an-X_002e509-certificate-1"></span><h4 class="subsubsection">4.1.1.2 Importing an X.509 certificate</h4>

<p>The certificate structure should be initialized using <a href="#gnutls_005fx509_005fcrt_005finit">gnutls_x509_crt_init</a>, and 
a certificate structure can be imported using <a href="#gnutls_005fx509_005fcrt_005fimport">gnutls_x509_crt_import</a>. 
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrt_005finit">gnutls_x509_crt_init</a> (gnutls_x509_crt_t * <var>cert</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrt_005fimport">gnutls_x509_crt_import</a> (gnutls_x509_crt_t <var>cert</var>, const gnutls_datum_t * <var>data</var>, gnutls_x509_crt_fmt_t <var>format</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005fx509_005fcrt_005fdeinit">gnutls_x509_crt_deinit</a> (gnutls_x509_crt_t <var>cert</var>)</code></dt>
</dl>

<p>In several functions an array of certificates is required. To assist in initialization
and import the following two functions are provided.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrt_005flist_005fimport">gnutls_x509_crt_list_import</a> (gnutls_x509_crt_t * <var>certs</var>, unsigned int * <var>cert_max</var>, const gnutls_datum_t * <var>data</var>, gnutls_x509_crt_fmt_t <var>format</var>, unsigned int <var>flags</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrt_005flist_005fimport2">gnutls_x509_crt_list_import2</a> (gnutls_x509_crt_t ** <var>certs</var>, unsigned int * <var>size</var>, const gnutls_datum_t * <var>data</var>, gnutls_x509_crt_fmt_t <var>format</var>, unsigned int <var>flags</var>)</code></dt>
</dl>

<p>In all cases after use a certificate must be deinitialized using <a href="#gnutls_005fx509_005fcrt_005fdeinit">gnutls_x509_crt_deinit</a>.
Note that although the functions above apply to <code>gnutls_x509_crt_t</code> structure, similar functions
exist for the CRL structure <code>gnutls_x509_crl_t</code>.
</p>
<hr>
<span id="X_002e509-certificate-names"></span><div class="header">
<p>
Next: <a href="#X_002e509-distinguished-names" accesskey="n" rel="next">X.509 distinguished names</a>, Previous: <a href="#Importing-an-X_002e509-certificate" accesskey="p" rel="prev">Importing an X.509 certificate</a>, Up: <a href="#X_002e509-certificates" accesskey="u" rel="up">X.509 certificates</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="X_002e509-certificate-names-1"></span><h4 class="subsubsection">4.1.1.3 X.509 certificate names</h4>
<span id="index-X_002e509-certificate-name"></span>

<p>X.509 certificates allow for multiple names and types of names to be specified.
CA certificates often rely on X.509 distinguished names (see <a href="#X_002e509-distinguished-names">X.509 distinguished names</a>)
for unique identification, while end-user and server certificates rely on the
&rsquo;subject alternative names&rsquo;. The subject alternative names provide a typed name, e.g.,
a DNS name, or an email address, which identifies the owner of the certificate.
The following functions provide access to that names.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrt_005fget_005fsubject_005falt_005fname2">gnutls_x509_crt_get_subject_alt_name2</a> (gnutls_x509_crt_t <var>cert</var>, unsigned int <var>seq</var>, void * <var>san</var>, size_t * <var>san_size</var>, unsigned int * <var>san_type</var>, unsigned int * <var>critical</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrt_005fset_005fsubject_005falt_005fname">gnutls_x509_crt_set_subject_alt_name</a> (gnutls_x509_crt_t <var>crt</var>, gnutls_x509_subject_alt_name_t <var>type</var>, const void * <var>data</var>, unsigned int <var>data_size</var>, unsigned int <var>flags</var>)</code></dt>
</dl>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fsubject_005falt_005fnames_005finit">gnutls_subject_alt_names_init</a> (gnutls_subject_alt_names_t * <var>sans</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fsubject_005falt_005fnames_005fget">gnutls_subject_alt_names_get</a> (gnutls_subject_alt_names_t <var>sans</var>, unsigned int <var>seq</var>, unsigned int * <var>san_type</var>, gnutls_datum_t * <var>san</var>, gnutls_datum_t * <var>othername_oid</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fsubject_005falt_005fnames_005fset">gnutls_subject_alt_names_set</a> (gnutls_subject_alt_names_t <var>sans</var>, unsigned int <var>san_type</var>, const gnutls_datum_t * <var>san</var>, const char * <var>othername_oid</var>)</code></dt>
</dl>

<p>Note however, that server certificates often used the Common Name (CN), part of the
certificate DistinguishedName to place a single DNS address. That practice is discouraged
(see [<a href="#RFC6125">RFC6125</a>]), because only a single address can be specified, and the CN field is
free-form making matching ambiguous.
</p>
<hr>
<span id="X_002e509-distinguished-names"></span><div class="header">
<p>
Next: <a href="#X_002e509-extensions" accesskey="n" rel="next">X.509 extensions</a>, Previous: <a href="#X_002e509-certificate-names" accesskey="p" rel="prev">X.509 certificate names</a>, Up: <a href="#X_002e509-certificates" accesskey="u" rel="up">X.509 certificates</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="X_002e509-distinguished-names-1"></span><h4 class="subsubsection">4.1.1.4 X.509 distinguished names</h4>
<span id="index-X_002e509-distinguished-name"></span>

<p>The &ldquo;subject&rdquo; of an X.509 certificate is not described by
a single name, but rather with a distinguished name. This in
X.509 terminology is a list of strings each associated an object
identifier. To make things simple GnuTLS provides <a href="#gnutls_005fx509_005fcrt_005fget_005fdn2">gnutls_x509_crt_get_dn2</a>
which follows the rules in [<a href="#RFC4514">RFC4514</a>] and returns a single
string. Access to each string by individual object identifiers
can be accessed using <a href="#gnutls_005fx509_005fcrt_005fget_005fdn_005fby_005foid">gnutls_x509_crt_get_dn_by_oid</a>.
</p>




<dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fdn2">Function: <em>int</em> <strong>gnutls_x509_crt_get_dn2</strong> <em>(gnutls_x509_crt_t <var>cert</var>, gnutls_datum_t * <var>dn</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>dn</var>: a pointer to a structure to hold the name
</p>
<p>This function will allocate buffer and copy the name of the Certificate.
The name will be in the form &quot;C=xxxx,O=yyyy,CN=zzzz&quot; as
described in RFC4514. The output string will be ASCII or UTF-8
encoded, depending on the certificate data.
</p>
<p>This function does not output a fully RFC4514 compliant string, if
that is required see <code>gnutls_x509_crt_get_dn3()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.1.10
</p></dd></dl>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrt_005fget_005fdn">gnutls_x509_crt_get_dn</a> (gnutls_x509_crt_t <var>cert</var>, char * <var>buf</var>, size_t * <var>buf_size</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrt_005fget_005fdn_005fby_005foid">gnutls_x509_crt_get_dn_by_oid</a> (gnutls_x509_crt_t <var>cert</var>, const char * <var>oid</var>, unsigned <var>indx</var>, unsigned int <var>raw_flag</var>, void * <var>buf</var>, size_t * <var>buf_size</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrt_005fget_005fdn_005foid">gnutls_x509_crt_get_dn_oid</a> (gnutls_x509_crt_t <var>cert</var>, unsigned <var>indx</var>, void * <var>oid</var>, size_t * <var>oid_size</var>)</code></dt>
</dl>

<p>Similar functions exist to access the distinguished name
of the issuer of the certificate.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrt_005fget_005fissuer_005fdn">gnutls_x509_crt_get_issuer_dn</a> (gnutls_x509_crt_t <var>cert</var>, char * <var>buf</var>, size_t * <var>buf_size</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrt_005fget_005fissuer_005fdn2">gnutls_x509_crt_get_issuer_dn2</a> (gnutls_x509_crt_t <var>cert</var>, gnutls_datum_t * <var>dn</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrt_005fget_005fissuer_005fdn_005fby_005foid">gnutls_x509_crt_get_issuer_dn_by_oid</a> (gnutls_x509_crt_t <var>cert</var>, const char * <var>oid</var>, unsigned <var>indx</var>, unsigned int <var>raw_flag</var>, void * <var>buf</var>, size_t * <var>buf_size</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrt_005fget_005fissuer_005fdn_005foid">gnutls_x509_crt_get_issuer_dn_oid</a> (gnutls_x509_crt_t <var>cert</var>, unsigned <var>indx</var>, void * <var>oid</var>, size_t * <var>oid_size</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrt_005fget_005fissuer">gnutls_x509_crt_get_issuer</a> (gnutls_x509_crt_t <var>cert</var>, gnutls_x509_dn_t * <var>dn</var>)</code></dt>
</dl>

<p>The more powerful <a href="#gnutls_005fx509_005fcrt_005fget_005fsubject">gnutls_x509_crt_get_subject</a> and 
<a href="#gnutls_005fx509_005fdn_005fget_005frdn_005fava">gnutls_x509_dn_get_rdn_ava</a> provide efficient but low-level access
to the contents of the distinguished name structure.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrt_005fget_005fsubject">gnutls_x509_crt_get_subject</a> (gnutls_x509_crt_t <var>cert</var>, gnutls_x509_dn_t * <var>dn</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrt_005fget_005fissuer">gnutls_x509_crt_get_issuer</a> (gnutls_x509_crt_t <var>cert</var>, gnutls_x509_dn_t * <var>dn</var>)</code></dt>
</dl>




<dl>
<dt id="index-gnutls_005fx509_005fdn_005fget_005frdn_005fava">Function: <em>int</em> <strong>gnutls_x509_dn_get_rdn_ava</strong> <em>(gnutls_x509_dn_t <var>dn</var>, int <var>irdn</var>, int <var>iava</var>, gnutls_x509_ava_st * <var>ava</var>)</em></dt>
<dd><p><var>dn</var>: a pointer to DN
</p>
<p><var>irdn</var>: index of RDN
</p>
<p><var>iava</var>: index of AVA.
</p>
<p><var>ava</var>: Pointer to structure which will hold output information.
</p>
<p>Get pointers to data within the DN. The format of the  <code>ava</code> structure
is shown below.
</p>
<p>struct gnutls_x509_ava_st {
gnutls_datum_t oid;
gnutls_datum_t value;
unsigned long value_tag;
};
</p>
<p>The X.509 distinguished name is a sequence of sequences of strings
and this is what the  <code>irdn</code> and  <code>iava</code> indexes model.
</p>
<p>Note that  <code>ava</code> will contain pointers into the  <code>dn</code> structure which
in turns points to the original certificate. Thus you should not
modify any data or deallocate any of those.
</p>
<p>This is a low-level function that requires the caller to do the
value conversions when necessary (e.g. from UCS-2).
</p>
<p><strong>Returns:</strong> Returns 0 on success, or an error code.
</p></dd></dl>

<hr>
<span id="X_002e509-extensions"></span><div class="header">
<p>
Next: <a href="#X_002e509-public-and-private-keys" accesskey="n" rel="next">X.509 public and private keys</a>, Previous: <a href="#X_002e509-distinguished-names" accesskey="p" rel="prev">X.509 distinguished names</a>, Up: <a href="#X_002e509-certificates" accesskey="u" rel="up">X.509 certificates</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="X_002e509-extensions-1"></span><h4 class="subsubsection">4.1.1.5 X.509 extensions</h4>
<span id="index-X_002e509-extensions"></span>

<p>X.509 version 3 certificates include a list of extensions that can
be used to obtain additional information on the subject or the issuer
of the certificate. Those may be e-mail addresses, flags that indicate whether the
belongs to a CA etc.  All the supported <acronym>X.509</acronym> version 3
extensions are shown in <a href="#tab_003ax509_002dext">Table 4.3</a>.
</p>
<p>The certificate extensions access is split into two parts. The first
requires to retrieve the extension, and the second is the parsing part.
</p>
<p>To enumerate and retrieve the DER-encoded extension data available in a certificate the following
two functions are available.
</p><dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrt_005fget_005fextension_005finfo">gnutls_x509_crt_get_extension_info</a> (gnutls_x509_crt_t <var>cert</var>, unsigned <var>indx</var>, void * <var>oid</var>, size_t * <var>oid_size</var>, unsigned int * <var>critical</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrt_005fget_005fextension_005fdata2">gnutls_x509_crt_get_extension_data2</a> (gnutls_x509_crt_t <var>cert</var>, unsigned <var>indx</var>, gnutls_datum_t * <var>data</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrt_005fget_005fextension_005fby_005foid2">gnutls_x509_crt_get_extension_by_oid2</a> (gnutls_x509_crt_t <var>cert</var>, const char * <var>oid</var>, unsigned <var>indx</var>, gnutls_datum_t * <var>output</var>, unsigned int * <var>critical</var>)</code></dt>
</dl>

<p>After a supported DER-encoded extension is retrieved it can be parsed using the APIs in <code>x509-ext.h</code>.
Complex extensions may require initializing an intermediate structure that holds the
parsed extension data. Examples of simple parsing functions are shown below.
</p><dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fext_005fimport_005fbasic_005fconstraints">gnutls_x509_ext_import_basic_constraints</a> (const gnutls_datum_t * <var>ext</var>, unsigned int * <var>ca</var>, int * <var>pathlen</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fext_005fexport_005fbasic_005fconstraints">gnutls_x509_ext_export_basic_constraints</a> (unsigned int <var>ca</var>, int <var>pathlen</var>, gnutls_datum_t * <var>ext</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fext_005fimport_005fkey_005fusage">gnutls_x509_ext_import_key_usage</a> (const gnutls_datum_t * <var>ext</var>, unsigned int * <var>key_usage</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fext_005fexport_005fkey_005fusage">gnutls_x509_ext_export_key_usage</a> (unsigned int <var>usage</var>, gnutls_datum_t * <var>ext</var>)</code></dt>
</dl>

<p>More complex extensions, such as Name Constraints, require an intermediate structure, in that
case <code>gnutls_x509_name_constraints_t</code> to be initialized in order to store the parsed
extension data. 
</p><dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fext_005fimport_005fname_005fconstraints">gnutls_x509_ext_import_name_constraints</a> (const gnutls_datum_t * <var>ext</var>, gnutls_x509_name_constraints_t <var>nc</var>, unsigned int <var>flags</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fext_005fexport_005fname_005fconstraints">gnutls_x509_ext_export_name_constraints</a> (gnutls_x509_name_constraints_t <var>nc</var>, gnutls_datum_t * <var>ext</var>)</code></dt>
</dl>

<p>After the name constraints are extracted in the structure, the following functions
can be used to access them.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fname_005fconstraints_005fget_005fpermitted">gnutls_x509_name_constraints_get_permitted</a> (gnutls_x509_name_constraints_t <var>nc</var>, unsigned <var>idx</var>, unsigned * <var>type</var>, gnutls_datum_t * <var>name</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fname_005fconstraints_005fget_005fexcluded">gnutls_x509_name_constraints_get_excluded</a> (gnutls_x509_name_constraints_t <var>nc</var>, unsigned <var>idx</var>, unsigned * <var>type</var>, gnutls_datum_t * <var>name</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fname_005fconstraints_005fadd_005fpermitted">gnutls_x509_name_constraints_add_permitted</a> (gnutls_x509_name_constraints_t <var>nc</var>, gnutls_x509_subject_alt_name_t <var>type</var>, const gnutls_datum_t * <var>name</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fname_005fconstraints_005fadd_005fexcluded">gnutls_x509_name_constraints_add_excluded</a> (gnutls_x509_name_constraints_t <var>nc</var>, gnutls_x509_subject_alt_name_t <var>type</var>, const gnutls_datum_t * <var>name</var>)</code></dt>
</dl>
<dl compact="compact">
<dt><code><var>unsigned</var> <a href="#gnutls_005fx509_005fname_005fconstraints_005fcheck">gnutls_x509_name_constraints_check</a> (gnutls_x509_name_constraints_t <var>nc</var>, gnutls_x509_subject_alt_name_t <var>type</var>, const gnutls_datum_t * <var>name</var>)</code></dt>
<dt><code><var>unsigned</var> <a href="#gnutls_005fx509_005fname_005fconstraints_005fcheck_005fcrt">gnutls_x509_name_constraints_check_crt</a> (gnutls_x509_name_constraints_t <var>nc</var>, gnutls_x509_subject_alt_name_t <var>type</var>, gnutls_x509_crt_t <var>cert</var>)</code></dt>
</dl>

<p>Other utility functions are listed below.
</p><dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fname_005fconstraints_005finit">gnutls_x509_name_constraints_init</a> (gnutls_x509_name_constraints_t * <var>nc</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005fx509_005fname_005fconstraints_005fdeinit">gnutls_x509_name_constraints_deinit</a> (gnutls_x509_name_constraints_t <var>nc</var>)</code></dt>
</dl>

<p>Similar functions exist for all of the other supported extensions, listed in <a href="#tab_003ax509_002dext">Table 4.3</a>.
</p>
<div class="float"><span id="tab_003ax509_002dext"></span>
<table>
<thead><tr><th width="30%">Extension</th><th width="20%">OID</th><th width="40%">Description</th></tr></thead>
<tr><td width="30%">Subject key id</td><td width="20%">2.5.29.14</td><td width="40%">An identifier of the key of the subject.</td></tr>
<tr><td width="30%">Key usage</td><td width="20%">2.5.29.15</td><td width="40%">Constraints the key&rsquo;s usage of the certificate.</td></tr>
<tr><td width="30%">Private key usage period</td><td width="20%">2.5.29.16</td><td width="40%">Constraints the validity time of the private key.</td></tr>
<tr><td width="30%">Subject alternative name</td><td width="20%">2.5.29.17</td><td width="40%">Alternative names to subject&rsquo;s distinguished name.</td></tr>
<tr><td width="30%">Issuer alternative name</td><td width="20%">2.5.29.18</td><td width="40%">Alternative names to the issuer&rsquo;s distinguished name.</td></tr>
<tr><td width="30%">Basic constraints</td><td width="20%">2.5.29.19</td><td width="40%">Indicates whether this is a CA certificate or not, and specify the
maximum path lengths of certificate chains.</td></tr>
<tr><td width="30%">Name constraints</td><td width="20%">2.5.29.30</td><td width="40%">A field in CA certificates that restricts the scope of the name of
issued certificates.</td></tr>
<tr><td width="30%">CRL distribution points</td><td width="20%">2.5.29.31</td><td width="40%">This extension is set by the CA, in order to inform about the
location of issued Certificate Revocation Lists.</td></tr>
<tr><td width="30%">Certificate policy</td><td width="20%">2.5.29.32</td><td width="40%">This extension is set to indicate the certificate policy as object
identifier and may contain a descriptive string or URL.</td></tr>
<tr><td width="30%">Extended key usage</td><td width="20%">2.5.29.54</td><td width="40%">Inhibit any policy extension. Constraints the any policy OID
(<code>GNUTLS_X509_OID_POLICY_ANY</code>) use in the policy extension.</td></tr>
<tr><td width="30%">Authority key identifier</td><td width="20%">2.5.29.35</td><td width="40%">An identifier of the key of the issuer of the certificate. That is
used to distinguish between different keys of the same issuer.</td></tr>
<tr><td width="30%">Extended key usage</td><td width="20%">2.5.29.37</td><td width="40%">Constraints the purpose of the certificate.</td></tr>
<tr><td width="30%">Authority information access</td><td width="20%">1.3.6.1.5.5.7.1.1</td><td width="40%">Information on services by the issuer of the certificate.</td></tr>
<tr><td width="30%">Proxy Certification Information</td><td width="20%">1.3.6.1.5.5.7.1.14</td><td width="40%">Proxy Certificates includes this extension that contains the OID of
the proxy policy language used, and can specify limits on the maximum
lengths of proxy chains.  Proxy Certificates are specified in
[<a href="#RFC3820">RFC3820</a>].</td></tr>
</table>

<div class="float-caption"><p><strong>Table 4.3: </strong>Supported X.509 certificate extensions.</p></div></div>
<p>Note, that there are also direct APIs to access extensions that may
be simpler to use for non-complex extensions. They are available
in <code>x509.h</code> and some examples are listed below.
</p><dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrt_005fget_005fbasic_005fconstraints">gnutls_x509_crt_get_basic_constraints</a> (gnutls_x509_crt_t <var>cert</var>, unsigned int * <var>critical</var>, unsigned int * <var>ca</var>, int * <var>pathlen</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrt_005fset_005fbasic_005fconstraints">gnutls_x509_crt_set_basic_constraints</a> (gnutls_x509_crt_t <var>crt</var>, unsigned int <var>ca</var>, int <var>pathLenConstraint</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrt_005fget_005fkey_005fusage">gnutls_x509_crt_get_key_usage</a> (gnutls_x509_crt_t <var>cert</var>, unsigned int * <var>key_usage</var>, unsigned int * <var>critical</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrt_005fset_005fkey_005fusage">gnutls_x509_crt_set_key_usage</a> (gnutls_x509_crt_t <var>crt</var>, unsigned int <var>usage</var>)</code></dt>
</dl>


<hr>
<span id="X_002e509-public-and-private-keys"></span><div class="header">
<p>
Next: <a href="#Verifying-X_002e509-certificate-paths" accesskey="n" rel="next">Verifying X.509 certificate paths</a>, Previous: <a href="#X_002e509-extensions" accesskey="p" rel="prev">X.509 extensions</a>, Up: <a href="#X_002e509-certificates" accesskey="u" rel="up">X.509 certificates</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Accessing-public-and-private-keys"></span><h4 class="subsubsection">4.1.1.6 Accessing public and private keys</h4>

<p>Each X.509 certificate contains a public key that corresponds to a private key. To
get a unique identifier of the public key the <a href="#gnutls_005fx509_005fcrt_005fget_005fkey_005fid">gnutls_x509_crt_get_key_id</a>
function is provided. To export the public key or its parameters you may need
to convert the X.509 structure to a <code>gnutls_pubkey_t</code>. See 
<a href="#Abstract-public-keys">Abstract public keys</a> for more information.
</p>




<dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fkey_005fid">Function: <em>int</em> <strong>gnutls_x509_crt_get_key_id</strong> <em>(gnutls_x509_crt_t <var>crt</var>, unsigned int <var>flags</var>, unsigned char * <var>output_data</var>, size_t * <var>output_data_size</var>)</em></dt>
<dd><p><var>crt</var>: Holds the certificate
</p>
<p><var>flags</var>: should be one of the flags from <code>gnutls_keyid_flags_t</code> 
</p>
<p><var>output_data</var>: will contain the key ID
</p>
<p><var>output_data_size</var>: holds the size of output_data (and will be
replaced by the actual size of parameters)
</p>
<p>This function will return a unique ID that depends on the public
key parameters. This ID can be used in checking whether a
certificate corresponds to the given private key.
</p>
<p>If the buffer provided is not long enough to hold the output, then
*output_data_size is updated and GNUTLS_E_SHORT_MEMORY_BUFFER will
be returned.  The output will normally be a SHA-1 hash output,
which is 20 bytes.
</p>
<p><strong>Returns:</strong> In case of failure a negative error code will be
returned, and 0 on success.
</p></dd></dl>

<p>The private key parameters may be directly accessed by using one of the following functions.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fprivkey_005fget_005fpk_005falgorithm2">gnutls_x509_privkey_get_pk_algorithm2</a> (gnutls_x509_privkey_t <var>key</var>, unsigned int * <var>bits</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fprivkey_005fexport_005frsa_005fraw2">gnutls_x509_privkey_export_rsa_raw2</a> (gnutls_x509_privkey_t <var>key</var>, gnutls_datum_t * <var>m</var>, gnutls_datum_t * <var>e</var>, gnutls_datum_t * <var>d</var>, gnutls_datum_t * <var>p</var>, gnutls_datum_t * <var>q</var>, gnutls_datum_t * <var>u</var>, gnutls_datum_t * <var>e1</var>, gnutls_datum_t * <var>e2</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fprivkey_005fexport_005fecc_005fraw">gnutls_x509_privkey_export_ecc_raw</a> (gnutls_x509_privkey_t <var>key</var>, gnutls_ecc_curve_t * <var>curve</var>, gnutls_datum_t * <var>x</var>, gnutls_datum_t * <var>y</var>, gnutls_datum_t * <var>k</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fprivkey_005fexport_005fdsa_005fraw">gnutls_x509_privkey_export_dsa_raw</a> (gnutls_x509_privkey_t <var>key</var>, gnutls_datum_t * <var>p</var>, gnutls_datum_t * <var>q</var>, gnutls_datum_t * <var>g</var>, gnutls_datum_t * <var>y</var>, gnutls_datum_t * <var>x</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fprivkey_005fget_005fkey_005fid">gnutls_x509_privkey_get_key_id</a> (gnutls_x509_privkey_t <var>key</var>, unsigned int <var>flags</var>, unsigned char * <var>output_data</var>, size_t * <var>output_data_size</var>)</code></dt>
</dl>

<hr>
<span id="Verifying-X_002e509-certificate-paths"></span><div class="header">
<p>
Next: <a href="#Verifying-a-certificate-in-the-context-of-TLS-session" accesskey="n" rel="next">Verifying a certificate in the context of TLS session</a>, Previous: <a href="#X_002e509-public-and-private-keys" accesskey="p" rel="prev">X.509 public and private keys</a>, Up: <a href="#X_002e509-certificates" accesskey="u" rel="up">X.509 certificates</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Verifying-X_002e509-certificate-paths-1"></span><h4 class="subsubsection">4.1.1.7 Verifying <acronym>X.509</acronym> certificate paths</h4>
<span id="index-verifying-certificate-paths"></span>

<p>Verifying certificate paths is important in <acronym>X.509</acronym>
authentication. For this purpose the following functions are
provided.
</p>




<dl>
<dt id="index-gnutls_005fx509_005ftrust_005flist_005fadd_005fcas">Function: <em>int</em> <strong>gnutls_x509_trust_list_add_cas</strong> <em>(gnutls_x509_trust_list_t <var>list</var>, const gnutls_x509_crt_t * <var>clist</var>, unsigned <var>clist_size</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>list</var>: The list
</p>
<p><var>clist</var>: A list of CAs
</p>
<p><var>clist_size</var>: The length of the CA list
</p>
<p><var>flags</var>: flags from <code>gnutls_trust_list_flags_t</code> 
</p>
<p>This function will add the given certificate authorities
to the trusted list. The CAs in  <code>clist</code> must not be deinitialized
during the lifetime of  <code>list</code> .
</p>
<p>If the flag <code>GNUTLS_TL_NO_DUPLICATES</code>  is specified, then
this function will ensure that no duplicates will be
present in the final trust list.
</p>
<p>If the flag <code>GNUTLS_TL_NO_DUPLICATE_KEY</code>  is specified, then
this function will ensure that no certificates with the
same key are present in the final trust list.
</p>
<p>If either <code>GNUTLS_TL_NO_DUPLICATE_KEY</code>  or <code>GNUTLS_TL_NO_DUPLICATES</code> 
are given, <code>gnutls_x509_trust_list_deinit()</code>  must be called with parameter
 <code>all</code> being 1.
</p>
<p><strong>Returns:</strong> The number of added elements is returned; that includes
duplicate entries.
</p>
<p><strong>Since:</strong> 3.0.0
</p></dd></dl>




<dl>
<dt id="index-gnutls_005fx509_005ftrust_005flist_005fadd_005fnamed_005fcrt">Function: <em>int</em> <strong>gnutls_x509_trust_list_add_named_crt</strong> <em>(gnutls_x509_trust_list_t <var>list</var>, gnutls_x509_crt_t <var>cert</var>, const void * <var>name</var>, size_t <var>name_size</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>list</var>: The list
</p>
<p><var>cert</var>: A certificate
</p>
<p><var>name</var>: An identifier for the certificate
</p>
<p><var>name_size</var>: The size of the identifier
</p>
<p><var>flags</var>: should be 0.
</p>
<p>This function will add the given certificate to the trusted
list and associate it with a name. The certificate will not be
be used for verification with <code>gnutls_x509_trust_list_verify_crt()</code> 
but with <code>gnutls_x509_trust_list_verify_named_crt()</code>  or
<code>gnutls_x509_trust_list_verify_crt2()</code>  - the latter only since
GnuTLS 3.4.0 and if a hostname is provided.
</p>
<p>In principle this function can be used to set individual &quot;server&quot;
certificates that are trusted by the user for that specific server
but for no other purposes.
</p>
<p>The certificate  <code>cert</code> must not be deinitialized during the lifetime
of the  <code>list</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.0.0
</p></dd></dl>




<dl>
<dt id="index-gnutls_005fx509_005ftrust_005flist_005fadd_005fcrls">Function: <em>int</em> <strong>gnutls_x509_trust_list_add_crls</strong> <em>(gnutls_x509_trust_list_t <var>list</var>, const gnutls_x509_crl_t * <var>crl_list</var>, unsigned <var>crl_size</var>, unsigned int <var>flags</var>, unsigned int <var>verification_flags</var>)</em></dt>
<dd><p><var>list</var>: The list
</p>
<p><var>crl_list</var>: A list of CRLs
</p>
<p><var>crl_size</var>: The length of the CRL list
</p>
<p><var>flags</var>: flags from <code>gnutls_trust_list_flags_t</code> 
</p>
<p><var>verification_flags</var>: gnutls_certificate_verify_flags if flags specifies GNUTLS_TL_VERIFY_CRL
</p>
<p>This function will add the given certificate revocation lists
to the trusted list. The CRLs in  <code>crl_list</code> must not be deinitialized
during the lifetime of  <code>list</code> .
</p>
<p>This function must be called after <code>gnutls_x509_trust_list_add_cas()</code> 
to allow verifying the CRLs for validity. If the flag <code>GNUTLS_TL_NO_DUPLICATES</code> 
is given, then the final CRL list will not contain duplicate entries.
</p>
<p>If the flag <code>GNUTLS_TL_NO_DUPLICATES</code>  is given, <code>gnutls_x509_trust_list_deinit()</code>  must be
called with parameter  <code>all</code> being 1.
</p>
<p>If flag <code>GNUTLS_TL_VERIFY_CRL</code>  is given the CRLs will be verified before being added,
and if verification fails, they will be skipped.
</p>
<p><strong>Returns:</strong> The number of added elements is returned; that includes
duplicate entries.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>




<dl>
<dt id="index-gnutls_005fx509_005ftrust_005flist_005fverify_005fcrt">Function: <em>int</em> <strong>gnutls_x509_trust_list_verify_crt</strong> <em>(gnutls_x509_trust_list_t <var>list</var>, gnutls_x509_crt_t * <var>cert_list</var>, unsigned int <var>cert_list_size</var>, unsigned int <var>flags</var>, unsigned int * <var>voutput</var>, gnutls_verify_output_function <var>func</var>)</em></dt>
<dd><p><var>list</var>: The list
</p>
<p><var>cert_list</var>: is the certificate list to be verified
</p>
<p><var>cert_list_size</var>: is the certificate list size
</p>
<p><var>flags</var>: Flags that may be used to change the verification algorithm. Use OR of the gnutls_certificate_verify_flags enumerations.
</p>
<p><var>voutput</var>: will hold the certificate verification output.
</p>
<p><var>func</var>: If non-null will be called on each chain element verification with the output.
</p>
<p>This function will try to verify the given certificate and return
its status. The  <code>voutput</code> parameter will hold an OR&rsquo;ed sequence of
<code>gnutls_certificate_status_t</code>  flags.
</p>
<p>The details of the verification are the same as in <code>gnutls_x509_trust_list_verify_crt2()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>




<dl>
<dt id="index-gnutls_005fx509_005ftrust_005flist_005fverify_005fcrt2">Function: <em>int</em> <strong>gnutls_x509_trust_list_verify_crt2</strong> <em>(gnutls_x509_trust_list_t <var>list</var>, gnutls_x509_crt_t * <var>cert_list</var>, unsigned int <var>cert_list_size</var>, gnutls_typed_vdata_st * <var>data</var>, unsigned int <var>elements</var>, unsigned int <var>flags</var>, unsigned int * <var>voutput</var>, gnutls_verify_output_function <var>func</var>)</em></dt>
<dd><p><var>list</var>: The list
</p>
<p><var>cert_list</var>: is the certificate list to be verified
</p>
<p><var>cert_list_size</var>: is the certificate list size
</p>
<p><var>data</var>: an array of typed data
</p>
<p><var>elements</var>: the number of data elements
</p>
<p><var>flags</var>: Flags that may be used to change the verification algorithm. Use OR of the gnutls_certificate_verify_flags enumerations.
</p>
<p><var>voutput</var>: will hold the certificate verification output.
</p>
<p><var>func</var>: If non-null will be called on each chain element verification with the output.
</p>
<p>This function will attempt to verify the given certificate chain and return
its status. The  <code>voutput</code> parameter will hold an OR&rsquo;ed sequence of
<code>gnutls_certificate_status_t</code>  flags.
</p>
<p>When a certificate chain of  <code>cert_list_size</code> with more than one certificates is
provided, the verification status will apply to the first certificate in the chain
that failed verification. The verification process starts from the end of the chain
(from CA to end certificate). The first certificate in the chain must be the end-certificate
while the rest of the members may be sorted or not.
</p>
<p>Additionally a certificate verification profile can be specified
from the ones in <code>gnutls_certificate_verification_profiles_t</code>  by
ORing the result of <code>GNUTLS_PROFILE_TO_VFLAGS()</code>  to the verification
flags.
</p>
<p>Additional verification parameters are possible via the  <code>data</code> types; the
acceptable types are <code>GNUTLS_DT_DNS_HOSTNAME</code> , <code>GNUTLS_DT_IP_ADDRESS</code>  and <code>GNUTLS_DT_KEY_PURPOSE_OID</code> .
The former accepts as data a null-terminated hostname, and the latter a null-terminated
object identifier (e.g., <code>GNUTLS_KP_TLS_WWW_SERVER</code> ).
If a DNS hostname is provided then this function will compare
the hostname in the end certificate against the given. If names do not match the
<code>GNUTLS_CERT_UNEXPECTED_OWNER</code>  status flag will be set. In addition it
will consider certificates provided with <code>gnutls_x509_trust_list_add_named_crt()</code> .
</p>
<p>If a key purpose OID is provided and the end-certificate contains the extended key
usage PKIX extension, it will be required to match the provided OID
or be marked for any purpose, otherwise verification will fail with 
<code>GNUTLS_CERT_PURPOSE_MISMATCH</code>  status.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value. Note that verification failure will not result to an
error code, only  <code>voutput</code> will be updated.
</p>
<p><strong>Since:</strong> 3.3.8
</p></dd></dl>




<dl>
<dt id="index-gnutls_005fx509_005ftrust_005flist_005fverify_005fnamed_005fcrt">Function: <em>int</em> <strong>gnutls_x509_trust_list_verify_named_crt</strong> <em>(gnutls_x509_trust_list_t <var>list</var>, gnutls_x509_crt_t <var>cert</var>, const void * <var>name</var>, size_t <var>name_size</var>, unsigned int <var>flags</var>, unsigned int * <var>voutput</var>, gnutls_verify_output_function <var>func</var>)</em></dt>
<dd><p><var>list</var>: The list
</p>
<p><var>cert</var>: is the certificate to be verified
</p>
<p><var>name</var>: is the certificate&rsquo;s name
</p>
<p><var>name_size</var>: is the certificate&rsquo;s name size
</p>
<p><var>flags</var>: Flags that may be used to change the verification algorithm. Use OR of the gnutls_certificate_verify_flags enumerations.
</p>
<p><var>voutput</var>: will hold the certificate verification output.
</p>
<p><var>func</var>: If non-null will be called on each chain element verification with the output.
</p>
<p>This function will try to find a certificate that is associated with the provided
name &ndash;see <code>gnutls_x509_trust_list_add_named_crt()</code> . If a match is found the
certificate is considered valid. In addition to that this function will also 
check CRLs. The  <code>voutput</code> parameter will hold an OR&rsquo;ed sequence of 
<code>gnutls_certificate_status_t</code>  flags.
</p>
<p>Additionally a certificate verification profile can be specified
from the ones in <code>gnutls_certificate_verification_profiles_t</code>  by
ORing the result of <code>GNUTLS_PROFILE_TO_VFLAGS()</code>  to the verification
flags.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.0.0
</p></dd></dl>





<dl>
<dt id="index-gnutls_005fx509_005ftrust_005flist_005fadd_005ftrust_005ffile">Function: <em>int</em> <strong>gnutls_x509_trust_list_add_trust_file</strong> <em>(gnutls_x509_trust_list_t <var>list</var>, const char * <var>ca_file</var>, const char * <var>crl_file</var>, gnutls_x509_crt_fmt_t <var>type</var>, unsigned int <var>tl_flags</var>, unsigned int <var>tl_vflags</var>)</em></dt>
<dd><p><var>list</var>: The list
</p>
<p><var>ca_file</var>: A file containing a list of CAs (optional)
</p>
<p><var>crl_file</var>: A file containing a list of CRLs (optional)
</p>
<p><var>type</var>: The format of the certificates
</p>
<p><var>tl_flags</var>: flags from <code>gnutls_trust_list_flags_t</code> 
</p>
<p><var>tl_vflags</var>: gnutls_certificate_verify_flags if flags specifies GNUTLS_TL_VERIFY_CRL
</p>
<p>This function will add the given certificate authorities
to the trusted list. PKCS <code>11</code>  URLs are also accepted, instead
of files, by this function. A PKCS <code>11</code>  URL implies a trust
database (a specially marked module in p11-kit); the URL &quot;pkcs11:&quot;
implies all trust databases in the system. Only a single URL specifying
trust databases can be set; they cannot be stacked with multiple calls.
</p>
<p><strong>Returns:</strong> The number of added elements is returned.
</p>
<p><strong>Since:</strong> 3.1
</p></dd></dl>




<dl>
<dt id="index-gnutls_005fx509_005ftrust_005flist_005fadd_005ftrust_005fmem">Function: <em>int</em> <strong>gnutls_x509_trust_list_add_trust_mem</strong> <em>(gnutls_x509_trust_list_t <var>list</var>, const gnutls_datum_t * <var>cas</var>, const gnutls_datum_t * <var>crls</var>, gnutls_x509_crt_fmt_t <var>type</var>, unsigned int <var>tl_flags</var>, unsigned int <var>tl_vflags</var>)</em></dt>
<dd><p><var>list</var>: The list
</p>
<p><var>cas</var>: A buffer containing a list of CAs (optional)
</p>
<p><var>crls</var>: A buffer containing a list of CRLs (optional)
</p>
<p><var>type</var>: The format of the certificates
</p>
<p><var>tl_flags</var>: flags from <code>gnutls_trust_list_flags_t</code> 
</p>
<p><var>tl_vflags</var>: gnutls_certificate_verify_flags if flags specifies GNUTLS_TL_VERIFY_CRL
</p>
<p>This function will add the given certificate authorities
to the trusted list. 
</p>
<p>If this function is used <code>gnutls_x509_trust_list_deinit()</code>  must be called
with parameter  <code>all</code> being 1.
</p>
<p><strong>Returns:</strong> The number of added elements is returned.
</p>
<p><strong>Since:</strong> 3.1
</p></dd></dl>




<dl>
<dt id="index-gnutls_005fx509_005ftrust_005flist_005fadd_005fsystem_005ftrust">Function: <em>int</em> <strong>gnutls_x509_trust_list_add_system_trust</strong> <em>(gnutls_x509_trust_list_t <var>list</var>, unsigned int <var>tl_flags</var>, unsigned int <var>tl_vflags</var>)</em></dt>
<dd><p><var>list</var>: The structure of the list
</p>
<p><var>tl_flags</var>: GNUTLS_TL_*
</p>
<p><var>tl_vflags</var>: gnutls_certificate_verify_flags if flags specifies GNUTLS_TL_VERIFY_CRL
</p>
<p>This function adds the system&rsquo;s default trusted certificate
authorities to the trusted list. Note that on unsupported systems
this function returns <code>GNUTLS_E_UNIMPLEMENTED_FEATURE</code> .
</p>
<p>This function implies the flag <code>GNUTLS_TL_NO_DUPLICATES</code> .
</p>
<p><strong>Returns:</strong> The number of added elements or a negative error code on error.
</p>
<p><strong>Since:</strong> 3.1
</p></dd></dl>

<p>The verification function will verify a given certificate chain against a list of certificate
authorities and certificate revocation lists, and output
a bit-wise OR of elements of the <code>gnutls_certificate_status_t</code> 
enumeration shown in <a href="#gnutls_005fcertificate_005fstatus_005ft">Figure 4.2</a>. The <code>GNUTLS_CERT_INVALID</code> flag
is always set on a verification error and more detailed flags will also be set when appropriate.
</p>
<div class="float"><span id="gnutls_005fcertificate_005fstatus_005ft"></span>


<dl compact="compact">
<dt><code>GNUTLS_CERT_INVALID</code></dt>
<dd><p>The certificate is not signed by one of the
known authorities or the signature is invalid (deprecated by the flags 
<code>GNUTLS_CERT_SIGNATURE_FAILURE</code>  and <code>GNUTLS_CERT_SIGNER_NOT_FOUND</code> ).
</p></dd>
<dt><code>GNUTLS_CERT_REVOKED</code></dt>
<dd><p>Certificate is revoked by its authority.  In X.509 this will be
set only if CRLs are checked.
</p></dd>
<dt><code>GNUTLS_CERT_SIGNER_NOT_FOUND</code></dt>
<dd><p>The certificate&rsquo;s issuer is not known. 
This is the case if the issuer is not included in the trusted certificate list.
</p></dd>
<dt><code>GNUTLS_CERT_SIGNER_NOT_CA</code></dt>
<dd><p>The certificate&rsquo;s signer was not a CA. This
may happen if this was a version 1 certificate, which is common with
some CAs, or a version 3 certificate without the basic constrains extension.
</p></dd>
<dt><code>GNUTLS_CERT_INSECURE_ALGORITHM</code></dt>
<dd><p>The certificate was signed using an insecure
algorithm such as MD2 or MD5. These algorithms have been broken and
should not be trusted.
</p></dd>
<dt><code>GNUTLS_CERT_NOT_ACTIVATED</code></dt>
<dd><p>The certificate is not yet activated.
</p></dd>
<dt><code>GNUTLS_CERT_EXPIRED</code></dt>
<dd><p>The certificate has expired.
</p></dd>
<dt><code>GNUTLS_CERT_SIGNATURE_FAILURE</code></dt>
<dd><p>The signature verification failed.
</p></dd>
<dt><code>GNUTLS_CERT_REVOCATION_DATA_SUPERSEDED</code></dt>
<dd><p>The revocation data are old and have been superseded.
</p></dd>
<dt><code>GNUTLS_CERT_UNEXPECTED_OWNER</code></dt>
<dd><p>The owner is not the expected one.
</p></dd>
<dt><code>GNUTLS_CERT_REVOCATION_DATA_ISSUED_IN_FUTURE</code></dt>
<dd><p>The revocation data have a future issue date.
</p></dd>
<dt><code>GNUTLS_CERT_SIGNER_CONSTRAINTS_FAILURE</code></dt>
<dd><p>The certificate&rsquo;s signer constraints were
violated.
</p></dd>
<dt><code>GNUTLS_CERT_MISMATCH</code></dt>
<dd><p>The certificate presented isn&rsquo;t the expected one (TOFU)
</p></dd>
<dt><code>GNUTLS_CERT_PURPOSE_MISMATCH</code></dt>
<dd><p>The certificate or an intermediate does not match the intended purpose (extended key usage).
</p></dd>
<dt><code>GNUTLS_CERT_MISSING_OCSP_STATUS</code></dt>
<dd><p>The certificate requires the server to send the certifiate status, but no status was received.
</p></dd>
<dt><code>GNUTLS_CERT_INVALID_OCSP_STATUS</code></dt>
<dd><p>The received OCSP status response is invalid.
</p></dd>
<dt><code>GNUTLS_CERT_UNKNOWN_CRIT_EXTENSIONS</code></dt>
<dd><p>The certificate has extensions marked as critical which are not supported.
</p></dd>
</dl>

<div class="float-caption"><p><strong>Figure 4.2: </strong>The <code>gnutls_certificate_status_t</code> enumeration.</p></div></div>
<p>An example of certificate verification is shown in <a href="#ex_002dverify2">ex-verify2</a>.
It is also possible to have a set of certificates that
are trusted for a particular server but not to authorize other certificates.
This purpose is served by the functions <a href="#gnutls_005fx509_005ftrust_005flist_005fadd_005fnamed_005fcrt">gnutls_x509_trust_list_add_named_crt</a> and <a href="#gnutls_005fx509_005ftrust_005flist_005fverify_005fnamed_005fcrt">gnutls_x509_trust_list_verify_named_crt</a>.
</p>
<hr>
<span id="Verifying-a-certificate-in-the-context-of-TLS-session"></span><div class="header">
<p>
Next: <a href="#Verification-using-PKCS11" accesskey="n" rel="next">Verification using PKCS11</a>, Previous: <a href="#Verifying-X_002e509-certificate-paths" accesskey="p" rel="prev">Verifying X.509 certificate paths</a>, Up: <a href="#X_002e509-certificates" accesskey="u" rel="up">X.509 certificates</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Verifying-a-certificate-in-the-context-of-TLS-session-1"></span><h4 class="subsubsection">4.1.1.8 Verifying a certificate in the context of TLS session</h4>
<span id="index-verifying-certificate-paths-1"></span>
<span id="index-gnutls_005fcertificate_005fverify_005fflags"></span>

<p>When operating in the context of a TLS session, the trusted certificate
authority list may also be set using:
</p><dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fcertificate_005fset_005fx509_005ftrust_005ffile">gnutls_certificate_set_x509_trust_file</a> (gnutls_certificate_credentials_t            <var>cred</var>, const char * <var>cafile</var>, gnutls_x509_crt_fmt_t <var>type</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fcertificate_005fset_005fx509_005ftrust_005fdir">gnutls_certificate_set_x509_trust_dir</a> (gnutls_certificate_credentials_t <var>cred</var>, const char * <var>ca_dir</var>, gnutls_x509_crt_fmt_t <var>type</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fcertificate_005fset_005fx509_005fcrl_005ffile">gnutls_certificate_set_x509_crl_file</a> (gnutls_certificate_credentials_t <var>res</var>, const char * <var>crlfile</var>, gnutls_x509_crt_fmt_t <var>type</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fcertificate_005fset_005fx509_005fsystem_005ftrust">gnutls_certificate_set_x509_system_trust</a> (gnutls_certificate_credentials_t       <var>cred</var>)</code></dt>
</dl>

<p>These functions allow the specification of the trusted certificate authorities, either
via a file, a directory or use the system-specified certificate authorities. 
Unless the authorities are application specific, it is generally recommended
to use the system trust storage (see <a href="#gnutls_005fcertificate_005fset_005fx509_005fsystem_005ftrust">gnutls_certificate_set_x509_system_trust</a>).
</p>
<p>Unlike the previous section it is not required to setup a trusted list, and there
are two approaches to verify the peer&rsquo;s certificate and identity.
The recommended in GnuTLS 3.5.0 and later is via the <a href="#gnutls_005fsession_005fset_005fverify_005fcert">gnutls_session_set_verify_cert</a>,
but for older GnuTLS versions you may use an explicit callback set via
<a href="#gnutls_005fcertificate_005fset_005fverify_005ffunction">gnutls_certificate_set_verify_function</a> and then utilize
<a href="#gnutls_005fcertificate_005fverify_005fpeers3">gnutls_certificate_verify_peers3</a> for verification.
The reported verification status is identical to the verification functions described 
in the previous section.
</p>
<p>Note that in certain cases it is required to check the marked purpose of
the end certificate (e.g. <code>GNUTLS_KP_TLS_WWW_SERVER</code>); in these cases
the more advanced <a href="#gnutls_005fsession_005fset_005fverify_005fcert2">gnutls_session_set_verify_cert2</a> and
<a href="#gnutls_005fcertificate_005fverify_005fpeers">gnutls_certificate_verify_peers</a> should be used instead.
</p>
<p>There is also the possibility to pass some input to the verification
functions in the form of flags. For <a href="#gnutls_005fx509_005ftrust_005flist_005fverify_005fcrt2">gnutls_x509_trust_list_verify_crt2</a> the
flags are passed directly, but for
<a href="#gnutls_005fcertificate_005fverify_005fpeers3">gnutls_certificate_verify_peers3</a>, the flags are set using
<a href="#gnutls_005fcertificate_005fset_005fverify_005fflags">gnutls_certificate_set_verify_flags</a>.  All the available
flags are part of the enumeration
<code>gnutls_certificate_verify_flags</code> shown in <a href="#gnutls_005fcertificate_005fverify_005fflags">Figure 4.3</a>.
</p>
<div class="float"><span id="gnutls_005fcertificate_005fverify_005fflags"></span>


<dl compact="compact">
<dt><code>GNUTLS_VERIFY_DISABLE_CA_SIGN</code></dt>
<dd><p>If set a signer does not have to be
a certificate authority. This flag should normally be disabled,
unless you know what this means.
</p></dd>
<dt><code>GNUTLS_VERIFY_DO_NOT_ALLOW_IP_MATCHES</code></dt>
<dd><p>When verifying a hostname
prevent textual IP addresses from matching IP addresses in the
certificate. Treat the input only as a DNS name.
</p></dd>
<dt><code>GNUTLS_VERIFY_DO_NOT_ALLOW_SAME</code></dt>
<dd><p>If a certificate is not signed by
anyone trusted but exists in the trusted CA list do not treat it
as trusted.
</p></dd>
<dt><code>GNUTLS_VERIFY_ALLOW_ANY_X509_V1_CA_CRT</code></dt>
<dd><p>Allow CA certificates that
have version 1 (both root and intermediate). This might be
dangerous since those haven&rsquo;t the basicConstraints
extension. 
</p></dd>
<dt><code>GNUTLS_VERIFY_ALLOW_SIGN_RSA_MD2</code></dt>
<dd><p>Allow certificates to be signed
using the broken MD2 algorithm.
</p></dd>
<dt><code>GNUTLS_VERIFY_ALLOW_SIGN_RSA_MD5</code></dt>
<dd><p>Allow certificates to be signed
using the broken MD5 algorithm.
</p></dd>
<dt><code>GNUTLS_VERIFY_DISABLE_TIME_CHECKS</code></dt>
<dd><p>Disable checking of activation
and expiration validity periods of certificate chains. Don&rsquo;t set
this unless you understand the security implications.
</p></dd>
<dt><code>GNUTLS_VERIFY_DISABLE_TRUSTED_TIME_CHECKS</code></dt>
<dd><p>If set a signer in the trusted
list is never checked for expiration or activation.
</p></dd>
<dt><code>GNUTLS_VERIFY_DO_NOT_ALLOW_X509_V1_CA_CRT</code></dt>
<dd><p>Do not allow trusted CA
certificates that have version 1.  This option is to be used
to deprecate all certificates of version 1.
</p></dd>
<dt><code>GNUTLS_VERIFY_DISABLE_CRL_CHECKS</code></dt>
<dd><p>Disable checking for validity
using certificate revocation lists or the available OCSP data.
</p></dd>
<dt><code>GNUTLS_VERIFY_ALLOW_UNSORTED_CHAIN</code></dt>
<dd><p>A certificate chain is tolerated
if unsorted (the case with many TLS servers out there). This is the
default since GnuTLS 3.1.4.
</p></dd>
<dt><code>GNUTLS_VERIFY_DO_NOT_ALLOW_UNSORTED_CHAIN</code></dt>
<dd><p>Do not tolerate an unsorted
certificate chain.
</p></dd>
<dt><code>GNUTLS_VERIFY_DO_NOT_ALLOW_WILDCARDS</code></dt>
<dd><p>When including a hostname
check in the verification, do not consider any wildcards.
</p></dd>
<dt><code>GNUTLS_VERIFY_USE_TLS1_RSA</code></dt>
<dd><p>This indicates that a (raw) RSA signature is provided
as in the TLS 1.0 protocol. Not all functions accept this flag.
</p></dd>
<dt><code>GNUTLS_VERIFY_IGNORE_UNKNOWN_CRIT_EXTENSIONS</code></dt>
<dd><p>This signals the verification
process, not to fail on unknown critical extensions.
</p></dd>
<dt><code>GNUTLS_VERIFY_ALLOW_SIGN_WITH_SHA1</code></dt>
<dd><p>Allow certificates to be signed
using the broken SHA1 hash algorithm.
</p></dd>
</dl>

<div class="float-caption"><p><strong>Figure 4.3: </strong>The <code>gnutls_certificate_verify_flags</code> enumeration.</p></div></div>
<hr>
<span id="Verification-using-PKCS11"></span><div class="header">
<p>
Previous: <a href="#Verifying-a-certificate-in-the-context-of-TLS-session" accesskey="p" rel="prev">Verifying a certificate in the context of TLS session</a>, Up: <a href="#X_002e509-certificates" accesskey="u" rel="up">X.509 certificates</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Verifying-a-certificate-using-PKCS-_002311"></span><h4 class="subsubsection">4.1.1.9 Verifying a certificate using PKCS #11</h4>
<span id="index-verifying-certificate-with-pkcs11"></span>

<p>Some systems provide a system wide trusted certificate storage accessible using
the PKCS #11 API. That is, the trusted certificates are queried and accessed using the
PKCS #11 API, and trusted certificate properties, such as purpose, are marked using
attached extensions. One example is the p11-kit trust module<a id="DOCF8" href="#FOOT8"><sup>8</sup></a>.
</p>
<p>These special PKCS #11 modules can be used for GnuTLS certificate verification if marked as trust 
policy modules, i.e., with <code>trust-policy: yes</code> in the p11-kit module file.
The way to use them is by specifying to the file verification function (e.g., <a href="#gnutls_005fcertificate_005fset_005fx509_005ftrust_005ffile">gnutls_certificate_set_x509_trust_file</a>),
a pkcs11 URL, or simply <code>pkcs11:</code> to use all the marked with trust policy modules.
</p>
<p>The trust modules of p11-kit assign a purpose to trusted authorities using the extended
key usage object identifiers. The common purposes are shown in <a href="#tab_003apurposes">Table 4.4</a>. Note
that typically according to [<a href="#RFC5280">RFC5280</a>] the extended key usage object identifiers apply to end certificates. Their
application to CA certificates is an extension used by the trust modules.
</p>
<div class="float"><span id="tab_003apurposes"></span>
<table>
<thead><tr><th width="20%">Purpose</th><th width="20%">OID</th><th width="60%">Description</th></tr></thead>
<tr><td width="20%">GNUTLS_KP_TLS_WWW_SERVER</td><td width="20%">1.3.6.1.5.5.7.3.1</td><td width="60%">The certificate is to be used for TLS WWW authentication. When in a CA certificate, it
indicates that the CA is allowed to sign certificates for TLS WWW authentication.</td></tr>
<tr><td width="20%">GNUTLS_KP_TLS_WWW_CLIENT</td><td width="20%">1.3.6.1.5.5.7.3.2</td><td width="60%">The certificate is to be used for TLS WWW client authentication. When in a CA certificate, it
indicates that the CA is allowed to sign certificates for TLS WWW client authentication.</td></tr>
<tr><td width="20%">GNUTLS_KP_CODE_SIGNING</td><td width="20%">1.3.6.1.5.5.7.3.3</td><td width="60%">The certificate is to be used for code signing. When in a CA certificate, it
indicates that the CA is allowed to sign certificates for code signing.</td></tr>
<tr><td width="20%">GNUTLS_KP_EMAIL_PROTECTION</td><td width="20%">1.3.6.1.5.5.7.3.4</td><td width="60%">The certificate is to be used for email protection. When in a CA certificate, it
indicates that the CA is allowed to sign certificates for email users.</td></tr>
<tr><td width="20%">GNUTLS_KP_OCSP_SIGNING</td><td width="20%">1.3.6.1.5.5.7.3.9</td><td width="60%">The certificate is to be used for signing OCSP responses. When in a CA certificate, it
indicates that the CA is allowed to sign certificates which sign OCSP responses.</td></tr>
<tr><td width="20%">GNUTLS_KP_ANY</td><td width="20%">2.5.29.37.0</td><td width="60%">The certificate is to be used for any purpose. When in a CA certificate, it
indicates that the CA is allowed to sign any kind of certificates.</td></tr>
</table>

<div class="float-caption"><p><strong>Table 4.4: </strong>Key purpose object identifiers.</p></div></div>
<p>With such modules, it is recommended to use the verification functions <a href="#gnutls_005fx509_005ftrust_005flist_005fverify_005fcrt2">gnutls_x509_trust_list_verify_crt2</a>,
or <a href="#gnutls_005fcertificate_005fverify_005fpeers">gnutls_certificate_verify_peers</a>, which allow to explicitly specify the key purpose. The
other verification functions which do not allow setting a purpose, would operate as if
<code>GNUTLS_KP_TLS_WWW_SERVER</code> was requested from the trusted authorities.
</p>
<hr>
<span id="OpenPGP-certificates"></span><div class="header">
<p>
Next: <a href="#Raw-public_002dkeys" accesskey="n" rel="next">Raw public-keys</a>, Previous: <a href="#X_002e509-certificates" accesskey="p" rel="prev">X.509 certificates</a>, Up: <a href="#Certificate-authentication" accesskey="u" rel="up">Certificate authentication</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="OpenPGP-certificates-1"></span><h4 class="subsection">4.1.2 <acronym>OpenPGP</acronym> certificates</h4>
<span id="index-OpenPGP-certificates"></span>

<p>Previous versions of GnuTLS supported limited <acronym>OpenPGP</acronym> key
authentication. That functionality has been deprecated and is no longer
made available. The reason is that, supporting alternative authentication
methods, when X.509 and PKIX were new on the Internet and not well established, seemed like a
good idea, in today&rsquo;s Internet X.509 is unquestionably the main
container for certificates. As such supporting more options with no clear
use-cases, is a distraction that consumes considerable resources for
improving and testing the library. For that we have decided to drop
this functionality completely in 3.6.0.
</p>
<hr>
<span id="Raw-public_002dkeys"></span><div class="header">
<p>
Next: <a href="#Advanced-certificate-verification" accesskey="n" rel="next">Advanced certificate verification</a>, Previous: <a href="#OpenPGP-certificates" accesskey="p" rel="prev">OpenPGP certificates</a>, Up: <a href="#Certificate-authentication" accesskey="u" rel="up">Certificate authentication</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Raw-public_002dkeys-1"></span><h4 class="subsection">4.1.3 Raw public-keys</h4>
<span id="index-Raw-public_002dkeys"></span>

<p>There are situations in which a rather large certificate / certificate chain is undesirable or impractical.
An example could be a resource contrained sensor network in which you do want to use authentication of and
encryption between your devices but where your devices lack loads of memory or processing power. Furthermore,
there are situations in which you don&rsquo;t want to or can&rsquo;t rely on a PKIX. TLS is, next to a PKIX environment,
also commonly used with self-signed certificates in smaller deployments where the self-signed certificates
are distributed to all involved protocol endpoints out-of-band. This practice does, however, still require
the overhead of the certificate generation even though none of the information found in the certificate is
actually used.
</p>
<p>With raw public-keys, only a subset of the information found in typical certificates is utilized: namely,
the SubjectPublicKeyInfo structure (in ASN.1 format) of a PKIX certificate that carries the parameters
necessary to describe the public-key. Other parameters found in PKIX certificates are omitted. By omitting
various certificate-related structures, the resulting raw public-key is kept fairly small in comparison to
the original certificate, and the code to process the keys can be simpler.
</p>
<p>It should be noted however, that the authenticity of these raw keys must be verified by an out-of-band mechanism
or something like <acronym>TOFU</acronym>.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Importing-raw-public_002dkeys" accesskey="1">Importing raw public-keys</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Importing-raw-public_002dkeys"></span><div class="header">
<p>
Up: <a href="#Raw-public_002dkeys" accesskey="u" rel="up">Raw public-keys</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Importing-raw-public_002dkeys-1"></span><h4 class="subsubsection">4.1.3.1 Importing raw public-keys</h4>
<p>Raw public-keys and their private counterparts can best be handled by using the abstract types
<code>gnutls_pubkey_t</code> and <code>gnutls_privkey_t</code> respectively. To learn how to use these
see <a href="#Abstract-key-types">Abstract key types</a>.
</p>
<hr>
<span id="Advanced-certificate-verification"></span><div class="header">
<p>
Next: <a href="#Digital-signatures" accesskey="n" rel="next">Digital signatures</a>, Previous: <a href="#Raw-public_002dkeys" accesskey="p" rel="prev">Raw public-keys</a>, Up: <a href="#Certificate-authentication" accesskey="u" rel="up">Certificate authentication</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Advanced-certificate-verification-1"></span><h4 class="subsection">4.1.4 Advanced certificate verification</h4>
<span id="index-Certificate-verification"></span>

<p>The verification of X.509 certificates in the HTTPS and other Internet protocols is typically 
done by loading a trusted list of commercial Certificate Authorities
(see <a href="#gnutls_005fcertificate_005fset_005fx509_005fsystem_005ftrust">gnutls_certificate_set_x509_system_trust</a>), and using them as trusted anchors.
However, there are several examples (eg. the Diginotar incident) where one of these
authorities was compromised. This risk can be mitigated by using in addition to CA certificate verification,
other verification methods. In this section we list the available in GnuTLS methods.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Verifying-a-certificate-using-trust-on-first-use-authentication" accesskey="1">Verifying a certificate using trust on first use authentication</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Verifying-a-certificate-using-DANE" accesskey="2">Verifying a certificate using DANE</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Verifying-a-certificate-using-trust-on-first-use-authentication"></span><div class="header">
<p>
Next: <a href="#Verifying-a-certificate-using-DANE" accesskey="n" rel="next">Verifying a certificate using DANE</a>, Up: <a href="#Advanced-certificate-verification" accesskey="u" rel="up">Advanced certificate verification</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Verifying-a-certificate-using-trust-on-first-use-authentication-1"></span><h4 class="subsubsection">4.1.4.1 Verifying a certificate using trust on first use authentication</h4>
<span id="index-verifying-certificate-paths-2"></span>
<span id="index-SSH_002dstyle-authentication"></span>
<span id="index-Trust-on-first-use"></span>
<span id="index-Key-pinning"></span>

<p>It is possible to use a trust on first use (TOFU) authentication 
method in GnuTLS. That is the concept used by the SSH programs, where the 
public key of the peer is not verified, or verified in an out-of-bound way,
but subsequent connections to the same peer require the public key to 
remain the same.  Such a system in combination with the typical CA 
verification of a certificate, and OCSP revocation checks,
can help to provide multiple factor verification, where a single point of
failure is not enough to compromise the system. For example a server compromise
may be detected using OCSP, and a CA compromise can be detected using
the trust on first use method.
Such a hybrid system with X.509 and trust on first use authentication is 
shown in <a href="#Client-example-with-SSH_002dstyle-certificate-verification">Client example with SSH-style certificate verification</a>.
</p>
<p>See <a href="#Certificate-verification">Certificate verification</a> on how to use the available functionality.
</p>
<hr>
<span id="Verifying-a-certificate-using-DANE"></span><div class="header">
<p>
Previous: <a href="#Verifying-a-certificate-using-trust-on-first-use-authentication" accesskey="p" rel="prev">Verifying a certificate using trust on first use authentication</a>, Up: <a href="#Advanced-certificate-verification" accesskey="u" rel="up">Advanced certificate verification</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Verifying-a-certificate-using-DANE-_0028DNSSEC_0029"></span><h4 class="subsubsection">4.1.4.2 Verifying a certificate using DANE (DNSSEC)</h4>
<span id="index-verifying-certificate-paths-3"></span>
<span id="index-DANE"></span>
<span id="index-DNSSEC"></span>

<p>The DANE protocol is a protocol that can be used to verify TLS certificates
using the DNS (or better DNSSEC) protocols. The DNS security extensions (DNSSEC)
provide an alternative public key infrastructure to the commercial CAs that
are typically used to sign TLS certificates. The DANE protocol takes advantage
of the DNSSEC infrastructure to verify TLS certificates. This can be 
in addition to the verification by CA infrastructure or 
may even replace it where DNSSEC is fully deployed. Note however, that DNSSEC deployment is
fairly new and it would be better to use it as an additional verification
method rather than the only one.
</p>
<p>The DANE functionality is provided by the <code>libgnutls-dane</code> library that is shipped
with GnuTLS and the function prototypes are in <code>gnutls/dane.h</code>. 
See <a href="#Certificate-verification">Certificate verification</a> for information on how to use the library.
</p>
<p>Note however, that the DANE RFC mandates the verification methods
one should use in addition to the validation via DNSSEC TLSA entries.
GnuTLS doesn&rsquo;t follow that RFC requirement, and the term DANE verification
in this manual refers to the TLSA entry verification. In GnuTLS any 
other verification methods can be used (e.g., PKIX or TOFU) on top of
DANE.
</p>
<hr>
<span id="Digital-signatures"></span><div class="header">
<p>
Previous: <a href="#Advanced-certificate-verification" accesskey="p" rel="prev">Advanced certificate verification</a>, Up: <a href="#Certificate-authentication" accesskey="u" rel="up">Certificate authentication</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Digital-signatures-1"></span><h4 class="subsection">4.1.5 Digital signatures</h4>
<span id="index-digital-signatures"></span>

<p>In this section we will provide some information about digital
signatures, how they work, and give the rationale for disabling some
of the algorithms used.
</p>
<p>Digital signatures work by using somebody&rsquo;s secret key to sign some
arbitrary data.  Then anybody else could use the public key of that
person to verify the signature.  Since the data may be arbitrary it is
not suitable input to a cryptographic digital signature algorithm. For
this reason and also for performance cryptographic hash algorithms are
used to preprocess the input to the signature algorithm. This works as
long as it is difficult enough to generate two different messages with
the same hash algorithm output. In that case the same signature could
be used as a proof for both messages. Nobody wants to sign an innocent
message of donating 1 euro to Greenpeace and find out that they
donated 1.000.000 euros to Bad Inc.
</p>
<p>For a hash algorithm to be called cryptographic the following three
requirements must hold:
</p>
<ol>
<li> Preimage resistance.
That means the algorithm must be one way and given the output of the
hash function <em>H(x)</em>, it is impossible to calculate <em>x</em>.

</li><li> 2nd preimage resistance.
That means that given a pair <em>x,y</em> with <em>y=H(x)</em> it is
impossible to calculate an <em>x'</em> such that <em>y=H(x')</em>.

</li><li> Collision resistance.
That means that it is impossible to calculate random <em>x</em> and
<em>x'</em> such <em>H(x')=H(x)</em>.
</li></ol>

<p>The last two requirements in the list are the most important in
digital signatures. These protect against somebody who would like to
generate two messages with the same hash output. When an algorithm is
considered broken usually it means that the Collision resistance of
the algorithm is less than brute force. Using the birthday paradox the
brute force attack takes
<em>2^{((hash size) / 2)}</em>
operations. Today colliding certificates using the MD5 hash algorithm
have been generated as shown in [<a href="#WEGER">WEGER</a>].
</p>
<p>There has been cryptographic results for the SHA-1 hash algorithms as
well, although they are not yet critical.  Before 2004, MD5 had a
presumed collision strength of <em>2^{64}</em>, but it has been showed
to have a collision strength well under <em>2^{50}</em>.  As of November
2005, it is believed that SHA-1&rsquo;s collision strength is around
<em>2^{63}</em>.  We consider this sufficiently hard so that we still
support SHA-1.  We anticipate that SHA-256/386/512 will be used in
publicly-distributed certificates in the future.  When <em>2^{63}</em>
can be considered too weak compared to the computer power available
sometime in the future, SHA-1 will be disabled as well.  The collision
attacks on SHA-1 may also get better, given the new interest in tools
for creating them.
</p>
<span id="Trading-security-for-interoperability"></span><h4 class="subsubsection">4.1.5.1 Trading security for interoperability</h4>

<p>If you connect to a server and use GnuTLS&rsquo; functions to verify the
certificate chain, and get a <code>GNUTLS_CERT_INSECURE_ALGORITHM</code>
validation error (see <a href="#Verifying-X_002e509-certificate-paths">Verifying X.509 certificate paths</a>), it means
that somewhere in the certificate chain there is a certificate signed
using <code>RSA-MD2</code> or <code>RSA-MD5</code>.  These two digital signature
algorithms are considered broken, so GnuTLS fails verifying
the certificate.  In some situations, it may be useful to be
able to verify the certificate chain anyway, assuming an attacker did
not utilize the fact that these signatures algorithms are broken.
This section will give help on how to achieve that.
</p>
<p>It is important to know that you do not have to enable any of
the flags discussed here to be able to use trusted root CA
certificates self-signed using <code>RSA-MD2</code> or <code>RSA-MD5</code>. The
certificates in the trusted list are considered trusted irrespective
of the signature.
</p>
<p>If you are using <a href="#gnutls_005fcertificate_005fverify_005fpeers3">gnutls_certificate_verify_peers3</a> to verify the
certificate chain, you can call
<a href="#gnutls_005fcertificate_005fset_005fverify_005fflags">gnutls_certificate_set_verify_flags</a> with the flags:
</p><ul>
<li> <code>GNUTLS_VERIFY_ALLOW_SIGN_RSA_MD2</code>
</li><li> <code>GNUTLS_VERIFY_ALLOW_SIGN_RSA_MD5</code>
</li><li> <code>GNUTLS_VERIFY_ALLOW_SIGN_WITH_SHA1</code>
</li><li> <code>GNUTLS_VERIFY_ALLOW_BROKEN</code>
</li></ul>
<p>as in the following example:
</p>
<div class="example">
<pre class="example">  gnutls_certificate_set_verify_flags (x509cred,
                                       GNUTLS_VERIFY_ALLOW_SIGN_RSA_MD5);
</pre></div>

<p>This will signal the verifier algorithm to enable <code>RSA-MD5</code> when
verifying the certificates.
</p>
<p>If you are using <a href="#gnutls_005fx509_005fcrt_005fverify">gnutls_x509_crt_verify</a> or
<a href="#gnutls_005fx509_005fcrt_005flist_005fverify">gnutls_x509_crt_list_verify</a>, you can pass the
<code>GNUTLS_VERIFY_ALLOW_SIGN_RSA_MD5</code> parameter directly in the
<code>flags</code> parameter.
</p>
<p>If you are using these flags, it may also be a good idea to warn the
user when verification failure occur for this reason.  The simplest is
to not use the flags by default, and only fall back to using them
after warning the user.  If you wish to inspect the certificate chain
yourself, you can use <a href="#gnutls_005fcertificate_005fget_005fpeers">gnutls_certificate_get_peers</a> to extract
the raw server&rsquo;s certificate chain, <a href="#gnutls_005fx509_005fcrt_005flist_005fimport">gnutls_x509_crt_list_import</a> to parse each of the certificates, and
then <a href="#gnutls_005fx509_005fcrt_005fget_005fsignature_005falgorithm">gnutls_x509_crt_get_signature_algorithm</a> to find out the
signing algorithm used for each certificate.  If any of the
intermediary certificates are using <code>GNUTLS_SIGN_RSA_MD2</code> or
<code>GNUTLS_SIGN_RSA_MD5</code>, you could present a warning.
</p>
<hr>
<span id="More-on-certificate-authentication"></span><div class="header">
<p>
Next: <a href="#Shared_002dkey-and-anonymous-authentication" accesskey="n" rel="next">Shared-key and anonymous authentication</a>, Previous: <a href="#Certificate-authentication" accesskey="p" rel="prev">Certificate authentication</a>, Up: <a href="#Authentication-methods" accesskey="u" rel="up">Authentication methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="More-on-certificate-authentication-1"></span><h3 class="section">4.2 More on certificate authentication</h3>
<span id="index-certificate-authentication-1"></span>

<p>Certificates are not the only structures involved in a public key
infrastructure. Several other structures that are used for certificate
requests, encrypted private keys, revocation lists, GnuTLS abstract key
structures, etc., are discussed in this chapter.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#PKCS-10-certificate-requests" accesskey="1">PKCS 10 certificate requests</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#PKIX-certificate-revocation-lists" accesskey="2">PKIX certificate revocation lists</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#OCSP-certificate-status-checking" accesskey="3">OCSP certificate status checking</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#OCSP-stapling" accesskey="4">OCSP stapling</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Managing-encrypted-keys" accesskey="5">Managing encrypted keys</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#certtool-Invocation" accesskey="6">certtool Invocation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Invoking certtool
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#ocsptool-Invocation" accesskey="7">ocsptool Invocation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Invoking ocsptool
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#danetool-Invocation" accesskey="8">danetool Invocation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Invoking danetool
</td></tr>
</table>

<hr>
<span id="PKCS-10-certificate-requests"></span><div class="header">
<p>
Next: <a href="#PKIX-certificate-revocation-lists" accesskey="n" rel="next">PKIX certificate revocation lists</a>, Up: <a href="#More-on-certificate-authentication" accesskey="u" rel="up">More on certificate authentication</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="PKCS-_002310-certificate-requests"></span><h4 class="subsection">4.2.1 <acronym>PKCS</acronym> #10 certificate requests</h4>
<span id="index-certificate-requests"></span>
<span id="index-PKCS-_002310"></span>

<p>A certificate request is a structure, which contain information about
an applicant of a certificate service.  It typically contains a public
key, a distinguished name and secondary data such as a challenge
password. <acronym>GnuTLS</acronym> supports the requests defined in
<acronym>PKCS</acronym> #10 [<a href="#RFC2986">RFC2986</a>]. Other formats of certificate requests
are not currently supported by GnuTLS.
</p>
<p>A certificate request can be generated by
associating it with a private key, setting the
subject&rsquo;s information and finally self signing it.
The last step ensures that the requester is in
possession of the private key.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrq_005fset_005fversion">gnutls_x509_crq_set_version</a> (gnutls_x509_crq_t <var>crq</var>, unsigned int <var>version</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrq_005fset_005fdn">gnutls_x509_crq_set_dn</a> (gnutls_x509_crq_t <var>crq</var>, const char * <var>dn</var>, const char ** <var>err</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrq_005fset_005fdn_005fby_005foid">gnutls_x509_crq_set_dn_by_oid</a> (gnutls_x509_crq_t <var>crq</var>, const char * <var>oid</var>, unsigned int <var>raw_flag</var>, const void * <var>data</var>, unsigned int <var>sizeof_data</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrq_005fset_005fkey_005fusage">gnutls_x509_crq_set_key_usage</a> (gnutls_x509_crq_t <var>crq</var>, unsigned int <var>usage</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrq_005fset_005fkey_005fpurpose_005foid">gnutls_x509_crq_set_key_purpose_oid</a> (gnutls_x509_crq_t <var>crq</var>, const void * <var>oid</var>, unsigned int <var>critical</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrq_005fset_005fbasic_005fconstraints">gnutls_x509_crq_set_basic_constraints</a> (gnutls_x509_crq_t <var>crq</var>, unsigned int <var>ca</var>, int <var>pathLenConstraint</var>)</code></dt>
</dl>

<p>The <a href="#gnutls_005fx509_005fcrq_005fset_005fkey">gnutls_x509_crq_set_key</a> and <a href="#gnutls_005fx509_005fcrq_005fsign2">gnutls_x509_crq_sign2</a> 
functions associate the request with a private key and sign it. If a 
request is to be signed with a key residing in a PKCS #11 token it is recommended to use
the signing functions shown in <a href="#Abstract-key-types">Abstract key types</a>.
</p>




<dl>
<dt id="index-gnutls_005fx509_005fcrq_005fset_005fkey">Function: <em>int</em> <strong>gnutls_x509_crq_set_key</strong> <em>(gnutls_x509_crq_t <var>crq</var>, gnutls_x509_privkey_t <var>key</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>key</var>: holds a private key
</p>
<p>This function will set the public parameters from the given private
key to the request.  
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>




<dl>
<dt id="index-gnutls_005fx509_005fcrq_005fsign2">Function: <em>int</em> <strong>gnutls_x509_crq_sign2</strong> <em>(gnutls_x509_crq_t <var>crq</var>, gnutls_x509_privkey_t <var>key</var>, gnutls_digest_algorithm_t <var>dig</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>key</var>: holds a private key
</p>
<p><var>dig</var>: The message digest to use, i.e., <code>GNUTLS_DIG_SHA256</code> 
</p>
<p><var>flags</var>: must be 0
</p>
<p>This function will sign the certificate request with a private key.
This must be the same key as the one used in
<code>gnutls_x509_crt_set_key()</code>  since a certificate request is self
signed.
</p>
<p>This must be the last step in a certificate request generation
since all the previously set parameters are now signed.
</p>
<p>A known limitation of this function is, that a newly-signed request will not
be fully functional (e.g., for signature verification), until it
is exported an re-imported.
</p>
<p>After GnuTLS 3.6.1 the value of  <code>dig</code> may be <code>GNUTLS_DIG_UNKNOWN</code> ,
and in that case, a suitable but reasonable for the key algorithm will be selected.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
<code>GNUTLS_E_ASN1_VALUE_NOT_FOUND</code>  is returned if you didn&rsquo;t set all
information in the certificate request (e.g., the version using
<code>gnutls_x509_crq_set_version()</code> ).
</p></dd></dl>

<p>The following example is about generating a certificate request, and a
private key. A certificate request can be later be processed by a CA
which should return a signed certificate.
</p>
<span id="ex_002dcrq"></span><pre class="verbatim">/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;gnutls/gnutls.h&gt;
#include &lt;gnutls/x509.h&gt;
#include &lt;gnutls/abstract.h&gt;
#include &lt;time.h&gt;

/* This example will generate a private key and a certificate
 * request.
 */

int main(void)
{
        gnutls_x509_crq_t crq;
        gnutls_x509_privkey_t key;
        unsigned char buffer[10 * 1024];
        size_t buffer_size = sizeof(buffer);
        unsigned int bits;

        gnutls_global_init();

        /* Initialize an empty certificate request, and
         * an empty private key.
         */
        gnutls_x509_crq_init(&amp;crq);

        gnutls_x509_privkey_init(&amp;key);

        /* Generate an RSA key of moderate security.
         */
        bits =
            gnutls_sec_param_to_pk_bits(GNUTLS_PK_RSA,
                                        GNUTLS_SEC_PARAM_MEDIUM);
        gnutls_x509_privkey_generate(key, GNUTLS_PK_RSA, bits, 0);

        /* Add stuff to the distinguished name
         */
        gnutls_x509_crq_set_dn_by_oid(crq, GNUTLS_OID_X520_COUNTRY_NAME,
                                      0, &quot;GR&quot;, 2);

        gnutls_x509_crq_set_dn_by_oid(crq, GNUTLS_OID_X520_COMMON_NAME,
                                      0, &quot;Nikos&quot;, strlen(&quot;Nikos&quot;));

        /* Set the request version.
         */
        gnutls_x509_crq_set_version(crq, 1);

        /* Set a challenge password.
         */
        gnutls_x509_crq_set_challenge_password(crq,
                                               &quot;something to remember here&quot;);

        /* Associate the request with the private key
         */
        gnutls_x509_crq_set_key(crq, key);

        /* Self sign the certificate request.
         */
        gnutls_x509_crq_sign2(crq, key, GNUTLS_DIG_SHA1, 0);

        /* Export the PEM encoded certificate request, and
         * display it.
         */
        gnutls_x509_crq_export(crq, GNUTLS_X509_FMT_PEM, buffer,
                               &amp;buffer_size);

        printf(&quot;Certificate Request: \n%s&quot;, buffer);


        /* Export the PEM encoded private key, and
         * display it.
         */
        buffer_size = sizeof(buffer);
        gnutls_x509_privkey_export(key, GNUTLS_X509_FMT_PEM, buffer,
                                   &amp;buffer_size);

        printf(&quot;\n\nPrivate key: \n%s&quot;, buffer);

        gnutls_x509_crq_deinit(crq);
        gnutls_x509_privkey_deinit(key);

        return 0;

}
</pre>
<hr>
<span id="PKIX-certificate-revocation-lists"></span><div class="header">
<p>
Next: <a href="#OCSP-certificate-status-checking" accesskey="n" rel="next">OCSP certificate status checking</a>, Previous: <a href="#PKCS-10-certificate-requests" accesskey="p" rel="prev">PKCS 10 certificate requests</a>, Up: <a href="#More-on-certificate-authentication" accesskey="u" rel="up">More on certificate authentication</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="PKIX-certificate-revocation-lists-1"></span><h4 class="subsection">4.2.2 PKIX certificate revocation lists</h4>
<span id="index-certificate-revocation-lists"></span>
<span id="index-CRL"></span>

<p>A certificate revocation list (CRL) is a structure issued by an authority
periodically containing a list of revoked certificates serial numbers.
The CRL structure is signed with the issuing authorities&rsquo; keys. A typical
CRL contains the fields as shown in <a href="#tab_003acrl">Table 4.5</a>.
Certificate revocation lists are used to complement the expiration date of a certificate,
in order to account for other reasons of revocation, such as compromised keys, etc.
</p>
<p>Each CRL is valid for limited amount of
time and is required to provide, except for the current issuing time, also 
the issuing time of the next update.
</p>
<div class="float"><span id="tab_003acrl"></span>
<table>
<thead><tr><th width="20%">Field</th><th width="70%">Description</th></tr></thead>
<tr><td width="20%">version</td><td width="70%">The field that indicates the version of the CRL structure.</td></tr>
<tr><td width="20%">signature</td><td width="70%">A signature by the issuing authority.</td></tr>
<tr><td width="20%">issuer</td><td width="70%">Holds the issuer&rsquo;s distinguished name.</td></tr>
<tr><td width="20%">thisUpdate</td><td width="70%">The issuing time of the revocation list.</td></tr>
<tr><td width="20%">nextUpdate</td><td width="70%">The issuing time of the revocation list that will update that one.</td></tr>
<tr><td width="20%">revokedCertificates</td><td width="70%">List of revoked certificates serial numbers.</td></tr>
<tr><td width="20%">extensions</td><td width="70%">Optional CRL structure extensions.</td></tr>
</table>

<div class="float-caption"><p><strong>Table 4.5: </strong>Certificate revocation list fields.</p></div></div>
<p>The basic CRL structure functions follow.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrl_005finit">gnutls_x509_crl_init</a> (gnutls_x509_crl_t * <var>crl</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrl_005fimport">gnutls_x509_crl_import</a> (gnutls_x509_crl_t <var>crl</var>, const gnutls_datum_t * <var>data</var>, gnutls_x509_crt_fmt_t <var>format</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrl_005fexport">gnutls_x509_crl_export</a> (gnutls_x509_crl_t <var>crl</var>, gnutls_x509_crt_fmt_t <var>format</var>, void * <var>output_data</var>, size_t * <var>output_data_size</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrl_005fexport">gnutls_x509_crl_export</a> (gnutls_x509_crl_t <var>crl</var>, gnutls_x509_crt_fmt_t <var>format</var>, void * <var>output_data</var>, size_t * <var>output_data_size</var>)</code></dt>
</dl>

<span id="Reading-a-CRL"></span><h4 class="subsubheading">Reading a CRL</h4>

<p>The most important function that extracts the certificate revocation
information from a CRL is <a href="#gnutls_005fx509_005fcrl_005fget_005fcrt_005fserial">gnutls_x509_crl_get_crt_serial</a>. Other
functions that return other fields of the CRL structure are also provided.
</p>




<dl>
<dt id="index-gnutls_005fx509_005fcrl_005fget_005fcrt_005fserial">Function: <em>int</em> <strong>gnutls_x509_crl_get_crt_serial</strong> <em>(gnutls_x509_crl_t <var>crl</var>, unsigned <var>indx</var>, unsigned char * <var>serial</var>, size_t * <var>serial_size</var>, time_t * <var>t</var>)</em></dt>
<dd><p><var>crl</var>: should contain a <code>gnutls_x509_crl_t</code>  type
</p>
<p><var>indx</var>: the index of the certificate to extract (starting from 0)
</p>
<p><var>serial</var>: where the serial number will be copied
</p>
<p><var>serial_size</var>: initially holds the size of serial
</p>
<p><var>t</var>: if non null, will hold the time this certificate was revoked
</p>
<p>This function will retrieve the serial number of the specified, by
the index, revoked certificate.
</p>
<p>Note that this function will have performance issues in large sequences
of revoked certificates. In that case use <code>gnutls_x509_crl_iter_crt_serial()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrl_005fget_005fversion">gnutls_x509_crl_get_version</a> (gnutls_x509_crl_t <var>crl</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrl_005fget_005fissuer_005fdn">gnutls_x509_crl_get_issuer_dn</a> (gnutls_x509_crl_t <var>crl</var>, char * <var>buf</var>, size_t * <var>sizeof_buf</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrl_005fget_005fissuer_005fdn2">gnutls_x509_crl_get_issuer_dn2</a> (gnutls_x509_crl_t <var>crl</var>, gnutls_datum_t * <var>dn</var>)</code></dt>
<dt><code><var>time_t</var> <a href="#gnutls_005fx509_005fcrl_005fget_005fthis_005fupdate">gnutls_x509_crl_get_this_update</a> (gnutls_x509_crl_t <var>crl</var>)</code></dt>
<dt><code><var>time_t</var> <a href="#gnutls_005fx509_005fcrl_005fget_005fnext_005fupdate">gnutls_x509_crl_get_next_update</a> (gnutls_x509_crl_t <var>crl</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrl_005fget_005fcrt_005fcount">gnutls_x509_crl_get_crt_count</a> (gnutls_x509_crl_t <var>crl</var>)</code></dt>
</dl>

<span id="Generation-of-a-CRL"></span><h4 class="subsubheading">Generation of a CRL</h4>

<p>The following functions can be used to generate a CRL.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrl_005fset_005fversion">gnutls_x509_crl_set_version</a> (gnutls_x509_crl_t <var>crl</var>, unsigned int <var>version</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrl_005fset_005fcrt_005fserial">gnutls_x509_crl_set_crt_serial</a> (gnutls_x509_crl_t <var>crl</var>, const void * <var>serial</var>, size_t <var>serial_size</var>, time_t <var>revocation_time</var>)</code></dt>
</dl>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrl_005fset_005fcrt">gnutls_x509_crl_set_crt</a> (gnutls_x509_crl_t <var>crl</var>, gnutls_x509_crt_t <var>crt</var>, time_t <var>revocation_time</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrl_005fset_005fnext_005fupdate">gnutls_x509_crl_set_next_update</a> (gnutls_x509_crl_t <var>crl</var>, time_t <var>exp_time</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrl_005fset_005fthis_005fupdate">gnutls_x509_crl_set_this_update</a> (gnutls_x509_crl_t <var>crl</var>, time_t <var>act_time</var>)</code></dt>
</dl>

<p>The <a href="#gnutls_005fx509_005fcrl_005fsign2">gnutls_x509_crl_sign2</a> and <a href="#gnutls_005fx509_005fcrl_005fprivkey_005fsign">gnutls_x509_crl_privkey_sign</a> 
functions sign the revocation list with a private key. The latter function
can be used to sign with a key residing in a PKCS #11 token.
</p>




<dl>
<dt id="index-gnutls_005fx509_005fcrl_005fsign2">Function: <em>int</em> <strong>gnutls_x509_crl_sign2</strong> <em>(gnutls_x509_crl_t <var>crl</var>, gnutls_x509_crt_t <var>issuer</var>, gnutls_x509_privkey_t <var>issuer_key</var>, gnutls_digest_algorithm_t <var>dig</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>crl</var>: should contain a gnutls_x509_crl_t type
</p>
<p><var>issuer</var>: is the certificate of the certificate issuer
</p>
<p><var>issuer_key</var>: holds the issuer&rsquo;s private key
</p>
<p><var>dig</var>: The message digest to use. GNUTLS_DIG_SHA256 is the safe choice unless you know what you&rsquo;re doing.
</p>
<p><var>flags</var>: must be 0
</p>
<p>This function will sign the CRL with the issuer&rsquo;s private key, and
will copy the issuer&rsquo;s information into the CRL.
</p>
<p>This must be the last step in a certificate CRL since all
the previously set parameters are now signed.
</p>
<p>A known limitation of this function is, that a newly-signed CRL will not
be fully functional (e.g., for signature verification), until it
is exported an re-imported.
</p>
<p>After GnuTLS 3.6.1 the value of  <code>dig</code> may be <code>GNUTLS_DIG_UNKNOWN</code> ,
and in that case, a suitable but reasonable for the key algorithm will be selected.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>




<dl>
<dt id="index-gnutls_005fx509_005fcrl_005fprivkey_005fsign">Function: <em>int</em> <strong>gnutls_x509_crl_privkey_sign</strong> <em>(gnutls_x509_crl_t <var>crl</var>, gnutls_x509_crt_t <var>issuer</var>, gnutls_privkey_t <var>issuer_key</var>, gnutls_digest_algorithm_t <var>dig</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>crl</var>: should contain a gnutls_x509_crl_t type
</p>
<p><var>issuer</var>: is the certificate of the certificate issuer
</p>
<p><var>issuer_key</var>: holds the issuer&rsquo;s private key
</p>
<p><var>dig</var>: The message digest to use. GNUTLS_DIG_SHA256 is the safe choice unless you know what you&rsquo;re doing.
</p>
<p><var>flags</var>: must be 0
</p>
<p>This function will sign the CRL with the issuer&rsquo;s private key, and
will copy the issuer&rsquo;s information into the CRL.
</p>
<p>This must be the last step in a certificate CRL since all
the previously set parameters are now signed.
</p>
<p>A known limitation of this function is, that a newly-signed CRL will not
be fully functional (e.g., for signature verification), until it
is exported an re-imported.
</p>
<p>After GnuTLS 3.6.1 the value of  <code>dig</code> may be <code>GNUTLS_DIG_UNKNOWN</code> ,
and in that case, a suitable but reasonable for the key algorithm will be selected.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p>Since 2.12.0
</p></dd></dl>

<p>Few extensions on the CRL structure are supported, including the
CRL number extension and the authority key identifier.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrl_005fset_005fnumber">gnutls_x509_crl_set_number</a> (gnutls_x509_crl_t <var>crl</var>, const void * <var>nr</var>, size_t <var>nr_size</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrl_005fset_005fauthority_005fkey_005fid">gnutls_x509_crl_set_authority_key_id</a> (gnutls_x509_crl_t <var>crl</var>, const void * <var>id</var>, size_t <var>id_size</var>)</code></dt>
</dl>

<hr>
<span id="OCSP-certificate-status-checking"></span><div class="header">
<p>
Next: <a href="#OCSP-stapling" accesskey="n" rel="next">OCSP stapling</a>, Previous: <a href="#PKIX-certificate-revocation-lists" accesskey="p" rel="prev">PKIX certificate revocation lists</a>, Up: <a href="#More-on-certificate-authentication" accesskey="u" rel="up">More on certificate authentication</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="OCSP-certificate-status-checking-1"></span><h4 class="subsection">4.2.3 <acronym>OCSP</acronym> certificate status checking</h4>
<span id="index-certificate-status"></span>
<span id="index-Online-Certificate-Status-Protocol"></span>
<span id="index-OCSP"></span>

<p>Certificates may be revoked before their expiration time has been
reached.  There are several reasons for revoking certificates, but a
typical situation is when the private key associated with a
certificate has been compromised.  Traditionally, Certificate
Revocation Lists (CRLs) have been used by application to implement
revocation checking, however, several problems with CRLs have been
identified [<a href="#RIVESTCRL">RIVESTCRL</a>].
</p>
<p>The Online Certificate Status Protocol, or <acronym>OCSP</acronym> [<a href="#RFC2560">RFC2560</a>], 
is a widely implemented protocol which performs certificate revocation status
checking.  An application that wish to verify the
identity of a peer will verify the certificate against a set of
trusted certificates and then check whether the certificate is listed
in a CRL and/or perform an OCSP check for the certificate.
</p>
<p>Applications are typically expected to contact the OCSP server in order to
request the certificate validity status. The OCSP server replies with an OCSP
response. This section describes this online communication (which can be avoided
when using OCSP stapled responses, for that, see <a href="#OCSP-stapling">OCSP stapling</a>).
</p>
<p>Before performing the OCSP query, the application will need to figure
out the address of the OCSP server.  The OCSP server address can be
provided by the local user in manual configuration or may be stored
in the certificate that is being checked.  When stored in a certificate
the OCSP server is in the extension field called the Authority Information 
Access (AIA). The following function
extracts this information from a certificate.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrt_005fget_005fauthority_005finfo_005faccess">gnutls_x509_crt_get_authority_info_access</a> (gnutls_x509_crt_t <var>crt</var>, unsigned int <var>seq</var>, int <var>what</var>, gnutls_datum_t * <var>data</var>, unsigned int * <var>critical</var>)</code></dt>
</dl>

<p>There are several functions in GnuTLS for creating and manipulating
OCSP requests and responses.  The general idea is that a client
application creates an OCSP request object, stores some information
about the certificate to check in the request, and then exports the
request in DER format.  The request will then need to be sent to the
OCSP responder, which needs to be done by the application (GnuTLS does
not send and receive OCSP packets).  Normally an OCSP response is
received that the application will need to import into an OCSP
response object.  The digital signature in the OCSP response needs to
be verified against a set of trust anchors before the information in
the response can be trusted.
</p>
<p>The ASN.1 structure of OCSP requests are briefly as follows.  It is
useful to review the structures to get an understanding of which
fields are modified by GnuTLS functions.
</p>
<div class="example">
<pre class="example">OCSPRequest     ::=     SEQUENCE {
    tbsRequest                  TBSRequest,
    optionalSignature   [0]     EXPLICIT Signature OPTIONAL }

TBSRequest      ::=     SEQUENCE {
    version             [0]     EXPLICIT Version DEFAULT v1,
    requestorName       [1]     EXPLICIT GeneralName OPTIONAL,
    requestList                 SEQUENCE OF Request,
    requestExtensions   [2]     EXPLICIT Extensions OPTIONAL }

Request         ::=     SEQUENCE {
    reqCert                     CertID,
    singleRequestExtensions     [0] EXPLICIT Extensions OPTIONAL }

CertID          ::=     SEQUENCE {
    hashAlgorithm       AlgorithmIdentifier,
    issuerNameHash      OCTET STRING, -- Hash of Issuer's DN
    issuerKeyHash       OCTET STRING, -- Hash of Issuers public key
    serialNumber        CertificateSerialNumber }
</pre></div>

<p>The basic functions to initialize, import, export and deallocate OCSP
requests are the following.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005focsp_005freq_005finit">gnutls_ocsp_req_init</a> (gnutls_ocsp_req_t * <var>req</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005focsp_005freq_005fdeinit">gnutls_ocsp_req_deinit</a> (gnutls_ocsp_req_t <var>req</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005focsp_005freq_005fimport">gnutls_ocsp_req_import</a> (gnutls_ocsp_req_t <var>req</var>, const gnutls_datum_t * <var>data</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005focsp_005freq_005fexport">gnutls_ocsp_req_export</a> (gnutls_ocsp_req_t <var>req</var>, gnutls_datum_t * <var>data</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005focsp_005freq_005fprint">gnutls_ocsp_req_print</a> (gnutls_ocsp_req_t <var>req</var>, gnutls_ocsp_print_formats_t <var>format</var>, gnutls_datum_t * <var>out</var>)</code></dt>
</dl>

<p>To generate an OCSP request the issuer name hash, issuer key hash, and 
the checked certificate&rsquo;s serial number are required. There are two
interfaces available for setting those in an OCSP request.
The is a low-level function when you have the
issuer name hash, issuer key hash, and certificate serial number in
binary form.  The second is more useful if you have the
certificate (and its issuer) in a <code>gnutls_x509_crt_t</code> type.
There is also a function to extract this information from existing an OCSP
request.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005focsp_005freq_005fadd_005fcert_005fid">gnutls_ocsp_req_add_cert_id</a> (gnutls_ocsp_req_t <var>req</var>, gnutls_digest_algorithm_t <var>digest</var>, const gnutls_datum_t * <var>issuer_name_hash</var>, const gnutls_datum_t * <var>issuer_key_hash</var>, const gnutls_datum_t * <var>serial_number</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005focsp_005freq_005fadd_005fcert">gnutls_ocsp_req_add_cert</a> (gnutls_ocsp_req_t <var>req</var>, gnutls_digest_algorithm_t <var>digest</var>, gnutls_x509_crt_t <var>issuer</var>, gnutls_x509_crt_t <var>cert</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005focsp_005freq_005fget_005fcert_005fid">gnutls_ocsp_req_get_cert_id</a> (gnutls_ocsp_req_t <var>req</var>, unsigned <var>indx</var>, gnutls_digest_algorithm_t * <var>digest</var>, gnutls_datum_t * <var>issuer_name_hash</var>, gnutls_datum_t * <var>issuer_key_hash</var>, gnutls_datum_t * <var>serial_number</var>)</code></dt>
</dl>

<p>Each OCSP request may contain a number of extensions.  Extensions are
identified by an Object Identifier (OID) and an opaque data buffer
whose syntax and semantics is implied by the OID. You can extract or
set those extensions using the following functions.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005focsp_005freq_005fget_005fextension">gnutls_ocsp_req_get_extension</a> (gnutls_ocsp_req_t <var>req</var>, unsigned <var>indx</var>, gnutls_datum_t * <var>oid</var>, unsigned int * <var>critical</var>, gnutls_datum_t * <var>data</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005focsp_005freq_005fset_005fextension">gnutls_ocsp_req_set_extension</a> (gnutls_ocsp_req_t <var>req</var>, const char * <var>oid</var>, unsigned int <var>critical</var>, const gnutls_datum_t * <var>data</var>)</code></dt>
</dl>

<p>A common OCSP Request extension is the nonce extension (OID
1.3.6.1.5.5.7.48.1.2), which is used to avoid replay attacks of
earlier recorded OCSP responses.  The nonce extension carries a value
that is intended to be sufficiently random and unique so that an
attacker will not be able to give a stale response for the same nonce.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005focsp_005freq_005fget_005fnonce">gnutls_ocsp_req_get_nonce</a> (gnutls_ocsp_req_t <var>req</var>, unsigned int * <var>critical</var>, gnutls_datum_t * <var>nonce</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005focsp_005freq_005fset_005fnonce">gnutls_ocsp_req_set_nonce</a> (gnutls_ocsp_req_t <var>req</var>, unsigned int <var>critical</var>, const gnutls_datum_t * <var>nonce</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005focsp_005freq_005frandomize_005fnonce">gnutls_ocsp_req_randomize_nonce</a> (gnutls_ocsp_req_t <var>req</var>)</code></dt>
</dl>

<p>The OCSP response structures is a complex structure. A simplified overview
of it is in <a href="#tab_003aocsp_002dresponse">Table 4.6</a>. Note that a response may contain 
information on multiple certificates.
</p>
<div class="float"><span id="tab_003aocsp_002dresponse"></span>
<table>
<thead><tr><th width="20%">Field</th><th width="70%">Description</th></tr></thead>
<tr><td width="20%">version</td><td width="70%">The OCSP response version number (typically 1).</td></tr>
<tr><td width="20%">responder ID</td><td width="70%">An identifier of the responder (DN name or a hash of its key).</td></tr>
<tr><td width="20%">issue time</td><td width="70%">The time the response was generated.</td></tr>
<tr><td width="20%">thisUpdate</td><td width="70%">The issuing time of the revocation information.</td></tr>
<tr><td width="20%">nextUpdate</td><td width="70%">The issuing time of the revocation information that will update that one.</td></tr>
<tr><td width="20%"></td><td width="70%">Revoked certificates</td></tr>
<tr><td width="20%">certificate status</td><td width="70%">The status of the certificate.</td></tr>
<tr><td width="20%">certificate serial</td><td width="70%">The certificate&rsquo;s serial number.</td></tr>
<tr><td width="20%">revocationTime</td><td width="70%">The time the certificate was revoked.</td></tr>
<tr><td width="20%">revocationReason</td><td width="70%">The reason the certificate was revoked.</td></tr>
</table>

<div class="float-caption"><p><strong>Table 4.6: </strong>The most important OCSP response fields.</p></div></div>

<p>We provide basic functions for initialization, importing, exporting
and deallocating OCSP responses.  
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005focsp_005fresp_005finit">gnutls_ocsp_resp_init</a> (gnutls_ocsp_resp_t * <var>resp</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005focsp_005fresp_005fdeinit">gnutls_ocsp_resp_deinit</a> (gnutls_ocsp_resp_t <var>resp</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005focsp_005fresp_005fimport">gnutls_ocsp_resp_import</a> (gnutls_ocsp_resp_t <var>resp</var>, const gnutls_datum_t * <var>data</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005focsp_005fresp_005fexport">gnutls_ocsp_resp_export</a> (gnutls_ocsp_resp_t <var>resp</var>, gnutls_datum_t * <var>data</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005focsp_005fresp_005fprint">gnutls_ocsp_resp_print</a> (gnutls_ocsp_resp_t <var>resp</var>, gnutls_ocsp_print_formats_t <var>format</var>, gnutls_datum_t * <var>out</var>)</code></dt>
</dl>

<p>The utility function that extracts the revocation as well as other information
from a response is shown below.
</p>




<dl>
<dt id="index-gnutls_005focsp_005fresp_005fget_005fsingle">Function: <em>int</em> <strong>gnutls_ocsp_resp_get_single</strong> <em>(gnutls_ocsp_resp_t <var>resp</var>, unsigned <var>indx</var>, gnutls_digest_algorithm_t * <var>digest</var>, gnutls_datum_t * <var>issuer_name_hash</var>, gnutls_datum_t * <var>issuer_key_hash</var>, gnutls_datum_t * <var>serial_number</var>, unsigned int * <var>cert_status</var>, time_t * <var>this_update</var>, time_t * <var>next_update</var>, time_t * <var>revocation_time</var>, unsigned int * <var>revocation_reason</var>)</em></dt>
<dd><p><var>resp</var>: should contain a <code>gnutls_ocsp_resp_t</code>  type
</p>
<p><var>indx</var>: Specifies response number to get. Use (0) to get the first one.
</p>
<p><var>digest</var>: output variable with <code>gnutls_digest_algorithm_t</code>  hash algorithm
</p>
<p><var>issuer_name_hash</var>: output buffer with hash of issuer&rsquo;s DN
</p>
<p><var>issuer_key_hash</var>: output buffer with hash of issuer&rsquo;s public key
</p>
<p><var>serial_number</var>: output buffer with serial number of certificate to check
</p>
<p><var>cert_status</var>: a certificate status, a <code>gnutls_ocsp_cert_status_t</code>  enum.
</p>
<p><var>this_update</var>: time at which the status is known to be correct.
</p>
<p><var>next_update</var>: when newer information will be available, or (time_t)-1 if unspecified
</p>
<p><var>revocation_time</var>: when  <code>cert_status</code> is <code>GNUTLS_OCSP_CERT_REVOKED</code> , holds time of revocation.
</p>
<p><var>revocation_reason</var>: revocation reason, a <code>gnutls_x509_crl_reason_t</code>  enum.
</p>
<p>This function will return the certificate information of the
 <code>indx</code> &rsquo;ed response in the Basic OCSP Response  <code>resp</code> .  The
information returned corresponds to the OCSP SingleResponse structure
except the final singleExtensions.
</p>
<p>Each of the pointers to output variables may be NULL to indicate
that the caller is not interested in that value.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error code is returned.  If you have reached the last
CertID available <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  will be
returned.
</p></dd></dl>

<p>The possible revocation reasons available in an OCSP response are shown
below.
</p>
<div class="float"><span id="gnutls_005fx509_005fcrl_005freason_005ft"></span>


<dl compact="compact">
<dt><code>GNUTLS_X509_CRLREASON_UNSPECIFIED</code></dt>
<dd><p>Unspecified reason.
</p></dd>
<dt><code>GNUTLS_X509_CRLREASON_KEYCOMPROMISE</code></dt>
<dd><p>Private key compromised.
</p></dd>
<dt><code>GNUTLS_X509_CRLREASON_CACOMPROMISE</code></dt>
<dd><p>CA compromised.
</p></dd>
<dt><code>GNUTLS_X509_CRLREASON_AFFILIATIONCHANGED</code></dt>
<dd><p>Affiliation has changed.
</p></dd>
<dt><code>GNUTLS_X509_CRLREASON_SUPERSEDED</code></dt>
<dd><p>Certificate superseded.
</p></dd>
<dt><code>GNUTLS_X509_CRLREASON_CESSATIONOFOPERATION</code></dt>
<dd><p>Operation has ceased.
</p></dd>
<dt><code>GNUTLS_X509_CRLREASON_CERTIFICATEHOLD</code></dt>
<dd><p>Certificate is on hold.
</p></dd>
<dt><code>GNUTLS_X509_CRLREASON_REMOVEFROMCRL</code></dt>
<dd><p>Will be removed from delta CRL.
</p></dd>
<dt><code>GNUTLS_X509_CRLREASON_PRIVILEGEWITHDRAWN</code></dt>
<dd><p>Privilege withdrawn.
</p></dd>
<dt><code>GNUTLS_X509_CRLREASON_AACOMPROMISE</code></dt>
<dd><p>AA compromised.
</p></dd>
</dl>

<div class="float-caption"><p><strong>Figure 4.4: </strong>The revocation reasons</p></div></div>
<p>Note, that the OCSP response needs to be verified against some set of trust
anchors before it can be relied upon. It is also important to check
whether the received OCSP response corresponds to the certificate being checked.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005focsp_005fresp_005fverify">gnutls_ocsp_resp_verify</a> (gnutls_ocsp_resp_t <var>resp</var>, gnutls_x509_trust_list_t <var>trustlist</var>, unsigned int * <var>verify</var>, unsigned int <var>flags</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005focsp_005fresp_005fverify_005fdirect">gnutls_ocsp_resp_verify_direct</a> (gnutls_ocsp_resp_t <var>resp</var>, gnutls_x509_crt_t <var>issuer</var>, unsigned int * <var>verify</var>, unsigned int <var>flags</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005focsp_005fresp_005fcheck_005fcrt">gnutls_ocsp_resp_check_crt</a> (gnutls_ocsp_resp_t <var>resp</var>, unsigned int <var>indx</var>, gnutls_x509_crt_t <var>crt</var>)</code></dt>
</dl>

<hr>
<span id="OCSP-stapling"></span><div class="header">
<p>
Next: <a href="#Managing-encrypted-keys" accesskey="n" rel="next">Managing encrypted keys</a>, Previous: <a href="#OCSP-certificate-status-checking" accesskey="p" rel="prev">OCSP certificate status checking</a>, Up: <a href="#More-on-certificate-authentication" accesskey="u" rel="up">More on certificate authentication</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="OCSP-stapling-1"></span><h4 class="subsection">4.2.4 OCSP stapling</h4>
<span id="index-certificate-status-1"></span>
<span id="index-Online-Certificate-Status-Protocol-1"></span>
<span id="index-OCSP-stapling"></span>

<p>To avoid applications contacting the OCSP server directly, TLS servers
can provide a &quot;stapled&quot; OCSP response in the TLS handshake. That way
the client application needs to do nothing more. GnuTLS will automatically
consider the stapled OCSP response during the TLS certificate verification
(see <a href="#gnutls_005fcertificate_005fverify_005fpeers2">gnutls_certificate_verify_peers2</a>). To disable the automatic
OCSP verification the flag <code>GNUTLS_VERIFY_DISABLE_CRL_CHECKS</code> should be
specified to <a href="#gnutls_005fcertificate_005fset_005fverify_005fflags">gnutls_certificate_set_verify_flags</a>.
</p>
<p>Since GnuTLS 3.5.1 the client certificate verification will consider the [<a href="#RFC7633">RFC7633</a>]
OCSP-Must-staple certificate extension, and will consider it while checking for stapled
OCSP responses. If the extension is present and no OCSP staple is found, the certificate
verification will fail and the status code <code>GNUTLS_CERT_MISSING_OCSP_STATUS</code> will
returned from the verification function.
</p>
<p>Under TLS 1.2 only one stapled response can be sent by a server, the OCSP
response associated with the end-certificate. Under TLS 1.3 a server can
send multiple OCSP responses, typically one for each certificate in the
certificate chain. The following functions can be used by a client
application to retrieve the OCSP responses as sent by the server.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005focsp_005fstatus_005frequest_005fget">gnutls_ocsp_status_request_get</a> (gnutls_session_t <var>session</var>, gnutls_datum_t * <var>response</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005focsp_005fstatus_005frequest_005fget2">gnutls_ocsp_status_request_get2</a> (gnutls_session_t <var>session</var>, unsigned <var>idx</var>, gnutls_datum_t * <var>response</var>)</code></dt>
</dl>

<p>GnuTLS servers can provide OCSP responses to their clients using the following functions.
</p>
<dl compact="compact">
<dt><code><var>void</var> <a href="#gnutls_005fcertificate_005fset_005fretrieve_005ffunction3">gnutls_certificate_set_retrieve_function3</a> (gnutls_certificate_credentials_t <var>cred</var>, gnutls_certificate_retrieve_function3 * <var>func</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fcertificate_005fset_005focsp_005fstatus_005frequest_005ffile2">gnutls_certificate_set_ocsp_status_request_file2</a> (gnutls_certificate_credentials_t <var>sc</var>, const char * <var>response_file</var>, unsigned <var>idx</var>, gnutls_x509_crt_fmt_t <var>fmt</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005focsp_005fstatus_005frequest_005fis_005fchecked">gnutls_ocsp_status_request_is_checked</a> (gnutls_session_t <var>session</var>, unsigned int <var>flags</var>)</code></dt>
</dl>

<p>A server is expected to provide the relevant certificate&rsquo;s OCSP responses using
<a href="#gnutls_005fcertificate_005fset_005focsp_005fstatus_005frequest_005ffile2">gnutls_certificate_set_ocsp_status_request_file2</a>, and ensure a
periodic reload/renew of the credentials. An estimation of the OCSP responses
expiration can be obtained using the <a href="#gnutls_005fcertificate_005fget_005focsp_005fexpiration">gnutls_certificate_get_ocsp_expiration</a> function.
</p>




<dl>
<dt id="index-gnutls_005fcertificate_005fget_005focsp_005fexpiration">Function: <em>time_t</em> <strong>gnutls_certificate_get_ocsp_expiration</strong> <em>(gnutls_certificate_credentials_t <var>sc</var>, unsigned <var>idx</var>, int <var>oidx</var>, unsigned <var>flags</var>)</em></dt>
<dd><p><var>sc</var>: is a credentials structure.
</p>
<p><var>idx</var>: is a certificate chain index as returned by <code>gnutls_certificate_set_key()</code>  and friends
</p>
<p><var>oidx</var>: is an OCSP response index
</p>
<p><var>flags</var>: should be zero
</p>
<p>This function returns the validity of the loaded OCSP responses,
to provide information on when to reload/refresh them.
</p>
<p>Note that the credentials structure should be read-only when in
use, thus when reloading, either the credentials structure must not
be in use by any sessions, or a new credentials structure should be
allocated for new sessions.
</p>
<p>When  <code>oidx</code> is (-1) then the minimum refresh time for all responses
is returned. Otherwise the index specifies the response corresponding
to the  <code>odix</code> certificate in the certificate chain.
</p>
<p><strong>Returns:</strong> On success, the expiration time of the OCSP response. Otherwise
(time_t)(-1) on error, or (time_t)-2 on out of bounds.
</p>
<p><strong>Since:</strong> 3.6.3
</p></dd></dl>

<p>Prior to GnuTLS 3.6.4, the functions
<a href="#gnutls_005fcertificate_005fset_005focsp_005fstatus_005frequest_005ffunction2">gnutls_certificate_set_ocsp_status_request_function2</a>
<a href="#gnutls_005fcertificate_005fset_005focsp_005fstatus_005frequest_005ffile">gnutls_certificate_set_ocsp_status_request_file</a> were provided
to set OCSP responses. These functions are still functional, but cannot be used
to set multiple OCSP responses as allowed by TLS1.3.
</p>
<p>The responses can be updated periodically using the &rsquo;ocsptool&rsquo; command
(see also <a href="#ocsptool-Invocation">ocsptool Invocation</a>).
</p>
<div class="example">
<pre class="example">ocsptool --ask --load-cert server_cert.pem --load-issuer the_issuer.pem
         --load-signer the_issuer.pem --outfile ocsp.resp
</pre></div>

<p>In order to allow multiple OCSP responses to be concatenated, GnuTLS
supports PEM-encoded OCSP responses. These can be generated using
&rsquo;ocsptool&rsquo; with the &rsquo;&ndash;no-outder&rsquo; parameter.
</p>

<hr>
<span id="Managing-encrypted-keys"></span><div class="header">
<p>
Next: <a href="#certtool-Invocation" accesskey="n" rel="next">certtool Invocation</a>, Previous: <a href="#OCSP-stapling" accesskey="p" rel="prev">OCSP stapling</a>, Up: <a href="#More-on-certificate-authentication" accesskey="u" rel="up">More on certificate authentication</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Managing-encrypted-keys-1"></span><h4 class="subsection">4.2.5 Managing encrypted keys</h4>
<span id="index-Encrypted-keys"></span>

<p>Transferring or storing private keys in plain may not be a
good idea, since any compromise is irreparable.
Storing the keys in hardware security modules (see <a href="#Smart-cards-and-HSMs">Smart cards and HSMs</a>)
could solve the storage problem but it is not always practical
or efficient enough. This section describes ways to store and
transfer encrypted private keys.
</p>
<p>There are methods for key encryption, namely the
PKCS #8, PKCS #12 and OpenSSL&rsquo;s custom encrypted private key formats. 
The PKCS #8 and the OpenSSL&rsquo;s method allow encryption of the private key, 
while the PKCS #12 method allows, in addition, the bundling of accompanying 
data into the structure. That is typically the corresponding certificate, as 
well as a trusted CA certificate.
</p>
<span id="High-level-functionality"></span><h4 class="subsubheading">High level functionality</h4>
<p>Generic and higher level private key import functions are available, that
import plain or encrypted keys and will auto-detect the encrypted key format.
</p>




<dl>
<dt id="index-gnutls_005fprivkey_005fimport_005fx509_005fraw">Function: <em>int</em> <strong>gnutls_privkey_import_x509_raw</strong> <em>(gnutls_privkey_t <var>pkey</var>, const gnutls_datum_t * <var>data</var>, gnutls_x509_crt_fmt_t <var>format</var>, const char * <var>password</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>pkey</var>: The private key
</p>
<p><var>data</var>: The private key data to be imported
</p>
<p><var>format</var>: The format of the private key
</p>
<p><var>password</var>: A password (optional)
</p>
<p><var>flags</var>: an ORed sequence of gnutls_pkcs_encrypt_flags_t
</p>
<p>This function will import the given private key to the abstract
<code>gnutls_privkey_t</code>  type. 
</p>
<p>The supported formats are basic unencrypted key, PKCS8, PKCS12, 
and the openssl format.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.1.0
</p></dd></dl>





<dl>
<dt id="index-gnutls_005fx509_005fprivkey_005fimport2">Function: <em>int</em> <strong>gnutls_x509_privkey_import2</strong> <em>(gnutls_x509_privkey_t <var>key</var>, const gnutls_datum_t * <var>data</var>, gnutls_x509_crt_fmt_t <var>format</var>, const char * <var>password</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>key</var>: The data to store the parsed key
</p>
<p><var>data</var>: The DER or PEM encoded key.
</p>
<p><var>format</var>: One of DER or PEM
</p>
<p><var>password</var>: A password (optional)
</p>
<p><var>flags</var>: an ORed sequence of gnutls_pkcs_encrypt_flags_t
</p>
<p>This function will import the given DER or PEM encoded key, to 
the native <code>gnutls_x509_privkey_t</code>  format, irrespective of the
input format. The input format is auto-detected.
</p>
<p>The supported formats are basic unencrypted key, PKCS8, PKCS12,
and the openssl format.
</p>
<p>If the provided key is encrypted but no password was given, then
<code>GNUTLS_E_DECRYPTION_FAILED</code>  is returned. Since GnuTLS 3.4.0 this
function will utilize the PIN callbacks if any.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<p>Any keys imported using those functions can be imported to a certificate
credentials structure using <a href="#gnutls_005fcertificate_005fset_005fkey">gnutls_certificate_set_key</a>, or alternatively
they can be directly imported using <a href="#gnutls_005fcertificate_005fset_005fx509_005fkey_005ffile2">gnutls_certificate_set_x509_key_file2</a>.
</p>
<span id="PKCS-_00238-structures"></span><h4 class="subsubheading"><acronym>PKCS</acronym> #8 structures</h4>
<span id="index-PKCS-_00238"></span>

<p>PKCS #8 keys can be imported and exported as normal private keys using
the functions below. An addition to the normal import functions, are
a password and a flags argument. The flags can be any element of the <code>gnutls_pkcs_encrypt_flags_t</code>
enumeration. Note however, that GnuTLS only supports the PKCS #5 PBES2
encryption scheme. Keys encrypted with the obsolete PBES1 scheme cannot 
be decrypted.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fprivkey_005fimport_005fpkcs8">gnutls_x509_privkey_import_pkcs8</a> (gnutls_x509_privkey_t <var>key</var>, const gnutls_datum_t * <var>data</var>, gnutls_x509_crt_fmt_t <var>format</var>, const char * <var>password</var>, unsigned int <var>flags</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fprivkey_005fexport_005fpkcs8">gnutls_x509_privkey_export_pkcs8</a> (gnutls_x509_privkey_t <var>key</var>, gnutls_x509_crt_fmt_t <var>format</var>, const char * <var>password</var>, unsigned int <var>flags</var>, void * <var>output_data</var>, size_t * <var>output_data_size</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fprivkey_005fexport2_005fpkcs8">gnutls_x509_privkey_export2_pkcs8</a> (gnutls_x509_privkey_t <var>key</var>, gnutls_x509_crt_fmt_t <var>format</var>, const char * <var>password</var>, unsigned int <var>flags</var>, gnutls_datum_t * <var>out</var>)</code></dt>
</dl>

<div class="float"><span id="gnutls_005fpkcs_005fencrypt_005fflags_005ft"></span>


<dl compact="compact">
<dt><code>GNUTLS_PKCS_PLAIN</code></dt>
<dd><p>Unencrypted private key.
</p></dd>
<dt><code>GNUTLS_PKCS_PKCS12_3DES</code></dt>
<dd><p>PKCS-12 3DES.
</p></dd>
<dt><code>GNUTLS_PKCS_PKCS12_ARCFOUR</code></dt>
<dd><p>PKCS-12 ARCFOUR.
</p></dd>
<dt><code>GNUTLS_PKCS_PKCS12_RC2_40</code></dt>
<dd><p>PKCS-12 RC2-40.
</p></dd>
<dt><code>GNUTLS_PKCS_PBES2_3DES</code></dt>
<dd><p>PBES2 3DES.
</p></dd>
<dt><code>GNUTLS_PKCS_PBES2_AES_128</code></dt>
<dd><p>PBES2 AES-128.
</p></dd>
<dt><code>GNUTLS_PKCS_PBES2_AES_192</code></dt>
<dd><p>PBES2 AES-192.
</p></dd>
<dt><code>GNUTLS_PKCS_PBES2_AES_256</code></dt>
<dd><p>PBES2 AES-256.
</p></dd>
<dt><code>GNUTLS_PKCS_NULL_PASSWORD</code></dt>
<dd><p>Some schemas distinguish between an empty and a NULL password.
</p></dd>
<dt><code>GNUTLS_PKCS_PBES2_DES</code></dt>
<dd><p>PBES2 single DES.
</p></dd>
<dt><code>GNUTLS_PKCS_PBES1_DES_MD5</code></dt>
<dd><p>PBES1 with single DES; for compatibility with openssl only.
</p></dd>
<dt><code>GNUTLS_PKCS_PBES2_GOST_TC26Z</code></dt>
<dd><p>PBES2 GOST 28147-89 CFB with TC26-Z S-box.
</p></dd>
<dt><code>GNUTLS_PKCS_PBES2_GOST_CPA</code></dt>
<dd><p>PBES2 GOST 28147-89 CFB with CryptoPro-A S-box.
</p></dd>
<dt><code>GNUTLS_PKCS_PBES2_GOST_CPB</code></dt>
<dd><p>PBES2 GOST 28147-89 CFB with CryptoPro-B S-box.
</p></dd>
<dt><code>GNUTLS_PKCS_PBES2_GOST_CPC</code></dt>
<dd><p>PBES2 GOST 28147-89 CFB with CryptoPro-C S-box.
</p></dd>
<dt><code>GNUTLS_PKCS_PBES2_GOST_CPD</code></dt>
<dd><p>PBES2 GOST 28147-89 CFB with CryptoPro-D S-box.
</p></dd>
</dl>

<div class="float-caption"><p><strong>Figure 4.5: </strong>Encryption flags</p></div></div>
<span id="PKCS-_002312-structures"></span><h4 class="subsubheading"><acronym>PKCS</acronym> #12 structures</h4>
<span id="index-PKCS-_002312"></span>

<p>A <acronym>PKCS</acronym> #12 structure [<a href="#PKCS12">PKCS12</a>] usually contains a user&rsquo;s
private keys and certificates. It is commonly used in browsers to
export and import the user&rsquo;s identities. A file containing such a key can 
be directly imported to a certificate credentials structure by using 
<a href="#gnutls_005fcertificate_005fset_005fx509_005fsimple_005fpkcs12_005ffile">gnutls_certificate_set_x509_simple_pkcs12_file</a>.
</p>
<p>In <acronym>GnuTLS</acronym> the <acronym>PKCS</acronym> #12 structures are handled
using the <code>gnutls_pkcs12_t</code> type. This is an abstract type that
may hold several <code>gnutls_pkcs12_bag_t</code> types.  The bag types are
the holders of the actual data, which may be certificates, private
keys or encrypted data.  A bag of type encrypted should be decrypted
in order for its data to be accessed.
</p>
<p>To reduce the complexity in parsing the structures the simple 
helper function <a href="#gnutls_005fpkcs12_005fsimple_005fparse">gnutls_pkcs12_simple_parse</a> is provided. For more
advanced uses, manual parsing of the structure is required using the
functions below.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fpkcs12_005fget_005fbag">gnutls_pkcs12_get_bag</a> (gnutls_pkcs12_t <var>pkcs12</var>, int <var>indx</var>, gnutls_pkcs12_bag_t <var>bag</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpkcs12_005fverify_005fmac">gnutls_pkcs12_verify_mac</a> (gnutls_pkcs12_t <var>pkcs12</var>, const char * <var>pass</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpkcs12_005fbag_005fdecrypt">gnutls_pkcs12_bag_decrypt</a> (gnutls_pkcs12_bag_t <var>bag</var>, const char * <var>pass</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpkcs12_005fbag_005fget_005fcount">gnutls_pkcs12_bag_get_count</a> (gnutls_pkcs12_bag_t <var>bag</var>)</code></dt>
</dl>





<dl>
<dt id="index-gnutls_005fpkcs12_005fsimple_005fparse">Function: <em>int</em> <strong>gnutls_pkcs12_simple_parse</strong> <em>(gnutls_pkcs12_t <var>p12</var>, const char * <var>password</var>, gnutls_x509_privkey_t * <var>key</var>, gnutls_x509_crt_t ** <var>chain</var>, unsigned int * <var>chain_len</var>, gnutls_x509_crt_t ** <var>extra_certs</var>, unsigned int * <var>extra_certs_len</var>, gnutls_x509_crl_t * <var>crl</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>p12</var>: A pkcs12 type
</p>
<p><var>password</var>: optional password used to decrypt the structure, bags and keys.
</p>
<p><var>key</var>: a structure to store the parsed private key.
</p>
<p><var>chain</var>: the corresponding to key certificate chain (may be <code>NULL</code> )
</p>
<p><var>chain_len</var>: will be updated with the number of additional (may be <code>NULL</code> )
</p>
<p><var>extra_certs</var>: optional pointer to receive an array of additional
certificates found in the PKCS12 structure (may be <code>NULL</code> ).
</p>
<p><var>extra_certs_len</var>: will be updated with the number of additional
certs (may be <code>NULL</code> ).
</p>
<p><var>crl</var>: an optional structure to store the parsed CRL (may be <code>NULL</code> ).
</p>
<p><var>flags</var>: should be zero or one of GNUTLS_PKCS12_SP_*
</p>
<p>This function parses a PKCS12 structure in  <code>pkcs12</code> and extracts the
private key, the corresponding certificate chain, any additional
certificates and a CRL. The structures in  <code>key</code> ,  <code>chain</code>  <code>crl</code> , and  <code>extra_certs</code> must not be initialized.
</p>
<p>The  <code>extra_certs</code> and  <code>extra_certs_len</code> parameters are optional
and both may be set to <code>NULL</code> . If either is non-<code>NULL</code> , then both must
be set. The value for  <code>extra_certs</code> is allocated
using <code>gnutls_malloc()</code> .
</p>
<p>Encrypted PKCS12 bags and PKCS8 private keys are supported, but
only with password based security and the same password for all
operations.
</p>
<p>Note that a PKCS12 structure may contain many keys and/or certificates,
and there is no way to identify which key/certificate pair you want.
For this reason this function is useful for PKCS12 files that contain 
only one key/certificate pair and/or one CRL.
</p>
<p>If the provided structure has encrypted fields but no password
is provided then this function returns <code>GNUTLS_E_DECRYPTION_FAILED</code> .
</p>
<p>Note that normally the chain constructed does not include self signed
certificates, to comply with TLS&rsquo; requirements. If, however, the flag 
<code>GNUTLS_PKCS12_SP_INCLUDE_SELF_SIGNED</code>  is specified then
self signed certificates will be included in the chain.
</p>
<p>Prior to using this function the PKCS <code>12</code>  structure integrity must
be verified using <code>gnutls_pkcs12_verify_mac()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.1.0
</p></dd></dl>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fpkcs12_005fbag_005fget_005fdata">gnutls_pkcs12_bag_get_data</a> (gnutls_pkcs12_bag_t <var>bag</var>, unsigned <var>indx</var>, gnutls_datum_t * <var>data</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpkcs12_005fbag_005fget_005fkey_005fid">gnutls_pkcs12_bag_get_key_id</a> (gnutls_pkcs12_bag_t <var>bag</var>, unsigned <var>indx</var>, gnutls_datum_t * <var>id</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpkcs12_005fbag_005fget_005ffriendly_005fname">gnutls_pkcs12_bag_get_friendly_name</a> (gnutls_pkcs12_bag_t <var>bag</var>, unsigned <var>indx</var>, char ** <var>name</var>)</code></dt>
</dl>

<p>The functions below are used to generate a PKCS #12 structure. An example
of their usage is shown at <a href="#PKCS12-structure-generation-example">PKCS12 structure generation example</a>.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fpkcs12_005fset_005fbag">gnutls_pkcs12_set_bag</a> (gnutls_pkcs12_t <var>pkcs12</var>, gnutls_pkcs12_bag_t <var>bag</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpkcs12_005fbag_005fencrypt">gnutls_pkcs12_bag_encrypt</a> (gnutls_pkcs12_bag_t <var>bag</var>, const char * <var>pass</var>, unsigned int <var>flags</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpkcs12_005fgenerate_005fmac">gnutls_pkcs12_generate_mac</a> (gnutls_pkcs12_t <var>pkcs12</var>, const char * <var>pass</var>)</code></dt>
</dl>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fpkcs12_005fbag_005fset_005fdata">gnutls_pkcs12_bag_set_data</a> (gnutls_pkcs12_bag_t <var>bag</var>, gnutls_pkcs12_bag_type_t <var>type</var>, const gnutls_datum_t * <var>data</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpkcs12_005fbag_005fset_005fcrl">gnutls_pkcs12_bag_set_crl</a> (gnutls_pkcs12_bag_t <var>bag</var>, gnutls_x509_crl_t <var>crl</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpkcs12_005fbag_005fset_005fcrt">gnutls_pkcs12_bag_set_crt</a> (gnutls_pkcs12_bag_t <var>bag</var>, gnutls_x509_crt_t <var>crt</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpkcs12_005fbag_005fset_005fkey_005fid">gnutls_pkcs12_bag_set_key_id</a> (gnutls_pkcs12_bag_t <var>bag</var>, unsigned <var>indx</var>, const gnutls_datum_t * <var>id</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpkcs12_005fbag_005fset_005ffriendly_005fname">gnutls_pkcs12_bag_set_friendly_name</a> (gnutls_pkcs12_bag_t <var>bag</var>, unsigned <var>indx</var>, const char * <var>name</var>)</code></dt>
</dl>

<span id="OpenSSL-encrypted-keys"></span><h4 class="subsubheading">OpenSSL encrypted keys</h4>
<span id="index-OpenSSL-encrypted-keys"></span>
<p>Unfortunately the structures discussed in the previous sections are
not the only structures that may hold an encrypted private key. For example
the OpenSSL library offers a custom key encryption method. Those structures
are also supported in GnuTLS with <a href="#gnutls_005fx509_005fprivkey_005fimport_005fopenssl">gnutls_x509_privkey_import_openssl</a>.
</p>




<dl>
<dt id="index-gnutls_005fx509_005fprivkey_005fimport_005fopenssl">Function: <em>int</em> <strong>gnutls_x509_privkey_import_openssl</strong> <em>(gnutls_x509_privkey_t <var>key</var>, const gnutls_datum_t * <var>data</var>, const char * <var>password</var>)</em></dt>
<dd><p><var>key</var>: The data to store the parsed key
</p>
<p><var>data</var>: The DER or PEM encoded key.
</p>
<p><var>password</var>: the password to decrypt the key (if it is encrypted).
</p>
<p>This function will convert the given PEM encrypted to 
the native gnutls_x509_privkey_t format. The
output will be stored in  <code>key</code> .  
</p>
<p>The  <code>password</code> should be in ASCII. If the password is not provided
or wrong then <code>GNUTLS_E_DECRYPTION_FAILED</code>  will be returned.
</p>
<p>If the Certificate is PEM encoded it should have a header of
&quot;PRIVATE KEY&quot; and the &quot;DEK-Info&quot; header. 
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<hr>
<span id="certtool-Invocation"></span><div class="header">
<p>
Next: <a href="#ocsptool-Invocation" accesskey="n" rel="next">ocsptool Invocation</a>, Previous: <a href="#Managing-encrypted-keys" accesskey="p" rel="prev">Managing encrypted keys</a>, Up: <a href="#More-on-certificate-authentication" accesskey="u" rel="up">More on certificate authentication</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Invoking-certtool"></span><h4 class="subsection">4.2.6 Invoking certtool</h4>
<span id="index-certtool"></span>


<p>Tool to parse and generate X.509 certificates, requests and private keys.
It can be used interactively or non interactively by
specifying the template command line option.
</p>
<p>The tool accepts files or supported URIs via the &ndash;infile option. In case PIN
is required for URI access you can provide it using the environment variables GNUTLS_PIN 
and GNUTLS_SO_PIN.
</p>

<p>This section was generated by <strong>AutoGen</strong>,
using the <code>agtexi-cmd</code> template and the option descriptions for the <code>certtool</code> program.
This software is released under the GNU General Public License, version 3 or later.
</p>

<span id="certtool-usage"></span><span id="certtool-help_002fusage-_0028_002d_002dhelp_0029"></span><h4 class="subsubheading">certtool help/usage (<samp>--help</samp>)</h4>
<span id="index-certtool-help"></span>

<p>This is the automatically generated usage text for certtool.
</p>
<p>The text printed is the same whether selected with the <code>help</code> option
(<samp>--help</samp>) or the <code>more-help</code> option (<samp>--more-help</samp>).  <code>more-help</code> will print
the usage text by passing it through a pager program.
<code>more-help</code> is disabled on platforms without a working
<code>fork(2)</code> function.  The <code>PAGER</code> environment variable is
used to select the program, defaulting to <samp>more</samp>.  Both will exit
with a status code of 0.
</p>
<div class="example">
<pre class="example">certtool - GnuTLS certificate tool
Usage:  certtool [ -&lt;flag&gt; [&lt;val&gt;] | --&lt;name&gt;[{=| }&lt;val&gt;] ]...

   -d, --debug=num            Enable debugging
                                - it must be in the range:
                                  0 to 9999
   -V, --verbose              More verbose output
                                - may appear multiple times
       --infile=file          Input file
                                - file must pre-exist
       --outfile=str          Output file

Certificate related options:

   -i, --certificate-info     Print information on the given certificate
       --pubkey-info          Print information on a public key
   -s, --generate-self-signed  Generate a self-signed certificate
   -c, --generate-certificate  Generate a signed certificate
       --generate-proxy       Generates a proxy certificate
   -u, --update-certificate   Update a signed certificate
       --fingerprint          Print the fingerprint of the given certificate
       --key-id               Print the key ID of the given certificate
       --v1                   Generate an X.509 version 1 certificate (with no extensions)
       --sign-params=str      Sign a certificate with a specific signature algorithm

Certificate request related options:

       --crq-info             Print information on the given certificate request
   -q, --generate-request     Generate a PKCS #10 certificate request
                                - prohibits the option 'infile'
       --no-crq-extensions    Do not use extensions in certificate requests

PKCS#12 file related options:

       --p12-info             Print information on a PKCS #12 structure
       --p12-name=str         The PKCS #12 friendly name to use
       --to-p12               Generate a PKCS #12 structure

Private key related options:

   -k, --key-info             Print information on a private key
       --p8-info              Print information on a PKCS #8 structure
       --to-rsa               Convert an RSA-PSS key to raw RSA format
   -p, --generate-privkey     Generate a private key
       --key-type=str         Specify the key type to use on key generation
       --bits=num             Specify the number of bits for key generation
       --curve=str            Specify the curve used for EC key generation
       --sec-param=str        Specify the security level [low, legacy, medium, high, ultra]
       --to-p8                Convert a given key to a PKCS #8 structure
   -8, --pkcs8                Use PKCS #8 format for private keys
       --provable             Generate a private key or parameters from a seed using a provable method
       --verify-provable-privkey  Verify a private key generated from a seed using a provable method
       --seed=str             When generating a private key use the given hex-encoded seed

CRL related options:

   -l, --crl-info             Print information on the given CRL structure
       --generate-crl         Generate a CRL
       --verify-crl           Verify a Certificate Revocation List using a trusted list
                                - requires the option 'load-ca-certificate'

Certificate verification related options:

   -e, --verify-chain         Verify a PEM encoded certificate chain
       --verify               Verify a PEM encoded certificate (chain) against a trusted set
       --verify-hostname=str  Specify a hostname to be used for certificate chain verification
       --verify-email=str     Specify a email to be used for certificate chain verification
                                - prohibits the option 'verify-hostname'
       --verify-purpose=str   Specify a purpose OID to be used for certificate chain verification
       --verify-allow-broken  Allow broken algorithms, such as MD5 for verification

PKCS#7 structure options:

       --p7-generate          Generate a PKCS #7 structure
       --p7-sign              Signs using a PKCS #7 structure
       --p7-detached-sign     Signs using a detached PKCS #7 structure
       --p7-include-cert      The signer's certificate will be included in the cert list.
                                - disabled as '--no-p7-include-cert'
                                - enabled by default
       --p7-time              Will include a timestamp in the PKCS #7 structure
                                - disabled as '--no-p7-time'
       --p7-show-data         Will show the embedded data in the PKCS #7 structure
                                - disabled as '--no-p7-show-data'
       --p7-info              Print information on a PKCS #7 structure
       --p7-verify            Verify the provided PKCS #7 structure
       --smime-to-p7          Convert S/MIME to PKCS #7 structure

Other options:

       --get-dh-params        List the included PKCS #3 encoded Diffie-Hellman parameters
       --dh-info              Print information PKCS #3 encoded Diffie-Hellman parameters
       --load-privkey=str     Loads a private key file
       --load-pubkey=str      Loads a public key file
       --load-request=str     Loads a certificate request file
       --load-certificate=str Loads a certificate file
       --load-ca-privkey=str  Loads the certificate authority's private key file
       --load-ca-certificate=str Loads the certificate authority's certificate file
       --load-crl=str         Loads the provided CRL
       --load-data=str        Loads auxiliary data
       --password=str         Password to use
       --null-password        Enforce a NULL password
       --empty-password       Enforce an empty password
       --hex-numbers          Print big number in an easier format to parse
       --cprint               In certain operations it prints the information in C-friendly format
       --hash=str             Hash algorithm to use for signing
       --salt-size=num        Specify the RSA-PSS key default salt size
       --inder                Use DER format for input certificates, private keys, and DH parameters
                                - disabled as '--no-inder'
       --inraw                an alias for the 'inder' option
       --outder               Use DER format for output certificates, private keys, and DH parameters
                                - disabled as '--no-outder'
       --outraw               an alias for the 'outder' option
       --template=str         Template file to use for non-interactive operation
       --stdout-info          Print information to stdout instead of stderr
       --ask-pass             Enable interaction for entering password when in batch mode.
       --pkcs-cipher=str      Cipher to use for PKCS #8 and #12 operations
       --provider=str         Specify the PKCS #11 provider library
       --text                 Output textual information before PEM-encoded certificates, private
keys, etc
                                - disabled as '--no-text'
                                - enabled by default

Version, usage and configuration options:

   -v, --version[=arg]        output version information and exit
   -h, --help                 display extended usage information and exit
   -!, --more-help            extended usage information passed thru pager

Options are specified by doubled hyphens and their name or by a single
hyphen and the flag character.

Tool to parse and generate X.509 certificates, requests and private keys.
It can be used interactively or non interactively by specifying the
template command line option.

The tool accepts files or supported URIs via the --infile option.  In case
PIN is required for URI access you can provide it using the environment
variables GNUTLS_PIN and GNUTLS_SO_PIN.

</pre></div>

<span id="certtool"></span><span id="Base-options"></span><h4 class="subsubheading">Base options</h4>
<span id="debug-option-_0028_002dd_0029_002e"></span><h4 class="subsubheading">debug option (-d).</h4>
<span id="certtool-debug"></span>
<p>This is the &ldquo;enable debugging&rdquo; option.
This option takes a number argument.
Specifies the debug level.
<span id="certtool-cert_002doptions"></span></p><span id="cert_002doptions-options"></span><h4 class="subsubheading">cert-options options</h4>
<p>Certificate related options.
</p><span id="pubkey_002dinfo-option_002e"></span><h4 class="subsubheading">pubkey-info option.</h4>
<span id="certtool-pubkey_002dinfo"></span>
<p>This is the &ldquo;print information on a public key&rdquo; option.
The option combined with &ndash;load-request, &ndash;load-pubkey, &ndash;load-privkey and &ndash;load-certificate will extract the public key of the object in question.
</p><span id="fingerprint-option_002e"></span><h4 class="subsubheading">fingerprint option.</h4>
<span id="certtool-fingerprint"></span>
<p>This is the &ldquo;print the fingerprint of the given certificate&rdquo; option.
This is a simple hash of the DER encoding of the certificate. It can be combined with the &ndash;hash parameter. However, it is recommended for identification to use the key-id which depends only on the certificate&rsquo;s key.
</p><span id="key_002did-option_002e"></span><h4 class="subsubheading">key-id option.</h4>
<span id="certtool-key_002did"></span>
<p>This is the &ldquo;print the key id of the given certificate&rdquo; option.
This is a hash of the public key of the given certificate. It identifies the key uniquely, remains the same on a certificate renewal and depends only on signed fields of the certificate.
</p><span id="certificate_002dpubkey-option_002e"></span><h4 class="subsubheading">certificate-pubkey option.</h4>
<span id="certtool-certificate_002dpubkey"></span>
<p>This is the &ldquo;print certificate&rsquo;s public key&rdquo; option.
This option is deprecated as a duplicate of &ndash;pubkey-info
</p>
<p><strong>NOTE</strong><strong>: THIS OPTION IS DEPRECATED</strong>
</p><span id="sign_002dparams-option_002e"></span><h4 class="subsubheading">sign-params option.</h4>
<span id="certtool-sign_002dparams"></span>
<p>This is the &ldquo;sign a certificate with a specific signature algorithm&rdquo; option.
This option takes a string argument.
This option can be combined with &ndash;generate-certificate, to sign the certificate with
a specific signature algorithm variant. The only option supported is &rsquo;RSA-PSS&rsquo;, and should be
specified when the signer does not have a certificate which is marked for RSA-PSS use only.
<span id="certtool-crq_002doptions"></span></p><span id="crq_002doptions-options"></span><h4 class="subsubheading">crq-options options</h4>
<p>Certificate request related options.
</p><span id="generate_002drequest-option-_0028_002dq_0029_002e"></span><h4 class="subsubheading">generate-request option (-q).</h4>
<span id="certtool-generate_002drequest"></span>
<p>This is the &ldquo;generate a pkcs #10 certificate request&rdquo; option.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> must not appear in combination with any of the following options:
infile.
</li></ul>

<p>Will generate a PKCS #10 certificate request. To specify a private key use &ndash;load-privkey.
<span id="certtool-pkcs12_002doptions"></span></p><span id="pkcs12_002doptions-options"></span><h4 class="subsubheading">pkcs12-options options</h4>
<p>PKCS#12 file related options.
</p><span id="p12_002dinfo-option_002e"></span><h4 class="subsubheading">p12-info option.</h4>
<span id="certtool-p12_002dinfo"></span>
<p>This is the &ldquo;print information on a pkcs #12 structure&rdquo; option.
This option will dump the contents and print the metadata of the provided PKCS #12 structure.
</p><span id="p12_002dname-option_002e"></span><h4 class="subsubheading">p12-name option.</h4>
<span id="certtool-p12_002dname"></span>
<p>This is the &ldquo;the pkcs #12 friendly name to use&rdquo; option.
This option takes a string argument.
The name to be used for the primary certificate and private key in a PKCS #12 file.
</p><span id="to_002dp12-option_002e"></span><h4 class="subsubheading">to-p12 option.</h4>
<span id="certtool-to_002dp12"></span>
<p>This is the &ldquo;generate a pkcs #12 structure&rdquo; option.
It requires a certificate, a private key and possibly a CA certificate to be specified.
<span id="certtool-key_002doptions"></span></p><span id="key_002doptions-options"></span><h4 class="subsubheading">key-options options</h4>
<p>Private key related options.
</p><span id="p8_002dinfo-option_002e"></span><h4 class="subsubheading">p8-info option.</h4>
<span id="certtool-p8_002dinfo"></span>
<p>This is the &ldquo;print information on a pkcs #8 structure&rdquo; option.
This option will print information about encrypted PKCS #8 structures. That option does not require the decryption of the structure.
</p><span id="to_002drsa-option_002e"></span><h4 class="subsubheading">to-rsa option.</h4>
<span id="certtool-to_002drsa"></span>
<p>This is the &ldquo;convert an rsa-pss key to raw rsa format&rdquo; option.
It requires an RSA-PSS key as input and will output a raw RSA
key. This command is necessary for compatibility with applications that
cannot read RSA-PSS keys.
</p><span id="generate_002dprivkey-option-_0028_002dp_0029_002e"></span><h4 class="subsubheading">generate-privkey option (-p).</h4>
<span id="certtool-generate_002dprivkey"></span>
<p>This is the &ldquo;generate a private key&rdquo; option.
When generating RSA-PSS private keys, the &ndash;hash option will
restrict the allowed hash for the key; in the same keys the &ndash;salt-size
option is also acceptable.
</p><span id="key_002dtype-option_002e"></span><h4 class="subsubheading">key-type option.</h4>
<span id="certtool-key_002dtype"></span>
<p>This is the &ldquo;specify the key type to use on key generation&rdquo; option.
This option takes a string argument.
This option can be combined with &ndash;generate-privkey, to specify
the key type to be generated. Valid options are, &rsquo;rsa&rsquo;, &rsquo;rsa-pss&rsquo;, &rsquo;dsa&rsquo;, &rsquo;ecdsa&rsquo;, and &rsquo;ed25519&rsquo;.
When combined with certificate generation it can be used to specify an
RSA-PSS certificate when an RSA key is given.
</p><span id="curve-option_002e"></span><h4 class="subsubheading">curve option.</h4>
<span id="certtool-curve"></span>
<p>This is the &ldquo;specify the curve used for ec key generation&rdquo; option.
This option takes a string argument.
Supported values are secp192r1, secp224r1, secp256r1, secp384r1 and secp521r1.
</p><span id="sec_002dparam-option_002e"></span><h4 class="subsubheading">sec-param option.</h4>
<span id="certtool-sec_002dparam"></span>
<p>This is the &ldquo;specify the security level [low, legacy, medium, high, ultra]&rdquo; option.
This option takes a string argument <samp>Security parameter</samp>.
This is alternative to the bits option.
</p><span id="to_002dp8-option_002e"></span><h4 class="subsubheading">to-p8 option.</h4>
<span id="certtool-to_002dp8"></span>
<p>This is the &ldquo;convert a given key to a pkcs #8 structure&rdquo; option.
This needs to be combined with &ndash;load-privkey.
</p><span id="provable-option_002e"></span><h4 class="subsubheading">provable option.</h4>
<span id="certtool-provable"></span>
<p>This is the &ldquo;generate a private key or parameters from a seed using a provable method&rdquo; option.
This will use the FIPS PUB186-4 algorithms (i.e., Shawe-Taylor) for provable key generation.
When specified the private keys or parameters will be generated from a seed, and can be
later validated with &ndash;verify-provable-privkey to be correctly generated from the seed. You may
specify &ndash;seed or allow GnuTLS to generate one (recommended). This option can be combined with
&ndash;generate-privkey or &ndash;generate-dh-params.
</p>
<p>That option applies to RSA and DSA keys. On the DSA keys the PQG parameters
are generated using the seed, and on RSA the two primes.
</p><span id="verify_002dprovable_002dprivkey-option_002e"></span><h4 class="subsubheading">verify-provable-privkey option.</h4>
<span id="certtool-verify_002dprovable_002dprivkey"></span>
<p>This is the &ldquo;verify a private key generated from a seed using a provable method&rdquo; option.
This will use the FIPS-186-4 algorithms for provable key generation. You may specify &ndash;seed or use the seed stored in the private key structure.
</p><span id="seed-option_002e"></span><h4 class="subsubheading">seed option.</h4>
<span id="certtool-seed"></span>
<p>This is the &ldquo;when generating a private key use the given hex-encoded seed&rdquo; option.
This option takes a string argument.
The seed acts as a security parameter for the private key, and
thus a seed size which corresponds to the security level of the private key
should be provided (e.g., 256-bits seed).
<span id="certtool-crl_002doptions"></span></p><span id="crl_002doptions-options"></span><h4 class="subsubheading">crl-options options</h4>
<p>CRL related options.
</p><span id="generate_002dcrl-option_002e"></span><h4 class="subsubheading">generate-crl option.</h4>
<span id="certtool-generate_002dcrl"></span>
<p>This is the &ldquo;generate a crl&rdquo; option.
This option generates a Certificate Revocation List. When combined with &ndash;load-crl it would use the loaded CRL as base for the generated (i.e., all revoked certificates in the base will be copied to the new CRL).
To add new certificates to the CRL use &ndash;load-certificate.
</p><span id="verify_002dcrl-option_002e"></span><h4 class="subsubheading">verify-crl option.</h4>
<span id="certtool-verify_002dcrl"></span>
<p>This is the &ldquo;verify a certificate revocation list using a trusted list&rdquo; option.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> must appear in combination with the following options:
load-ca-certificate.
</li></ul>

<p>The trusted certificate list must be loaded with &ndash;load-ca-certificate.
<span id="certtool-cert_002dverify_002doptions"></span></p><span id="cert_002dverify_002doptions-options"></span><h4 class="subsubheading">cert-verify-options options</h4>
<p>Certificate verification related options.
</p><span id="verify_002dchain-option-_0028_002de_0029_002e"></span><h4 class="subsubheading">verify-chain option (-e).</h4>
<span id="certtool-verify_002dchain"></span>
<p>This is the &ldquo;verify a pem encoded certificate chain&rdquo; option.
Verifies the validity of a certificate chain. That is, an ordered set of
certificates where each one is the issuer of the previous, and the first is
the end-certificate to be validated. In a proper chain the last certificate
is a self signed one. It can be combined with &ndash;verify-purpose or &ndash;verify-hostname.
</p><span id="verify-option_002e"></span><h4 class="subsubheading">verify option.</h4>
<span id="certtool-verify"></span>
<p>This is the &ldquo;verify a pem encoded certificate (chain) against a trusted set&rdquo; option.
The trusted certificate list can be loaded with &ndash;load-ca-certificate. If no
certificate list is provided, then the system&rsquo;s trusted certificate list is used. Note that
during verification multiple paths may be explored. On a successful verification
the successful path will be the last one. It can be combined with &ndash;verify-purpose or &ndash;verify-hostname.
</p><span id="verify_002dhostname-option_002e"></span><h4 class="subsubheading">verify-hostname option.</h4>
<span id="certtool-verify_002dhostname"></span>
<p>This is the &ldquo;specify a hostname to be used for certificate chain verification&rdquo; option.
This option takes a string argument.
This is to be combined with one of the verify certificate options.
</p><span id="verify_002demail-option_002e"></span><h4 class="subsubheading">verify-email option.</h4>
<span id="certtool-verify_002demail"></span>
<p>This is the &ldquo;specify a email to be used for certificate chain verification&rdquo; option.
This option takes a string argument.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> must not appear in combination with any of the following options:
verify-hostname.
</li></ul>

<p>This is to be combined with one of the verify certificate options.
</p><span id="verify_002dpurpose-option_002e"></span><h4 class="subsubheading">verify-purpose option.</h4>
<span id="certtool-verify_002dpurpose"></span>
<p>This is the &ldquo;specify a purpose oid to be used for certificate chain verification&rdquo; option.
This option takes a string argument.
This object identifier restricts the purpose of the certificates to be verified. Example purposes are 1.3.6.1.5.5.7.3.1 (TLS WWW), 1.3.6.1.5.5.7.3.4 (EMAIL) etc. Note that a CA certificate without a purpose set (extended key usage) is valid for any purpose.
</p><span id="verify_002dallow_002dbroken-option_002e"></span><h4 class="subsubheading">verify-allow-broken option.</h4>
<span id="certtool-verify_002dallow_002dbroken"></span>
<p>This is the &ldquo;allow broken algorithms, such as md5 for verification&rdquo; option.
This can be combined with &ndash;p7-verify, &ndash;verify or &ndash;verify-chain.
<span id="certtool-pkcs7_002doptions"></span></p><span id="pkcs7_002doptions-options"></span><h4 class="subsubheading">pkcs7-options options</h4>
<p>PKCS#7 structure options.
</p><span id="p7_002dgenerate-option_002e"></span><h4 class="subsubheading">p7-generate option.</h4>
<span id="certtool-p7_002dgenerate"></span>
<p>This is the &ldquo;generate a pkcs #7 structure&rdquo; option.
This option generates a PKCS #7 certificate container structure. To add certificates in the structure use &ndash;load-certificate and &ndash;load-crl.
</p><span id="p7_002dsign-option_002e"></span><h4 class="subsubheading">p7-sign option.</h4>
<span id="certtool-p7_002dsign"></span>
<p>This is the &ldquo;signs using a pkcs #7 structure&rdquo; option.
This option generates a PKCS #7 structure containing a signature for the provided data from infile. The data are stored within the structure. The signer certificate has to be specified using &ndash;load-certificate and &ndash;load-privkey. The input to &ndash;load-certificate can be a list of certificates. In case of a list, the first certificate is used for signing and the other certificates are included in the structure.
</p><span id="p7_002ddetached_002dsign-option_002e"></span><h4 class="subsubheading">p7-detached-sign option.</h4>
<span id="certtool-p7_002ddetached_002dsign"></span>
<p>This is the &ldquo;signs using a detached pkcs #7 structure&rdquo; option.
This option generates a PKCS #7 structure containing a signature for the provided data from infile. The signer certificate has to be specified using &ndash;load-certificate and &ndash;load-privkey. The input to &ndash;load-certificate can be a list of certificates. In case of a list, the first certificate is used for signing and the other certificates are included in the structure.
</p><span id="p7_002dinclude_002dcert-option_002e"></span><h4 class="subsubheading">p7-include-cert option.</h4>
<span id="certtool-p7_002dinclude_002dcert"></span>
<p>This is the &ldquo;the signer&rsquo;s certificate will be included in the cert list.&rdquo; option.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> can be disabled with &ndash;no-p7-include-cert.
</li><li> It is enabled by default.
</li></ul>

<p>This options works with &ndash;p7-sign or &ndash;p7-detached-sign and will include or exclude the signer&rsquo;s certificate into the generated signature.
</p><span id="p7_002dtime-option_002e"></span><h4 class="subsubheading">p7-time option.</h4>
<span id="certtool-p7_002dtime"></span>
<p>This is the &ldquo;will include a timestamp in the pkcs #7 structure&rdquo; option.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> can be disabled with &ndash;no-p7-time.
</li></ul>

<p>This option will include a timestamp in the generated signature
</p><span id="p7_002dshow_002ddata-option_002e"></span><h4 class="subsubheading">p7-show-data option.</h4>
<span id="certtool-p7_002dshow_002ddata"></span>
<p>This is the &ldquo;will show the embedded data in the pkcs #7 structure&rdquo; option.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> can be disabled with &ndash;no-p7-show-data.
</li></ul>

<p>This option can be combined with &ndash;p7-verify or &ndash;p7-info and will display the embedded signed data in the PKCS #7 structure.
</p><span id="p7_002dverify-option_002e"></span><h4 class="subsubheading">p7-verify option.</h4>
<span id="certtool-p7_002dverify"></span>
<p>This is the &ldquo;verify the provided pkcs #7 structure&rdquo; option.
This option verifies the signed PKCS #7 structure. The certificate list to use for verification can be specified with &ndash;load-ca-certificate. When no certificate list is provided, then the system&rsquo;s certificate list is used. Alternatively a direct signer can be provided using &ndash;load-certificate. A key purpose can be enforced with the &ndash;verify-purpose option, and the &ndash;load-data option will utilize detached data.
<span id="certtool-other_002doptions"></span></p><span id="other_002doptions-options"></span><h4 class="subsubheading">other-options options</h4>
<p>Other options.
</p><span id="generate_002ddh_002dparams-option_002e"></span><h4 class="subsubheading">generate-dh-params option.</h4>
<span id="certtool-generate_002ddh_002dparams"></span>
<p>This is the &ldquo;generate pkcs #3 encoded diffie-hellman parameters&rdquo; option.
The will generate random parameters to be used with
Diffie-Hellman key exchange. The output parameters will be in PKCS #3
format. Note that it is recommended to use the &ndash;get-dh-params option
instead.
</p>
<p><strong>NOTE</strong><strong>: THIS OPTION IS DEPRECATED</strong>
</p><span id="get_002ddh_002dparams-option_002e"></span><h4 class="subsubheading">get-dh-params option.</h4>
<span id="certtool-get_002ddh_002dparams"></span>
<p>This is the &ldquo;list the included pkcs #3 encoded diffie-hellman parameters&rdquo; option.
Returns stored DH parameters in GnuTLS. Those parameters returned
are defined in RFC7919, and can be considered standard parameters for a TLS
key exchange. This option is provided for old applications which require
DH parameters to be specified; modern GnuTLS applications should not require
them.
</p><span id="load_002dprivkey-option_002e"></span><h4 class="subsubheading">load-privkey option.</h4>
<span id="certtool-load_002dprivkey"></span>
<p>This is the &ldquo;loads a private key file&rdquo; option.
This option takes a string argument.
This can be either a file or a PKCS #11 URL
</p><span id="load_002dpubkey-option_002e"></span><h4 class="subsubheading">load-pubkey option.</h4>
<span id="certtool-load_002dpubkey"></span>
<p>This is the &ldquo;loads a public key file&rdquo; option.
This option takes a string argument.
This can be either a file or a PKCS #11 URL
</p><span id="load_002drequest-option_002e"></span><h4 class="subsubheading">load-request option.</h4>
<span id="certtool-load_002drequest"></span>
<p>This is the &ldquo;loads a certificate request file&rdquo; option.
This option takes a string argument.
This option can be used with a file
</p><span id="load_002dcertificate-option_002e"></span><h4 class="subsubheading">load-certificate option.</h4>
<span id="certtool-load_002dcertificate"></span>
<p>This is the &ldquo;loads a certificate file&rdquo; option.
This option takes a string argument.
This option can be used with a file
</p><span id="load_002dca_002dprivkey-option_002e"></span><h4 class="subsubheading">load-ca-privkey option.</h4>
<span id="certtool-load_002dca_002dprivkey"></span>
<p>This is the &ldquo;loads the certificate authority&rsquo;s private key file&rdquo; option.
This option takes a string argument.
This can be either a file or a PKCS #11 URL
</p><span id="load_002dca_002dcertificate-option_002e"></span><h4 class="subsubheading">load-ca-certificate option.</h4>
<span id="certtool-load_002dca_002dcertificate"></span>
<p>This is the &ldquo;loads the certificate authority&rsquo;s certificate file&rdquo; option.
This option takes a string argument.
This can be either a file or a PKCS #11 URL
</p><span id="load_002dcrl-option_002e"></span><h4 class="subsubheading">load-crl option.</h4>
<span id="certtool-load_002dcrl"></span>
<p>This is the &ldquo;loads the provided crl&rdquo; option.
This option takes a string argument.
This option can be used with a file
</p><span id="load_002ddata-option_002e"></span><h4 class="subsubheading">load-data option.</h4>
<span id="certtool-load_002ddata"></span>
<p>This is the &ldquo;loads auxiliary data&rdquo; option.
This option takes a string argument.
This option can be used with a file
</p><span id="password-option_002e"></span><h4 class="subsubheading">password option.</h4>
<span id="certtool-password"></span>
<p>This is the &ldquo;password to use&rdquo; option.
This option takes a string argument.
You can use this option to specify the password in the command line instead of reading it from the tty. Note, that the command line arguments are available for view in others in the system. Specifying password as &rdquo; is the same as specifying no password.
</p><span id="null_002dpassword-option_002e"></span><h4 class="subsubheading">null-password option.</h4>
<span id="certtool-null_002dpassword"></span>
<p>This is the &ldquo;enforce a null password&rdquo; option.
This option enforces a NULL password. This is different than the empty or no password in schemas like PKCS #8.
</p><span id="empty_002dpassword-option_002e"></span><h4 class="subsubheading">empty-password option.</h4>
<span id="certtool-empty_002dpassword"></span>
<p>This is the &ldquo;enforce an empty password&rdquo; option.
This option enforces an empty password. This is different than the NULL or no password in schemas like PKCS #8.
</p><span id="cprint-option_002e"></span><h4 class="subsubheading">cprint option.</h4>
<span id="certtool-cprint"></span>
<p>This is the &ldquo;in certain operations it prints the information in c-friendly format&rdquo; option.
In certain operations it prints the information in C-friendly format, suitable for including into C programs.
</p><span id="rsa-option_002e"></span><h4 class="subsubheading">rsa option.</h4>
<span id="certtool-rsa"></span>
<p>This is the &ldquo;generate rsa key&rdquo; option.
When combined with &ndash;generate-privkey generates an RSA private key.
</p>
<p><strong>NOTE</strong><strong>: THIS OPTION IS DEPRECATED</strong>
</p><span id="dsa-option_002e"></span><h4 class="subsubheading">dsa option.</h4>
<span id="certtool-dsa"></span>
<p>This is the &ldquo;generate dsa key&rdquo; option.
When combined with &ndash;generate-privkey generates a DSA private key.
</p>
<p><strong>NOTE</strong><strong>: THIS OPTION IS DEPRECATED</strong>
</p><span id="ecc-option_002e"></span><h4 class="subsubheading">ecc option.</h4>
<span id="certtool-ecc"></span>
<p>This is the &ldquo;generate ecc (ecdsa) key&rdquo; option.
When combined with &ndash;generate-privkey generates an elliptic curve private key to be used with ECDSA.
</p>
<p><strong>NOTE</strong><strong>: THIS OPTION IS DEPRECATED</strong>
</p><span id="ecdsa-option_002e"></span><h4 class="subsubheading">ecdsa option.</h4>
<span id="certtool-ecdsa"></span>
<p>This is an alias for the <code>ecc</code> option,
see <a href="#certtool-ecc">the ecc option documentation</a>.
</p>
<span id="hash-option_002e"></span><h4 class="subsubheading">hash option.</h4>
<span id="certtool-hash"></span>
<p>This is the &ldquo;hash algorithm to use for signing&rdquo; option.
This option takes a string argument.
Available hash functions are SHA1, RMD160, SHA256, SHA384, SHA512, SHA3-224, SHA3-256, SHA3-384, SHA3-512.
</p><span id="salt_002dsize-option_002e"></span><h4 class="subsubheading">salt-size option.</h4>
<span id="certtool-salt_002dsize"></span>
<p>This is the &ldquo;specify the rsa-pss key default salt size&rdquo; option.
This option takes a number argument.
Typical keys shouldn&rsquo;t set or restrict this option.
</p><span id="inder-option_002e"></span><h4 class="subsubheading">inder option.</h4>
<span id="certtool-inder"></span>
<p>This is the &ldquo;use der format for input certificates, private keys, and dh parameters &rdquo; option.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> can be disabled with &ndash;no-inder.
</li></ul>

<p>The input files will be assumed to be in DER or RAW format. 
Unlike options that in PEM input would allow multiple input data (e.g. multiple 
certificates), when reading in DER format a single data structure is read.
</p><span id="inraw-option_002e"></span><h4 class="subsubheading">inraw option.</h4>
<span id="certtool-inraw"></span>
<p>This is an alias for the <code>inder</code> option,
see <a href="#certtool-inder">the inder option documentation</a>.
</p>
<span id="outder-option_002e"></span><h4 class="subsubheading">outder option.</h4>
<span id="certtool-outder"></span>
<p>This is the &ldquo;use der format for output certificates, private keys, and dh parameters&rdquo; option.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> can be disabled with &ndash;no-outder.
</li></ul>

<p>The output will be in DER or RAW format.
</p><span id="outraw-option_002e"></span><h4 class="subsubheading">outraw option.</h4>
<span id="certtool-outraw"></span>
<p>This is an alias for the <code>outder</code> option,
see <a href="#certtool-outder">the outder option documentation</a>.
</p>
<span id="ask_002dpass-option_002e"></span><h4 class="subsubheading">ask-pass option.</h4>
<span id="certtool-ask_002dpass"></span>
<p>This is the &ldquo;enable interaction for entering password when in batch mode.&rdquo; option.
This option will enable interaction to enter password when in batch mode. That is useful when the template option has been specified.
</p><span id="pkcs_002dcipher-option_002e"></span><h4 class="subsubheading">pkcs-cipher option.</h4>
<span id="certtool-pkcs_002dcipher"></span>
<p>This is the &ldquo;cipher to use for pkcs #8 and #12 operations&rdquo; option.
This option takes a string argument <samp>Cipher</samp>.
Cipher may be one of 3des, 3des-pkcs12, aes-128, aes-192, aes-256, rc2-40, arcfour.
</p><span id="provider-option_002e"></span><h4 class="subsubheading">provider option.</h4>
<span id="certtool-provider"></span>
<p>This is the &ldquo;specify the pkcs #11 provider library&rdquo; option.
This option takes a string argument.
This will override the default options in /etc/gnutls/pkcs11.conf
</p><span id="text-option_002e"></span><h4 class="subsubheading">text option.</h4>
<span id="certtool-text"></span>
<p>This is the &ldquo;output textual information before pem-encoded certificates, private keys, etc&rdquo; option.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> can be disabled with &ndash;no-text.
</li><li> It is enabled by default.
</li></ul>

<p>Output textual information before PEM-encoded data
<span id="certtool-exit-status"></span></p><span id="certtool-exit-status-1"></span><h4 class="subsubheading">certtool exit status</h4>

<p>One of the following exit values will be returned:
</p><dl compact="compact">
<dt>&lsquo;<samp>0 (EXIT_SUCCESS)</samp>&rsquo;</dt>
<dd><p>Successful program execution.
</p></dd>
<dt>&lsquo;<samp>1 (EXIT_FAILURE)</samp>&rsquo;</dt>
<dd><p>The operation failed or the command syntax was not valid.
</p></dd>
</dl>
<span id="certtool-See-Also"></span><span id="certtool-See-Also-1"></span><h4 class="subsubheading">certtool See Also</h4>
<p>p11tool (1), psktool (1), srptool (1)
<span id="certtool-Examples"></span></p><span id="certtool-Examples-1"></span><h4 class="subsubheading">certtool Examples</h4>
<span id="Generating-private-keys"></span><h4 class="subsubheading">Generating private keys</h4>
<p>To create an RSA private key, run:
</p><div class="example">
<pre class="example">$ certtool --generate-privkey --outfile key.pem --rsa
</pre></div>

<p>To create a DSA or elliptic curves (ECDSA) private key use the
above command combined with &rsquo;dsa&rsquo; or &rsquo;ecc&rsquo; options.
</p>
<span id="Generating-certificate-requests"></span><h4 class="subsubheading">Generating certificate requests</h4>
<p>To create a certificate request (needed when the certificate is  issued  by
another party), run:
</p><div class="example">
<pre class="example">certtool --generate-request --load-privkey key.pem \
   --outfile request.pem
</pre></div>

<p>If the private key is stored in a smart card you can generate
a request by specifying the private key object URL.
</p><div class="example">
<pre class="example">$ ./certtool --generate-request --load-privkey &quot;pkcs11:...&quot; \
  --load-pubkey &quot;pkcs11:...&quot; --outfile request.pem
</pre></div>


<span id="Generating-a-self_002dsigned-certificate"></span><h4 class="subsubheading">Generating a self-signed certificate</h4>
<p>To create a self signed certificate, use the command:
</p><div class="example">
<pre class="example">$ certtool --generate-privkey --outfile ca-key.pem
$ certtool --generate-self-signed --load-privkey ca-key.pem \
   --outfile ca-cert.pem
</pre></div>

<p>Note that a self-signed certificate usually belongs to a certificate
authority, that signs other certificates.
</p>
<span id="Generating-a-certificate"></span><h4 class="subsubheading">Generating a certificate</h4>
<p>To generate a certificate using the previous request, use the command:
</p><div class="example">
<pre class="example">$ certtool --generate-certificate --load-request request.pem \
   --outfile cert.pem --load-ca-certificate ca-cert.pem \
   --load-ca-privkey ca-key.pem
</pre></div>

<p>To generate a certificate using the private key only, use the command:
</p><div class="example">
<pre class="example">$ certtool --generate-certificate --load-privkey key.pem \
   --outfile cert.pem --load-ca-certificate ca-cert.pem \
   --load-ca-privkey ca-key.pem
</pre></div>

<span id="Certificate-information"></span><h4 class="subsubheading">Certificate information</h4>
<p>To view the certificate information, use:
</p><div class="example">
<pre class="example">$ certtool --certificate-info --infile cert.pem
</pre></div>

<span id="Changing-the-certificate-format"></span><h4 class="subsubheading">Changing the certificate format</h4>
<p>To convert the certificate from PEM to DER format, use:
</p><div class="example">
<pre class="example">$ certtool --certificate-info --infile cert.pem --outder --outfile cert.der
</pre></div>

<span id="PKCS-_002312-structure-generation"></span><h4 class="subsubheading">PKCS #12 structure generation</h4>
<p>To generate a PKCS #12 structure using the previous key and certificate,
use the command:
</p><div class="example">
<pre class="example">$ certtool --load-certificate cert.pem --load-privkey key.pem \
   --to-p12 --outder --outfile key.p12
</pre></div>

<p>Some tools (reportedly web browsers) have problems with that file
because it does not contain the CA certificate for the certificate.
To work around that problem in the tool, you can use the
&ndash;load-ca-certificate parameter as follows:
</p>
<div class="example">
<pre class="example">$ certtool --load-ca-certificate ca.pem \
  --load-certificate cert.pem --load-privkey key.pem \
  --to-p12 --outder --outfile key.p12
</pre></div>

<span id="Obtaining-Diffie_002dHellman-parameters"></span><h4 class="subsubheading">Obtaining Diffie-Hellman parameters</h4>
<p>To obtain the RFC7919 parameters for Diffie-Hellman key exchange, use the command:
</p><div class="example">
<pre class="example">$ certtool --get-dh-params --outfile dh.pem --sec-param medium
</pre></div>

<span id="Verifying-a-certificate"></span><h4 class="subsubheading">Verifying a certificate</h4>
<p>To verify a certificate in a file against the system&rsquo;s CA trust store
use the following command:
</p><div class="example">
<pre class="example">$ certtool --verify --infile cert.pem
</pre></div>

<p>It is also possible to simulate hostname verification with the following
options:
</p><div class="example">
<pre class="example">$ certtool --verify --verify-hostname www.example.com --infile cert.pem
</pre></div>


<span id="Proxy-certificate-generation"></span><h4 class="subsubheading">Proxy certificate generation</h4>
<p>Proxy certificate can be used to delegate your credential to a
temporary, typically short-lived, certificate.  To create one from the
previously created certificate, first create a temporary key and then
generate a proxy certificate for it, using the commands:
</p>
<div class="example">
<pre class="example">$ certtool --generate-privkey &gt; proxy-key.pem
$ certtool --generate-proxy --load-ca-privkey key.pem \
  --load-privkey proxy-key.pem --load-certificate cert.pem \
  --outfile proxy-cert.pem
</pre></div>

<span id="Certificate-revocation-list-generation"></span><h4 class="subsubheading">Certificate revocation list generation</h4>
<p>To create an empty Certificate Revocation List (CRL) do:
</p>
<div class="example">
<pre class="example">$ certtool --generate-crl --load-ca-privkey x509-ca-key.pem \
           --load-ca-certificate x509-ca.pem
</pre></div>

<p>To create a CRL that contains some revoked certificates, place the
certificates in a file and use <code>--load-certificate</code> as follows:
</p>
<div class="example">
<pre class="example">$ certtool --generate-crl --load-ca-privkey x509-ca-key.pem \
  --load-ca-certificate x509-ca.pem --load-certificate revoked-certs.pem
</pre></div>

<p>To verify a Certificate Revocation List (CRL) do:
</p>
<div class="example">
<pre class="example">$ certtool --verify-crl --load-ca-certificate x509-ca.pem &lt; crl.pem
</pre></div>
<span id="certtool-Files"></span><span id="certtool-Files-1"></span><h4 class="subsubheading">certtool Files</h4>
<span id="Certtool_0027s-template-file-format"></span><h4 class="subsubheading">Certtool&rsquo;s template file format</h4>
<p>A template file can be used to avoid the interactive questions of
certtool. Initially create a file named &rsquo;cert.cfg&rsquo; that contains the information
about the certificate. The template can be used as below:
</p>
<div class="example">
<pre class="example">$ certtool --generate-certificate --load-privkey key.pem  \
   --template cert.cfg --outfile cert.pem \
   --load-ca-certificate ca-cert.pem --load-ca-privkey ca-key.pem
</pre></div>

<p>An example certtool template file that can be used to generate a certificate
request or a self signed certificate follows.
</p>
<div class="example">
<pre class="example"># X.509 Certificate options
#
# DN options

# The organization of the subject.
organization = &quot;Koko inc.&quot;

# The organizational unit of the subject.
unit = &quot;sleeping dept.&quot;

# The locality of the subject.
# locality =

# The state of the certificate owner.
state = &quot;Attiki&quot;

# The country of the subject. Two letter code.
country = GR

# The common name of the certificate owner.
cn = &quot;Cindy Lauper&quot;

# A user id of the certificate owner.
#uid = &quot;clauper&quot;

# Set domain components
#dc = &quot;name&quot;
#dc = &quot;domain&quot;

# If the supported DN OIDs are not adequate you can set
# any OID here.
# For example set the X.520 Title and the X.520 Pseudonym
# by using OID and string pairs.
#dn_oid = &quot;2.5.4.12 Dr.&quot;
#dn_oid = &quot;2.5.4.65 jackal&quot;

# This is deprecated and should not be used in new
# certificates.
# pkcs9_email = &quot;none@none.org&quot;

# An alternative way to set the certificate's distinguished name directly
# is with the &quot;dn&quot; option. The attribute names allowed are:
# C (country), street, O (organization), OU (unit), title, CN (common name),
# L (locality), ST (state), placeOfBirth, gender, countryOfCitizenship, 
# countryOfResidence, serialNumber, telephoneNumber, surName, initials, 
# generationQualifier, givenName, pseudonym, dnQualifier, postalCode, name, 
# businessCategory, DC, UID, jurisdictionOfIncorporationLocalityName, 
# jurisdictionOfIncorporationStateOrProvinceName,
# jurisdictionOfIncorporationCountryName, XmppAddr, and numeric OIDs.

#dn = &quot;cn = Nikos,st = New\, Something,C=GR,surName=Mavrogiannopoulos,2.5.4.9=Arkadias&quot;

# The serial number of the certificate
# The value is in decimal (i.e. 1963) or hex (i.e. 0x07ab).
# Comment the field for a random serial number.
serial = 007

# In how many days, counting from today, this certificate will expire.
# Use -1 if there is no expiration date.
expiration_days = 700

# Alternatively you may set concrete dates and time. The GNU date string 
# formats are accepted. See:
# https://www.gnu.org/software/tar/manual/html_node/Date-input-formats.html

#activation_date = &quot;2004-02-29 16:21:42&quot;
#expiration_date = &quot;2025-02-29 16:24:41&quot;

# X.509 v3 extensions

# A dnsname in case of a WWW server.
#dns_name = &quot;www.none.org&quot;
#dns_name = &quot;www.morethanone.org&quot;

# An othername defined by an OID and a hex encoded string
#other_name = &quot;1.3.6.1.5.2.2 302ca00d1b0b56414e5245494e2e4f5247a11b3019a006020400000002a10f300d1b047269636b1b0561646d696e&quot;
#other_name_utf8 = &quot;1.2.4.5.6 A UTF8 string&quot;
#other_name_octet = &quot;1.2.4.5.6 A string that will be encoded as ASN.1 octet string&quot;

# Allows writing an XmppAddr Identifier
#xmpp_name = juliet@im.example.com

# Names used in PKINIT
#krb5_principal = user@REALM.COM
#krb5_principal = HTTP/user@REALM.COM

# A subject alternative name URI
#uri = &quot;https://www.example.com&quot;

# An IP address in case of a server.
#ip_address = &quot;192.168.1.1&quot;

# An email in case of a person
email = &quot;none@none.org&quot;

# TLS feature (rfc7633) extension. That can is used to indicate mandatory TLS
# extension features to be provided by the server. In practice this is used
# to require the Status Request (extid: 5) extension from the server. That is,
# to require the server holding this certificate to provide a stapled OCSP response.
# You can have multiple lines for multiple TLS features.

# To ask for OCSP status request use:
#tls_feature = 5

# Challenge password used in certificate requests
challenge_password = 123456

# Password when encrypting a private key
#password = secret

# An URL that has CRLs (certificate revocation lists)
# available. Needed in CA certificates.
#crl_dist_points = &quot;https://www.getcrl.crl/getcrl/&quot;

# Whether this is a CA certificate or not
#ca

# Subject Unique ID (in hex)
#subject_unique_id = 00153224

# Issuer Unique ID (in hex)
#issuer_unique_id = 00153225

#### Key usage

# The following key usage flags are used by CAs and end certificates

# Whether this certificate will be used to sign data (needed
# in TLS DHE ciphersuites). This is the digitalSignature flag
# in RFC5280 terminology.
signing_key

# Whether this certificate will be used to encrypt data (needed
# in TLS RSA ciphersuites). Note that it is preferred to use different
# keys for encryption and signing. This is the keyEncipherment flag
# in RFC5280 terminology.
encryption_key

# Whether this key will be used to sign other certificates. The
# keyCertSign flag in RFC5280 terminology.
#cert_signing_key

# Whether this key will be used to sign CRLs. The
# cRLSign flag in RFC5280 terminology.
#crl_signing_key

# The keyAgreement flag of RFC5280. It's purpose is loosely
# defined. Not use it unless required by a protocol.
#key_agreement

# The dataEncipherment flag of RFC5280. It's purpose is loosely
# defined. Not use it unless required by a protocol.
#data_encipherment

# The nonRepudiation flag of RFC5280. It's purpose is loosely
# defined. Not use it unless required by a protocol.
#non_repudiation

#### Extended key usage (key purposes)

# The following extensions are used in an end certificate
# to clarify its purpose. Some CAs also use it to indicate
# the types of certificates they are purposed to sign.


# Whether this certificate will be used for a TLS client;
# this sets the id-kp-clientAuth (1.3.6.1.5.5.7.3.2) of
# extended key usage.
#tls_www_client

# Whether this certificate will be used for a TLS server;
# this sets the id-kp-serverAuth (1.3.6.1.5.5.7.3.1) of
# extended key usage.
#tls_www_server

# Whether this key will be used to sign code. This sets the
# id-kp-codeSigning (1.3.6.1.5.5.7.3.3) of extended key usage
# extension.
#code_signing_key

# Whether this key will be used to sign OCSP data. This sets the
# id-kp-OCSPSigning (1.3.6.1.5.5.7.3.9) of extended key usage extension.
#ocsp_signing_key

# Whether this key will be used for time stamping. This sets the
# id-kp-timeStamping (1.3.6.1.5.5.7.3.8) of extended key usage extension.
#time_stamping_key

# Whether this key will be used for email protection. This sets the
# id-kp-emailProtection (1.3.6.1.5.5.7.3.4) of extended key usage extension.
#email_protection_key

# Whether this key will be used for IPsec IKE operations (1.3.6.1.5.5.7.3.17).
#ipsec_ike_key

## adding custom key purpose OIDs

# for microsoft smart card logon
# key_purpose_oid = 1.3.6.1.4.1.311.20.2.2

# for email protection
# key_purpose_oid = 1.3.6.1.5.5.7.3.4

# for any purpose (must not be used in intermediate CA certificates)
# key_purpose_oid = 2.5.29.37.0

### end of key purpose OIDs

### Adding arbitrary extensions
# This requires to provide the extension OIDs, as well as the extension data in
# hex format. The following two options are available since GnuTLS 3.5.3.
#add_extension = &quot;1.2.3.4 0x0AAB01ACFE&quot;

# As above but encode the data as an octet string
#add_extension = &quot;1.2.3.4 octet_string(0x0AAB01ACFE)&quot;

# For portability critical extensions shouldn't be set to certificates.
#add_critical_extension = &quot;5.6.7.8 0x1AAB01ACFE&quot;

# When generating a certificate from a certificate
# request, then honor the extensions stored in the request
# and store them in the real certificate.
#honor_crq_extensions

# Alternatively only specific extensions can be copied.
#honor_crq_ext = 2.5.29.17
#honor_crq_ext = 2.5.29.15

# Path length contraint. Sets the maximum number of
# certificates that can be used to certify this certificate.
# (i.e. the certificate chain length)
#path_len = -1
#path_len = 2

# OCSP URI
# ocsp_uri = https://my.ocsp.server/ocsp

# CA issuers URI
# ca_issuers_uri = https://my.ca.issuer

# Certificate policies
#policy1 = 1.3.6.1.4.1.5484.1.10.99.1.0
#policy1_txt = &quot;This is a long policy to summarize&quot;
#policy1_url = https://www.example.com/a-policy-to-read

#policy2 = 1.3.6.1.4.1.5484.1.10.99.1.1
#policy2_txt = &quot;This is a short policy&quot;
#policy2_url = https://www.example.com/another-policy-to-read

# The number of additional certificates that may appear in a
# path before the anyPolicy is no longer acceptable.
#inhibit_anypolicy_skip_certs 1

# Name constraints

# DNS
#nc_permit_dns = example.com
#nc_exclude_dns = test.example.com

# EMAIL
#nc_permit_email = &quot;nmav@ex.net&quot;

# Exclude subdomains of example.com
#nc_exclude_email = .example.com

# Exclude all e-mail addresses of example.com
#nc_exclude_email = example.com

# IP
#nc_permit_ip = 192.168.0.0/16
#nc_exclude_ip = 192.168.5.0/24
#nc_permit_ip = fc0a:eef2:e7e7:a56e::/64


# Options for proxy certificates
#proxy_policy_language = 1.3.6.1.5.5.7.21.1


# Options for generating a CRL

# The number of days the next CRL update will be due.
# next CRL update will be in 43 days
#crl_next_update = 43

# this is the 5th CRL by this CA
# The value is in decimal (i.e. 1963) or hex (i.e. 0x07ab).
# Comment the field for a time-based number.
# Time-based CRL numbers generated in GnuTLS 3.6.3 and later
# are significantly larger than those generated in previous
# versions. Since CRL numbers need to be monotonic, you need
# to specify the CRL number here manually if you intend to
# downgrade to an earlier version than 3.6.3 after publishing
# the CRL as it is not possible to specify CRL numbers greater
# than 2**63-2 using hex notation in those versions.
#crl_number = 5

# Specify the update dates more precisely.
#crl_this_update_date = &quot;2004-02-29 16:21:42&quot;
#crl_next_update_date = &quot;2025-02-29 16:24:41&quot;

# The date that the certificates will be made seen as
# being revoked.
#crl_revocation_date = &quot;2025-02-29 16:24:41&quot;

</pre></div>

<hr>
<span id="ocsptool-Invocation"></span><div class="header">
<p>
Next: <a href="#danetool-Invocation" accesskey="n" rel="next">danetool Invocation</a>, Previous: <a href="#certtool-Invocation" accesskey="p" rel="prev">certtool Invocation</a>, Up: <a href="#More-on-certificate-authentication" accesskey="u" rel="up">More on certificate authentication</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Invoking-ocsptool"></span><h4 class="subsection">4.2.7 Invoking ocsptool</h4>
<span id="index-ocsptool"></span>



<span id="On-verification"></span><h4 class="subsubheading">On verification</h4>
<p>Responses are typically signed/issued by designated certificates or
certificate authorities and thus this tool requires on verification
the certificate of the issuer or the full certificate chain in order to
determine the appropriate signing authority. The specified certificate
of the issuer is assumed trusted.
</p>

<p>This section was generated by <strong>AutoGen</strong>,
using the <code>agtexi-cmd</code> template and the option descriptions for the <code>ocsptool</code> program.
This software is released under the GNU General Public License, version 3 or later.
</p>

<span id="ocsptool-usage"></span><span id="ocsptool-help_002fusage-_0028_002d_002dhelp_0029"></span><h4 class="subsubheading">ocsptool help/usage (<samp>--help</samp>)</h4>
<span id="index-ocsptool-help"></span>

<p>This is the automatically generated usage text for ocsptool.
</p>
<p>The text printed is the same whether selected with the <code>help</code> option
(<samp>--help</samp>) or the <code>more-help</code> option (<samp>--more-help</samp>).  <code>more-help</code> will print
the usage text by passing it through a pager program.
<code>more-help</code> is disabled on platforms without a working
<code>fork(2)</code> function.  The <code>PAGER</code> environment variable is
used to select the program, defaulting to <samp>more</samp>.  Both will exit
with a status code of 0.
</p>
<div class="example">
<pre class="example">ocsptool - GnuTLS OCSP tool
Usage:  ocsptool [ -&lt;flag&gt; [&lt;val&gt;] | --&lt;name&gt;[{=| }&lt;val&gt;] ]...

   -d, --debug=num            Enable debugging
                                - it must be in the range:
                                  0 to 9999
   -V, --verbose              More verbose output
                                - may appear multiple times
       --infile=file          Input file
                                - file must pre-exist
       --outfile=str          Output file
       --ask[=arg]            Ask an OCSP/HTTP server on a certificate validity
   -e, --verify-response      Verify response
   -i, --request-info         Print information on a OCSP request
   -j, --response-info        Print information on a OCSP response
   -q, --generate-request     Generates an OCSP request
       --nonce                Use (or not) a nonce to OCSP request
                                - disabled as '--no-nonce'
       --load-chain=file      Reads a set of certificates forming a chain from file
                                - file must pre-exist
       --load-issuer=file     Reads issuer's certificate from file
                                - file must pre-exist
       --load-cert=file       Reads the certificate to check from file
                                - file must pre-exist
       --load-trust=file      Read OCSP trust anchors from file
                                - prohibits the option 'load-signer'
                                - file must pre-exist
       --load-signer=file     Reads the OCSP response signer from file
                                - prohibits the option 'load-trust'
                                - file must pre-exist
       --inder                Use DER format for input certificates and private keys
                                - disabled as '--no-inder'
       --outder               Use DER format for output of responses (this is the default)
       --outpem               Use PEM format for output of responses
   -Q, --load-request=file    Reads the DER encoded OCSP request from file
                                - file must pre-exist
   -S, --load-response=file   Reads the DER encoded OCSP response from file
                                - file must pre-exist
       --ignore-errors        Ignore any verification errors
       --verify-allow-broken  Allow broken algorithms, such as MD5 for verification
   -v, --version[=arg]        output version information and exit
   -h, --help                 display extended usage information and exit
   -!, --more-help            extended usage information passed thru pager

Options are specified by doubled hyphens and their name or by a single
hyphen and the flag character.

ocsptool is a program that can parse and print information about OCSP
requests/responses, generate requests and verify responses.  Unlike other
GnuTLS applications it outputs DER encoded structures by default unless the
'--outpem' option is specified.

</pre></div>

<span id="ocsptool-debug"></span><span id="debug-option-_0028_002dd_0029"></span><h4 class="subsubheading">debug option (-d)</h4>

<p>This is the &ldquo;enable debugging&rdquo; option.
This option takes a number argument.
Specifies the debug level.
<span id="ocsptool-ask"></span></p><span id="ask-option"></span><h4 class="subsubheading">ask option</h4>

<p>This is the &ldquo;ask an ocsp/http server on a certificate validity&rdquo; option.
This option takes an optional string argument <samp>server name|url</samp>.
Connects to the specified HTTP OCSP server and queries on the validity of the loaded certificate.
Its argument can be a URL or a plain server name. It can be combined with &ndash;load-chain, where it checks
all certificates in the provided chain, or with &ndash;load-cert and
&ndash;load-issuer options. The latter checks the provided certificate
against its specified issuer certificate.
<span id="ocsptool-verify_002dresponse"></span></p><span id="verify_002dresponse-option-_0028_002de_0029"></span><h4 class="subsubheading">verify-response option (-e)</h4>

<p>This is the &ldquo;verify response&rdquo; option.
Verifies the provided OCSP response against the system trust
anchors (unless &ndash;load-trust is provided). It requires the &ndash;load-signer
or &ndash;load-chain options to obtain the signer of the OCSP response.
<span id="ocsptool-request_002dinfo"></span></p><span id="request_002dinfo-option-_0028_002di_0029"></span><h4 class="subsubheading">request-info option (-i)</h4>

<p>This is the &ldquo;print information on a ocsp request&rdquo; option.
Display detailed information on the provided OCSP request.
<span id="ocsptool-response_002dinfo"></span></p><span id="response_002dinfo-option-_0028_002dj_0029"></span><h4 class="subsubheading">response-info option (-j)</h4>

<p>This is the &ldquo;print information on a ocsp response&rdquo; option.
Display detailed information on the provided OCSP response.
<span id="ocsptool-load_002dtrust"></span></p><span id="load_002dtrust-option"></span><h4 class="subsubheading">load-trust option</h4>

<p>This is the &ldquo;read ocsp trust anchors from file&rdquo; option.
This option takes a file argument.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> must not appear in combination with any of the following options:
load-signer.
</li></ul>

<p>When verifying an OCSP response read the trust anchors from the
provided file. When this is not provided, the system&rsquo;s trust anchors will be
used.
<span id="ocsptool-outder"></span></p><span id="outder-option"></span><h4 class="subsubheading">outder option</h4>

<p>This is the &ldquo;use der format for output of responses (this is the default)&rdquo; option.
The output will be in DER encoded format. Unlike other GnuTLS tools, this is the default for this tool
<span id="ocsptool-outpem"></span></p><span id="outpem-option"></span><h4 class="subsubheading">outpem option</h4>

<p>This is the &ldquo;use pem format for output of responses&rdquo; option.
The output will be in PEM format.
<span id="ocsptool-verify_002dallow_002dbroken"></span></p><span id="verify_002dallow_002dbroken-option"></span><h4 class="subsubheading">verify-allow-broken option</h4>

<p>This is the &ldquo;allow broken algorithms, such as md5 for verification&rdquo; option.
This can be combined with &ndash;verify-response.
<span id="ocsptool-exit-status"></span></p><span id="ocsptool-exit-status-1"></span><h4 class="subsubheading">ocsptool exit status</h4>

<p>One of the following exit values will be returned:
</p><dl compact="compact">
<dt>&lsquo;<samp>0 (EXIT_SUCCESS)</samp>&rsquo;</dt>
<dd><p>Successful program execution.
</p></dd>
<dt>&lsquo;<samp>1 (EXIT_FAILURE)</samp>&rsquo;</dt>
<dd><p>The operation failed or the command syntax was not valid.
</p></dd>
</dl>
<span id="ocsptool-See-Also"></span><span id="ocsptool-See-Also-1"></span><h4 class="subsubheading">ocsptool See Also</h4>
<p>certtool (1)
<span id="ocsptool-Examples"></span></p><span id="ocsptool-Examples-1"></span><h4 class="subsubheading">ocsptool Examples</h4>
<span id="Print-information-about-an-OCSP-request"></span><h4 class="subsubheading">Print information about an OCSP request</h4>

<p>To parse an OCSP request and print information about the content, the
<code>-i</code> or <code>--request-info</code> parameter may be used as follows.
The <code>-Q</code> parameter specify the name of the file containing the
OCSP request, and it should contain the OCSP request in binary DER
format.
</p>
<div class="example">
<pre class="example">$ ocsptool -i -Q ocsp-request.der
</pre></div>

<p>The input file may also be sent to standard input like this:
</p>
<div class="example">
<pre class="example">$ cat ocsp-request.der | ocsptool --request-info
</pre></div>

<span id="Print-information-about-an-OCSP-response"></span><h4 class="subsubheading">Print information about an OCSP response</h4>

<p>Similar to parsing OCSP requests, OCSP responses can be parsed using
the <code>-j</code> or <code>--response-info</code> as follows.
</p>
<div class="example">
<pre class="example">$ ocsptool -j -Q ocsp-response.der
$ cat ocsp-response.der | ocsptool --response-info
</pre></div>

<span id="Generate-an-OCSP-request"></span><h4 class="subsubheading">Generate an OCSP request</h4>

<p>The <code>-q</code> or <code>--generate-request</code> parameters are used to
generate an OCSP request.  By default the OCSP request is written to
standard output in binary DER format, but can be stored in a file
using <code>--outfile</code>.  To generate an OCSP request the issuer of the
certificate to check needs to be specified with <code>--load-issuer</code>
and the certificate to check with <code>--load-cert</code>.  By default PEM
format is used for these files, although <code>--inder</code> can be used to
specify that the input files are in DER format.
</p>
<div class="example">
<pre class="example">$ ocsptool -q --load-issuer issuer.pem --load-cert client.pem \
           --outfile ocsp-request.der
</pre></div>

<p>When generating OCSP requests, the tool will add an OCSP extension
containing a nonce.  This behaviour can be disabled by specifying
<code>--no-nonce</code>.
</p>
<span id="Verify-signature-in-OCSP-response"></span><h4 class="subsubheading">Verify signature in OCSP response</h4>

<p>To verify the signature in an OCSP response the <code>-e</code> or
<code>--verify-response</code> parameter is used.  The tool will read an
OCSP response in DER format from standard input, or from the file
specified by <code>--load-response</code>.  The OCSP response is verified
against a set of trust anchors, which are specified using
<code>--load-trust</code>.  The trust anchors are concatenated certificates
in PEM format.  The certificate that signed the OCSP response needs to
be in the set of trust anchors, or the issuer of the signer
certificate needs to be in the set of trust anchors and the OCSP
Extended Key Usage bit has to be asserted in the signer certificate.
</p>
<div class="example">
<pre class="example">$ ocsptool -e --load-trust issuer.pem \
           --load-response ocsp-response.der
</pre></div>

<p>The tool will print status of verification.
</p>
<span id="Verify-signature-in-OCSP-response-against-given-certificate"></span><h4 class="subsubheading">Verify signature in OCSP response against given certificate</h4>

<p>It is possible to override the normal trust logic if you know that a
certain certificate is supposed to have signed the OCSP response, and
you want to use it to check the signature.  This is achieved using
<code>--load-signer</code> instead of <code>--load-trust</code>.  This will load
one certificate and it will be used to verify the signature in the
OCSP response.  It will not check the Extended Key Usage bit.
</p>
<div class="example">
<pre class="example">$ ocsptool -e --load-signer ocsp-signer.pem \
           --load-response ocsp-response.der
</pre></div>

<p>This approach is normally only relevant in two situations.  The first
is when the OCSP response does not contain a copy of the signer
certificate, so the <code>--load-trust</code> code would fail.  The second
is if you want to avoid the indirect mode where the OCSP response
signer certificate is signed by a trust anchor.
</p>
<span id="Real_002dworld-example"></span><h4 class="subsubheading">Real-world example</h4>

<p>Here is an example of how to generate an OCSP request for a
certificate and to verify the response.  For illustration we&rsquo;ll use
the <code>blog.josefsson.org</code> host, which (as of writing) uses a
certificate from CACert.  First we&rsquo;ll use <code>gnutls-cli</code> to get a
copy of the server certificate chain.  The server is not required to
send this information, but this particular one is configured to do so.
</p>
<div class="example">
<pre class="example">$ echo | gnutls-cli -p 443 blog.josefsson.org --save-cert chain.pem
</pre></div>

<p>The saved certificates normally contain a pointer to where the OCSP
responder is located, in the Authority Information Access Information
extension.  For example, from <code>certtool -i &lt; chain.pem</code> there is
this information:
</p>
<div class="example">
<pre class="example">Authority Information Access Information (not critical):
Access Method: 1.3.6.1.5.5.7.48.1 (id-ad-ocsp)
Access Location URI: https://ocsp.CAcert.org/
</pre></div>

<p>This means that ocsptool can discover the servers to contact over HTTP.
We can now request information on the chain certificates.
</p>
<div class="example">
<pre class="example">$ ocsptool --ask --load-chain chain.pem
</pre></div>

<p>The request is sent via HTTP to the OCSP server address found in
the certificates. It is possible to override the address of the
OCSP server as well as ask information on a particular certificate
using &ndash;load-cert and &ndash;load-issuer.
</p>
<div class="example">
<pre class="example">$ ocsptool --ask https://ocsp.CAcert.org/ --load-chain chain.pem
</pre></div>

<hr>
<span id="danetool-Invocation"></span><div class="header">
<p>
Previous: <a href="#ocsptool-Invocation" accesskey="p" rel="prev">ocsptool Invocation</a>, Up: <a href="#More-on-certificate-authentication" accesskey="u" rel="up">More on certificate authentication</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Invoking-danetool"></span><h4 class="subsection">4.2.8 Invoking danetool</h4>
<span id="index-danetool"></span>


<p>Tool to generate and check DNS resource records for the DANE protocol.
</p>
<p>This section was generated by <strong>AutoGen</strong>,
using the <code>agtexi-cmd</code> template and the option descriptions for the <code>danetool</code> program.
This software is released under the GNU General Public License, version 3 or later.
</p>

<span id="danetool-usage"></span><span id="danetool-help_002fusage-_0028_002d_002dhelp_0029"></span><h4 class="subsubheading">danetool help/usage (<samp>--help</samp>)</h4>
<span id="index-danetool-help"></span>

<p>This is the automatically generated usage text for danetool.
</p>
<p>The text printed is the same whether selected with the <code>help</code> option
(<samp>--help</samp>) or the <code>more-help</code> option (<samp>--more-help</samp>).  <code>more-help</code> will print
the usage text by passing it through a pager program.
<code>more-help</code> is disabled on platforms without a working
<code>fork(2)</code> function.  The <code>PAGER</code> environment variable is
used to select the program, defaulting to <samp>more</samp>.  Both will exit
with a status code of 0.
</p>
<div class="example">
<pre class="example">danetool - GnuTLS DANE tool
Usage:  danetool [ -&lt;flag&gt; [&lt;val&gt;] | --&lt;name&gt;[{=| }&lt;val&gt;] ]...

   -d, --debug=num            Enable debugging
                                - it must be in the range:
                                  0 to 9999
   -V, --verbose              More verbose output
                                - may appear multiple times
       --infile=file          Input file
                                - file must pre-exist
       --outfile=str          Output file
       --load-pubkey=str      Loads a public key file
       --load-certificate=str Loads a certificate file
       --dlv=str              Sets a DLV file
       --hash=str             Hash algorithm to use for signing
       --check=str            Check a host's DANE TLSA entry
       --check-ee             Check only the end-entity's certificate
       --check-ca             Check only the CA's certificate
       --tlsa-rr              Print the DANE RR data on a certificate or public key
                                - requires the option 'host'
       --host=str             Specify the hostname to be used in the DANE RR
       --proto=str            The protocol set for DANE data (tcp, udp etc.)
       --port=str             The port or service to connect to, for DANE data
       --app-proto=str        an alias for the 'starttls-proto' option
       --starttls-proto=str   The application protocol to be used to obtain the server's certificate
(https, ftp, smtp, imap, ldap, xmpp, lmtp, pop3, nntp, sieve, postgres)
       --ca                   Whether the provided certificate or public key is a Certificate
Authority
       --x509                 Use the hash of the X.509 certificate, rather than the public key
       --local                an alias for the 'domain' option
                                - enabled by default
       --domain               The provided certificate or public key is issued by the local domain
                                - disabled as '--no-domain'
                                - enabled by default
       --local-dns            Use the local DNS server for DNSSEC resolving
                                - disabled as '--no-local-dns'
       --insecure             Do not verify any DNSSEC signature
       --inder                Use DER format for input certificates and private keys
                                - disabled as '--no-inder'
       --inraw                an alias for the 'inder' option
       --print-raw            Print the received DANE data in raw format
                                - disabled as '--no-print-raw'
       --quiet                Suppress several informational messages
   -v, --version[=arg]        output version information and exit
   -h, --help                 display extended usage information and exit
   -!, --more-help            extended usage information passed thru pager

Options are specified by doubled hyphens and their name or by a single
hyphen and the flag character.

Tool to generate and check DNS resource records for the DANE protocol.

</pre></div>

<span id="danetool-debug"></span><span id="debug-option-_0028_002dd_0029-1"></span><h4 class="subsubheading">debug option (-d)</h4>

<p>This is the &ldquo;enable debugging&rdquo; option.
This option takes a number argument.
Specifies the debug level.
<span id="danetool-load_002dpubkey"></span></p><span id="load_002dpubkey-option"></span><h4 class="subsubheading">load-pubkey option</h4>

<p>This is the &ldquo;loads a public key file&rdquo; option.
This option takes a string argument.
This can be either a file or a PKCS #11 URL
<span id="danetool-load_002dcertificate"></span></p><span id="load_002dcertificate-option"></span><h4 class="subsubheading">load-certificate option</h4>

<p>This is the &ldquo;loads a certificate file&rdquo; option.
This option takes a string argument.
This can be either a file or a PKCS #11 URL
<span id="danetool-dlv"></span></p><span id="dlv-option"></span><h4 class="subsubheading">dlv option</h4>

<p>This is the &ldquo;sets a dlv file&rdquo; option.
This option takes a string argument.
This sets a DLV file to be used for DNSSEC verification.
<span id="danetool-hash"></span></p><span id="hash-option"></span><h4 class="subsubheading">hash option</h4>

<p>This is the &ldquo;hash algorithm to use for signing&rdquo; option.
This option takes a string argument.
Available hash functions are SHA1, RMD160, SHA256, SHA384, SHA512.
<span id="danetool-check"></span></p><span id="check-option"></span><h4 class="subsubheading">check option</h4>

<p>This is the &ldquo;check a host&rsquo;s dane tlsa entry&rdquo; option.
This option takes a string argument.
Obtains the DANE TLSA entry from the given hostname and prints information. Note that the actual certificate of the host can be provided using &ndash;load-certificate, otherwise danetool will connect to the server to obtain it. The exit code on verification success will be zero.
<span id="danetool-check_002dee"></span></p><span id="check_002dee-option"></span><h4 class="subsubheading">check-ee option</h4>

<p>This is the &ldquo;check only the end-entity&rsquo;s certificate&rdquo; option.
Checks the end-entity&rsquo;s certificate only. Trust anchors or CAs are not considered.
<span id="danetool-check_002dca"></span></p><span id="check_002dca-option"></span><h4 class="subsubheading">check-ca option</h4>

<p>This is the &ldquo;check only the ca&rsquo;s certificate&rdquo; option.
Checks the trust anchor&rsquo;s and CA&rsquo;s certificate only. End-entities are not considered.
<span id="danetool-tlsa_002drr"></span></p><span id="tlsa_002drr-option"></span><h4 class="subsubheading">tlsa-rr option</h4>

<p>This is the &ldquo;print the dane rr data on a certificate or public key&rdquo; option.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> must appear in combination with the following options:
host.
</li></ul>

<p>This command prints the DANE RR data needed to enable DANE on a DNS server.
<span id="danetool-host"></span></p><span id="host-option"></span><h4 class="subsubheading">host option</h4>

<p>This is the &ldquo;specify the hostname to be used in the dane rr&rdquo; option.
This option takes a string argument <samp>Hostname</samp>.
This command sets the hostname for the DANE RR.
<span id="danetool-proto"></span></p><span id="proto-option"></span><h4 class="subsubheading">proto option</h4>

<p>This is the &ldquo;the protocol set for dane data (tcp, udp etc.)&rdquo; option.
This option takes a string argument <samp>Protocol</samp>.
This command specifies the protocol for the service set in the DANE data.
<span id="danetool-app_002dproto"></span></p><span id="app_002dproto-option"></span><h4 class="subsubheading">app-proto option</h4>

<p>This is an alias for the <code>starttls-proto</code> option,
see <a href="#danetool-starttls_002dproto">the starttls-proto option documentation</a>.
</p>
<span id="danetool-starttls_002dproto"></span><span id="starttls_002dproto-option"></span><h4 class="subsubheading">starttls-proto option</h4>

<p>This is the &ldquo;the application protocol to be used to obtain the server&rsquo;s certificate (https, ftp, smtp, imap, ldap, xmpp, lmtp, pop3, nntp, sieve, postgres)&rdquo; option.
This option takes a string argument.
When the server&rsquo;s certificate isn&rsquo;t provided danetool will connect to the server to obtain the certificate. In that case it is required to know the protocol to talk with the server prior to initiating the TLS handshake.
<span id="danetool-ca"></span></p><span id="ca-option"></span><h4 class="subsubheading">ca option</h4>

<p>This is the &ldquo;whether the provided certificate or public key is a certificate authority&rdquo; option.
Marks the DANE RR as a CA certificate if specified.
<span id="danetool-x509"></span></p><span id="x509-option"></span><h4 class="subsubheading">x509 option</h4>

<p>This is the &ldquo;use the hash of the x.509 certificate, rather than the public key&rdquo; option.
This option forces the generated record to contain the hash of the full X.509 certificate. By default only the hash of the public key is used.
<span id="danetool-local"></span></p><span id="local-option"></span><h4 class="subsubheading">local option</h4>

<p>This is an alias for the <code>domain</code> option,
see <a href="#danetool-domain">the domain option documentation</a>.
</p>
<span id="danetool-domain"></span><span id="domain-option"></span><h4 class="subsubheading">domain option</h4>

<p>This is the &ldquo;the provided certificate or public key is issued by the local domain&rdquo; option.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> can be disabled with &ndash;no-domain.
</li><li> It is enabled by default.
</li></ul>

<p>DANE distinguishes certificates and public keys offered via the DNSSEC to trusted and local entities. This flag indicates that this is a domain-issued certificate, meaning that there could be no CA involved.
<span id="danetool-local_002ddns"></span></p><span id="local_002ddns-option"></span><h4 class="subsubheading">local-dns option</h4>

<p>This is the &ldquo;use the local dns server for dnssec resolving&rdquo; option.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> can be disabled with &ndash;no-local-dns.
</li></ul>

<p>This option will use the local DNS server for DNSSEC.
This is disabled by default due to many servers not allowing DNSSEC.
<span id="danetool-insecure"></span></p><span id="insecure-option"></span><h4 class="subsubheading">insecure option</h4>

<p>This is the &ldquo;do not verify any dnssec signature&rdquo; option.
Ignores any DNSSEC signature verification results.
<span id="danetool-inder"></span></p><span id="inder-option"></span><h4 class="subsubheading">inder option</h4>

<p>This is the &ldquo;use der format for input certificates and private keys&rdquo; option.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> can be disabled with &ndash;no-inder.
</li></ul>

<p>The input files will be assumed to be in DER or RAW format. 
Unlike options that in PEM input would allow multiple input data (e.g. multiple 
certificates), when reading in DER format a single data structure is read.
<span id="danetool-inraw"></span></p><span id="inraw-option"></span><h4 class="subsubheading">inraw option</h4>

<p>This is an alias for the <code>inder</code> option,
see <a href="#danetool-inder">the inder option documentation</a>.
</p>
<span id="danetool-print_002draw"></span><span id="print_002draw-option"></span><h4 class="subsubheading">print-raw option</h4>

<p>This is the &ldquo;print the received dane data in raw format&rdquo; option.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> can be disabled with &ndash;no-print-raw.
</li></ul>

<p>This option will print the received DANE data.
<span id="danetool-quiet"></span></p><span id="quiet-option"></span><h4 class="subsubheading">quiet option</h4>

<p>This is the &ldquo;suppress several informational messages&rdquo; option.
In that case on the exit code can be used as an indication of verification success
<span id="danetool-exit-status"></span></p><span id="danetool-exit-status-1"></span><h4 class="subsubheading">danetool exit status</h4>

<p>One of the following exit values will be returned:
</p><dl compact="compact">
<dt>&lsquo;<samp>0 (EXIT_SUCCESS)</samp>&rsquo;</dt>
<dd><p>Successful program execution.
</p></dd>
<dt>&lsquo;<samp>1 (EXIT_FAILURE)</samp>&rsquo;</dt>
<dd><p>The operation failed or the command syntax was not valid.
</p></dd>
</dl>
<span id="danetool-See-Also"></span><span id="danetool-See-Also-1"></span><h4 class="subsubheading">danetool See Also</h4>
<p>certtool (1)
<span id="danetool-Examples"></span></p><span id="danetool-Examples-1"></span><h4 class="subsubheading">danetool Examples</h4>
<span id="DANE-TLSA-RR-generation"></span><h4 class="subsubheading">DANE TLSA RR generation</h4>

<p>To create a DANE TLSA resource record for a certificate (or public key) 
that was issued localy and may or may not be signed by a CA use the following command.
</p><div class="example">
<pre class="example">$ danetool --tlsa-rr --host www.example.com --load-certificate cert.pem
</pre></div>

<p>To create a DANE TLSA resource record for a CA signed certificate, which will
be marked as such use the following command.
</p><div class="example">
<pre class="example">$ danetool --tlsa-rr --host www.example.com --load-certificate cert.pem \
  --no-domain
</pre></div>

<p>The former is useful to add in your DNS entry even if your certificate is signed 
by a CA. That way even users who do not trust your CA will be able to verify your
certificate using DANE.
</p>
<p>In order to create a record for the CA signer of your certificate use the following.
</p><div class="example">
<pre class="example">$ danetool --tlsa-rr --host www.example.com --load-certificate cert.pem \
  --ca --no-domain
</pre></div>

<p>To read a server&rsquo;s DANE TLSA entry, use:
</p><div class="example">
<pre class="example">$ danetool --check www.example.com --proto tcp --port 443
</pre></div>

<p>To verify an HTTPS server&rsquo;s DANE TLSA entry, use:
</p><div class="example">
<pre class="example">$ danetool --check www.example.com --proto tcp --port 443 --load-certificate chain.pem
</pre></div>

<p>To verify an SMTP server&rsquo;s DANE TLSA entry, use:
</p><div class="example">
<pre class="example">$ danetool --check www.example.com --proto tcp --starttls-proto=smtp --load-certificate chain.pem
</pre></div>

<hr>
<span id="Shared_002dkey-and-anonymous-authentication"></span><div class="header">
<p>
Next: <a href="#Selecting-an-appropriate-authentication-method" accesskey="n" rel="next">Selecting an appropriate authentication method</a>, Previous: <a href="#More-on-certificate-authentication" accesskey="p" rel="prev">More on certificate authentication</a>, Up: <a href="#Authentication-methods" accesskey="u" rel="up">Authentication methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Shared_002dkey-and-anonymous-authentication-1"></span><h3 class="section">4.3 Shared-key and anonymous authentication</h3>

<p>In addition to certificate authentication, the TLS protocol may be
used with password, shared-key and anonymous authentication methods.
The rest of this chapter discusses details of these methods.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#PSK-authentication" accesskey="1">PSK authentication</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#SRP-authentication" accesskey="2">SRP authentication</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Anonymous-authentication" accesskey="3">Anonymous authentication</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="PSK-authentication"></span><div class="header">
<p>
Next: <a href="#SRP-authentication" accesskey="n" rel="next">SRP authentication</a>, Up: <a href="#Shared_002dkey-and-anonymous-authentication" accesskey="u" rel="up">Shared-key and anonymous authentication</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="PSK-authentication-1"></span><h4 class="subsection">4.3.1 PSK authentication</h4>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Authentication-using-PSK" accesskey="1">Authentication using PSK</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#psktool-Invocation" accesskey="2">psktool Invocation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Invoking psktool
</td></tr>
</table>

<hr>
<span id="Authentication-using-PSK"></span><div class="header">
<p>
Next: <a href="#psktool-Invocation" accesskey="n" rel="next">psktool Invocation</a>, Up: <a href="#PSK-authentication" accesskey="u" rel="up">PSK authentication</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Authentication-using-PSK-1"></span><h4 class="subsubsection">4.3.1.1 Authentication using <acronym>PSK</acronym></h4>
<span id="index-PSK-authentication"></span>

<p>Authentication using Pre-shared keys is a method to authenticate using
usernames and binary keys. This protocol avoids making use of public
key infrastructure and expensive calculations, thus it is suitable for
constraint clients. It is available under all TLS protocol versions.
</p>
<p>The implementation in <acronym>GnuTLS</acronym> is based on [<a href="#TLSPSK">TLSPSK</a>].  
The supported <acronym>PSK</acronym> key exchange methods are:
</p>
<dl compact="compact">
<dt><code>PSK:</code></dt>
<dd><p>Authentication using the <acronym>PSK</acronym> protocol (no forward secrecy).
</p>
</dd>
<dt><code>DHE-PSK:</code></dt>
<dd><p>Authentication using the <acronym>PSK</acronym> protocol and Diffie-Hellman key
exchange.  This method offers perfect forward secrecy.
</p>
</dd>
<dt><code>ECDHE-PSK:</code></dt>
<dd><p>Authentication using the <acronym>PSK</acronym> protocol and Elliptic curve Diffie-Hellman key
exchange.  This method offers perfect forward secrecy.
</p>
</dd>
<dt><code>RSA-PSK:</code></dt>
<dd><p>Authentication using the <acronym>PSK</acronym> protocol for the client and an RSA certificate
for the server. This is not available under TLS 1.3.
</p>
</dd>
</dl>

<p>Helper functions to generate and maintain <acronym>PSK</acronym> keys are also included
in <acronym>GnuTLS</acronym>.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fkey_005fgenerate">gnutls_key_generate</a> (gnutls_datum_t * <var>key</var>, unsigned int <var>key_size</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fhex_005fencode">gnutls_hex_encode</a> (const gnutls_datum_t * <var>data</var>, char * <var>result</var>, size_t * <var>result_size</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fhex_005fdecode">gnutls_hex_decode</a> (const gnutls_datum_t * <var>hex_data</var>, void * <var>result</var>, size_t * <var>result_size</var>)</code></dt>
</dl>

<hr>
<span id="psktool-Invocation"></span><div class="header">
<p>
Previous: <a href="#Authentication-using-PSK" accesskey="p" rel="prev">Authentication using PSK</a>, Up: <a href="#PSK-authentication" accesskey="u" rel="up">PSK authentication</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Invoking-psktool"></span><h4 class="subsubsection">4.3.1.2 Invoking psktool</h4>
<span id="index-psktool"></span>


<p>Program  that generates random keys for use with TLS-PSK. The
keys are stored in hexadecimal format in a key file.
</p>
<p>This section was generated by <strong>AutoGen</strong>,
using the <code>agtexi-cmd</code> template and the option descriptions for the <code>psktool</code> program.
This software is released under the GNU General Public License, version 3 or later.
</p>

<span id="psktool-usage"></span><span id="psktool-help_002fusage-_0028_002d_002dhelp_0029"></span><h4 class="subsubheading">psktool help/usage (<samp>--help</samp>)</h4>
<span id="index-psktool-help"></span>

<p>This is the automatically generated usage text for psktool.
</p>
<p>The text printed is the same whether selected with the <code>help</code> option
(<samp>--help</samp>) or the <code>more-help</code> option (<samp>--more-help</samp>).  <code>more-help</code> will print
the usage text by passing it through a pager program.
<code>more-help</code> is disabled on platforms without a working
<code>fork(2)</code> function.  The <code>PAGER</code> environment variable is
used to select the program, defaulting to <samp>more</samp>.  Both will exit
with a status code of 0.
</p>
<div class="example">
<pre class="example">psktool - GnuTLS PSK tool
Usage:  psktool [ -&lt;flag&gt; [&lt;val&gt;] | --&lt;name&gt;[{=| }&lt;val&gt;] ]...

   -d, --debug=num            Enable debugging
                                - it must be in the range:
                                  0 to 9999
   -s, --keysize=num          Specify the key size in bytes (default is 32-bytes or 256-bits)
                                - it must be in the range:
                                  0 to 512
   -u, --username=str         Specify the username to use
   -p, --pskfile=str          Specify a pre-shared key file
   -v, --version[=arg]        output version information and exit
   -h, --help                 display extended usage information and exit
   -!, --more-help            extended usage information passed thru pager

Options are specified by doubled hyphens and their name or by a single
hyphen and the flag character.

Program that generates random keys for use with TLS-PSK.  The keys are
stored in hexadecimal format in a key file.

</pre></div>

<span id="psktool-debug"></span><span id="debug-option-_0028_002dd_0029-2"></span><h4 class="subsubheading">debug option (-d)</h4>

<p>This is the &ldquo;enable debugging&rdquo; option.
This option takes a number argument.
Specifies the debug level.
<span id="psktool-pskfile"></span></p><span id="pskfile-option-_0028_002dp_0029"></span><h4 class="subsubheading">pskfile option (-p)</h4>

<p>This is the &ldquo;specify a pre-shared key file&rdquo; option.
This option takes a string argument.
This option will specify the pre-shared key file to store the generated keys.
<span id="psktool-passwd"></span></p><span id="passwd-option"></span><h4 class="subsubheading">passwd option</h4>

<p>This is an alias for the <code>pskfile</code> option,
see <a href="#psktool-pskfile">the pskfile option documentation</a>.
</p>
<span id="psktool-exit-status"></span><span id="psktool-exit-status-1"></span><h4 class="subsubheading">psktool exit status</h4>

<p>One of the following exit values will be returned:
</p><dl compact="compact">
<dt>&lsquo;<samp>0 (EXIT_SUCCESS)</samp>&rsquo;</dt>
<dd><p>Successful program execution.
</p></dd>
<dt>&lsquo;<samp>1 (EXIT_FAILURE)</samp>&rsquo;</dt>
<dd><p>The operation failed or the command syntax was not valid.
</p></dd>
</dl>
<span id="psktool-See-Also"></span><span id="psktool-See-Also-1"></span><h4 class="subsubheading">psktool See Also</h4>
<p>gnutls-cli-debug (1), gnutls-serv (1), srptool (1), certtool (1)
<span id="psktool-Examples"></span></p><span id="psktool-Examples-1"></span><h4 class="subsubheading">psktool Examples</h4>
<p>To add a user &rsquo;psk_identity&rsquo; in <samp>keys.psk</samp> for use with GnuTLS run:
</p><div class="example">
<pre class="example">$ ./psktool -u psk_identity -p keys.psk
Generating a random key for user 'psk_identity'
Key stored to keys.psk
$ cat keys.psk
psk_identity:88f3824b3e5659f52d00e959bacab954b6540344
$
</pre></div>

<p>This command will create <samp>keys.psk</samp> if it does not exist
and will add user &rsquo;psk_identity&rsquo;.
</p>

<hr>
<span id="SRP-authentication"></span><div class="header">
<p>
Next: <a href="#Anonymous-authentication" accesskey="n" rel="next">Anonymous authentication</a>, Previous: <a href="#PSK-authentication" accesskey="p" rel="prev">PSK authentication</a>, Up: <a href="#Shared_002dkey-and-anonymous-authentication" accesskey="u" rel="up">Shared-key and anonymous authentication</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="SRP-authentication-1"></span><h4 class="subsection">4.3.2 SRP authentication</h4>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Authentication-using-SRP" accesskey="1">Authentication using SRP</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#srptool-Invocation" accesskey="2">srptool Invocation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Invoking srptool
</td></tr>
</table>

<hr>
<span id="Authentication-using-SRP"></span><div class="header">
<p>
Next: <a href="#srptool-Invocation" accesskey="n" rel="next">srptool Invocation</a>, Up: <a href="#SRP-authentication" accesskey="u" rel="up">SRP authentication</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Authentication-using-SRP-1"></span><h4 class="subsubsection">4.3.2.1 Authentication using <acronym>SRP</acronym></h4>
<span id="index-SRP-authentication"></span>

<p><acronym>GnuTLS</acronym> supports authentication via the Secure Remote Password 
or <acronym>SRP</acronym> protocol (see [<a href="#RFC2945">TOMSRP</a>] for a description).
The <acronym>SRP</acronym> key exchange is an extension to the
<acronym>TLS</acronym> protocol, and it provides an authenticated with a 
password key exchange. The peers can be identified using a single password, 
or there can be combinations where the client is authenticated using <acronym>SRP</acronym>
and the server using a certificate. It is only available under TLS 1.2 or earlier
versions.
</p>
<p>The advantage of <acronym>SRP</acronym> authentication, over other proposed
secure password authentication schemes, is that <acronym>SRP</acronym> is not
susceptible to off-line dictionary attacks.
Moreover, SRP does not require the server to hold the user&rsquo;s password.
This kind of protection is similar to the one used traditionally in the <acronym>UNIX</acronym>
<samp>/etc/passwd</samp> file, where the contents of this file did not cause
harm to the system security if they were revealed.  The <acronym>SRP</acronym>
needs instead of the plain password something called a verifier, which
is calculated using the user&rsquo;s password, and if stolen cannot be used
to impersonate the user. 
</p>
<p>Typical conventions in SRP are a password file, called <samp>tpasswd</samp> that 
holds the SRP verifiers (encoded passwords) and another file, <samp>tpasswd.conf</samp>,
which holds the allowed SRP parameters.  The included in GnuTLS helper 
follow those conventions. The srptool program, discussed in the next section
is a tool to manipulate the SRP parameters.
</p>
<p>The implementation in <acronym>GnuTLS</acronym> is based on [<a href="#TLSSRP">TLSSRP</a>]. The
supported key exchange methods are shown below. Enabling any of these
key exchange methods in a session disables support for TLS1.3.
</p>
<dl compact="compact">
<dt><code>SRP:</code></dt>
<dd><p>Authentication using the <acronym>SRP</acronym> protocol.
</p>
</dd>
<dt><code>SRP_DSS:</code></dt>
<dd><p>Client authentication using the <acronym>SRP</acronym> protocol. Server is
authenticated using a certificate with DSA parameters.
</p>
</dd>
<dt><code>SRP_RSA:</code></dt>
<dd><p>Client authentication using the <acronym>SRP</acronym> protocol. Server is
authenticated using a certificate with RSA parameters.
</p>
</dd>
</dl>






<dl>
<dt id="index-gnutls_005fsrp_005fverifier">Function: <em>int</em> <strong>gnutls_srp_verifier</strong> <em>(const char * <var>username</var>, const char * <var>password</var>, const gnutls_datum_t * <var>salt</var>, const gnutls_datum_t * <var>generator</var>, const gnutls_datum_t * <var>prime</var>, gnutls_datum_t * <var>res</var>)</em></dt>
<dd><p><var>username</var>: is the user&rsquo;s name
</p>
<p><var>password</var>: is the user&rsquo;s password
</p>
<p><var>salt</var>: should be some randomly generated bytes
</p>
<p><var>generator</var>: is the generator of the group
</p>
<p><var>prime</var>: is the group&rsquo;s prime
</p>
<p><var>res</var>: where the verifier will be stored.
</p>
<p>This function will create an SRP verifier, as specified in
RFC2945.  The  <code>prime</code> and  <code>generator</code> should be one of the static
parameters defined in gnutls/gnutls.h or may be generated.
</p>
<p>The verifier will be allocated with  <code>gnutls_malloc</code> () and will be stored in
 <code>res</code> using binary format.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, or an
error code.
</p></dd></dl>

<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fsrp_005fbase64_005fencode2">gnutls_srp_base64_encode2</a> (const gnutls_datum_t * <var>data</var>, gnutls_datum_t * <var>result</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fsrp_005fbase64_005fdecode2">gnutls_srp_base64_decode2</a> (const gnutls_datum_t * <var>b64_data</var>, gnutls_datum_t * <var>result</var>)</code></dt>
</dl>

<hr>
<span id="srptool-Invocation"></span><div class="header">
<p>
Previous: <a href="#Authentication-using-SRP" accesskey="p" rel="prev">Authentication using SRP</a>, Up: <a href="#SRP-authentication" accesskey="u" rel="up">SRP authentication</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Invoking-srptool"></span><h4 class="subsubsection">4.3.2.2 Invoking srptool</h4>
<span id="index-srptool"></span>


<p>Simple program that emulates the programs in the Stanford SRP (Secure
Remote Password) libraries using GnuTLS.  It is intended for use in  places
where you don&rsquo;t expect SRP authentication to be the used for system users.
</p>
<p>In  brief,  to use SRP you need to create two files. These are the password
file that holds the users and the verifiers associated with  them  and  the
configuration file to hold the group parameters (called tpasswd.conf).
</p>
<p>This section was generated by <strong>AutoGen</strong>,
using the <code>agtexi-cmd</code> template and the option descriptions for the <code>srptool</code> program.
This software is released under the GNU General Public License, version 3 or later.
</p>

<span id="srptool-usage"></span><span id="srptool-help_002fusage-_0028_002d_002dhelp_0029"></span><h4 class="subsubheading">srptool help/usage (<samp>--help</samp>)</h4>
<span id="index-srptool-help"></span>

<p>This is the automatically generated usage text for srptool.
</p>
<p>The text printed is the same whether selected with the <code>help</code> option
(<samp>--help</samp>) or the <code>more-help</code> option (<samp>--more-help</samp>).  <code>more-help</code> will print
the usage text by passing it through a pager program.
<code>more-help</code> is disabled on platforms without a working
<code>fork(2)</code> function.  The <code>PAGER</code> environment variable is
used to select the program, defaulting to <samp>more</samp>.  Both will exit
with a status code of 0.
</p>
<div class="example">
<pre class="example">srptool - GnuTLS SRP tool
Usage:  srptool [ -&lt;flag&gt; [&lt;val&gt;] | --&lt;name&gt;[{=| }&lt;val&gt;] ]...

   -d, --debug=num            Enable debugging
                                - it must be in the range:
                                  0 to 9999
   -i, --index=num            specify the index of the group parameters in tpasswd.conf to use
   -u, --username=str         specify a username
   -p, --passwd=str           specify a password file
   -s, --salt=num             specify salt size
       --verify               just verify the password.
   -v, --passwd-conf=str      specify a password conf file.
       --create-conf=str      Generate a password configuration file.
   -v, --version[=arg]        output version information and exit
   -h, --help                 display extended usage information and exit
   -!, --more-help            extended usage information passed thru pager

Options are specified by doubled hyphens and their name or by a single
hyphen and the flag character.

Simple program that emulates the programs in the Stanford SRP (Secure
Remote Password) libraries using GnuTLS.  It is intended for use in places
where you don't expect SRP authentication to be the used for system users.

In brief, to use SRP you need to create two files.  These are the password
file that holds the users and the verifiers associated with them and the
configuration file to hold the group parameters (called tpasswd.conf).

</pre></div>

<span id="srptool-debug"></span><span id="debug-option-_0028_002dd_0029-3"></span><h4 class="subsubheading">debug option (-d)</h4>

<p>This is the &ldquo;enable debugging&rdquo; option.
This option takes a number argument.
Specifies the debug level.
<span id="srptool-verify"></span></p><span id="verify-option"></span><h4 class="subsubheading">verify option</h4>

<p>This is the &ldquo;just verify the password.&rdquo; option.
Verifies the password provided against the password file.
<span id="srptool-passwd_002dconf"></span></p><span id="passwd_002dconf-option-_0028_002dv_0029"></span><h4 class="subsubheading">passwd-conf option (-v)</h4>

<p>This is the &ldquo;specify a password conf file.&rdquo; option.
This option takes a string argument.
Specify a filename or a PKCS #11 URL to read the CAs from.
<span id="srptool-create_002dconf"></span></p><span id="create_002dconf-option"></span><h4 class="subsubheading">create-conf option</h4>

<p>This is the &ldquo;generate a password configuration file.&rdquo; option.
This option takes a string argument.
This generates a password configuration file (tpasswd.conf)
containing the required for TLS parameters.
<span id="srptool-exit-status"></span></p><span id="srptool-exit-status-1"></span><h4 class="subsubheading">srptool exit status</h4>

<p>One of the following exit values will be returned:
</p><dl compact="compact">
<dt>&lsquo;<samp>0 (EXIT_SUCCESS)</samp>&rsquo;</dt>
<dd><p>Successful program execution.
</p></dd>
<dt>&lsquo;<samp>1 (EXIT_FAILURE)</samp>&rsquo;</dt>
<dd><p>The operation failed or the command syntax was not valid.
</p></dd>
</dl>
<span id="srptool-See-Also"></span><span id="srptool-See-Also-1"></span><h4 class="subsubheading">srptool See Also</h4>
<p>gnutls-cli-debug (1), gnutls-serv (1), srptool (1), psktool (1), certtool (1)
<span id="srptool-Examples"></span></p><span id="srptool-Examples-1"></span><h4 class="subsubheading">srptool Examples</h4>
<p>To create <samp>tpasswd.conf</samp> which holds the g and n values for SRP protocol
(generator and a large prime), run:
</p><div class="example">
<pre class="example">$ srptool --create-conf /etc/tpasswd.conf
</pre></div>

<p>This command will create <samp>/etc/tpasswd</samp> and will add user &rsquo;test&rsquo; (you
will also be prompted for a password). Verifiers are stored by default
in the way libsrp expects.
</p><div class="example">
<pre class="example">$ srptool --passwd /etc/tpasswd --passwd-conf /etc/tpasswd.conf -u test
</pre></div>


<p>This command will check against a password. If the password matches
the one in <samp>/etc/tpasswd</samp> you will get an ok.
</p><div class="example">
<pre class="example">$ srptool --passwd /etc/tpasswd --passwd\-conf /etc/tpasswd.conf --verify -u test
</pre></div>

<hr>
<span id="Anonymous-authentication"></span><div class="header">
<p>
Previous: <a href="#SRP-authentication" accesskey="p" rel="prev">SRP authentication</a>, Up: <a href="#Shared_002dkey-and-anonymous-authentication" accesskey="u" rel="up">Shared-key and anonymous authentication</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Anonymous-authentication-1"></span><h4 class="subsection">4.3.3 Anonymous authentication</h4>
<span id="index-anonymous-authentication"></span>

<p>The anonymous key exchange offers encryption without any
indication of the peer&rsquo;s identity.  This kind of authentication
is vulnerable to a man in the middle attack, but can be
used even if there is no prior communication or shared trusted parties 
with the peer. It is useful to establish a session over which certificate
authentication will occur in order to hide the indentities of the participants
from passive eavesdroppers. It is only available under TLS 1.2 or earlier
versions.
</p>
<p>Unless in the above case, it is not recommended to use anonymous authentication. 
In the cases where there is no prior communication with the peers, 
an alternative with better properties, such as key continuity, is trust on first use
(see <a href="#Verifying-a-certificate-using-trust-on-first-use-authentication">Verifying a certificate using trust on first use authentication</a>).
</p>
<p>The available key exchange algorithms for anonymous authentication are
shown below, but note that few public servers support them, and they 
have to be explicitly enabled. These ciphersuites are negotiated only under
TLS 1.2.
</p>
<dl compact="compact">
<dt><code>ANON_DH:</code></dt>
<dd><p>This algorithm exchanges Diffie-Hellman parameters.
</p>
</dd>
<dt><code>ANON_ECDH:</code></dt>
<dd><p>This algorithm exchanges elliptic curve Diffie-Hellman parameters. It is more 
efficient than ANON_DH on equivalent security levels.
</p>
</dd>
</dl>

<hr>
<span id="Selecting-an-appropriate-authentication-method"></span><div class="header">
<p>
Previous: <a href="#Shared_002dkey-and-anonymous-authentication" accesskey="p" rel="prev">Shared-key and anonymous authentication</a>, Up: <a href="#Authentication-methods" accesskey="u" rel="up">Authentication methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Selecting-an-appropriate-authentication-method-1"></span><h3 class="section">4.4 Selecting an appropriate authentication method</h3>

<p>This section provides some guidance on how to use the available authentication
methods in <acronym>GnuTLS</acronym> in various scenarios.
</p>
<span id="Two-peers-with-an-out_002dof_002dband-channel"></span><h4 class="subsection">4.4.1 Two peers with an out-of-band channel</h4>

<p>Let&rsquo;s consider two peers who need to communicate over an untrusted channel
(the Internet), but have an out-of-band channel available. The latter
channel is considered safe from eavesdropping and message modification and thus
can be used for an initial bootstrapping of the protocol. The options 
available are:
</p><ul>
<li> Pre-shared keys (see <a href="#PSK-authentication">PSK authentication</a>). The server and a
client communicate a shared randomly generated key over the trusted
channel and use it to negotiate further sessions over the untrusted channel.

</li><li> Passwords (see <a href="#SRP-authentication">SRP authentication</a>). The client communicates
to the server its username and password of choice and uses it to
negotiate further sessions over the untrusted channel.

</li><li> Public keys (see <a href="#Certificate-authentication">Certificate authentication</a>). The client 
and the server exchange their public keys (or fingerprints of them)
over the trusted channel. 
On future sessions over the untrusted channel they verify the key
being the same (similar to <a href="#Verifying-a-certificate-using-trust-on-first-use-authentication">Verifying a certificate using trust on first use authentication</a>).
</li></ul>

<p>Provided that the out-of-band channel is trusted all of the above provide
a similar level of protection. An out-of-band channel may be the initial
bootstrapping of a user&rsquo;s PC in a corporate environment, in-person
communication, communication over an alternative network (e.g. the phone
network), etc.
</p>
<span id="Two-peers-without-an-out_002dof_002dband-channel"></span><h4 class="subsection">4.4.2 Two peers without an out-of-band channel</h4>

<p>When an out-of-band channel is not available a peer cannot be reliably
authenticated. What can be done, however, is to allow some form of
registration of users connecting for the first time and ensure that their
keys remain the same after that initial connection. This is termed
key continuity or trust on first use (TOFU).
</p>
<p>The available option is to use public key authentication (see <a href="#Certificate-authentication">Certificate authentication</a>). 
The client and the server store each other&rsquo;s public keys (or fingerprints of them)
and associate them with their identity.
On future sessions over the untrusted channel they verify the keys
being the same (see <a href="#Verifying-a-certificate-using-trust-on-first-use-authentication">Verifying a certificate using trust on first use authentication</a>).
</p>
<p>To mitigate the uncertainty of the information exchanged in the first 
connection other channels over the Internet may be used, e.g., <acronym>DNSSEC</acronym>
(see <a href="#Verifying-a-certificate-using-DANE">Verifying a certificate using DANE</a>).
</p>
<span id="Two-peers-and-a-trusted-third-party"></span><h4 class="subsection">4.4.3 Two peers and a trusted third party</h4>

<p>When a trusted third party is available (or a certificate authority) 
the most suitable option is to use 
certificate authentication (see <a href="#Certificate-authentication">Certificate authentication</a>). 
The client and the server obtain certificates that associate their identity
and public keys using a digital signature by the trusted party and use 
them to on the subsequent communications with each other. 
Each party verifies the peer&rsquo;s certificate using the trusted third party&rsquo;s 
signature. The parameters of the third party&rsquo;s signature are present
in its certificate which must be available to all communicating parties.
</p>
<p>While the above is the typical authentication method for servers in the
Internet by using the commercial CAs, the users that act as clients in the
protocol rarely possess such certificates. In that case a hybrid method
can be used where the server is authenticated by the client using the
commercial CAs and the client is authenticated based on some information
the client provided over the initial server-authenticated channel. The
available options are:
</p><ul>
<li> Passwords (see <a href="#SRP-authentication">SRP authentication</a>). The client communicates
to the server its username and password of choice on the initial
server-authenticated connection and uses it to negotiate further sessions. 
This is possible because the SRP protocol allows for the server to be 
authenticated using a certificate and the client using the
password.

</li><li> Public keys (see <a href="#Certificate-authentication">Certificate authentication</a>). The client 
sends its public key to the server (or a fingerprint of it) over the
initial server-authenticated connection. 
On future sessions the client verifies the server using the third party
certificate and the server verifies that the client&rsquo;s public key remained 
the same (see <a href="#Verifying-a-certificate-using-trust-on-first-use-authentication">Verifying a certificate using trust on first use authentication</a>).
</li></ul>


<hr>
<span id="Hardware-security-modules-and-abstract-key-types"></span><div class="header">
<p>
Next: <a href="#How-to-use-GnuTLS-in-applications" accesskey="n" rel="next">How to use GnuTLS in applications</a>, Previous: <a href="#Authentication-methods" accesskey="p" rel="prev">Authentication methods</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Abstract-key-types-and-Hardware-security-modules"></span><h2 class="chapter">5 Abstract key types and Hardware security modules</h2>

<p>In several cases storing the long term cryptographic keys in a hard disk or
even in memory poses a significant risk. Once the system they are stored
is compromised the keys must be replaced as the secrecy of future sessions
is no longer guaranteed. Moreover, past sessions that were not protected by a
perfect forward secrecy offering ciphersuite are also to be assumed compromised.
</p>
<p>If such threats need to be addressed, then it may be wise storing the keys in a security
module such as a smart card, an HSM or the TPM chip. Those modules ensure the
protection of the cryptographic keys by only allowing operations on them and
preventing their extraction. The purpose of the abstract key API is to provide
an API that will allow the handle of keys in memory and files, as well as keys
stored in such modules.
</p>
<p>In GnuTLS the approach is to handle all keys transparently by the high level API, e.g.,
the API that loads a key or certificate from a file.
The high-level API will accept URIs in addition to files that specify keys on an HSM or in TPM,
and a callback function will be used to obtain any required keys. The URI format is defined in
[<a href="#PKCS11URI">PKCS11URI</a>].
</p>
<p>More information on the API is provided in the next sections. Examples of a URI of a certificate 
stored in an HSM, as well as a key stored in the TPM chip are shown below. To discover the URIs 
of the objects the <code>p11tool</code> (see <a href="#p11tool-Invocation">p11tool Invocation</a>).
</p><div class="example">
<pre class="example">pkcs11:token=Nikos;serial=307521161601031;model=PKCS%2315; \
manufacturer=EnterSafe;object=test1;type=cert

</pre></div>


<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Abstract-key-types" accesskey="1">Abstract key types</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Application_002dspecific-keys" accesskey="2">Application-specific keys</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Smart-cards-and-HSMs" accesskey="3">Smart cards and HSMs</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Trusted-Platform-Module" accesskey="4">Trusted Platform Module</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Abstract-key-types"></span><div class="header">
<p>
Next: <a href="#Application_002dspecific-keys" accesskey="n" rel="next">Application-specific keys</a>, Up: <a href="#Hardware-security-modules-and-abstract-key-types" accesskey="u" rel="up">Hardware security modules and abstract key types</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Abstract-key-types-1"></span><h3 class="section">5.1 Abstract key types</h3>
<span id="index-abstract-types"></span>

<p>Since there are many forms of a public or private keys supported by <acronym>GnuTLS</acronym> such as
<acronym>X.509</acronym>, <acronym>PKCS</acronym> #11 or TPM it is desirable to allow common operations
on them. For these reasons the abstract <code>gnutls_privkey_t</code> and <code>gnutls_pubkey_t</code> were
introduced in <code>gnutls/abstract.h</code> header. Those types are initialized using a specific type of 
key and then can be used to perform operations in an abstract way. For example in order
to sign an X.509 certificate with a key that resides in a token the following steps can be
used.
</p>
<div class="example">
<pre class="example">#include &lt;gnutls/abstract.h&gt;

void sign_cert( gnutls_x509_crt_t to_be_signed)
{
gnutls_x509_crt_t ca_cert;
gnutls_privkey_t abs_key;

  /* initialize the abstract key */
  gnutls_privkey_init(&amp;abs_key);

  /* keys stored in tokens are identified by URLs */
  gnutls_privkey_import_url(abs_key, key_url);

  gnutls_x509_crt_init(&amp;ca_cert);
  gnutls_x509_crt_import_url(&amp;ca_cert, cert_url);

  /* sign the certificate to be signed */
  gnutls_x509_crt_privkey_sign(to_be_signed, ca_cert, abs_key, 
                               GNUTLS_DIG_SHA256, 0);
}
</pre></div>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Abstract-public-keys" accesskey="1">Abstract public keys</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Abstract-private-keys" accesskey="2">Abstract private keys</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Operations" accesskey="3">Operations</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Abstract-public-keys"></span><div class="header">
<p>
Next: <a href="#Abstract-private-keys" accesskey="n" rel="next">Abstract private keys</a>, Up: <a href="#Abstract-key-types" accesskey="u" rel="up">Abstract key types</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Public-keys"></span><h4 class="subsection">5.1.1 Public keys</h4>
<p>An abstract <code>gnutls_pubkey_t</code> can be initialized and freed by
using the functions below.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fpubkey_005finit">gnutls_pubkey_init</a> (gnutls_pubkey_t * <var>key</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005fpubkey_005fdeinit">gnutls_pubkey_deinit</a> (gnutls_pubkey_t <var>key</var>)</code></dt>
</dl>

<p>After initialization its values can be imported from
an existing structure like <code>gnutls_x509_crt_t</code>,
or through an ASN.1 encoding of the X.509 <code>SubjectPublicKeyInfo</code>
sequence.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fpubkey_005fimport_005fx509">gnutls_pubkey_import_x509</a> (gnutls_pubkey_t <var>key</var>, gnutls_x509_crt_t <var>crt</var>, unsigned int <var>flags</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpubkey_005fimport_005fpkcs11">gnutls_pubkey_import_pkcs11</a> (gnutls_pubkey_t <var>key</var>, gnutls_pkcs11_obj_t <var>obj</var>, unsigned int <var>flags</var>)</code></dt>
</dl>

<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fpubkey_005fimport_005furl">gnutls_pubkey_import_url</a> (gnutls_pubkey_t <var>key</var>, const char * <var>url</var>, unsigned int <var>flags</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpubkey_005fimport_005fprivkey">gnutls_pubkey_import_privkey</a> (gnutls_pubkey_t <var>key</var>, gnutls_privkey_t <var>pkey</var>, unsigned int <var>usage</var>, unsigned int <var>flags</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpubkey_005fimport">gnutls_pubkey_import</a> (gnutls_pubkey_t <var>key</var>, const gnutls_datum_t * <var>data</var>, gnutls_x509_crt_fmt_t <var>format</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpubkey_005fexport">gnutls_pubkey_export</a> (gnutls_pubkey_t <var>key</var>, gnutls_x509_crt_fmt_t <var>format</var>, void * <var>output_data</var>, size_t * <var>output_data_size</var>)</code></dt>
</dl>





<dl>
<dt id="index-gnutls_005fpubkey_005fexport2">Function: <em>int</em> <strong>gnutls_pubkey_export2</strong> <em>(gnutls_pubkey_t <var>key</var>, gnutls_x509_crt_fmt_t <var>format</var>, gnutls_datum_t * <var>out</var>)</em></dt>
<dd><p><var>key</var>: Holds the certificate
</p>
<p><var>format</var>: the format of output params. One of PEM or DER.
</p>
<p><var>out</var>: will contain a certificate PEM or DER encoded
</p>
<p>This function will export the public key to DER or PEM format.
The contents of the exported data is the SubjectPublicKeyInfo
X.509 structure.
</p>
<p>The output buffer will be allocated using <code>gnutls_malloc()</code> .
</p>
<p>If the structure is PEM encoded, it will have a header
of &quot;BEGIN CERTIFICATE&quot;.
</p>
<p><strong>Returns:</strong> In case of failure a negative error code will be
returned, and 0 on success.
</p>
<p><strong>Since:</strong> 3.1.3
</p></dd></dl>

<p>Other helper functions that allow directly importing from raw X.509 structures are shown below.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fpubkey_005fimport_005fx509_005fraw">gnutls_pubkey_import_x509_raw</a> (gnutls_pubkey_t <var>pkey</var>, const gnutls_datum_t * <var>data</var>, gnutls_x509_crt_fmt_t <var>format</var>, unsigned int <var>flags</var>)</code></dt>
</dl>

<p>An important function is <a href="#gnutls_005fpubkey_005fimport_005furl">gnutls_pubkey_import_url</a> which will import
public keys from URLs that identify objects stored in tokens (see <a href="#Smart-cards-and-HSMs">Smart cards and HSMs</a> and <a href="#Trusted-Platform-Module">Trusted Platform Module</a>).
A function to check for a supported by GnuTLS URL is <a href="#gnutls_005furl_005fis_005fsupported">gnutls_url_is_supported</a>.
</p>




<dl>
<dt id="index-gnutls_005furl_005fis_005fsupported">Function: <em>unsigned</em> <strong>gnutls_url_is_supported</strong> <em>(const char * <var>url</var>)</em></dt>
<dd><p><var>url</var>: A URI to be tested
</p>
<p>Check whether the provided  <code>url</code> is supported.  Depending on the system libraries
GnuTLS may support pkcs11, tpmkey or other URLs.
</p>
<p><strong>Returns:</strong> return non-zero if the given URL is supported, and zero if
it is not known.
</p>
<p><strong>Since:</strong> 3.1.0
</p></dd></dl>

<p>Additional functions are available that will return
information over a public key, such as a unique key ID, as well as a function 
that given a public key fingerprint would provide a memorable sketch.
</p>
<p>Note that <a href="#gnutls_005fpubkey_005fget_005fkey_005fid">gnutls_pubkey_get_key_id</a> calculates a SHA1 digest of the 
public key as a DER-formatted, subjectPublicKeyInfo object.  Other implementations 
use different approaches, e.g., some use the &ldquo;common method&rdquo; described in
section 4.2.1.2 of [<a href="#RFC5280">RFC5280</a>] which calculates a digest on a part of the
subjectPublicKeyInfo object.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fpubkey_005fget_005fpk_005falgorithm">gnutls_pubkey_get_pk_algorithm</a> (gnutls_pubkey_t <var>key</var>, unsigned int * <var>bits</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpubkey_005fget_005fpreferred_005fhash_005falgorithm">gnutls_pubkey_get_preferred_hash_algorithm</a> (gnutls_pubkey_t <var>key</var>, gnutls_digest_algorithm_t *         <var>hash</var>, unsigned int * <var>mand</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpubkey_005fget_005fkey_005fid">gnutls_pubkey_get_key_id</a> (gnutls_pubkey_t <var>key</var>, unsigned int <var>flags</var>, unsigned char * <var>output_data</var>, size_t * <var>output_data_size</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005frandom_005fart">gnutls_random_art</a> (gnutls_random_art_t <var>type</var>, const char * <var>key_type</var>, unsigned int <var>key_size</var>, void * <var>fpr</var>, size_t <var>fpr_size</var>, gnutls_datum_t * <var>art</var>)</code></dt>
</dl>

<p>To export the key-specific parameters, or obtain a unique key ID the following functions are provided.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fpubkey_005fexport_005frsa_005fraw2">gnutls_pubkey_export_rsa_raw2</a> (gnutls_pubkey_t <var>key</var>, gnutls_datum_t * <var>m</var>, gnutls_datum_t * <var>e</var>, unsigned <var>flags</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpubkey_005fexport_005fdsa_005fraw2">gnutls_pubkey_export_dsa_raw2</a> (gnutls_pubkey_t <var>key</var>, gnutls_datum_t * <var>p</var>, gnutls_datum_t * <var>q</var>, gnutls_datum_t * <var>g</var>, gnutls_datum_t * <var>y</var>, unsigned <var>flags</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpubkey_005fexport_005fecc_005fraw2">gnutls_pubkey_export_ecc_raw2</a> (gnutls_pubkey_t <var>key</var>, gnutls_ecc_curve_t * <var>curve</var>, gnutls_datum_t * <var>x</var>, gnutls_datum_t * <var>y</var>, unsigned int <var>flags</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpubkey_005fexport_005fecc_005fx962">gnutls_pubkey_export_ecc_x962</a> (gnutls_pubkey_t <var>key</var>, gnutls_datum_t * <var>parameters</var>, gnutls_datum_t * <var>ecpoint</var>)</code></dt>
</dl>

<hr>
<span id="Abstract-private-keys"></span><div class="header">
<p>
Next: <a href="#Operations" accesskey="n" rel="next">Operations</a>, Previous: <a href="#Abstract-public-keys" accesskey="p" rel="prev">Abstract public keys</a>, Up: <a href="#Abstract-key-types" accesskey="u" rel="up">Abstract key types</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Private-keys"></span><h4 class="subsection">5.1.2 Private keys</h4>
<p>An abstract <code>gnutls_privkey_t</code> can be initialized and freed by
using the functions below.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fprivkey_005finit">gnutls_privkey_init</a> (gnutls_privkey_t * <var>key</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005fprivkey_005fdeinit">gnutls_privkey_deinit</a> (gnutls_privkey_t <var>key</var>)</code></dt>
</dl>

<p>After initialization its values can be imported from
an existing structure like <code>gnutls_x509_privkey_t</code>,
but unlike public keys it cannot be exported. That is
to allow abstraction over keys stored in hardware that 
makes available only operations.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fprivkey_005fimport_005fx509">gnutls_privkey_import_x509</a> (gnutls_privkey_t <var>pkey</var>, gnutls_x509_privkey_t <var>key</var>, unsigned int <var>flags</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fprivkey_005fimport_005fpkcs11">gnutls_privkey_import_pkcs11</a> (gnutls_privkey_t <var>pkey</var>, gnutls_pkcs11_privkey_t <var>key</var>, unsigned int <var>flags</var>)</code></dt>
</dl>

<p>Other helper functions that allow directly importing from raw X.509
structures are shown below. Again, as with public keys, private keys
can be imported from a hardware module using URLs.
</p>




<dl>
<dt id="index-gnutls_005fprivkey_005fimport_005furl">Function: <em>int</em> <strong>gnutls_privkey_import_url</strong> <em>(gnutls_privkey_t <var>key</var>, const char * <var>url</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>key</var>: A key of type <code>gnutls_privkey_t</code> 
</p>
<p><var>url</var>: A PKCS 11 url
</p>
<p><var>flags</var>: should be zero
</p>
<p>This function will import a PKCS11 or TPM URL as a
private key. The supported URL types can be checked
using <code>gnutls_url_is_supported()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.1.0
</p></dd></dl>

<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fprivkey_005fimport_005fx509_005fraw">gnutls_privkey_import_x509_raw</a> (gnutls_privkey_t <var>pkey</var>, const gnutls_datum_t * <var>data</var>, gnutls_x509_crt_fmt_t <var>format</var>, const char * <var>password</var>, unsigned int <var>flags</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fprivkey_005fget_005fpk_005falgorithm">gnutls_privkey_get_pk_algorithm</a> (gnutls_privkey_t <var>key</var>, unsigned int * <var>bits</var>)</code></dt>
<dt><code><var>gnutls_privkey_type_t</var> <a href="#gnutls_005fprivkey_005fget_005ftype">gnutls_privkey_get_type</a> (gnutls_privkey_t <var>key</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fprivkey_005fstatus">gnutls_privkey_status</a> (gnutls_privkey_t <var>key</var>)</code></dt>
</dl>

<p>In order to support cryptographic operations using 
an external API, the following function is provided.
This allows for a simple extensibility API without
resorting to <acronym>PKCS</acronym> #11.
</p>




<dl>
<dt id="index-gnutls_005fprivkey_005fimport_005fext4">Function: <em>int</em> <strong>gnutls_privkey_import_ext4</strong> <em>(gnutls_privkey_t <var>pkey</var>, void * <var>userdata</var>, gnutls_privkey_sign_data_func <var>sign_data_fn</var>, gnutls_privkey_sign_hash_func <var>sign_hash_fn</var>, gnutls_privkey_decrypt_func <var>decrypt_fn</var>, gnutls_privkey_deinit_func <var>deinit_fn</var>, gnutls_privkey_info_func <var>info_fn</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>pkey</var>: The private key
</p>
<p><var>userdata</var>: private data to be provided to the callbacks
</p>
<p><var>sign_data_fn</var>: callback for signature operations (may be <code>NULL</code> )
</p>
<p><var>sign_hash_fn</var>: callback for signature operations (may be <code>NULL</code> )
</p>
<p><var>decrypt_fn</var>: callback for decryption operations (may be <code>NULL</code> )
</p>
<p><var>deinit_fn</var>: a deinitialization function
</p>
<p><var>info_fn</var>: returns info about the public key algorithm (should not be <code>NULL</code> )
</p>
<p><var>flags</var>: Flags for the import
</p>
<p>This function will associate the given callbacks with the
<code>gnutls_privkey_t</code>  type. At least one of the callbacks
must be non-null. If a deinitialization function is provided
then flags is assumed to contain <code>GNUTLS_PRIVKEY_IMPORT_AUTO_RELEASE</code> .
</p>
<p>Note that in contrast with the signing function of
<code>gnutls_privkey_import_ext3()</code> , the signing functions provided to this
function take explicitly the signature algorithm as parameter and
different functions are provided to sign the data and hashes.
</p>
<p>The  <code>sign_hash_fn</code> is to be called to sign pre-hashed data. The input
to the callback is the output of the hash (such as SHA256) corresponding
to the signature algorithm. For RSA PKCS<code>1</code>  signatures, the signature
algorithm can be set to <code>GNUTLS_SIGN_RSA_RAW</code> , and in that case the data
should be handled as if they were an RSA PKCS<code>1</code>  DigestInfo structure.
</p>
<p>The  <code>sign_data_fn</code> is to be called to sign data. The input data will be
he data to be signed (and hashed), with the provided signature
algorithm. This function is to be used for signature algorithms like
Ed25519 which cannot take pre-hashed data as input.
</p>
<p>When both  <code>sign_data_fn</code> and  <code>sign_hash_fn</code> functions are provided they
must be able to operate on all the supported signature algorithms,
unless prohibited by the type of the algorithm (e.g., as with Ed25519).
</p>
<p>The  <code>info_fn</code> must provide information on the signature algorithms supported by
this private key, and should support the flags <code>GNUTLS_PRIVKEY_INFO_PK_ALGO</code> ,
<code>GNUTLS_PRIVKEY_INFO_HAVE_SIGN_ALGO</code>  and <code>GNUTLS_PRIVKEY_INFO_PK_ALGO_BITS</code> .
It must return -1 on unknown flags.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.6.0
</p></dd></dl>

<p>On the private keys where exporting of parameters is possible (i.e.,
software keys), the following functions are also available.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fprivkey_005fexport_005frsa_005fraw2">gnutls_privkey_export_rsa_raw2</a> (gnutls_privkey_t <var>key</var>, gnutls_datum_t * <var>m</var>, gnutls_datum_t * <var>e</var>, gnutls_datum_t * <var>d</var>, gnutls_datum_t * <var>p</var>, gnutls_datum_t * <var>q</var>, gnutls_datum_t * <var>u</var>, gnutls_datum_t * <var>e1</var>, gnutls_datum_t * <var>e2</var>, unsigned int <var>flags</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fprivkey_005fexport_005fdsa_005fraw2">gnutls_privkey_export_dsa_raw2</a> (gnutls_privkey_t <var>key</var>, gnutls_datum_t * <var>p</var>, gnutls_datum_t * <var>q</var>, gnutls_datum_t * <var>g</var>, gnutls_datum_t * <var>y</var>, gnutls_datum_t * <var>x</var>, unsigned int <var>flags</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fprivkey_005fexport_005fecc_005fraw2">gnutls_privkey_export_ecc_raw2</a> (gnutls_privkey_t <var>key</var>, gnutls_ecc_curve_t * <var>curve</var>, gnutls_datum_t * <var>x</var>, gnutls_datum_t * <var>y</var>, gnutls_datum_t * <var>k</var>, unsigned int <var>flags</var>)</code></dt>
</dl>

<hr>
<span id="Operations"></span><div class="header">
<p>
Previous: <a href="#Abstract-private-keys" accesskey="p" rel="prev">Abstract private keys</a>, Up: <a href="#Abstract-key-types" accesskey="u" rel="up">Abstract key types</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Operations-1"></span><h4 class="subsection">5.1.3 Operations</h4>
<p>The abstract key types can be used to access signing and
signature verification operations with the underlying keys.
</p>




<dl>
<dt id="index-gnutls_005fpubkey_005fverify_005fdata2">Function: <em>int</em> <strong>gnutls_pubkey_verify_data2</strong> <em>(gnutls_pubkey_t <var>pubkey</var>, gnutls_sign_algorithm_t <var>algo</var>, unsigned int <var>flags</var>, const gnutls_datum_t * <var>data</var>, const gnutls_datum_t * <var>signature</var>)</em></dt>
<dd><p><var>pubkey</var>: Holds the public key
</p>
<p><var>algo</var>: The signature algorithm used
</p>
<p><var>flags</var>: Zero or an OR list of <code>gnutls_certificate_verify_flags</code> 
</p>
<p><var>data</var>: holds the signed data
</p>
<p><var>signature</var>: contains the signature
</p>
<p>This function will verify the given signed data, using the
parameters from the certificate.
</p>
<p><strong>Returns:</strong> In case of a verification failure <code>GNUTLS_E_PK_SIG_VERIFY_FAILED</code>  
is returned, and zero or positive code on success. For known to be insecure
signatures this function will return <code>GNUTLS_E_INSUFFICIENT_SECURITY</code>  unless
the flag <code>GNUTLS_VERIFY_ALLOW_BROKEN</code>  is specified.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>




<dl>
<dt id="index-gnutls_005fpubkey_005fverify_005fhash2">Function: <em>int</em> <strong>gnutls_pubkey_verify_hash2</strong> <em>(gnutls_pubkey_t <var>key</var>, gnutls_sign_algorithm_t <var>algo</var>, unsigned int <var>flags</var>, const gnutls_datum_t * <var>hash</var>, const gnutls_datum_t * <var>signature</var>)</em></dt>
<dd><p><var>key</var>: Holds the public key
</p>
<p><var>algo</var>: The signature algorithm used
</p>
<p><var>flags</var>: Zero or an OR list of <code>gnutls_certificate_verify_flags</code> 
</p>
<p><var>hash</var>: holds the hash digest to be verified
</p>
<p><var>signature</var>: contains the signature
</p>
<p>This function will verify the given signed digest, using the
parameters from the public key. Note that unlike <code>gnutls_privkey_sign_hash()</code> ,
this function accepts a signature algorithm instead of a digest algorithm.
You can use <code>gnutls_pk_to_sign()</code>  to get the appropriate value.
</p>
<p><strong>Returns:</strong> In case of a verification failure <code>GNUTLS_E_PK_SIG_VERIFY_FAILED</code>  
is returned, and zero or positive code on success. For known to be insecure
signatures this function will return <code>GNUTLS_E_INSUFFICIENT_SECURITY</code>  unless
the flag <code>GNUTLS_VERIFY_ALLOW_BROKEN</code>  is specified.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>




<dl>
<dt id="index-gnutls_005fpubkey_005fencrypt_005fdata">Function: <em>int</em> <strong>gnutls_pubkey_encrypt_data</strong> <em>(gnutls_pubkey_t <var>key</var>, unsigned int <var>flags</var>, const gnutls_datum_t * <var>plaintext</var>, gnutls_datum_t * <var>ciphertext</var>)</em></dt>
<dd><p><var>key</var>: Holds the public key
</p>
<p><var>flags</var>: should be 0 for now
</p>
<p><var>plaintext</var>: The data to be encrypted
</p>
<p><var>ciphertext</var>: contains the encrypted data
</p>
<p>This function will encrypt the given data, using the public
key. On success the  <code>ciphertext</code> will be allocated using <code>gnutls_malloc()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>





<dl>
<dt id="index-gnutls_005fprivkey_005fsign_005fdata">Function: <em>int</em> <strong>gnutls_privkey_sign_data</strong> <em>(gnutls_privkey_t <var>signer</var>, gnutls_digest_algorithm_t <var>hash</var>, unsigned int <var>flags</var>, const gnutls_datum_t * <var>data</var>, gnutls_datum_t * <var>signature</var>)</em></dt>
<dd><p><var>signer</var>: Holds the key
</p>
<p><var>hash</var>: should be a digest algorithm
</p>
<p><var>flags</var>: Zero or one of <code>gnutls_privkey_flags_t</code> 
</p>
<p><var>data</var>: holds the data to be signed
</p>
<p><var>signature</var>: will contain the signature allocated with <code>gnutls_malloc()</code> 
</p>
<p>This function will sign the given data using a signature algorithm
supported by the private key. Signature algorithms are always used
together with a hash functions.  Different hash functions may be
used for the RSA algorithm, but only the SHA family for the DSA keys.
</p>
<p>You may use <code>gnutls_pubkey_get_preferred_hash_algorithm()</code>  to determine
the hash algorithm.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>




<dl>
<dt id="index-gnutls_005fprivkey_005fsign_005fhash">Function: <em>int</em> <strong>gnutls_privkey_sign_hash</strong> <em>(gnutls_privkey_t <var>signer</var>, gnutls_digest_algorithm_t <var>hash_algo</var>, unsigned int <var>flags</var>, const gnutls_datum_t * <var>hash_data</var>, gnutls_datum_t * <var>signature</var>)</em></dt>
<dd><p><var>signer</var>: Holds the signer&rsquo;s key
</p>
<p><var>hash_algo</var>: The hash algorithm used
</p>
<p><var>flags</var>: Zero or one of <code>gnutls_privkey_flags_t</code> 
</p>
<p><var>hash_data</var>: holds the data to be signed
</p>
<p><var>signature</var>: will contain newly allocated signature
</p>
<p>This function will sign the given hashed data using a signature algorithm
supported by the private key. Signature algorithms are always used
together with a hash functions.  Different hash functions may be
used for the RSA algorithm, but only SHA-XXX for the DSA keys.
</p>
<p>You may use <code>gnutls_pubkey_get_preferred_hash_algorithm()</code>  to determine
the hash algorithm.
</p>
<p>The flags may be <code>GNUTLS_PRIVKEY_SIGN_FLAG_TLS1_RSA</code>  or <code>GNUTLS_PRIVKEY_SIGN_FLAG_RSA_PSS</code> .
In the former case this function will ignore  <code>hash_algo</code> and perform a raw PKCS1 signature,
and in the latter an RSA-PSS signature will be generated.
</p>
<p>Note that, not all algorithm support signing already hashed data. When
signing with Ed25519, <code>gnutls_privkey_sign_data()</code>  should be used.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>




<dl>
<dt id="index-gnutls_005fprivkey_005fdecrypt_005fdata">Function: <em>int</em> <strong>gnutls_privkey_decrypt_data</strong> <em>(gnutls_privkey_t <var>key</var>, unsigned int <var>flags</var>, const gnutls_datum_t * <var>ciphertext</var>, gnutls_datum_t * <var>plaintext</var>)</em></dt>
<dd><p><var>key</var>: Holds the key
</p>
<p><var>flags</var>: zero for now
</p>
<p><var>ciphertext</var>: holds the data to be decrypted
</p>
<p><var>plaintext</var>: will contain the decrypted data, allocated with <code>gnutls_malloc()</code> 
</p>
<p>This function will decrypt the given data using the algorithm
supported by the private key.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<p>Signing existing structures, such as certificates, CRLs,
or certificate requests, as well as associating public
keys with structures is also possible using the 
key abstractions.
</p>




<dl>
<dt id="index-gnutls_005fx509_005fcrq_005fset_005fpubkey">Function: <em>int</em> <strong>gnutls_x509_crq_set_pubkey</strong> <em>(gnutls_x509_crq_t <var>crq</var>, gnutls_pubkey_t <var>key</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>key</var>: holds a public key
</p>
<p>This function will set the public parameters from the given public
key to the request. The  <code>key</code> can be deallocated after that.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>




<dl>
<dt id="index-gnutls_005fx509_005fcrt_005fset_005fpubkey">Function: <em>int</em> <strong>gnutls_x509_crt_set_pubkey</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_pubkey_t <var>key</var>)</em></dt>
<dd><p><var>crt</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>key</var>: holds a public key
</p>
<p>This function will set the public parameters from the given public
key to the certificate. The  <code>key</code> can be deallocated after that.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrt_005fprivkey_005fsign">gnutls_x509_crt_privkey_sign</a> (gnutls_x509_crt_t <var>crt</var>, gnutls_x509_crt_t <var>issuer</var>, gnutls_privkey_t <var>issuer_key</var>, gnutls_digest_algorithm_t <var>dig</var>, unsigned int <var>flags</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrl_005fprivkey_005fsign">gnutls_x509_crl_privkey_sign</a> (gnutls_x509_crl_t <var>crl</var>, gnutls_x509_crt_t <var>issuer</var>, gnutls_privkey_t <var>issuer_key</var>, gnutls_digest_algorithm_t <var>dig</var>, unsigned int <var>flags</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrq_005fprivkey_005fsign">gnutls_x509_crq_privkey_sign</a> (gnutls_x509_crq_t <var>crq</var>, gnutls_privkey_t <var>key</var>, gnutls_digest_algorithm_t <var>dig</var>, unsigned int <var>flags</var>)</code></dt>
</dl>


<hr>
<span id="Application_002dspecific-keys"></span><div class="header">
<p>
Next: <a href="#Smart-cards-and-HSMs" accesskey="n" rel="next">Smart cards and HSMs</a>, Previous: <a href="#Abstract-key-types" accesskey="p" rel="prev">Abstract key types</a>, Up: <a href="#Hardware-security-modules-and-abstract-key-types" accesskey="u" rel="up">Hardware security modules and abstract key types</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="System-and-application_002dspecific-keys"></span><h3 class="section">5.2 System and application-specific keys</h3>
<span id="index-Application_002dspecific-keys"></span>
<span id="index-System_002dspecific-keys"></span>

<span id="System_002dspecific-keys"></span><h4 class="subsection">5.2.1 System-specific keys</h4>
<p>In several systems there are keystores which allow to read, store and use certificates
and private keys. For these systems GnuTLS provides the system-key API in <code>gnutls/system-keys.h</code>.
That API provides the ability to iterate through all stored keys, add and delete keys as well
as use these keys using a URL which starts with &quot;system:&quot;. The format of the URLs is system-specific.
The <code>systemkey</code> tool is also provided to assist in listing keys and debugging.
</p>
<p>The systems supported via this API are the following.
</p><ul>
<li> Windows Cryptography API (CNG)
</li></ul>





<dl>
<dt id="index-gnutls_005fsystem_005fkey_005fiter_005fget_005finfo">Function: <em>int</em> <strong>gnutls_system_key_iter_get_info</strong> <em>(gnutls_system_key_iter_t * <var>iter</var>, unsigned <var>cert_type</var>, char ** <var>cert_url</var>, char ** <var>key_url</var>, char ** <var>label</var>, gnutls_datum_t * <var>der</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>iter</var>: an iterator of the system keys (must be set to <code>NULL</code>  initially)
</p>
<p><var>cert_type</var>: A value of gnutls_certificate_type_t which indicates the type of certificate to look for
</p>
<p><var>cert_url</var>: The certificate URL of the pair (may be <code>NULL</code> )
</p>
<p><var>key_url</var>: The key URL of the pair (may be <code>NULL</code> )
</p>
<p><var>label</var>: The friendly name (if any) of the pair (may be <code>NULL</code> )
</p>
<p><var>der</var>: if non-NULL the DER data of the certificate
</p>
<p><var>flags</var>: should be zero
</p>
<p>This function will return on each call a certificate
and key pair URLs, as well as a label associated with them,
and the DER-encoded certificate. When the iteration is complete it will
return <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> .
</p>
<p>Typically  <code>cert_type</code> should be <code>GNUTLS_CRT_X509</code> .
</p>
<p>All values set are allocated and must be cleared using <code>gnutls_free()</code> ,
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<dl compact="compact">
<dt><code><var>void</var> <a href="#gnutls_005fsystem_005fkey_005fiter_005fdeinit">gnutls_system_key_iter_deinit</a> (gnutls_system_key_iter_t <var>iter</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fsystem_005fkey_005fadd_005fx509">gnutls_system_key_add_x509</a> (gnutls_x509_crt_t <var>crt</var>, gnutls_x509_privkey_t <var>privkey</var>, const char * <var>label</var>, char ** <var>cert_url</var>, char ** <var>key_url</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fsystem_005fkey_005fdelete">gnutls_system_key_delete</a> (const char * <var>cert_url</var>, const char * <var>key_url</var>)</code></dt>
</dl>

<span id="Application_002dspecific-keys-1"></span><h4 class="subsection">5.2.2 Application-specific keys</h4>
<p>For systems where GnuTLS doesn&rsquo;t provide a system specific store,
it may often be desirable to define a custom class of keys
that are identified via URLs and available to GnuTLS calls such as <a href="#gnutls_005fcertificate_005fset_005fx509_005fkey_005ffile2">gnutls_certificate_set_x509_key_file2</a>.
Such keys can be registered using the API in <code>gnutls/urls.h</code>. The function
which registers such keys is <a href="#gnutls_005fregister_005fcustom_005furl">gnutls_register_custom_url</a>.
</p>




<dl>
<dt id="index-gnutls_005fregister_005fcustom_005furl">Function: <em>int</em> <strong>gnutls_register_custom_url</strong> <em>(const gnutls_custom_url_st * <var>st</var>)</em></dt>
<dd><p><var>st</var>: A <code>gnutls_custom_url_st</code>  structure
</p>
<p>Register a custom URL. This will affect the following functions:
<code>gnutls_url_is_supported()</code> , <code>gnutls_privkey_import_url()</code> ,
gnutls_pubkey_import_url, <code>gnutls_x509_crt_import_url()</code>  
and all functions that depend on
them, e.g., <code>gnutls_certificate_set_x509_key_file2()</code> .
</p>
<p>The provided structure and callback functions must be valid throughout
the lifetime of the process. The registration of an existing URL type
will fail with <code>GNUTLS_E_INVALID_REQUEST</code> . Since GnuTLS 3.5.0 this function
can be used to override the builtin URLs.
</p>
<p>This function is not thread safe.
</p>
<p><strong>Returns:</strong> returns zero if the given structure was imported or a negative value otherwise.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<p>The input to this function are three callback functions as well as
the prefix of the URL, (e.g., &quot;mypkcs11:&quot;) and the length of the prefix.
The types of the callbacks are shown below, and are expected to
use the exported gnutls functions to import the keys and certificates.
E.g., a typical <code>import_key</code> callback should use <a href="#gnutls_005fprivkey_005fimport_005fext4">gnutls_privkey_import_ext4</a>.
</p>
<div class="example">
<pre class="example">typedef int (*gnutls_privkey_import_url_func)(gnutls_privkey_t pkey,
                                              const char *url,
                                              unsigned flags);

typedef int (*gnutls_x509_crt_import_url_func)(gnutls_x509_crt_t pkey,
                                               const char *url,
                                               unsigned flags);

/* The following callbacks are optional */

/* This is to enable gnutls_pubkey_import_url() */
typedef int (*gnutls_pubkey_import_url_func)(gnutls_pubkey_t pkey,
					     const char *url, unsigned flags);

/* This is to allow constructing a certificate chain. It will be provided
 * the initial certificate URL and the certificate to find its issuer, and must
 * return zero and the DER encoding of the issuer's certificate. If not available,
 * it should return GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE. */
typedef int (*gnutls_get_raw_issuer_func)(const char *url, gnutls_x509_crt_t crt,
					  gnutls_datum_t *issuer_der, unsigned flags);

typedef struct custom_url_st {
        const char *name;
        unsigned name_size;
        gnutls_privkey_import_url_func import_key;
        gnutls_x509_crt_import_url_func import_crt;
        gnutls_pubkey_import_url_func import_pubkey;
	gnutls_get_raw_issuer_func get_issuer;
} gnutls_custom_url_st;
</pre></div>



<hr>
<span id="Smart-cards-and-HSMs"></span><div class="header">
<p>
Next: <a href="#Trusted-Platform-Module" accesskey="n" rel="next">Trusted Platform Module</a>, Previous: <a href="#Application_002dspecific-keys" accesskey="p" rel="prev">Application-specific keys</a>, Up: <a href="#Hardware-security-modules-and-abstract-key-types" accesskey="u" rel="up">Hardware security modules and abstract key types</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Smart-cards-and-HSMs-1"></span><h3 class="section">5.3 Smart cards and HSMs</h3>
<span id="index-PKCS-_002311-tokens"></span>
<span id="index-hardware-tokens"></span>
<span id="index-hardware-security-modules"></span>
<span id="index-smart-cards"></span>

<p>In this section we present the smart-card and hardware security module (HSM) support 
in <acronym>GnuTLS</acronym> using <acronym>PKCS</acronym> #11 [<a href="#PKCS11">PKCS11</a>]. Hardware security
modules and smart cards provide a way to store private keys and perform
operations on them without exposing them. This decouples cryptographic
keys from the applications that use them and provide an additional 
security layer against cryptographic key extraction.
Since this can also be achieved in software components such as in Gnome keyring,
we will use the term security module to describe any cryptographic key 
separation subsystem.
</p>
<p><acronym>PKCS</acronym> #11 is plugin API allowing applications to access cryptographic
operations on a security module, as well as to objects residing on it. PKCS
#11 modules exist for hardware tokens such as smart cards<a id="DOCF9" href="#FOOT9"><sup>9</sup></a>,
cryptographic tokens, as well as for software modules like <acronym>Gnome Keyring</acronym>. 
The objects residing on a security module may be certificates, public keys, 
private keys or secret keys. Of those certificates and public/private key 
pairs can be used with <acronym>GnuTLS</acronym>. PKCS #11&rsquo;s main advantage is that 
it allows operations on private key objects such as decryption
and signing without exposing the key. In GnuTLS the PKCS #11 functionality is
available in <code>gnutls/pkcs11.h</code>.
</p>
<div class="float"><span id="fig_002dpkcs11_002dvision"></span>
<img src="pkcs11-vision.png" alt="pkcs11-vision">

<div class="float-caption"><p><strong>Figure 5.1: </strong>PKCS #11 module usage.</p></div></div>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#PKCS11-Initialization" accesskey="1">PKCS11 Initialization</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#PKCS11-Manual-Initialization" accesskey="2">PKCS11 Manual Initialization</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Accessing-objects-that-require-a-PIN" accesskey="3">Accessing objects that require a PIN</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Reading-objects" accesskey="4">Reading objects</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Writing-objects" accesskey="5">Writing objects</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#PKCS11-Low-Level-Access" accesskey="6">PKCS11 Low Level Access</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Using-a-PKCS11-token-with-TLS" accesskey="7">Using a PKCS11 token with TLS</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Verifying-certificates-over-PKCS11" accesskey="8">Verifying certificates over PKCS11</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#p11tool-Invocation" accesskey="9">p11tool Invocation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="PKCS11-Initialization"></span><div class="header">
<p>
Next: <a href="#PKCS11-Manual-Initialization" accesskey="n" rel="next">PKCS11 Manual Initialization</a>, Up: <a href="#Smart-cards-and-HSMs" accesskey="u" rel="up">Smart cards and HSMs</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Initialization-1"></span><h4 class="subsection">5.3.1 Initialization</h4>
<p>To allow all <acronym>GnuTLS</acronym> applications to transparently access smart cards
and tokens, <acronym>PKCS</acronym> #11 is automatically initialized during the first
call of a <acronym>PKCS</acronym> #11 related function, in a thread safe way.
The default initialization process, utilizes p11-kit configuration, and loads any
appropriate <acronym>PKCS</acronym> #11 modules. The p11-kit configuration
files<a id="DOCF10" href="#FOOT10"><sup>10</sup></a> are typically stored in <code>/etc/pkcs11/modules/</code>.
For example a file that will instruct GnuTLS to load the <acronym>OpenSC</acronym> module,
could be named <code>/etc/pkcs11/modules/opensc.module</code> and contain the following:
</p>
<div class="example">
<pre class="example">module: /usr/lib/opensc-pkcs11.so
</pre></div>

<p>If you use these configuration files, then there is no need for other initialization in
<acronym>GnuTLS</acronym>, except for the PIN and token callbacks (see next section).
In several cases, however, it is desirable to limit badly behaving modules
(e.g., modules that add an unacceptable delay on initialization)
to single applications. That can be done using the &ldquo;enable-in:&rdquo; option
followed by the base name of applications that this module should be used.
</p>
<p>It is also possible to manually initialize or even disable the PKCS #11 subsystem if the 
default settings are not desirable or not available (see <a href="#PKCS11-Manual-Initialization">PKCS11 Manual Initialization</a>
for more information).
</p>
<p>Note that, PKCS #11 modules behave in a peculiar way after a fork; they
require a reinitialization of all the used PKCS #11 resources.
While GnuTLS automates that process, there are corner cases where
it is not possible to handle it correctly in an automated way<a id="DOCF11" href="#FOOT11"><sup>11</sup></a>. For that, it is
recommended not to mix fork() and PKCS #11 module usage. It is recommended
to initialize and use any PKCS #11 resources in a single process.
</p>
<p>Older versions of <acronym>GnuTLS</acronym> required to call <a href="#gnutls_005fpkcs11_005freinit">gnutls_pkcs11_reinit</a>
after a fork() call; since 3.3.0 this is no longer required.
</p>

<hr>
<span id="PKCS11-Manual-Initialization"></span><div class="header">
<p>
Next: <a href="#Accessing-objects-that-require-a-PIN" accesskey="n" rel="next">Accessing objects that require a PIN</a>, Previous: <a href="#PKCS11-Initialization" accesskey="p" rel="prev">PKCS11 Initialization</a>, Up: <a href="#Smart-cards-and-HSMs" accesskey="u" rel="up">Smart cards and HSMs</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Manual-initialization-of-user_002dspecific-modules"></span><h4 class="subsection">5.3.2 Manual initialization of user-specific modules</h4>

<p>In systems where one cannot rely on a globally available p11-kit configuration
to be available, it is still possible to utilize PKCS #11 objects. That
can be done by loading directly the PKCS #11 shared module in the
application using <a href="#gnutls_005fpkcs11_005fadd_005fprovider">gnutls_pkcs11_add_provider</a>, after having
called <a href="#gnutls_005fpkcs11_005finit">gnutls_pkcs11_init</a> specifying the <code>GNUTLS_PKCS11_FLAG_MANUAL</code>
flag.
</p>



<dl>
<dt id="index-gnutls_005fpkcs11_005fadd_005fprovider">Function: <em>int</em> <strong>gnutls_pkcs11_add_provider</strong> <em>(const char * <var>name</var>, const char * <var>params</var>)</em></dt>
<dd><p><var>name</var>: The filename of the module
</p>
<p><var>params</var>: should be NULL or a known string (see description)
</p>
<p>This function will load and add a PKCS 11 module to the module
list used in gnutls. After this function is called the module will
be used for PKCS 11 operations.
</p>
<p>When loading a module to be used for certificate verification,
use the string &rsquo;trusted&rsquo; as  <code>params</code> .
</p>
<p>Note that this function is not thread safe.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<p>In that case, the application will only have access to the modules explicitly
loaded. If the <code>GNUTLS_PKCS11_FLAG_MANUAL</code> flag is specified and no calls
to <a href="#gnutls_005fpkcs11_005fadd_005fprovider">gnutls_pkcs11_add_provider</a> are made, then the PKCS #11 functionality
is effectively disabled.
</p>




<dl>
<dt id="index-gnutls_005fpkcs11_005finit">Function: <em>int</em> <strong>gnutls_pkcs11_init</strong> <em>(unsigned int <var>flags</var>, const char * <var>deprecated_config_file</var>)</em></dt>
<dd><p><var>flags</var>: An ORed sequence of <code>GNUTLS_PKCS11_FLAG_</code> *
</p>
<p><var>deprecated_config_file</var>: either NULL or the location of a deprecated
configuration file
</p>
<p>This function will initialize the PKCS 11 subsystem in gnutls. It will
read configuration files if <code>GNUTLS_PKCS11_FLAG_AUTO</code>  is used or allow
you to independently load PKCS 11 modules using <code>gnutls_pkcs11_add_provider()</code> 
if <code>GNUTLS_PKCS11_FLAG_MANUAL</code>  is specified.
</p>
<p>You don&rsquo;t need to call this function since GnuTLS 3.3.0 because it is being called
during the first request PKCS 11 operation. That call will assume the <code>GNUTLS_PKCS11_FLAG_AUTO</code> 
flag. If another flags are required then it must be called independently
prior to any PKCS 11 operation.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>


<hr>
<span id="Accessing-objects-that-require-a-PIN"></span><div class="header">
<p>
Next: <a href="#Reading-objects" accesskey="n" rel="next">Reading objects</a>, Previous: <a href="#PKCS11-Manual-Initialization" accesskey="p" rel="prev">PKCS11 Manual Initialization</a>, Up: <a href="#Smart-cards-and-HSMs" accesskey="u" rel="up">Smart cards and HSMs</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Accessing-objects-that-require-a-PIN-1"></span><h4 class="subsection">5.3.3 Accessing objects that require a PIN</h4>

<p>Objects stored in token such as a private keys are typically protected
from access by a PIN or password. This PIN may be required to either read
the object (if allowed) or to perform operations with it. To allow obtaining
the PIN when accessing a protected object, as well as probe
the user to insert the token the following functions allow to set a callback.
</p>
<dl compact="compact">
<dt><code><var>void</var> <a href="#gnutls_005fpkcs11_005fset_005ftoken_005ffunction">gnutls_pkcs11_set_token_function</a> (gnutls_pkcs11_token_callback_t <var>fn</var>, void * <var>userdata</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005fpkcs11_005fset_005fpin_005ffunction">gnutls_pkcs11_set_pin_function</a> (gnutls_pin_callback_t <var>fn</var>, void * <var>userdata</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpkcs11_005fadd_005fprovider">gnutls_pkcs11_add_provider</a> (const char * <var>name</var>, const char * <var>params</var>)</code></dt>
<dt><code><var>gnutls_pin_callback_t</var> <a href="#gnutls_005fpkcs11_005fget_005fpin_005ffunction">gnutls_pkcs11_get_pin_function</a> (void ** <var>userdata</var>)</code></dt>
</dl>

<p>The callback is of type <code>gnutls_pin_callback_t</code> and will have as
input the provided userdata, the PIN attempt number, a URL describing the
token, a label describing the object and flags. The PIN must be at most 
of <code>pin_max</code> size and must be copied to pin variable. The function must
return 0 on success or a negative error code otherwise.
</p>
<pre class="verbatim">typedef int (*gnutls_pin_callback_t) (void *userdata, int attempt,
                                      const char *token_url,
                                      const char *token_label,
                                      unsigned int flags,
                                      char *pin, size_t pin_max);
</pre>
<p>The flags are of <code>gnutls_pin_flag_t</code> type and are explained below.
</p>
<div class="float"><span id="gnutls_005fpin_005fflag_005ft"></span>


<dl compact="compact">
<dt><code>GNUTLS_PIN_USER</code></dt>
<dd><p>The PIN for the user.
</p></dd>
<dt><code>GNUTLS_PIN_SO</code></dt>
<dd><p>The PIN for the security officer (admin).
</p></dd>
<dt><code>GNUTLS_PIN_FINAL_TRY</code></dt>
<dd><p>This is the final try before blocking.
</p></dd>
<dt><code>GNUTLS_PIN_COUNT_LOW</code></dt>
<dd><p>Few tries remain before token blocks.
</p></dd>
<dt><code>GNUTLS_PIN_CONTEXT_SPECIFIC</code></dt>
<dd><p>The PIN is for a specific action and key like signing.
</p></dd>
<dt><code>GNUTLS_PIN_WRONG</code></dt>
<dd><p>Last given PIN was not correct.
</p></dd>
</dl>

<div class="float-caption"><p><strong>Figure 5.2: </strong>The <code>gnutls_pin_flag_t</code> enumeration.</p></div></div>
<p>Note that due to limitations of <acronym>PKCS</acronym> #11 there are issues when multiple libraries 
are sharing a module. To avoid this problem GnuTLS uses <acronym>p11-kit</acronym>
that provides a middleware to control access to resources over the
multiple users.
</p>
<p>To avoid conflicts with multiple registered callbacks for PIN functions,
<a href="#gnutls_005fpkcs11_005fget_005fpin_005ffunction">gnutls_pkcs11_get_pin_function</a> may be used to check for any previously
set functions. In addition context specific PIN functions are allowed, e.g., by
using functions below.
</p>
<dl compact="compact">
<dt><code><var>void</var> <a href="#gnutls_005fcertificate_005fset_005fpin_005ffunction">gnutls_certificate_set_pin_function</a> (gnutls_certificate_credentials_t       <var>cred</var>, gnutls_pin_callback_t <var>fn</var>, void * <var>userdata</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005fpubkey_005fset_005fpin_005ffunction">gnutls_pubkey_set_pin_function</a> (gnutls_pubkey_t <var>key</var>, gnutls_pin_callback_t <var>fn</var>, void * <var>userdata</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005fprivkey_005fset_005fpin_005ffunction">gnutls_privkey_set_pin_function</a> (gnutls_privkey_t <var>key</var>, gnutls_pin_callback_t <var>fn</var>, void * <var>userdata</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005fpkcs11_005fobj_005fset_005fpin_005ffunction">gnutls_pkcs11_obj_set_pin_function</a> (gnutls_pkcs11_obj_t <var>obj</var>, gnutls_pin_callback_t <var>fn</var>, void * <var>userdata</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005fx509_005fcrt_005fset_005fpin_005ffunction">gnutls_x509_crt_set_pin_function</a> (gnutls_x509_crt_t <var>crt</var>, gnutls_pin_callback_t <var>fn</var>, void * <var>userdata</var>)</code></dt>
</dl>

<hr>
<span id="Reading-objects"></span><div class="header">
<p>
Next: <a href="#Writing-objects" accesskey="n" rel="next">Writing objects</a>, Previous: <a href="#Accessing-objects-that-require-a-PIN" accesskey="p" rel="prev">Accessing objects that require a PIN</a>, Up: <a href="#Smart-cards-and-HSMs" accesskey="u" rel="up">Smart cards and HSMs</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Reading-objects-1"></span><h4 class="subsection">5.3.4 Reading objects</h4>

<p>All <acronym>PKCS</acronym> #11 objects are referenced by <acronym>GnuTLS</acronym> functions by
URLs as described in [<a href="#PKCS11URI">PKCS11URI</a>]. 
This allows for a consistent naming of objects across systems and applications
in the same system. For example a public
key on a smart card may be referenced as:
</p>
<div class="example">
<pre class="example">pkcs11:token=Nikos;serial=307521161601031;model=PKCS%2315; \
manufacturer=EnterSafe;object=test1;type=public;\
id=32f153f3e37990b08624141077ca5dec2d15faed
</pre></div>

<p>while the smart card itself can be referenced as:
</p><div class="example">
<pre class="example">pkcs11:token=Nikos;serial=307521161601031;model=PKCS%2315;manufacturer=EnterSafe
</pre></div>

<p>Objects stored in a <acronym>PKCS</acronym> #11 token can typically be extracted
if they are not marked as sensitive. Usually only private keys are marked as
sensitive and cannot be extracted, while certificates and other data can
be retrieved. The functions that can be used to enumerate and access objects
are shown below.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fpkcs11_005fobj_005flist_005fimport_005furl4">gnutls_pkcs11_obj_list_import_url4</a> (gnutls_pkcs11_obj_t ** <var>p_list</var>, unsigned int * <var>n_list</var>, const char * <var>url</var>, unsigned int <var>flags</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpkcs11_005fobj_005fimport_005furl">gnutls_pkcs11_obj_import_url</a> (gnutls_pkcs11_obj_t <var>obj</var>, const char * <var>url</var>, unsigned int <var>flags</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpkcs11_005fobj_005fexport_005furl">gnutls_pkcs11_obj_export_url</a> (gnutls_pkcs11_obj_t <var>obj</var>, gnutls_pkcs11_url_type_t <var>detailed</var>, char ** <var>url</var>)</code></dt>
</dl>





<dl>
<dt id="index-gnutls_005fpkcs11_005fobj_005fget_005finfo">Function: <em>int</em> <strong>gnutls_pkcs11_obj_get_info</strong> <em>(gnutls_pkcs11_obj_t <var>obj</var>, gnutls_pkcs11_obj_info_t <var>itype</var>, void * <var>output</var>, size_t * <var>output_size</var>)</em></dt>
<dd><p><var>obj</var>: should contain a <code>gnutls_pkcs11_obj_t</code>  type
</p>
<p><var>itype</var>: Denotes the type of information requested
</p>
<p><var>output</var>: where output will be stored
</p>
<p><var>output_size</var>: contains the maximum size of the output buffer and will be
overwritten with the actual size.
</p>
<p>This function will return information about the PKCS11 certificate
such as the label, id as well as token information where the key is
stored.
</p>
<p>When output is text, a null terminated string is written to  <code>output</code> and its
string length is written to  <code>output_size</code> (without null terminator). If the
buffer is too small,  <code>output_size</code> will contain the expected buffer size
(with null terminator for text) and return <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> .
</p>
<p>In versions previously to 3.6.0 this function included the null terminator
to  <code>output_size</code> . After 3.6.0 the output size doesn&rsquo;t include the terminator character.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  (0) on success or a negative error code on error.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrt_005fimport_005fpkcs11">gnutls_x509_crt_import_pkcs11</a> (gnutls_x509_crt_t <var>crt</var>, gnutls_pkcs11_obj_t <var>pkcs11_crt</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrt_005fimport_005furl">gnutls_x509_crt_import_url</a> (gnutls_x509_crt_t <var>crt</var>, const char * <var>url</var>, unsigned int <var>flags</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fx509_005fcrt_005flist_005fimport_005fpkcs11">gnutls_x509_crt_list_import_pkcs11</a> (gnutls_x509_crt_t * <var>certs</var>, unsigned int <var>cert_max</var>, gnutls_pkcs11_obj_t * const <var>objs</var>, unsigned int <var>flags</var>)</code></dt>
</dl>

<p>Properties of the physical token can also be accessed and altered with <acronym>GnuTLS</acronym>.
For example data in a token can be erased (initialized), PIN can be altered, etc.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fpkcs11_005ftoken_005finit">gnutls_pkcs11_token_init</a> (const char * <var>token_url</var>, const char * <var>so_pin</var>, const char * <var>label</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpkcs11_005ftoken_005fget_005furl">gnutls_pkcs11_token_get_url</a> (unsigned int <var>seq</var>, gnutls_pkcs11_url_type_t <var>detailed</var>, char ** <var>url</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpkcs11_005ftoken_005fget_005finfo">gnutls_pkcs11_token_get_info</a> (const char * <var>url</var>, gnutls_pkcs11_token_info_t <var>ttype</var>, void * <var>output</var>, size_t * <var>output_size</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpkcs11_005ftoken_005fget_005fflags">gnutls_pkcs11_token_get_flags</a> (const char * <var>url</var>, unsigned int * <var>flags</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpkcs11_005ftoken_005fset_005fpin">gnutls_pkcs11_token_set_pin</a> (const char * <var>token_url</var>, const char * <var>oldpin</var>, const char * <var>newpin</var>, unsigned int <var>flags</var>)</code></dt>
</dl>

<p>The following examples demonstrate the usage of the API. The first example
will list all available PKCS #11 tokens in a system and the latter will
list all certificates in a token that have a corresponding private key.
</p>
<div class="example">
<pre class="example">int i;
char* url;

gnutls_global_init();

for (i=0;;i++) 
  {
    ret = gnutls_pkcs11_token_get_url(i, &amp;url);
    if (ret == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE)
      break;

    if (ret &lt; 0)
      exit(1);
		
    fprintf(stdout, &quot;Token[%d]: URL: %s\n&quot;, i, url);
    gnutls_free(url);
  }
gnutls_global_deinit();
</pre></div>

<pre class="verbatim">/* This example code is placed in the public domain. */

#include &lt;config.h&gt;
#include &lt;gnutls/gnutls.h&gt;
#include &lt;gnutls/pkcs11.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define URL &quot;pkcs11:URL&quot;

int main(int argc, char **argv)
{
        gnutls_pkcs11_obj_t *obj_list;
        gnutls_x509_crt_t xcrt;
        unsigned int obj_list_size = 0;
        gnutls_datum_t cinfo;
        int ret;
        unsigned int i;

        ret = gnutls_pkcs11_obj_list_import_url4(&amp;obj_list, &amp;obj_list_size, URL,
                                                GNUTLS_PKCS11_OBJ_FLAG_CRT|
                                                GNUTLS_PKCS11_OBJ_FLAG_WITH_PRIVKEY);
        if (ret &lt; 0)
                return -1;

        /* now all certificates are in obj_list */
        for (i = 0; i &lt; obj_list_size; i++) {

                gnutls_x509_crt_init(&amp;xcrt);

                gnutls_x509_crt_import_pkcs11(xcrt, obj_list[i]);

                gnutls_x509_crt_print(xcrt, GNUTLS_CRT_PRINT_FULL, &amp;cinfo);

                fprintf(stdout, &quot;cert[%d]:\n %s\n\n&quot;, i, cinfo.data);

                gnutls_free(cinfo.data);
                gnutls_x509_crt_deinit(xcrt);
        }

        for (i = 0; i &lt; obj_list_size; i++)
                gnutls_pkcs11_obj_deinit(obj_list[i]);
	gnutls_free(obj_list);

        return 0;
}
</pre>
<hr>
<span id="Writing-objects"></span><div class="header">
<p>
Next: <a href="#PKCS11-Low-Level-Access" accesskey="n" rel="next">PKCS11 Low Level Access</a>, Previous: <a href="#Reading-objects" accesskey="p" rel="prev">Reading objects</a>, Up: <a href="#Smart-cards-and-HSMs" accesskey="u" rel="up">Smart cards and HSMs</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Writing-objects-1"></span><h4 class="subsection">5.3.5 Writing objects</h4>

<p>With <acronym>GnuTLS</acronym> you can copy existing private keys and certificates
to a token. Note that when copying private keys it is recommended to mark
them as sensitive using the <code>GNUTLS_PKCS11_OBJ_FLAG_MARK_SENSITIVE</code>
to prevent its extraction. An object can be marked as private using the flag 
<code>GNUTLS_PKCS11_OBJ_FLAG_MARK_PRIVATE</code>, to require PIN to be
entered before accessing the object (for operations or otherwise).
</p>




<dl>
<dt id="index-gnutls_005fpkcs11_005fcopy_005fx509_005fprivkey2">Function: <em>int</em> <strong>gnutls_pkcs11_copy_x509_privkey2</strong> <em>(const char * <var>token_url</var>, gnutls_x509_privkey_t <var>key</var>, const char * <var>label</var>, const gnutls_datum_t * <var>cid</var>, unsigned int <var>key_usage</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>token_url</var>: A PKCS <code>11</code>  URL specifying a token
</p>
<p><var>key</var>: A private key
</p>
<p><var>label</var>: A name to be used for the stored data
</p>
<p><var>cid</var>: The CKA_ID to set for the object -if NULL, the ID will be derived from the public key
</p>
<p><var>key_usage</var>: One of GNUTLS_KEY_*
</p>
<p><var>flags</var>: One of GNUTLS_PKCS11_OBJ_* flags
</p>
<p>This function will copy a private key into a PKCS <code>11</code>  token specified by
a URL.
</p>
<p>Since 3.6.3 the objects are marked as sensitive by default unless
<code>GNUTLS_PKCS11_OBJ_FLAG_MARK_NOT_SENSITIVE</code>  is specified.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>





<dl>
<dt id="index-gnutls_005fpkcs11_005fcopy_005fx509_005fcrt2">Function: <em>int</em> <strong>gnutls_pkcs11_copy_x509_crt2</strong> <em>(const char * <var>token_url</var>, gnutls_x509_crt_t <var>crt</var>, const char * <var>label</var>, const gnutls_datum_t * <var>cid</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>token_url</var>: A PKCS <code>11</code>  URL specifying a token
</p>
<p><var>crt</var>: The certificate to copy
</p>
<p><var>label</var>: The name to be used for the stored data
</p>
<p><var>cid</var>: The CKA_ID to set for the object -if NULL, the ID will be derived from the public key
</p>
<p><var>flags</var>: One of GNUTLS_PKCS11_OBJ_FLAG_*
</p>
<p>This function will copy a certificate into a PKCS <code>11</code>  token specified by
a URL. Valid flags to mark the certificate: <code>GNUTLS_PKCS11_OBJ_FLAG_MARK_TRUSTED</code> ,
<code>GNUTLS_PKCS11_OBJ_FLAG_MARK_PRIVATE</code> , <code>GNUTLS_PKCS11_OBJ_FLAG_MARK_CA</code> ,
<code>GNUTLS_PKCS11_OBJ_FLAG_MARK_ALWAYS_AUTH</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>




<dl>
<dt id="index-gnutls_005fpkcs11_005fdelete_005furl">Function: <em>int</em> <strong>gnutls_pkcs11_delete_url</strong> <em>(const char * <var>object_url</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>object_url</var>: The URL of the object to delete.
</p>
<p><var>flags</var>: One of GNUTLS_PKCS11_OBJ_* flags
</p>
<p>This function will delete objects matching the given URL.
Note that not all tokens support the delete operation.
</p>
<p><strong>Returns:</strong> On success, the number of objects deleted is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>


<hr>
<span id="PKCS11-Low-Level-Access"></span><div class="header">
<p>
Next: <a href="#Using-a-PKCS11-token-with-TLS" accesskey="n" rel="next">Using a PKCS11 token with TLS</a>, Previous: <a href="#Writing-objects" accesskey="p" rel="prev">Writing objects</a>, Up: <a href="#Smart-cards-and-HSMs" accesskey="u" rel="up">Smart cards and HSMs</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Low-Level-Access"></span><h4 class="subsection">5.3.6 Low Level Access</h4>

<p>When it is needed to use PKCS#11 functionality which is not wrapped by
GnuTLS, it is possible to extract the PKCS#11 session, object or token pointers.
That allows an application to still access the low-level functionality,
while at the same time take advantage of the URI addressing scheme supported
by GnuTLS.
</p>




<dl>
<dt id="index-gnutls_005fpkcs11_005ftoken_005fget_005fptr">Function: <em>int</em> <strong>gnutls_pkcs11_token_get_ptr</strong> <em>(const char * <var>url</var>, void ** <var>ptr</var>, unsigned long * <var>slot_id</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>url</var>: should contain a PKCS<code>11</code>  URL identifying a token
</p>
<p><var>ptr</var>: will contain the CK_FUNCTION_LIST_PTR pointer
</p>
<p><var>slot_id</var>: will contain the slot_id (may be <code>NULL</code> )
</p>
<p><var>flags</var>: should be zero
</p>
<p>This function will return the function pointer of the specified
token by the URL. The returned pointers are valid until
gnutls is deinitialized, c.f. <code>_global_deinit()</code> .
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  (0) on success or a negative error code
on error.
</p>
<p><strong>Since:</strong> 3.6.3
</p></dd></dl>




<dl>
<dt id="index-gnutls_005fpkcs11_005fobj_005fget_005fptr">Function: <em>int</em> <strong>gnutls_pkcs11_obj_get_ptr</strong> <em>(gnutls_pkcs11_obj_t <var>obj</var>, void ** <var>ptr</var>, void ** <var>session</var>, void ** <var>ohandle</var>, unsigned long * <var>slot_id</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>obj</var>: should contain a <code>gnutls_pkcs11_obj_t</code>  type
</p>
<p><var>ptr</var>: will contain the CK_FUNCTION_LIST_PTR pointer (may be <code>NULL</code> )
</p>
<p><var>session</var>: will contain the CK_SESSION_HANDLE of the object
</p>
<p><var>ohandle</var>: will contain the CK_OBJECT_HANDLE of the object
</p>
<p><var>slot_id</var>: the identifier of the slot (may be <code>NULL</code> )
</p>
<p><var>flags</var>: Or sequence of GNUTLS_PKCS11_OBJ_* flags
</p>
<p>Obtains the PKCS<code>11</code>  session handles of an object.  <code>session</code> and  <code>ohandle</code> must be deinitialized by the caller. The returned pointers are
independent of the  <code>obj</code> lifetime.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  (0) on success or a negative error code
on error.
</p>
<p><strong>Since:</strong> 3.6.3
</p></dd></dl>


<hr>
<span id="Using-a-PKCS11-token-with-TLS"></span><div class="header">
<p>
Next: <a href="#Verifying-certificates-over-PKCS11" accesskey="n" rel="next">Verifying certificates over PKCS11</a>, Previous: <a href="#PKCS11-Low-Level-Access" accesskey="p" rel="prev">PKCS11 Low Level Access</a>, Up: <a href="#Smart-cards-and-HSMs" accesskey="u" rel="up">Smart cards and HSMs</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Using-a-PKCS-_002311-token-with-TLS"></span><h4 class="subsection">5.3.7 Using a <acronym>PKCS</acronym> #11 token with TLS</h4>

<p>It is possible to use a <acronym>PKCS</acronym> #11 token to a TLS
session, as shown in <a href="#ex_002dpkcs11_002dclient">ex-pkcs11-client</a>. In addition
the following functions can be used to load PKCS #11 key and
certificates by specifying a PKCS #11 URL instead of a filename.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fcertificate_005fset_005fx509_005ftrust_005ffile">gnutls_certificate_set_x509_trust_file</a> (gnutls_certificate_credentials_t            <var>cred</var>, const char * <var>cafile</var>, gnutls_x509_crt_fmt_t <var>type</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fcertificate_005fset_005fx509_005fkey_005ffile2">gnutls_certificate_set_x509_key_file2</a> (gnutls_certificate_credentials_t <var>res</var>, const char * <var>certfile</var>, const char * <var>keyfile</var>, gnutls_x509_crt_fmt_t <var>type</var>, const char * <var>pass</var>, unsigned int <var>flags</var>)</code></dt>
</dl>


<hr>
<span id="Verifying-certificates-over-PKCS11"></span><div class="header">
<p>
Next: <a href="#p11tool-Invocation" accesskey="n" rel="next">p11tool Invocation</a>, Previous: <a href="#Using-a-PKCS11-token-with-TLS" accesskey="p" rel="prev">Using a PKCS11 token with TLS</a>, Up: <a href="#Smart-cards-and-HSMs" accesskey="u" rel="up">Smart cards and HSMs</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Verifying-certificates-over-PKCS-_002311"></span><h4 class="subsection">5.3.8 Verifying certificates over <acronym>PKCS</acronym> #11</h4>

<p>The <acronym>PKCS</acronym> #11 API can be used to allow all applications in the
same operating system to access shared cryptographic keys and certificates in a
uniform way, as in <a href="#fig_002dpkcs11_002dvision">Figure 5.1</a>. That way applications could load their
trusted certificate list, as well as user certificates from a common PKCS #11 module.
Such a provider is the p11-kit trust storage module<a id="DOCF12" href="#FOOT12"><sup>12</sup></a>
and it provides access to the trusted Root CA certificates in a system. That
provides a more dynamic list of Root CA certificates, as opposed to a static
list in a file or directory.
</p>
<p>That store, allows for blacklisting of CAs or certificates, as well as
categorization of the Root CAs (Web verification, Code signing, etc.), in
addition to restricting their purpose via stapled extensions<a id="DOCF13" href="#FOOT13"><sup>13</sup></a>.
GnuTLS will utilize the p11-kit trust module as the default trust store
if configured to; i.e., if &rsquo;&ndash;with-default-trust-store-pkcs11=pkcs11:&rsquo; is given to 
the configure script.
</p>

<hr>
<span id="p11tool-Invocation"></span><div class="header">
<p>
Previous: <a href="#Verifying-certificates-over-PKCS11" accesskey="p" rel="prev">Verifying certificates over PKCS11</a>, Up: <a href="#Smart-cards-and-HSMs" accesskey="u" rel="up">Smart cards and HSMs</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Invoking-p11tool"></span><h4 class="subsection">5.3.9 Invoking p11tool</h4>
<span id="index-p11tool"></span>


<p>Program that allows operations on PKCS #11 smart cards
and security modules. 
</p>
<p>To use PKCS #11 tokens with GnuTLS the p11-kit configuration files need to be setup.
That is create a .module file in /etc/pkcs11/modules with the contents &rsquo;module: /path/to/pkcs11.so&rsquo;.
Alternatively the configuration file /etc/gnutls/pkcs11.conf has to exist and contain a number
of lines of the form &rsquo;load=/usr/lib/opensc-pkcs11.so&rsquo;.
</p>
<p>You can provide the PIN to be used for the PKCS #11 operations with the environment variables
GNUTLS_PIN and GNUTLS_SO_PIN.
</p>

<p>This section was generated by <strong>AutoGen</strong>,
using the <code>agtexi-cmd</code> template and the option descriptions for the <code>p11tool</code> program.
This software is released under the GNU General Public License, version 3 or later.
</p>

<span id="p11tool-usage"></span><span id="p11tool-help_002fusage-_0028_002d_002dhelp_0029"></span><h4 class="subheading">p11tool help/usage (<samp>--help</samp>)</h4>
<span id="index-p11tool-help"></span>

<p>This is the automatically generated usage text for p11tool.
</p>
<p>The text printed is the same whether selected with the <code>help</code> option
(<samp>--help</samp>) or the <code>more-help</code> option (<samp>--more-help</samp>).  <code>more-help</code> will print
the usage text by passing it through a pager program.
<code>more-help</code> is disabled on platforms without a working
<code>fork(2)</code> function.  The <code>PAGER</code> environment variable is
used to select the program, defaulting to <samp>more</samp>.  Both will exit
with a status code of 0.
</p>
<div class="example">
<pre class="example">p11tool - GnuTLS PKCS #11 tool
Usage:  p11tool [ -&lt;flag&gt; [&lt;val&gt;] | --&lt;name&gt;[{=| }&lt;val&gt;] ]... [url]


Tokens:

       --list-tokens          List all available tokens
       --list-token-urls      List the URLs available tokens
       --list-mechanisms      List all available mechanisms in a token
       --initialize           Initializes a PKCS #11 token
       --initialize-pin       Initializes/Resets a PKCS #11 token user PIN
       --initialize-so-pin    Initializes/Resets a PKCS #11 token security officer PIN.
       --set-pin=str          Specify the PIN to use on token operations
       --set-so-pin=str       Specify the Security Officer's PIN to use on token initialization

Object listing:

       --list-all             List all available objects in a token
       --list-all-certs       List all available certificates in a token
       --list-certs           List all certificates that have an associated private key
       --list-all-privkeys    List all available private keys in a token
       --list-privkeys        an alias for the 'list-all-privkeys' option
       --list-keys            an alias for the 'list-all-privkeys' option
       --list-all-trusted     List all available certificates marked as trusted
       --export               Export the object specified by the URL
                                - prohibits these options:
                                export-stapled
                                export-chain
                                export-pubkey
       --export-stapled       Export the certificate object specified by the URL
                                - prohibits these options:
                                export
                                export-chain
                                export-pubkey
       --export-chain         Export the certificate specified by the URL and its chain of trust
                                - prohibits these options:
                                export-stapled
                                export
                                export-pubkey
       --export-pubkey        Export the public key for a private key
                                - prohibits these options:
                                export-stapled
                                export
                                export-chain
       --info                 List information on an available object in a token
       --trusted              an alias for the 'mark-trusted' option
       --distrusted           an alias for the 'mark-distrusted' option

Key generation:

       --generate-privkey=str Generate private-public key pair of given type
       --bits=num             Specify the number of bits for the key generate
       --curve=str            Specify the curve used for EC key generation
       --sec-param=str        Specify the security level

Writing objects:

       --set-id=str           Set the CKA_ID (in hex) for the specified by the URL object
                                - prohibits the option 'write'
       --set-label=str        Set the CKA_LABEL for the specified by the URL object
                                - prohibits these options:
                                write
                                set-id
       --write                Writes the loaded objects to a PKCS #11 token
       --delete               Deletes the objects matching the given PKCS #11 URL
       --label=str            Sets a label for the write operation
       --id=str               Sets an ID for the write operation
       --mark-wrap            Marks the generated key to be a wrapping key
                                - disabled as '--no-mark-wrap'
       --mark-trusted         Marks the object to be written as trusted
                                - prohibits the option 'mark-distrusted'
                                - disabled as '--no-mark-trusted'
       --mark-distrusted      When retrieving objects, it requires the objects to be distrusted
(blacklisted)
                                - prohibits the option 'mark-trusted'
       --mark-decrypt         Marks the object to be written for decryption
                                - disabled as '--no-mark-decrypt'
       --mark-sign            Marks the object to be written for signature generation
                                - disabled as '--no-mark-sign'
       --mark-ca              Marks the object to be written as a CA
                                - disabled as '--no-mark-ca'
       --mark-private         Marks the object to be written as private
                                - disabled as '--no-mark-private'
       --ca                   an alias for the 'mark-ca' option
       --private              an alias for the 'mark-private' option
       --secret-key=str       Provide a hex encoded secret key
       --load-privkey=file    Private key file to use
                                - file must pre-exist
       --load-pubkey=file     Public key file to use
                                - file must pre-exist
       --load-certificate=file Certificate file to use
                                - file must pre-exist

Other options:

   -d, --debug=num            Enable debugging
                                - it must be in the range:
                                  0 to 9999
       --outfile=str          Output file
       --login                Force (user) login to token
                                - disabled as '--no-login'
       --so-login             Force security officer login to token
                                - disabled as '--no-so-login'
       --admin-login          an alias for the 'so-login' option
       --test-sign            Tests the signature operation of the provided object
       --sign-params=str      Sign with a specific signature algorithm
       --hash=str             Hash algorithm to use for signing
       --generate-random=num  Generate random data
   -8, --pkcs8                Use PKCS #8 format for private keys
       --inder                Use DER/RAW format for input
                                - disabled as '--no-inder'
       --inraw                an alias for the 'inder' option
       --outder               Use DER format for output certificates, private keys, and DH parameters
                                - disabled as '--no-outder'
       --outraw               an alias for the 'outder' option
       --provider=file        Specify the PKCS #11 provider library
       --detailed-url         Print detailed URLs
                                - disabled as '--no-detailed-url'
       --only-urls            Print a compact listing using only the URLs
       --batch                Disable all interaction with the tool

Version, usage and configuration options:

   -v, --version[=arg]        output version information and exit
   -h, --help                 display extended usage information and exit
   -!, --more-help            extended usage information passed thru pager

Options are specified by doubled hyphens and their name or by a single
hyphen and the flag character.
Operands and options may be intermixed.  They will be reordered.

Program that allows operations on PKCS #11 smart cards and security
modules.

To use PKCS #11 tokens with GnuTLS the p11-kit configuration files need to
be setup.  That is create a .module file in /etc/pkcs11/modules with the
contents 'module: /path/to/pkcs11.so'.  Alternatively the configuration
file /etc/gnutls/pkcs11.conf has to exist and contain a number of lines of
the form 'load=/usr/lib/opensc-pkcs11.so'.

You can provide the PIN to be used for the PKCS #11 operations with the
environment variables GNUTLS_PIN and GNUTLS_SO_PIN.

</pre></div>

<span id="p11tool-token_002drelated_002doptions"></span><span id="token_002drelated_002doptions-options"></span><h4 class="subheading">token-related-options options</h4>
<p>Tokens.
</p><span id="list_002dtoken_002durls-option_002e"></span><h4 class="subsubheading">list-token-urls option.</h4>
<span id="p11tool-list_002dtoken_002durls"></span>
<p>This is the &ldquo;list the urls available tokens&rdquo; option.
This is a more compact version of &ndash;list-tokens.
</p><span id="initialize_002dso_002dpin-option_002e"></span><h4 class="subsubheading">initialize-so-pin option.</h4>
<span id="p11tool-initialize_002dso_002dpin"></span>
<p>This is the &ldquo;initializes/resets a pkcs #11 token security officer pin.&rdquo; option.
This initializes the security officer&rsquo;s PIN. When used non-interactively use the GNUTLS_NEW_SO_PIN
environment variables to initialize SO&rsquo;s PIN.
</p><span id="set_002dpin-option_002e"></span><h4 class="subsubheading">set-pin option.</h4>
<span id="p11tool-set_002dpin"></span>
<p>This is the &ldquo;specify the pin to use on token operations&rdquo; option.
This option takes a string argument.
Alternatively the GNUTLS_PIN environment variable may be used.
</p><span id="set_002dso_002dpin-option_002e"></span><h4 class="subsubheading">set-so-pin option.</h4>
<span id="p11tool-set_002dso_002dpin"></span>
<p>This is the &ldquo;specify the security officer&rsquo;s pin to use on token initialization&rdquo; option.
This option takes a string argument.
Alternatively the GNUTLS_SO_PIN environment variable may be used.
<span id="p11tool-object_002dlist_002drelated_002doptions"></span></p><span id="object_002dlist_002drelated_002doptions-options"></span><h4 class="subheading">object-list-related-options options</h4>
<p>Object listing.
</p><span id="list_002dall-option_002e"></span><h4 class="subsubheading">list-all option.</h4>
<span id="p11tool-list_002dall"></span>
<p>This is the &ldquo;list all available objects in a token&rdquo; option.
All objects available in the token will be listed. That includes
objects which are potentially unaccessible using this tool.
</p><span id="list_002dall_002dcerts-option_002e"></span><h4 class="subsubheading">list-all-certs option.</h4>
<span id="p11tool-list_002dall_002dcerts"></span>
<p>This is the &ldquo;list all available certificates in a token&rdquo; option.
That option will also provide more information on the
certificates, for example, expand the attached extensions in a trust
token (like p11-kit-trust).
</p><span id="list_002dcerts-option_002e"></span><h4 class="subsubheading">list-certs option.</h4>
<span id="p11tool-list_002dcerts"></span>
<p>This is the &ldquo;list all certificates that have an associated private key&rdquo; option.
That option will only display certificates which have a private
key associated with them (share the same ID).
</p><span id="list_002dall_002dprivkeys-option_002e"></span><h4 class="subsubheading">list-all-privkeys option.</h4>
<span id="p11tool-list_002dall_002dprivkeys"></span>
<p>This is the &ldquo;list all available private keys in a token&rdquo; option.
Lists all the private keys in a token that match the specified URL.
</p><span id="list_002dprivkeys-option_002e"></span><h4 class="subsubheading">list-privkeys option.</h4>
<span id="p11tool-list_002dprivkeys"></span>
<p>This is an alias for the <code>list-all-privkeys</code> option,
see <a href="#p11tool-list_002dall_002dprivkeys">the list-all-privkeys option documentation</a>.
</p>
<span id="list_002dkeys-option_002e"></span><h4 class="subsubheading">list-keys option.</h4>
<span id="p11tool-list_002dkeys"></span>
<p>This is an alias for the <code>list-all-privkeys</code> option,
see <a href="#p11tool-list_002dall_002dprivkeys">the list-all-privkeys option documentation</a>.
</p>
<span id="export_002dstapled-option_002e"></span><h4 class="subsubheading">export-stapled option.</h4>
<span id="p11tool-export_002dstapled"></span>
<p>This is the &ldquo;export the certificate object specified by the url&rdquo; option.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> must not appear in combination with any of the following options:
export, export-chain, export-pubkey.
</li></ul>

<p>Exports the certificate specified by the URL while including any attached extensions to it.
Since attached extensions are a p11-kit extension, this option is only
available on p11-kit registered trust modules.
</p><span id="export_002dchain-option_002e"></span><h4 class="subsubheading">export-chain option.</h4>
<span id="p11tool-export_002dchain"></span>
<p>This is the &ldquo;export the certificate specified by the url and its chain of trust&rdquo; option.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> must not appear in combination with any of the following options:
export-stapled, export, export-pubkey.
</li></ul>

<p>Exports the certificate specified by the URL and generates its chain of trust based on the stored certificates in the module.
</p><span id="export_002dpubkey-option_002e"></span><h4 class="subsubheading">export-pubkey option.</h4>
<span id="p11tool-export_002dpubkey"></span>
<p>This is the &ldquo;export the public key for a private key&rdquo; option.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> must not appear in combination with any of the following options:
export-stapled, export, export-chain.
</li></ul>

<p>Exports the public key for the specified private key
</p><span id="trusted-option_002e"></span><h4 class="subsubheading">trusted option.</h4>
<span id="p11tool-trusted"></span>
<p>This is an alias for the <code>mark-trusted</code> option,
see <a href="#p11tool-mark_002dtrusted">the mark-trusted option documentation</a>.
</p>
<span id="distrusted-option_002e"></span><h4 class="subsubheading">distrusted option.</h4>
<span id="p11tool-distrusted"></span>
<p>This is an alias for the <code>mark-distrusted</code> option,
see <a href="#p11tool-mark_002ddistrusted">the mark-distrusted option documentation</a>.
</p>
<span id="p11tool-keygen_002drelated_002doptions"></span><span id="keygen_002drelated_002doptions-options"></span><h4 class="subheading">keygen-related-options options</h4>
<p>Key generation.
</p><span id="generate_002dprivkey-option_002e"></span><h4 class="subsubheading">generate-privkey option.</h4>
<span id="p11tool-generate_002dprivkey"></span>
<p>This is the &ldquo;generate private-public key pair of given type&rdquo; option.
This option takes a string argument.
Generates a private-public key pair in the specified token.
Acceptable types are RSA, ECDSA, Ed25519, and DSA. Should be combined with &ndash;sec-param or &ndash;bits.
</p><span id="generate_002drsa-option_002e"></span><h4 class="subsubheading">generate-rsa option.</h4>
<span id="p11tool-generate_002drsa"></span>
<p>This is the &ldquo;generate an rsa private-public key pair&rdquo; option.
Generates an RSA private-public key pair on the specified token.
Should be combined with &ndash;sec-param or &ndash;bits.
</p>
<p><strong>NOTE</strong><strong>: THIS OPTION IS DEPRECATED</strong>
</p><span id="generate_002ddsa-option_002e"></span><h4 class="subsubheading">generate-dsa option.</h4>
<span id="p11tool-generate_002ddsa"></span>
<p>This is the &ldquo;generate a dsa private-public key pair&rdquo; option.
Generates a DSA private-public key pair on the specified token.
Should be combined with &ndash;sec-param or &ndash;bits.
</p>
<p><strong>NOTE</strong><strong>: THIS OPTION IS DEPRECATED</strong>
</p><span id="generate_002decc-option_002e"></span><h4 class="subsubheading">generate-ecc option.</h4>
<span id="p11tool-generate_002decc"></span>
<p>This is the &ldquo;generate an ecdsa private-public key pair&rdquo; option.
Generates an ECDSA private-public key pair on the specified token.
Should be combined with &ndash;curve, &ndash;sec-param or &ndash;bits.
</p>
<p><strong>NOTE</strong><strong>: THIS OPTION IS DEPRECATED</strong>
</p><span id="bits-option_002e"></span><h4 class="subsubheading">bits option.</h4>
<span id="p11tool-bits"></span>
<p>This is the &ldquo;specify the number of bits for the key generate&rdquo; option.
This option takes a number argument.
For applications which have no key-size restrictions the
&ndash;sec-param option is recommended, as the sec-param levels will adapt
to the acceptable security levels with the new versions of gnutls.
</p><span id="curve-option_002e-1"></span><h4 class="subsubheading">curve option.</h4>
<span id="p11tool-curve"></span>
<p>This is the &ldquo;specify the curve used for ec key generation&rdquo; option.
This option takes a string argument.
Supported values are secp192r1, secp224r1, secp256r1, secp384r1 and secp521r1.
</p><span id="sec_002dparam-option_002e-1"></span><h4 class="subsubheading">sec-param option.</h4>
<span id="p11tool-sec_002dparam"></span>
<p>This is the &ldquo;specify the security level&rdquo; option.
This option takes a string argument <samp>Security parameter</samp>.
This is alternative to the bits option. Available options are [low, legacy, medium, high, ultra].
<span id="p11tool-write_002dobject_002drelated_002doptions"></span></p><span id="write_002dobject_002drelated_002doptions-options"></span><h4 class="subheading">write-object-related-options options</h4>
<p>Writing objects.
</p><span id="set_002did-option_002e"></span><h4 class="subsubheading">set-id option.</h4>
<span id="p11tool-set_002did"></span>
<p>This is the &ldquo;set the cka_id (in hex) for the specified by the url object&rdquo; option.
This option takes a string argument.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> must not appear in combination with any of the following options:
write.
</li></ul>

<p>Modifies or sets the CKA_ID in the specified by the URL object. The ID should be specified in hexadecimal format without a &rsquo;0x&rsquo; prefix.
</p><span id="set_002dlabel-option_002e"></span><h4 class="subsubheading">set-label option.</h4>
<span id="p11tool-set_002dlabel"></span>
<p>This is the &ldquo;set the cka_label for the specified by the url object&rdquo; option.
This option takes a string argument.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> must not appear in combination with any of the following options:
write, set-id.
</li></ul>

<p>Modifies or sets the CKA_LABEL in the specified by the URL object
</p><span id="write-option_002e"></span><h4 class="subsubheading">write option.</h4>
<span id="p11tool-write"></span>
<p>This is the &ldquo;writes the loaded objects to a pkcs #11 token&rdquo; option.
It can be used to write private, public keys, certificates or secret keys to a token. Must be combined with
    one of &ndash;load-privkey, &ndash;load-pubkey, &ndash;load-certificate option.
</p><span id="id-option_002e"></span><h4 class="subsubheading">id option.</h4>
<span id="p11tool-id"></span>
<p>This is the &ldquo;sets an id for the write operation&rdquo; option.
This option takes a string argument.
Sets the CKA_ID to be set by the write operation. The ID should be specified in hexadecimal format without a &rsquo;0x&rsquo; prefix.
</p><span id="mark_002dwrap-option_002e"></span><h4 class="subsubheading">mark-wrap option.</h4>
<span id="p11tool-mark_002dwrap"></span>
<p>This is the &ldquo;marks the generated key to be a wrapping key&rdquo; option.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> can be disabled with &ndash;no-mark-wrap.
</li></ul>

<p>Marks the generated key with the CKA_WRAP flag.
</p><span id="mark_002dtrusted-option_002e"></span><h4 class="subsubheading">mark-trusted option.</h4>
<span id="p11tool-mark_002dtrusted"></span>
<p>This is the &ldquo;marks the object to be written as trusted&rdquo; option.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> can be disabled with &ndash;no-mark-trusted.
</li><li> must not appear in combination with any of the following options:
mark-distrusted.
</li></ul>

<p>Marks the object to be generated/written with the CKA_TRUST flag.
</p><span id="mark_002ddistrusted-option_002e"></span><h4 class="subsubheading">mark-distrusted option.</h4>
<span id="p11tool-mark_002ddistrusted"></span>
<p>This is the &ldquo;when retrieving objects, it requires the objects to be distrusted (blacklisted)&rdquo; option.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> must not appear in combination with any of the following options:
mark-trusted.
</li></ul>

<p>Ensures that the objects retrieved have the CKA_X_TRUST flag.
This is p11-kit trust module extension, thus this flag is only valid with
p11-kit registered trust modules.
</p><span id="mark_002ddecrypt-option_002e"></span><h4 class="subsubheading">mark-decrypt option.</h4>
<span id="p11tool-mark_002ddecrypt"></span>
<p>This is the &ldquo;marks the object to be written for decryption&rdquo; option.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> can be disabled with &ndash;no-mark-decrypt.
</li></ul>

<p>Marks the object to be generated/written with the CKA_DECRYPT flag set to true.
</p><span id="mark_002dsign-option_002e"></span><h4 class="subsubheading">mark-sign option.</h4>
<span id="p11tool-mark_002dsign"></span>
<p>This is the &ldquo;marks the object to be written for signature generation&rdquo; option.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> can be disabled with &ndash;no-mark-sign.
</li></ul>

<p>Marks the object to be generated/written with the CKA_SIGN flag set to true.
</p><span id="mark_002dca-option_002e"></span><h4 class="subsubheading">mark-ca option.</h4>
<span id="p11tool-mark_002dca"></span>
<p>This is the &ldquo;marks the object to be written as a ca&rdquo; option.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> can be disabled with &ndash;no-mark-ca.
</li></ul>

<p>Marks the object to be generated/written with the CKA_CERTIFICATE_CATEGORY as CA.
</p><span id="mark_002dprivate-option_002e"></span><h4 class="subsubheading">mark-private option.</h4>
<span id="p11tool-mark_002dprivate"></span>
<p>This is the &ldquo;marks the object to be written as private&rdquo; option.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> can be disabled with &ndash;no-mark-private.
</li></ul>

<p>Marks the object to be generated/written with the CKA_PRIVATE flag. The written object will require a PIN to be used.
</p><span id="ca-option_002e"></span><h4 class="subsubheading">ca option.</h4>
<span id="p11tool-ca"></span>
<p>This is an alias for the <code>mark-ca</code> option,
see <a href="#p11tool-mark_002dca">the mark-ca option documentation</a>.
</p>
<span id="private-option_002e"></span><h4 class="subsubheading">private option.</h4>
<span id="p11tool-private"></span>
<p>This is an alias for the <code>mark-private</code> option,
see <a href="#p11tool-mark_002dprivate">the mark-private option documentation</a>.
</p>
<span id="secret_002dkey-option_002e"></span><h4 class="subsubheading">secret-key option.</h4>
<span id="p11tool-secret_002dkey"></span>
<p>This is the &ldquo;provide a hex encoded secret key&rdquo; option.
This option takes a string argument.
This secret key will be written to the module if &ndash;write is specified.
<span id="p11tool-other_002doptions"></span></p><span id="other_002doptions-options-1"></span><h4 class="subheading">other-options options</h4>
<p>Other options.
</p><span id="debug-option-_0028_002dd_0029_002e-1"></span><h4 class="subsubheading">debug option (-d).</h4>
<span id="p11tool-debug"></span>
<p>This is the &ldquo;enable debugging&rdquo; option.
This option takes a number argument.
Specifies the debug level.
</p><span id="so_002dlogin-option_002e"></span><h4 class="subsubheading">so-login option.</h4>
<span id="p11tool-so_002dlogin"></span>
<p>This is the &ldquo;force security officer login to token&rdquo; option.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> can be disabled with &ndash;no-so-login.
</li></ul>

<p>Forces login to the token as security officer (admin).
</p><span id="admin_002dlogin-option_002e"></span><h4 class="subsubheading">admin-login option.</h4>
<span id="p11tool-admin_002dlogin"></span>
<p>This is an alias for the <code>so-login</code> option,
see <a href="#p11tool-so_002dlogin">the so-login option documentation</a>.
</p>
<span id="test_002dsign-option_002e"></span><h4 class="subsubheading">test-sign option.</h4>
<span id="p11tool-test_002dsign"></span>
<p>This is the &ldquo;tests the signature operation of the provided object&rdquo; option.
It can be used to test the correct operation of the signature operation.
If both a private and a public key are available this operation will sign and verify
the signed data.
</p><span id="sign_002dparams-option_002e-1"></span><h4 class="subsubheading">sign-params option.</h4>
<span id="p11tool-sign_002dparams"></span>
<p>This is the &ldquo;sign with a specific signature algorithm&rdquo; option.
This option takes a string argument.
This option can be combined with &ndash;test-sign, to sign with
a specific signature algorithm variant. The only option supported is &rsquo;RSA-PSS&rsquo;, and should be
specified in order to use RSA-PSS signature on RSA keys.
</p><span id="hash-option_002e-1"></span><h4 class="subsubheading">hash option.</h4>
<span id="p11tool-hash"></span>
<p>This is the &ldquo;hash algorithm to use for signing&rdquo; option.
This option takes a string argument.
This option can be combined with test-sign. Available hash functions are SHA1, RMD160, SHA256, SHA384, SHA512, SHA3-224, SHA3-256, SHA3-384, SHA3-512.
</p><span id="generate_002drandom-option_002e"></span><h4 class="subsubheading">generate-random option.</h4>
<span id="p11tool-generate_002drandom"></span>
<p>This is the &ldquo;generate random data&rdquo; option.
This option takes a number argument.
Asks the token to generate a number of bytes of random bytes.
</p><span id="inder-option_002e-1"></span><h4 class="subsubheading">inder option.</h4>
<span id="p11tool-inder"></span>
<p>This is the &ldquo;use der/raw format for input&rdquo; option.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> can be disabled with &ndash;no-inder.
</li></ul>

<p>Use DER/RAW format for input certificates and private keys.
</p><span id="inraw-option_002e-1"></span><h4 class="subsubheading">inraw option.</h4>
<span id="p11tool-inraw"></span>
<p>This is an alias for the <code>inder</code> option,
see <a href="#p11tool-inder">the inder option documentation</a>.
</p>
<span id="outder-option_002e-1"></span><h4 class="subsubheading">outder option.</h4>
<span id="p11tool-outder"></span>
<p>This is the &ldquo;use der format for output certificates, private keys, and dh parameters&rdquo; option.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> can be disabled with &ndash;no-outder.
</li></ul>

<p>The output will be in DER or RAW format.
</p><span id="outraw-option_002e-1"></span><h4 class="subsubheading">outraw option.</h4>
<span id="p11tool-outraw"></span>
<p>This is an alias for the <code>outder</code> option,
see <a href="#p11tool-outder">the outder option documentation</a>.
</p>
<span id="provider-option_002e-1"></span><h4 class="subsubheading">provider option.</h4>
<span id="p11tool-provider"></span>
<p>This is the &ldquo;specify the pkcs #11 provider library&rdquo; option.
This option takes a file argument.
This will override the default options in /etc/gnutls/pkcs11.conf
</p><span id="provider_002dopts-option_002e"></span><h4 class="subsubheading">provider-opts option.</h4>
<span id="p11tool-provider_002dopts"></span>
<p>This is the &ldquo;specify parameters for the pkcs #11 provider library&rdquo; option.
This option takes a string argument.
This is a PKCS#11 internal option used by few modules.
    Mainly for testing PKCS#11 modules.
</p>
<p><strong>NOTE</strong><strong>: THIS OPTION IS DEPRECATED</strong>
</p><span id="batch-option_002e"></span><h4 class="subsubheading">batch option.</h4>
<span id="p11tool-batch"></span>
<p>This is the &ldquo;disable all interaction with the tool&rdquo; option.
In batch mode there will be no prompts, all parameters need to be specified on command line.
<span id="p11tool-exit-status"></span></p><span id="p11tool-exit-status-1"></span><h4 class="subheading">p11tool exit status</h4>

<p>One of the following exit values will be returned:
</p><dl compact="compact">
<dt>&lsquo;<samp>0 (EXIT_SUCCESS)</samp>&rsquo;</dt>
<dd><p>Successful program execution.
</p></dd>
<dt>&lsquo;<samp>1 (EXIT_FAILURE)</samp>&rsquo;</dt>
<dd><p>The operation failed or the command syntax was not valid.
</p></dd>
</dl>
<span id="p11tool-See-Also"></span><span id="p11tool-See-Also-1"></span><h4 class="subheading">p11tool See Also</h4>
<p>certtool (1)
<span id="p11tool-Examples"></span></p><span id="p11tool-Examples-1"></span><h4 class="subheading">p11tool Examples</h4>
<p>To view all tokens in your system use:
</p><div class="example">
<pre class="example">$ p11tool --list-tokens
</pre></div>

<p>To view all objects in a token use:
</p><div class="example">
<pre class="example">$ p11tool --login --list-all &quot;pkcs11:TOKEN-URL&quot;
</pre></div>

<p>To store a private key and a certificate in a token run:
</p><div class="example">
<pre class="example">$ p11tool --login --write &quot;pkcs11:URL&quot; --load-privkey key.pem \
          --label &quot;Mykey&quot;
$ p11tool --login --write &quot;pkcs11:URL&quot; --load-certificate cert.pem \
          --label &quot;Mykey&quot;
</pre></div>
<p>Note that some tokens require the same label to be used for the certificate
and its corresponding private key.
</p>
<p>To generate an RSA private key inside the token use:
</p><div class="example">
<pre class="example">$ p11tool --login --generate-privkey rsa --bits 1024 --label &quot;MyNewKey&quot; \
          --outfile MyNewKey.pub &quot;pkcs11:TOKEN-URL&quot;
</pre></div>
<p>The bits parameter in the above example is explicitly set because some
tokens only support limited choices in the bit length. The output file is the
corresponding public key. This key can be used to general a certificate
request with certtool.
</p><div class="example">
<pre class="example">certtool --generate-request --load-privkey &quot;pkcs11:KEY-URL&quot; \
   --load-pubkey MyNewKey.pub --outfile request.pem
</pre></div>

<hr>
<span id="Trusted-Platform-Module"></span><div class="header">
<p>
Previous: <a href="#Smart-cards-and-HSMs" accesskey="p" rel="prev">Smart cards and HSMs</a>, Up: <a href="#Hardware-security-modules-and-abstract-key-types" accesskey="u" rel="up">Hardware security modules and abstract key types</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Trusted-Platform-Module-_0028TPM_0029"></span><h3 class="section">5.4 Trusted Platform Module (TPM)</h3>
<span id="index-trusted-platform-module"></span>
<span id="index-TPM"></span>

<p>In this section we present the Trusted Platform Module (TPM) support 
in <acronym>GnuTLS</acronym>. Note that we recommend against using TPM with this
API because it is restricted to TPM 1.2. We recommend instead
to use PKCS#11 wrappers for TPM such as CHAPS<a id="DOCF14" href="#FOOT14"><sup>14</sup></a> or opencryptoki<a id="DOCF15" href="#FOOT15"><sup>15</sup></a>.
These will allow using the standard smart card and HSM functionality (see <a href="#Smart-cards-and-HSMs">Smart cards and HSMs</a>) for TPM keys.
</p>
<p>There was a big hype when the TPM chip was introduced into 
computers. Briefly it is a co-processor in your PC that allows it to perform 
calculations independently of the main processor. This has good and bad 
side-effects. In this section we focus on the good ones; these are the fact that 
you can use the TPM chip to perform cryptographic operations on keys stored in it, without 
accessing them. That is very similar to the operation of a <acronym>PKCS</acronym> #11 smart card. 
The chip allows for storage and usage of RSA keys, but has quite some 
operational differences from <acronym>PKCS</acronym> #11 module, and thus require different handling. 
The basic TPM operations supported and used by GnuTLS, are key generation and signing. 
That support is currently limited to TPM 1.2.
</p>
<p>The next sections assume that the TPM chip in the system is already initialized and
in a operational state. If not, ensure that the TPM chip is enabled by your BIOS,
that the <code>tcsd</code> daemon is running, and that TPM ownership is set
(by running <code>tpm_takeownership</code>).
</p>
<p>In GnuTLS the TPM functionality is available in <code>gnutls/tpm.h</code>.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Keys-in-TPM" accesskey="1">Keys in TPM</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Key-generation" accesskey="2">Key generation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Using-keys" accesskey="3">Using keys</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#tpmtool-Invocation" accesskey="4">tpmtool Invocation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Keys-in-TPM"></span><div class="header">
<p>
Next: <a href="#Key-generation" accesskey="n" rel="next">Key generation</a>, Up: <a href="#Trusted-Platform-Module" accesskey="u" rel="up">Trusted Platform Module</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Keys-in-TPM-1"></span><h4 class="subsection">5.4.1 Keys in TPM</h4>

<p>The RSA keys in the TPM module may either be stored in a flash memory
within TPM or stored in a file in disk. In the former case the key can
provide operations as with <acronym>PKCS</acronym> #11 and is identified by
a URL. The URL is described in [<a href="#TPMURI">TPMURI</a>] and is of the following form.
</p><pre class="verbatim">tpmkey:uuid=42309df8-d101-11e1-a89a-97bb33c23ad1;storage=user
</pre>
<p>It consists from a unique identifier of the key as well as the part of the
flash memory the key is stored at. The two options for the storage field are
&lsquo;user&rsquo; and &lsquo;system&rsquo;. The user keys are typically only available to the generating
user and the system keys to all users. The stored in TPM keys are called
registered keys.
</p>
<p>The keys that are stored in the disk are exported from the TPM but in an
encrypted form. To access them two passwords are required. The first is the TPM
Storage Root Key (SRK), and the other is a key-specific password. Also those keys are
identified by a URL of the form:
</p><pre class="verbatim">tpmkey:file=/path/to/file
</pre>
<p>When objects require a PIN to be accessed the same callbacks as with PKCS #11
objects are expected (see <a href="#Accessing-objects-that-require-a-PIN">Accessing objects that require a PIN</a>). Note
that the PIN function may be called multiple times to unlock the SRK and
the specific key in use. The label in the key function will then be set to
&lsquo;SRK&rsquo; when unlocking the SRK key, or to &lsquo;TPM&rsquo; when unlocking any other key.
</p>
<hr>
<span id="Key-generation"></span><div class="header">
<p>
Next: <a href="#Using-keys" accesskey="n" rel="next">Using keys</a>, Previous: <a href="#Keys-in-TPM" accesskey="p" rel="prev">Keys in TPM</a>, Up: <a href="#Trusted-Platform-Module" accesskey="u" rel="up">Trusted Platform Module</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Key-generation-1"></span><h4 class="subsection">5.4.2 Key generation</h4>

<p>All keys used by the TPM must be generated by the TPM. This can be
done using <a href="#gnutls_005ftpm_005fprivkey_005fgenerate">gnutls_tpm_privkey_generate</a>.
</p>




<dl>
<dt id="index-gnutls_005ftpm_005fprivkey_005fgenerate">Function: <em>int</em> <strong>gnutls_tpm_privkey_generate</strong> <em>(gnutls_pk_algorithm_t <var>pk</var>, unsigned int <var>bits</var>, const char * <var>srk_password</var>, const char * <var>key_password</var>, gnutls_tpmkey_fmt_t <var>format</var>, gnutls_x509_crt_fmt_t <var>pub_format</var>, gnutls_datum_t * <var>privkey</var>, gnutls_datum_t * <var>pubkey</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>pk</var>: the public key algorithm
</p>
<p><var>bits</var>: the security bits
</p>
<p><var>srk_password</var>: a password to protect the exported key (optional)
</p>
<p><var>key_password</var>: the password for the TPM (optional)
</p>
<p><var>format</var>: the format of the private key
</p>
<p><var>pub_format</var>: the format of the public key
</p>
<p><var>privkey</var>: the generated key
</p>
<p><var>pubkey</var>: the corresponding public key (may be null)
</p>
<p><var>flags</var>: should be a list of GNUTLS_TPM_* flags
</p>
<p>This function will generate a private key in the TPM
chip. The private key will be generated within the chip
and will be exported in a wrapped with TPM&rsquo;s master key
form. Furthermore the wrapped key can be protected with
the provided  <code>password</code> .
</p>
<p>Note that bits in TPM is quantized value. If the input value
is not one of the allowed values, then it will be quantized to
one of 512, 1024, 2048, 4096, 8192 and 16384.
</p>
<p>Allowed flags are:
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.1.0
</p></dd></dl>

<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005ftpm_005fget_005fregistered">gnutls_tpm_get_registered</a> (gnutls_tpm_key_list_t * <var>list</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005ftpm_005fkey_005flist_005fdeinit">gnutls_tpm_key_list_deinit</a> (gnutls_tpm_key_list_t <var>list</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005ftpm_005fkey_005flist_005fget_005furl">gnutls_tpm_key_list_get_url</a> (gnutls_tpm_key_list_t <var>list</var>, unsigned int <var>idx</var>, char ** <var>url</var>, unsigned int <var>flags</var>)</code></dt>
</dl>





<dl>
<dt id="index-gnutls_005ftpm_005fprivkey_005fdelete">Function: <em>int</em> <strong>gnutls_tpm_privkey_delete</strong> <em>(const char * <var>url</var>, const char * <var>srk_password</var>)</em></dt>
<dd><p><var>url</var>: the URL describing the key
</p>
<p><var>srk_password</var>: a password for the SRK key
</p>
<p>This function will unregister the private key from the TPM
chip. 
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.1.0
</p></dd></dl>

<hr>
<span id="Using-keys"></span><div class="header">
<p>
Next: <a href="#tpmtool-Invocation" accesskey="n" rel="next">tpmtool Invocation</a>, Previous: <a href="#Key-generation" accesskey="p" rel="prev">Key generation</a>, Up: <a href="#Trusted-Platform-Module" accesskey="u" rel="up">Trusted Platform Module</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Using-keys-1"></span><h4 class="subsection">5.4.3 Using keys</h4>

<span id="Importing-keys"></span><h4 class="subsubheading">Importing keys</h4>

<p>The TPM keys can be used directly by the abstract key types and do not require
any special structures. Moreover functions like <a href="#gnutls_005fcertificate_005fset_005fx509_005fkey_005ffile2">gnutls_certificate_set_x509_key_file2</a>
can access TPM URLs.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fprivkey_005fimport_005ftpm_005fraw">gnutls_privkey_import_tpm_raw</a> (gnutls_privkey_t <var>pkey</var>, const gnutls_datum_t * <var>fdata</var>, gnutls_tpmkey_fmt_t <var>format</var>, const char * <var>srk_password</var>, const char * <var>key_password</var>, unsigned int <var>flags</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpubkey_005fimport_005ftpm_005fraw">gnutls_pubkey_import_tpm_raw</a> (gnutls_pubkey_t <var>pkey</var>, const gnutls_datum_t * <var>fdata</var>, gnutls_tpmkey_fmt_t <var>format</var>, const char * <var>srk_password</var>, unsigned int <var>flags</var>)</code></dt>
</dl>





<dl>
<dt id="index-gnutls_005fprivkey_005fimport_005ftpm_005furl">Function: <em>int</em> <strong>gnutls_privkey_import_tpm_url</strong> <em>(gnutls_privkey_t <var>pkey</var>, const char * <var>url</var>, const char * <var>srk_password</var>, const char * <var>key_password</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>pkey</var>: The private key
</p>
<p><var>url</var>: The URL of the TPM key to be imported
</p>
<p><var>srk_password</var>: The password for the SRK key (optional)
</p>
<p><var>key_password</var>: A password for the key (optional)
</p>
<p><var>flags</var>: One of the GNUTLS_PRIVKEY_* flags
</p>
<p>This function will import the given private key to the abstract
<code>gnutls_privkey_t</code>  type.
</p>
<p>Note that unless <code>GNUTLS_PRIVKEY_DISABLE_CALLBACKS</code> 
is specified, if incorrect (or NULL) passwords are given
the PKCS11 callback functions will be used to obtain the
correct passwords. Otherwise if the SRK password is wrong
<code>GNUTLS_E_TPM_SRK_PASSWORD_ERROR</code>  is returned and if the key password
is wrong or not provided then <code>GNUTLS_E_TPM_KEY_PASSWORD_ERROR</code> 
is returned. 
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.1.0
</p></dd></dl>




<dl>
<dt id="index-gnutls_005fpubkey_005fimport_005ftpm_005furl">Function: <em>int</em> <strong>gnutls_pubkey_import_tpm_url</strong> <em>(gnutls_pubkey_t <var>pkey</var>, const char * <var>url</var>, const char * <var>srk_password</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>pkey</var>: The public key
</p>
<p><var>url</var>: The URL of the TPM key to be imported
</p>
<p><var>srk_password</var>: The password for the SRK key (optional)
</p>
<p><var>flags</var>: should be zero
</p>
<p>This function will import the given private key to the abstract
<code>gnutls_privkey_t</code>  type. 
</p>
<p>Note that unless <code>GNUTLS_PUBKEY_DISABLE_CALLBACKS</code> 
is specified, if incorrect (or NULL) passwords are given
the PKCS11 callback functions will be used to obtain the
correct passwords. Otherwise if the SRK password is wrong
<code>GNUTLS_E_TPM_SRK_PASSWORD_ERROR</code>  is returned.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.1.0
</p></dd></dl>

<span id="Listing-and-deleting-keys"></span><h4 class="subsubheading">Listing and deleting keys</h4>

<p>The registered keys (that are stored in the TPM) can be listed using one of
the following functions. Those keys are unfortunately only identified by
their UUID and have no label or other human friendly identifier.
Keys can be deleted from permament storage using <a href="#gnutls_005ftpm_005fprivkey_005fdelete">gnutls_tpm_privkey_delete</a>.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005ftpm_005fget_005fregistered">gnutls_tpm_get_registered</a> (gnutls_tpm_key_list_t * <var>list</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005ftpm_005fkey_005flist_005fdeinit">gnutls_tpm_key_list_deinit</a> (gnutls_tpm_key_list_t <var>list</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005ftpm_005fkey_005flist_005fget_005furl">gnutls_tpm_key_list_get_url</a> (gnutls_tpm_key_list_t <var>list</var>, unsigned int <var>idx</var>, char ** <var>url</var>, unsigned int <var>flags</var>)</code></dt>
</dl>





<dl>
<dt id="index-gnutls_005ftpm_005fprivkey_005fdelete-1">Function: <em>int</em> <strong>gnutls_tpm_privkey_delete</strong> <em>(const char * <var>url</var>, const char * <var>srk_password</var>)</em></dt>
<dd><p><var>url</var>: the URL describing the key
</p>
<p><var>srk_password</var>: a password for the SRK key
</p>
<p>This function will unregister the private key from the TPM
chip. 
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.1.0
</p></dd></dl>


<hr>
<span id="tpmtool-Invocation"></span><div class="header">
<p>
Previous: <a href="#Using-keys" accesskey="p" rel="prev">Using keys</a>, Up: <a href="#Trusted-Platform-Module" accesskey="u" rel="up">Trusted Platform Module</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Invoking-tpmtool"></span><h4 class="subsection">5.4.4 Invoking tpmtool</h4>
<span id="index-tpmtool"></span>


<p>Program that allows handling cryptographic data from the TPM chip.
</p>
<p>This section was generated by <strong>AutoGen</strong>,
using the <code>agtexi-cmd</code> template and the option descriptions for the <code>tpmtool</code> program.
This software is released under the GNU General Public License, version 3 or later.
</p>

<span id="tpmtool-usage"></span><span id="tpmtool-help_002fusage-_0028_002d_002dhelp_0029"></span><h4 class="subheading">tpmtool help/usage (<samp>--help</samp>)</h4>
<span id="index-tpmtool-help"></span>

<p>This is the automatically generated usage text for tpmtool.
</p>
<p>The text printed is the same whether selected with the <code>help</code> option
(<samp>--help</samp>) or the <code>more-help</code> option (<samp>--more-help</samp>).  <code>more-help</code> will print
the usage text by passing it through a pager program.
<code>more-help</code> is disabled on platforms without a working
<code>fork(2)</code> function.  The <code>PAGER</code> environment variable is
used to select the program, defaulting to <samp>more</samp>.  Both will exit
with a status code of 0.
</p>
<div class="example">
<pre class="example">tpmtool - GnuTLS TPM tool
Usage:  tpmtool [ -&lt;flag&gt; [&lt;val&gt;] | --&lt;name&gt;[{=| }&lt;val&gt;] ]...

   -d, --debug=num            Enable debugging
                                - it must be in the range:
                                  0 to 9999
       --infile=file          Input file
                                - file must pre-exist
       --outfile=str          Output file
       --generate-rsa         Generate an RSA private-public key pair
       --register             Any generated key will be registered in the TPM
                                - requires the option 'generate-rsa'
       --signing              Any generated key will be a signing key
                                - requires the option 'generate-rsa'
                                -- and prohibits the option 'legacy'
       --legacy               Any generated key will be a legacy key
                                - requires the option 'generate-rsa'
                                -- and prohibits the option 'signing'
       --user                 Any registered key will be a user key
                                - requires the option 'register'
                                -- and prohibits the option 'system'
       --system               Any registered key will be a system key
                                - requires the option 'register'
                                -- and prohibits the option 'user'
       --pubkey=str           Prints the public key of the provided key
       --list                 Lists all stored keys in the TPM
       --delete=str           Delete the key identified by the given URL (UUID).
       --test-sign=str        Tests the signature operation of the provided object
       --sec-param=str        Specify the security level [low, legacy, medium, high, ultra].
       --bits=num             Specify the number of bits for key generate
       --inder                Use the DER format for keys.
                                - disabled as '--no-inder'
       --outder               Use DER format for output keys
                                - disabled as '--no-outder'
       --srk-well-known       SRK has well known password (20 bytes of zeros)
   -v, --version[=arg]        output version information and exit
   -h, --help                 display extended usage information and exit
   -!, --more-help            extended usage information passed thru pager

Options are specified by doubled hyphens and their name or by a single
hyphen and the flag character.

Program that allows handling cryptographic data from the TPM chip.

</pre></div>

<span id="tpmtool-debug"></span><span id="debug-option-_0028_002dd_0029-4"></span><h4 class="subheading">debug option (-d)</h4>

<p>This is the &ldquo;enable debugging&rdquo; option.
This option takes a number argument.
Specifies the debug level.
<span id="tpmtool-generate_002drsa"></span></p><span id="generate_002drsa-option"></span><h4 class="subheading">generate-rsa option</h4>

<p>This is the &ldquo;generate an rsa private-public key pair&rdquo; option.
Generates an RSA private-public key pair in the TPM chip. 
The key may be stored in file system and protected by a PIN, or stored (registered)
in the TPM chip flash.
<span id="tpmtool-user"></span></p><span id="user-option"></span><h4 class="subheading">user option</h4>

<p>This is the &ldquo;any registered key will be a user key&rdquo; option.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> must appear in combination with the following options:
register.
</li><li> must not appear in combination with any of the following options:
system.
</li></ul>

<p>The generated key will be stored in a user specific persistent storage.
<span id="tpmtool-system"></span></p><span id="system-option"></span><h4 class="subheading">system option</h4>

<p>This is the &ldquo;any registered key will be a system key&rdquo; option.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> must appear in combination with the following options:
register.
</li><li> must not appear in combination with any of the following options:
user.
</li></ul>

<p>The generated key will be stored in system persistent storage.
<span id="tpmtool-test_002dsign"></span></p><span id="test_002dsign-option"></span><h4 class="subheading">test-sign option</h4>

<p>This is the &ldquo;tests the signature operation of the provided object&rdquo; option.
This option takes a string argument <samp>url</samp>.
It can be used to test the correct operation of the signature operation.
This operation will sign and verify the signed data.
<span id="tpmtool-sec_002dparam"></span></p><span id="sec_002dparam-option"></span><h4 class="subheading">sec-param option</h4>

<p>This is the &ldquo;specify the security level [low, legacy, medium, high, ultra].&rdquo; option.
This option takes a string argument <samp>Security parameter</samp>.
This is alternative to the bits option. Note however that the
values allowed by the TPM chip are quantized and given values may be rounded up.
<span id="tpmtool-inder"></span></p><span id="inder-option-1"></span><h4 class="subheading">inder option</h4>

<p>This is the &ldquo;use the der format for keys.&rdquo; option.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> can be disabled with &ndash;no-inder.
</li></ul>

<p>The input files will be assumed to be in the portable
DER format of TPM. The default format is a custom format used by various
TPM tools
<span id="tpmtool-outder"></span></p><span id="outder-option-1"></span><h4 class="subheading">outder option</h4>

<p>This is the &ldquo;use der format for output keys&rdquo; option.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> can be disabled with &ndash;no-outder.
</li></ul>

<p>The output will be in the TPM portable DER format.
<span id="tpmtool-srk_002dwell_002dknown"></span></p><span id="srk_002dwell_002dknown-option"></span><h4 class="subheading">srk-well-known option</h4>

<p>This is the &ldquo;srk has well known password (20 bytes of zeros)&rdquo; option.
This option has no &lsquo;<samp>doc</samp>&rsquo; documentation.
<span id="tpmtool-exit-status"></span></p><span id="tpmtool-exit-status-1"></span><h4 class="subheading">tpmtool exit status</h4>

<p>One of the following exit values will be returned:
</p><dl compact="compact">
<dt>&lsquo;<samp>0 (EXIT_SUCCESS)</samp>&rsquo;</dt>
<dd><p>Successful program execution.
</p></dd>
<dt>&lsquo;<samp>1 (EXIT_FAILURE)</samp>&rsquo;</dt>
<dd><p>The operation failed or the command syntax was not valid.
</p></dd>
</dl>
<span id="tpmtool-See-Also"></span><span id="tpmtool-See-Also-1"></span><h4 class="subheading">tpmtool See Also</h4>
<p>p11tool (1), certtool (1)
<span id="tpmtool-Examples"></span></p><span id="tpmtool-Examples-1"></span><h4 class="subheading">tpmtool Examples</h4>
<p>To generate a key that is to be stored in file system use:
</p><div class="example">
<pre class="example">$ tpmtool --generate-rsa --bits 2048 --outfile tpmkey.pem
</pre></div>

<p>To generate a key that is to be stored in TPM&rsquo;s flash use:
</p><div class="example">
<pre class="example">$ tpmtool --generate-rsa --bits 2048 --register --user
</pre></div>

<p>To get the public key of a TPM key use:
</p><div class="example">
<pre class="example">$ tpmtool --pubkey tpmkey:uuid=58ad734b-bde6-45c7-89d8-756a55ad1891;storage=user \
          --outfile pubkey.pem
</pre></div>

<p>or if the key is stored in the file system:
</p><div class="example">
<pre class="example">$ tpmtool --pubkey tpmkey:file=tmpkey.pem --outfile pubkey.pem
</pre></div>

<p>To list all keys stored in TPM use:
</p><div class="example">
<pre class="example">$ tpmtool --list
</pre></div>


<hr>
<span id="How-to-use-GnuTLS-in-applications"></span><div class="header">
<p>
Next: <a href="#GnuTLS-application-examples" accesskey="n" rel="next">GnuTLS application examples</a>, Previous: <a href="#Hardware-security-modules-and-abstract-key-types" accesskey="p" rel="prev">Hardware security modules and abstract key types</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="How-to-use-GnuTLS-in-applications-1"></span><h2 class="chapter">6 How to use <acronym>GnuTLS</acronym> in applications</h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Introduction-to-the-library" accesskey="1">Introduction to the library</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Preparation" accesskey="2">Preparation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Session-initialization" accesskey="3">Session initialization</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Associating-the-credentials" accesskey="4">Associating the credentials</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Setting-up-the-transport-layer" accesskey="5">Setting up the transport layer</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#TLS-handshake" accesskey="6">TLS handshake</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Data-transfer-and-termination" accesskey="7">Data transfer and termination</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Buffered-data-transfer" accesskey="8">Buffered data transfer</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Handling-alerts" accesskey="9">Handling alerts</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Priority-Strings">Priority Strings</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Selecting-cryptographic-key-sizes">Selecting cryptographic key sizes</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Advanced-topics">Advanced topics</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Introduction-to-the-library"></span><div class="header">
<p>
Next: <a href="#Preparation" accesskey="n" rel="next">Preparation</a>, Up: <a href="#How-to-use-GnuTLS-in-applications" accesskey="u" rel="up">How to use GnuTLS in applications</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Introduction"></span><h3 class="section">6.1 Introduction</h3>

<p>This chapter tries to explain the basic functionality of the current GnuTLS
library. Note that there may be additional functionality not discussed here
but included in the library. Checking the header files in <samp>/usr/include/gnutls/</samp>
and the manpages is recommended.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#General-idea" accesskey="1">General idea</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Error-handling" accesskey="2">Error handling</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Common-types" accesskey="3">Common types</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Debugging-and-auditing" accesskey="4">Debugging and auditing</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Thread-safety" accesskey="5">Thread safety</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Running-in-a-sandbox" accesskey="6">Running in a sandbox</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Sessions-and-fork" accesskey="7">Sessions and fork</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Callback-functions" accesskey="8">Callback functions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="General-idea"></span><div class="header">
<p>
Next: <a href="#Error-handling" accesskey="n" rel="next">Error handling</a>, Up: <a href="#Introduction-to-the-library" accesskey="u" rel="up">Introduction to the library</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="General-idea-1"></span><h4 class="subsection">6.1.1 General idea</h4>

<p>A brief description of how <acronym>GnuTLS</acronym> sessions operate is shown
at <a href="#fig_002dgnutls_002ddesign">Figure 6.1</a>. This section will become more clear when it
is completely read.
As shown in the figure, there is a read-only global state that is
initialized once by the global initialization function.  This global
structure, among others, contains the memory allocation functions
used, structures needed for the <acronym>ASN.1</acronym> parser and depending
on the system&rsquo;s CPU, pointers to hardware accelerated encryption functions.  This
structure is never modified by any <acronym>GnuTLS</acronym> function, except
for the deinitialization function which frees all allocated memory
and must be called after the program has permanently
finished using <acronym>GnuTLS</acronym>.
</p>
<div class="float"><span id="fig_002dgnutls_002ddesign"></span>
<img src="gnutls-internals.png" alt="gnutls-internals">

<div class="float-caption"><p><strong>Figure 6.1: </strong>High level design of GnuTLS.</p></div></div>
<p>The credentials structures are used by the authentication methods, such
as certificate authentication. They store certificates, privates keys,
and other information that is needed to prove the identity to the peer,
and/or verify the identity of the peer. The information stored in
the credentials structures is initialized once and then can be 
shared by many <acronym>TLS</acronym> sessions.
</p>
<p>A <acronym>GnuTLS</acronym> session contains all the required state and 
information to handle one secure connection. The session communicates with the
peers using the provided functions of the transport layer.
Every session has a unique session ID shared with the peer.
</p>
<p>Since TLS sessions can be resumed, servers need a
database back-end to hold the session&rsquo;s parameters.  Every
<acronym>GnuTLS</acronym> session after a successful handshake calls the
appropriate back-end function (see <a href="#resume">resume</a>)
to store the newly negotiated session. The session
database is examined by the server just after having received the
client hello<a id="DOCF16" href="#FOOT16"><sup>16</sup></a>,
and if the session ID sent by the client, matches a stored session,
the stored session will be retrieved, and the new session will be a
resumed one, and will share the same session ID with the previous one.
</p>
<hr>
<span id="Error-handling"></span><div class="header">
<p>
Next: <a href="#Common-types" accesskey="n" rel="next">Common types</a>, Previous: <a href="#General-idea" accesskey="p" rel="prev">General idea</a>, Up: <a href="#Introduction-to-the-library" accesskey="u" rel="up">Introduction to the library</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Error-handling-1"></span><h4 class="subsection">6.1.2 Error handling</h4>

<p>There two types of <acronym>GnuTLS</acronym> functions. The first type returns
a boolean value, true (non-zero) or false (zero) value; these functions
are defined to return an unsigned integer type. The other type returns a
signed integer type with zero (or a positive number) indicating
success and a negative value indicating failure. For the latter
type it is recommended to check for errors as following.
</p><div class="example">
<pre class="example">    ret = gnutls_function();
    if (ret &lt; 0) {
        return -1;
    }
</pre></div>
<p>The above example checks for a failure condition rather than
for explicit success (e.g., equality to zero). That has the advantage
that future extensions of the API can be extended to provide
additional information via positive returned values (see for example
<a href="#gnutls_005fcertificate_005fset_005fx509_005fkey_005ffile">gnutls_certificate_set_x509_key_file</a>).
</p>
<p>For certain operations such as TLS handshake and TLS packet receive
there is the notion of fatal and non-fatal error codes.
Fatal errors terminate the TLS session immediately and further sends
and receives will be disallowed.  Such an example is
<code>GNUTLS_E_DECRYPTION_FAILED</code>. Non-fatal errors may warn about
something, i.e., a warning alert was received, or indicate the some
action has to be taken. This is the case with the error code
<code>GNUTLS_E_REHANDSHAKE</code> returned by <a href="#gnutls_005frecord_005frecv">gnutls_record_recv</a>.
This error code indicates that the server requests a re-handshake. The
client may ignore this request, or may reply with an alert.  You can
test if an error code is a fatal one by using the
<a href="#gnutls_005ferror_005fis_005ffatal">gnutls_error_is_fatal</a>.
All errors can be converted to a descriptive string using <a href="#gnutls_005fstrerror">gnutls_strerror</a>.
</p>
<p>If any non fatal errors, that require an action, are to be returned by
a function, these error codes will be documented in the function&rsquo;s
reference. For example the error codes <code>GNUTLS_E_WARNING_ALERT_RECEIVED</code> and <code>GNUTLS_E_FATAL_ALERT_RECEIVED</code>
that may returned when receiving data, should be handled by notifying the
user of the alert (as explained in <a href="#Handling-alerts">Handling alerts</a>).
See <a href="#Error-codes">Error codes</a>, for a description of the available error codes.
</p>
<hr>
<span id="Common-types"></span><div class="header">
<p>
Next: <a href="#Debugging-and-auditing" accesskey="n" rel="next">Debugging and auditing</a>, Previous: <a href="#Error-handling" accesskey="p" rel="prev">Error handling</a>, Up: <a href="#Introduction-to-the-library" accesskey="u" rel="up">Introduction to the library</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Common-types-1"></span><h4 class="subsection">6.1.3 Common types</h4>
<span id="index-gnutls_005fdatum_005ft"></span>
<span id="index-giovec_005ft"></span>

<p>All strings that are to provided as input to <acronym>GnuTLS</acronym> functions
should be in UTF-8 unless otherwise specified. Output strings are also
in UTF-8 format unless otherwise specified. When functions take as input
passwords, they will normalize them using [<a href="#RFC7613">RFC7613</a>] rules (since
GnuTLS 3.5.7).
</p>
<p>When data of a fixed size are provided to <acronym>GnuTLS</acronym> functions then
the helper structure <code>gnutls_datum_t</code> is often used. Its definition is
shown below.
</p><pre class="verbatim">  typedef struct
  {
    unsigned char *data;
    unsigned int size;
  } gnutls_datum_t;
</pre>
<p>In functions where this structure is a returned type, if the function succeeds,
it is expected from the caller to use <code>gnutls_free()</code> to deinitialize the
data element after use, unless otherwise specified. If the function fails, the
contents of the <code>gnutls_datum_t</code> should be considered undefined and must
not be deinitialized.
</p>
<p>Other functions that require data for scattered read use a structure similar
to <code>struct iovec</code> typically used by <code>readv</code>. It is shown
below.
</p><pre class="verbatim">  typedef struct
  {
    void *iov_base;             /* Starting address */
    size_t iov_len;             /* Number of bytes to transfer */
  } giovec_t;
</pre>

<hr>
<span id="Debugging-and-auditing"></span><div class="header">
<p>
Next: <a href="#Thread-safety" accesskey="n" rel="next">Thread safety</a>, Previous: <a href="#Common-types" accesskey="p" rel="prev">Common types</a>, Up: <a href="#Introduction-to-the-library" accesskey="u" rel="up">Introduction to the library</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Debugging-and-auditing-1"></span><h4 class="subsection">6.1.4 Debugging and auditing</h4>

<p>In many cases things may not go as expected and further information,
to assist debugging, from <acronym>GnuTLS</acronym> is desired. 
Those are the cases where the <a href="#gnutls_005fglobal_005fset_005flog_005flevel">gnutls_global_set_log_level</a> and
<a href="#gnutls_005fglobal_005fset_005flog_005ffunction">gnutls_global_set_log_function</a> are to be used. Those will print
verbose information on the <acronym>GnuTLS</acronym> functions internal flow.
</p>
<dl compact="compact">
<dt><code><var>void</var> <a href="#gnutls_005fglobal_005fset_005flog_005flevel">gnutls_global_set_log_level</a> (int <var>level</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005fglobal_005fset_005flog_005ffunction">gnutls_global_set_log_function</a> (gnutls_log_func <var>log_func</var>)</code></dt>
</dl>

<p>Alternatively the environment variable <code>GNUTLS_DEBUG_LEVEL</code> can be
set to a logging level and GnuTLS will output debugging output to standard
error. Other available environment variables are shown in <a href="#tab_003aenvironment">Table 6.1</a>.
</p>
<div class="float"><span id="tab_003aenvironment"></span>
<table>
<thead><tr><th width="30%">Variable</th><th width="70%">Purpose</th></tr></thead>
<tr><td width="30%"><code>GNUTLS_DEBUG_LEVEL</code></td><td width="70%">When set to a numeric value, it sets the default debugging level for GnuTLS applications.</td></tr>
<tr><td width="30%"><code>SSLKEYLOGFILE</code></td><td width="70%">When set to a filename, GnuTLS will append to it the session keys in the NSS Key Log
format. That format can be read by wireshark and will allow decryption of the session for debugging.</td></tr>
<tr><td width="30%"><code>GNUTLS_CPUID_OVERRIDE</code></td><td width="70%">That environment variable can be used to
explicitly enable/disable the use of certain CPU capabilities. Note that CPU
detection cannot be overridden, i.e., VIA options cannot be enabled on an Intel
CPU. The currently available options are:
<ul>
<li> 0x1: Disable all run-time detected optimizations
</li><li> 0x2: Enable AES-NI
</li><li> 0x4: Enable SSSE3
</li><li> 0x8: Enable PCLMUL
</li><li> 0x10: Enable AVX
</li><li> 0x20: Enable SHA_NI
</li><li> 0x100000: Enable VIA padlock
</li><li> 0x200000: Enable VIA PHE
</li><li> 0x400000: Enable VIA PHE SHA512
</li></ul></td></tr>
<tr><td width="30%"><code>GNUTLS_FORCE_FIPS_MODE</code></td><td width="70%">In setups where GnuTLS is compiled with support for FIPS140-2 (see <a href="#FIPS140_002d2-mode">FIPS140-2 mode</a>)
if set to one it will force the FIPS mode enablement.</td></tr>
</table>

<div class="float-caption"><p><strong>Table 6.1: </strong>Environment variables used by the library.</p></div></div>

<p>When debugging is not required, important issues, such as detected
attacks on the protocol still need to be logged. This is provided
by the logging function set by
<a href="#gnutls_005fglobal_005fset_005faudit_005flog_005ffunction">gnutls_global_set_audit_log_function</a>. The provided function
will receive an message and the corresponding
TLS session. The session information might be used to derive IP addresses
or other information about the peer involved.
</p>




<dl>
<dt id="index-gnutls_005fglobal_005fset_005faudit_005flog_005ffunction">Function: <em>void</em> <strong>gnutls_global_set_audit_log_function</strong> <em>(gnutls_audit_log_func <var>log_func</var>)</em></dt>
<dd><p><var>log_func</var>: it is the audit log function
</p>
<p>This is the function to set the audit logging function. This
is a function to report important issues, such as possible
attacks in the protocol. This is different from <code>gnutls_global_set_log_function()</code> 
because it will report also session-specific events. The session
parameter will be null if there is no corresponding TLS session.
</p>
<p><code>gnutls_audit_log_func</code> is of the form,
void (*gnutls_audit_log_func)( gnutls_session_t, const char*);
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<hr>
<span id="Thread-safety"></span><div class="header">
<p>
Next: <a href="#Running-in-a-sandbox" accesskey="n" rel="next">Running in a sandbox</a>, Previous: <a href="#Debugging-and-auditing" accesskey="p" rel="prev">Debugging and auditing</a>, Up: <a href="#Introduction-to-the-library" accesskey="u" rel="up">Introduction to the library</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Thread-safety-1"></span><h4 class="subsection">6.1.5 Thread safety</h4>
<span id="index-thread-safety"></span>

<p>The <acronym>GnuTLS</acronym> library is thread safe by design, meaning that
objects of the library such as TLS sessions, can be safely divided across
threads as long as a single thread accesses a single object. This is
sufficient to support a server which handles several sessions per thread.
Read-only access to objects, for example the credentials holding structures,
is also thread-safe. 
</p>
<p>A <code>gnutls_session_t</code> object could also be shared by two threads, one sending,
the other receiving. However, care must be taken on the following use cases:
</p><ul>
<li> The re-handshake process in TLS 1.2 or earlier must be handled only in
a single thread and no other thread may be performing any operation.
</li><li> The flag <code>GNUTLS_AUTO_REAUTH</code> cannot be used safely in this mode of operation.
</li><li> Any other operation which may send or receive data, like key update (c.f.,
<a href="#gnutls_005fsession_005fkey_005fupdate">gnutls_session_key_update</a>), must not be performed while threads
are receiving or writing.
</li><li> The termination of a session should be handled, either by a single thread being
active, or by the sender thread using <a href="#gnutls_005fbye">gnutls_bye</a> with <code>GNUTLS_SHUT_WR</code>
and the receiving thread waiting for a return value of zero (or timeout on
certain servers which do not respond).
</li><li> The functions <a href="#gnutls_005ftransport_005fset_005ferrno">gnutls_transport_set_errno</a> and <a href="#gnutls_005frecord_005fget_005fdirection">gnutls_record_get_direction</a>
should not be relied during parallel operation.
</li></ul>

<p>For several aspects of the library (e.g., the random generator, PKCS#11
operations), the library may utilize mutex locks (e.g., pthreads on GNU/Linux and CriticalSection on Windows)
which are transparently setup on library initialization. Prior to version 3.3.0
these were setup by explicitly calling <a href="#gnutls_005fglobal_005finit">gnutls_global_init</a>.<a id="DOCF17" href="#FOOT17"><sup>17</sup></a>
</p>
<p>Note that, on Glibc systems, unless the application is explicitly linked
with the libpthread library, no mutex locks are used and setup by GnuTLS. It 
will use the Glibc mutex stubs.
</p>
<hr>
<span id="Running-in-a-sandbox"></span><div class="header">
<p>
Next: <a href="#Sessions-and-fork" accesskey="n" rel="next">Sessions and fork</a>, Previous: <a href="#Thread-safety" accesskey="p" rel="prev">Thread safety</a>, Up: <a href="#Introduction-to-the-library" accesskey="u" rel="up">Introduction to the library</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Running-in-a-sandbox-1"></span><h4 class="subsection">6.1.6 Running in a sandbox</h4>
<span id="index-seccomp"></span>
<span id="index-isolated-mode"></span>

<p>Given that TLS protocol handling as well as X.509 certificate
parsing are complicated processes involving several thousands lines of code,
it is often desirable (and recommended) to run the TLS session handling in
a sandbox like seccomp. That has to be allowed by the overall software design,
but if available, it adds an additional layer of protection by
preventing parsing errors from becoming vessels for further security issues such
as code execution.
</p>
<p>GnuTLS requires the following system calls to be available for its proper
operation.
</p>
<ul>
<li> nanosleep
</li><li> time
</li><li> gettimeofday
</li><li> clock_gettime
</li><li> getrusage
</li><li> getpid
</li><li> send
</li><li> recv
</li><li> sendmsg
</li><li> read (to read from /dev/urandom)
</li><li> getrandom (this is Linux-kernel specific)
</li><li> poll
</li></ul>

<p>As well as any calls needed for memory allocation to work. Note however, that GnuTLS
depends on libc for the system calls, and there is no guarantee that libc will
call the expected system call. For that it is recommended to test your
program in all the targeted platforms when filters like seccomp are in place.
</p>
<p>An example with a seccomp filter from GnuTLS&rsquo; test suite is at:
<a href="https://gitlab.com/gnutls/gnutls/blob/master/tests/seccomp.c">https://gitlab.com/gnutls/gnutls/blob/master/tests/seccomp.c</a>.
</p>
<hr>
<span id="Sessions-and-fork"></span><div class="header">
<p>
Next: <a href="#Callback-functions" accesskey="n" rel="next">Callback functions</a>, Previous: <a href="#Running-in-a-sandbox" accesskey="p" rel="prev">Running in a sandbox</a>, Up: <a href="#Introduction-to-the-library" accesskey="u" rel="up">Introduction to the library</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Sessions-and-fork-1"></span><h4 class="subsection">6.1.7 Sessions and fork</h4>
<span id="index-fork"></span>

<p>A <code>gnutls_session_t</code> object can be shared by two processes after a fork,
one sending, the other receiving. In that case rehandshakes, 
cannot and must not be performed. As with threads, the termination of a session should be
handled by the sender process using <a href="#gnutls_005fbye">gnutls_bye</a> with <code>GNUTLS_SHUT_WR</code>
and the receiving process waiting for a return value of zero.
</p>

<hr>
<span id="Callback-functions"></span><div class="header">
<p>
Previous: <a href="#Sessions-and-fork" accesskey="p" rel="prev">Sessions and fork</a>, Up: <a href="#Introduction-to-the-library" accesskey="u" rel="up">Introduction to the library</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Callback-functions-1"></span><h4 class="subsection">6.1.8 Callback functions</h4>
<span id="index-callback-functions"></span>

<p>There are several cases where <acronym>GnuTLS</acronym> may need out of
band input from your program. This is now implemented using some
callback functions, which your program is expected to register.
</p>
<p>An example of this type of functions are the push and pull callbacks
which are used to specify the functions that will retrieve and send
data to the transport layer.
</p>
<dl compact="compact">
<dt><code><var>void</var> <a href="#gnutls_005ftransport_005fset_005fpush_005ffunction">gnutls_transport_set_push_function</a> (gnutls_session_t <var>session</var>, gnutls_push_func <var>push_func</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005ftransport_005fset_005fpull_005ffunction">gnutls_transport_set_pull_function</a> (gnutls_session_t <var>session</var>, gnutls_pull_func <var>pull_func</var>)</code></dt>
</dl>

<p>Other callback functions may require more complicated input and data
to be allocated. Such an example is 
<a href="#gnutls_005fsrp_005fset_005fserver_005fcredentials_005ffunction">gnutls_srp_set_server_credentials_function</a>.
All callbacks should allocate and free memory using 
<code>gnutls_malloc</code> and <code>gnutls_free</code>.
</p>

<hr>
<span id="Preparation"></span><div class="header">
<p>
Next: <a href="#Session-initialization" accesskey="n" rel="next">Session initialization</a>, Previous: <a href="#Introduction-to-the-library" accesskey="p" rel="prev">Introduction to the library</a>, Up: <a href="#How-to-use-GnuTLS-in-applications" accesskey="u" rel="up">How to use GnuTLS in applications</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Preparation-1"></span><h3 class="section">6.2 Preparation</h3>

<p>To use <acronym>GnuTLS</acronym>, you have to perform some changes to your
sources and your build system. The necessary changes are explained in
the following subsections.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Headers" accesskey="1">Headers</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Initialization" accesskey="2">Initialization</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Version-check" accesskey="3">Version check</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Building-the-source" accesskey="4">Building the source</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Headers"></span><div class="header">
<p>
Next: <a href="#Initialization" accesskey="n" rel="next">Initialization</a>, Up: <a href="#Preparation" accesskey="u" rel="up">Preparation</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Headers-1"></span><h4 class="subsection">6.2.1 Headers</h4>

<p>All the data types and functions of the <acronym>GnuTLS</acronym> library are
defined in the header file <samp>gnutls/gnutls.h</samp>.  This must be
included in all programs that make use of the <acronym>GnuTLS</acronym>
library.
</p>
<hr>
<span id="Initialization"></span><div class="header">
<p>
Next: <a href="#Version-check" accesskey="n" rel="next">Version check</a>, Previous: <a href="#Headers" accesskey="p" rel="prev">Headers</a>, Up: <a href="#Preparation" accesskey="u" rel="up">Preparation</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Initialization-2"></span><h4 class="subsection">6.2.2 Initialization</h4>

<p>The GnuTLS library is initialized on load; prior to 3.3.0 was initialized by calling <a href="#gnutls_005fglobal_005finit">gnutls_global_init</a><a id="DOCF18" href="#FOOT18"><sup>18</sup></a>. 
The initialization typically enables CPU-specific acceleration, performs any required
precalculations needed, opens any required system devices (e.g., /dev/urandom on Linux)
and initializes subsystems that could be used later.
</p>
<p>The resources allocated by the initialization process will be released 
on library deinitialization.
</p>
<p>Note that on certain systems file descriptors may be kept open by
GnuTLS (e.g. /dev/urandom) on library load. Applications closing all unknown file
descriptors must immediately call <a href="#gnutls_005fglobal_005finit">gnutls_global_init</a>, after that, to
ensure they don&rsquo;t disrupt GnuTLS&rsquo; operation.
</p>

<hr>
<span id="Version-check"></span><div class="header">
<p>
Next: <a href="#Building-the-source" accesskey="n" rel="next">Building the source</a>, Previous: <a href="#Initialization" accesskey="p" rel="prev">Initialization</a>, Up: <a href="#Preparation" accesskey="u" rel="up">Preparation</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Version-check-1"></span><h4 class="subsection">6.2.3 Version check</h4>

<p>It is often desirable to check that the version of &lsquo;gnutls&rsquo; used is
indeed one which fits all requirements.  Even with binary
compatibility new features may have been introduced but due to problem
with the dynamic linker an old version is actually used.  So you may
want to check that the version is okay right after program start-up.
See the function <a href="#gnutls_005fcheck_005fversion">gnutls_check_version</a>.
</p>
<p>On the other hand, it is often desirable to support more than one
versions of the library. In that case you could utilize compile-time 
feature checks using the <code>GNUTLS_VERSION_NUMBER</code> macro. 
For example, to conditionally add code for GnuTLS 3.2.1 or later, you may use:
</p><div class="example">
<pre class="example">#if GNUTLS_VERSION_NUMBER &gt;= 0x030201
 ...
#endif
</pre></div>

<hr>
<span id="Building-the-source"></span><div class="header">
<p>
Previous: <a href="#Version-check" accesskey="p" rel="prev">Version check</a>, Up: <a href="#Preparation" accesskey="u" rel="up">Preparation</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Building-the-source-1"></span><h4 class="subsection">6.2.4 Building the source</h4>

<p>If you want to compile a source file including the
<samp>gnutls/gnutls.h</samp> header file, you must make sure that the
compiler can find it in the directory hierarchy.  This is accomplished
by adding the path to the directory in which the header file is
located to the compilers include file search path (via the <samp>-I</samp>
option).
</p>
<p>However, the path to the include file is determined at the time the
source is configured.  To solve this problem, the library uses the
external package <code>pkg-config</code> that knows the path to the
include file and other configuration options.  The options that need
to be added to the compiler invocation at compile time are output by
the <samp>--cflags</samp> option to <code>pkg-config gnutls</code>.  The
following example shows how it can be used at the command line:
</p>
<div class="example">
<pre class="example">gcc -c foo.c `pkg-config gnutls --cflags`
</pre></div>

<p>Adding the output of &lsquo;<samp>pkg-config gnutls --cflags</samp>&rsquo; to the
compilers command line will ensure that the compiler can find the
<samp>gnutls/gnutls.h</samp> header file.
</p>
<p>A similar problem occurs when linking the program with the library.
Again, the compiler has to find the library files.  For this to work,
the path to the library files has to be added to the library search
path (via the <samp>-L</samp> option).  For this, the option
<samp>--libs</samp> to <code>pkg-config gnutls</code> can be used.  For
convenience, this option also outputs all other options that are
required to link the program with the library (for instance, the
&lsquo;<samp>-ltasn1</samp>&rsquo; option).  The example shows how to link <samp>foo.o</samp>
with the library to a program <code>foo</code>.
</p>
<div class="example">
<pre class="example">gcc -o foo foo.o `pkg-config gnutls --libs`
</pre></div>

<p>Of course you can also combine both examples to a single command by
specifying both options to <code>pkg-config</code>:
</p>
<div class="example">
<pre class="example">gcc -o foo foo.c `pkg-config gnutls --cflags --libs`
</pre></div>

<p>When a program uses the GNU autoconf system, then the following
line or similar can be used to detect the presence of GnuTLS.
</p>
<div class="example">
<pre class="example">PKG_CHECK_MODULES([LIBGNUTLS], [gnutls &gt;= 3.3.0])

AC_SUBST([LIBGNUTLS_CFLAGS])
AC_SUBST([LIBGNUTLS_LIBS])
</pre></div>

<hr>
<span id="Session-initialization"></span><div class="header">
<p>
Next: <a href="#Associating-the-credentials" accesskey="n" rel="next">Associating the credentials</a>, Previous: <a href="#Preparation" accesskey="p" rel="prev">Preparation</a>, Up: <a href="#How-to-use-GnuTLS-in-applications" accesskey="u" rel="up">How to use GnuTLS in applications</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Session-initialization-1"></span><h3 class="section">6.3 Session initialization</h3>

<p>In the previous sections we have discussed the global initialization
required for GnuTLS as well as the initialization required for each
authentication method&rsquo;s credentials (see <a href="#Authentication">Authentication</a>).
In this section we elaborate on the TLS or DTLS session initiation.
Each session is initialized using <a href="#gnutls_005finit">gnutls_init</a> which among
others is used to specify the type of the connection (server or client), 
and the underlying protocol type, i.e., datagram (UDP) or reliable (TCP).
</p>




<dl>
<dt id="index-gnutls_005finit">Function: <em>int</em> <strong>gnutls_init</strong> <em>(gnutls_session_t * <var>session</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>session</var>: is a pointer to a <code>gnutls_session_t</code>  type.
</p>
<p><var>flags</var>: indicate if this session is to be used for server or client.
</p>
<p>This function initializes the provided session. Every
session must be initialized before use, and must be deinitialized
after used by calling <code>gnutls_deinit()</code> .
</p>
<p><code>flags</code> can be any combination of flags from <code>gnutls_init_flags_t</code> .
</p>
<p>Note that since version 3.1.2 this function enables some common
TLS extensions such as session tickets and OCSP certificate status
request in client side by default. To prevent that use the <code>GNUTLS_NO_EXTENSIONS</code> 
flag.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, or an error code.
</p></dd></dl>

<div class="float"><span id="gnutls_005finit_005fflags_005ft"></span>


<dl compact="compact">
<dt><code>GNUTLS_SERVER</code></dt>
<dd><p>Connection end is a server.
</p></dd>
<dt><code>GNUTLS_CLIENT</code></dt>
<dd><p>Connection end is a client.
</p></dd>
<dt><code>GNUTLS_DATAGRAM</code></dt>
<dd><p>Connection is datagram oriented (DTLS). Since 3.0.0.
</p></dd>
<dt><code>GNUTLS_NONBLOCK</code></dt>
<dd><p>Connection should not block. Since 3.0.0.
</p></dd>
<dt><code>GNUTLS_NO_EXTENSIONS</code></dt>
<dd><p>Do not enable any TLS extensions by default (since 3.1.2). As TLS 1.2 and later require extensions this option is considered obsolete and should not be used.
</p></dd>
<dt><code>GNUTLS_NO_REPLAY_PROTECTION</code></dt>
<dd><p>Disable any replay protection in DTLS. This must only be used if  replay protection is achieved using other means. Since 3.2.2.
</p></dd>
<dt><code>GNUTLS_NO_SIGNAL</code></dt>
<dd><p>In systems where SIGPIPE is delivered on send, it will be disabled. That flag has effect in systems which support the MSG_NOSIGNAL sockets flag (since 3.4.2).
</p></dd>
<dt><code>GNUTLS_ALLOW_ID_CHANGE</code></dt>
<dd><p>Allow the peer to replace its certificate, or change its ID during a rehandshake. This change is often used in attacks and thus prohibited by default. Since 3.5.0.
</p></dd>
<dt><code>GNUTLS_ENABLE_FALSE_START</code></dt>
<dd><p>Enable the TLS false start on client side if the negotiated ciphersuites allow it. This will enable sending data prior to the handshake being complete, and may introduce a risk of crypto failure when combined with certain key exchanged; for that GnuTLS may not enable that option in ciphersuites that are known to be not safe for false start. Since 3.5.0.
</p></dd>
<dt><code>GNUTLS_FORCE_CLIENT_CERT</code></dt>
<dd><p>When in client side and only a single cert is specified, send that certificate irrespective of the issuers expected by the server. Since 3.5.0.
</p></dd>
<dt><code>GNUTLS_NO_TICKETS</code></dt>
<dd><p>Flag to indicate that the session should not use resumption with session tickets.
</p></dd>
<dt><code>GNUTLS_KEY_SHARE_TOP</code></dt>
<dd><p>Generate key share for the first group which is enabled.
For example x25519. This option is the most performant for client (less CPU spent
generating keys), but if the server doesn&rsquo;t support the advertized option it may
result to more roundtrips needed to discover the server&rsquo;s choice.
</p></dd>
<dt><code>GNUTLS_KEY_SHARE_TOP2</code></dt>
<dd><p>Generate key shares for the top-2 different groups which are enabled.
For example (ECDH + x25519). This is the default.
</p></dd>
<dt><code>GNUTLS_KEY_SHARE_TOP3</code></dt>
<dd><p>Generate key shares for the top-3 different groups which are enabled.
That is, as each group is associated with a key type (EC, finite field, x25519), generate
three keys using <code>GNUTLS_PK_DH</code> , <code>GNUTLS_PK_EC</code> , <code>GNUTLS_PK_ECDH_X25519</code>  if all of them are enabled.
</p></dd>
<dt><code>GNUTLS_POST_HANDSHAKE_AUTH</code></dt>
<dd><p>Enable post handshake authentication for server and client. When set and
a server requests authentication after handshake <code>GNUTLS_E_REAUTH_REQUEST</code>  will be returned
by <code>gnutls_record_recv()</code> . A client should then call <code>gnutls_reauth()</code>  to re-authenticate.
</p></dd>
<dt><code>GNUTLS_NO_AUTO_REKEY</code></dt>
<dd><p>Disable auto-rekeying under TLS1.3. If this option is not specified
gnutls will force a rekey after 2^24 records have been sent.
</p></dd>
<dt><code>GNUTLS_SAFE_PADDING_CHECK</code></dt>
<dd><p>Flag to indicate that the TLS 1.3 padding check will be done in a
safe way which doesn&rsquo;t leak the pad size based on GnuTLS processing time. This is of use to
applications which hide the length of transferred data via the TLS1.3 padding mechanism and
are already taking steps to hide the data processing time. This comes at a performance
penalty.
</p></dd>
<dt><code>GNUTLS_ENABLE_EARLY_START</code></dt>
<dd><p>Under TLS1.3 allow the server to return earlier than the full handshake
finish; similarly to false start the handshake will be completed once data are received by the
client, while the server is able to transmit sooner. This is not enabled by default as it could
break certain existing server assumptions and use-cases. Since 3.6.4.
</p></dd>
<dt><code>GNUTLS_ENABLE_RAWPK</code></dt>
<dd><p>Allows raw public-keys to be negotiated during the handshake. Since 3.6.6.
</p></dd>
<dt><code>GNUTLS_AUTO_REAUTH</code></dt>
<dd><p>Enable transparent re-authentication in client side when the server
requests to. That is, reauthentication is handled within <code>gnutls_record_recv()</code> , and
the <code>GNUTLS_E_REHANDSHAKE</code>  or <code>GNUTLS_E_REAUTH_REQUEST</code>  are not returned. This must be
enabled with <code>GNUTLS_POST_HANDSHAKE_AUTH</code>  for TLS1.3. Enabling this flag requires to restore
interrupted calls to <code>gnutls_record_recv()</code>  based on the output of <code>gnutls_record_get_direction()</code> ,
since <code>gnutls_record_recv()</code>  could be interrupted when sending when this flag is enabled.
Note this flag may not be used if you are using the same session for sending and receiving
in different threads.
</p></dd>
<dt><code>GNUTLS_ENABLE_EARLY_DATA</code></dt>
<dd><p>Under TLS1.3 allow the server to receive early data sent as part of the initial ClientHello (0-RTT). 
This is not enabled by default as early data has weaker security properties than other data. Since 3.6.5.
</p></dd>
</dl>

<div class="float-caption"><p><strong>Figure 6.2: </strong>The <code>gnutls_init_flags_t</code> enumeration.</p></div></div>
<p>After the session initialization details on the allowed ciphersuites
and protocol versions should be set using the priority functions
such as <a href="#gnutls_005fpriority_005fset">gnutls_priority_set</a> and <a href="#gnutls_005fpriority_005fset_005fdirect">gnutls_priority_set_direct</a>.
We elaborate on them in <a href="#Priority-Strings">Priority Strings</a>.
The credentials used for the key exchange method, such as certificates 
or usernames and passwords should also be associated with the session
current session using <a href="#gnutls_005fcredentials_005fset">gnutls_credentials_set</a>. 
</p>




<dl>
<dt id="index-gnutls_005fcredentials_005fset">Function: <em>int</em> <strong>gnutls_credentials_set</strong> <em>(gnutls_session_t <var>session</var>, gnutls_credentials_type_t <var>type</var>, void * <var>cred</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>type</var>: is the type of the credentials
</p>
<p><var>cred</var>: the credentials to set
</p>
<p>Sets the needed credentials for the specified type.  E.g. username,
password - or public and private keys etc.  The  <code>cred</code> parameter is
a structure that depends on the specified type and on the current
session (client or server).
</p>
<p>In order to minimize memory usage, and share credentials between
several threads gnutls keeps a pointer to cred, and not the whole
cred structure.  Thus you will have to keep the structure allocated
until you call <code>gnutls_deinit()</code> .
</p>
<p>For <code>GNUTLS_CRD_ANON</code> ,  <code>cred</code> should be
<code>gnutls_anon_client_credentials_t</code>  in case of a client.  In case of
a server it should be <code>gnutls_anon_server_credentials_t</code> .
</p>
<p>For <code>GNUTLS_CRD_SRP</code> ,  <code>cred</code> should be <code>gnutls_srp_client_credentials_t</code> 
in case of a client, and <code>gnutls_srp_server_credentials_t</code> , in case
of a server.
</p>
<p>For <code>GNUTLS_CRD_CERTIFICATE</code> ,  <code>cred</code> should be
<code>gnutls_certificate_credentials_t</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p></dd></dl>

<hr>
<span id="Associating-the-credentials"></span><div class="header">
<p>
Next: <a href="#Setting-up-the-transport-layer" accesskey="n" rel="next">Setting up the transport layer</a>, Previous: <a href="#Session-initialization" accesskey="p" rel="prev">Session initialization</a>, Up: <a href="#How-to-use-GnuTLS-in-applications" accesskey="u" rel="up">How to use GnuTLS in applications</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Associating-the-credentials-1"></span><h3 class="section">6.4 Associating the credentials</h3>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Certificate-credentials" accesskey="1">Certificate credentials</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Raw-public_002dkey-credentials" accesskey="2">Raw public-key credentials</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#SRP-credentials" accesskey="3">SRP credentials</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#PSK-credentials" accesskey="4">PSK credentials</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Anonymous-credentials" accesskey="5">Anonymous credentials</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<p>Each authentication method is associated with a key exchange method, and a credentials type. 
The contents of the credentials is method-dependent, e.g. certificates
for certificate authentication and should be initialized and associated
with a session (see <a href="#gnutls_005fcredentials_005fset">gnutls_credentials_set</a>).  A mapping of the key exchange methods
with the credential types is shown in <a href="#tab_003akey_002dexchange_002dcred">Table 6.2</a>.
</p>
<div class="float"><span id="tab_003akey_002dexchange_002dcred"></span>
<table>
<thead><tr><th width="25%">Authentication method</th><th width="25%">Key exchange</th><th width="20%">Client credentials</th><th width="20%">Server credentials</th></tr></thead>
<tr><td width="25%">Certificate and Raw public-key</td><td width="25%"><code>KX_RSA</code>,
<code>KX_DHE_RSA</code>,
<code>KX_DHE_DSS</code>,
<code>KX_ECDHE_RSA</code>,
<code>KX_ECDHE_ECDSA</code></td><td width="20%"><code>CRD_CERTIFICATE</code></td><td width="20%"><code>CRD_CERTIFICATE</code></td></tr>
<tr><td width="25%">Password and certificate</td><td width="25%"><code>KX_SRP_RSA</code>, <code>KX_SRP_DSS</code></td><td width="20%"><code>CRD_SRP</code></td><td width="20%"><code>CRD_CERTIFICATE</code>, <code>CRD_SRP</code></td></tr>
<tr><td width="25%">Password</td><td width="25%"><code>KX_SRP</code></td><td width="20%"><code>CRD_SRP</code></td><td width="20%"><code>CRD_SRP</code></td></tr>
<tr><td width="25%">Anonymous</td><td width="25%"><code>KX_ANON_DH</code>,
<code>KX_ANON_ECDH</code></td><td width="20%"><code>CRD_ANON</code></td><td width="20%"><code>CRD_ANON</code></td></tr>
<tr><td width="25%">Pre-shared key</td><td width="25%"><code>KX_PSK</code>,
<code>KX_DHE_PSK</code>, <code>KX_ECDHE_PSK</code></td><td width="20%"><code>CRD_PSK</code></td><td width="20%"><code>CRD_PSK</code></td></tr>
</table>

<div class="float-caption"><p><strong>Table 6.2: </strong>Key exchange algorithms and the corresponding credential types.</p></div></div>
<hr>
<span id="Certificate-credentials"></span><div class="header">
<p>
Next: <a href="#Raw-public_002dkey-credentials" accesskey="n" rel="next">Raw public-key credentials</a>, Up: <a href="#Associating-the-credentials" accesskey="u" rel="up">Associating the credentials</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Certificates"></span><h4 class="subsection">6.4.1 Certificates</h4>
<span id="Server-certificate-authentication"></span><h4 class="subsubheading">Server certificate authentication</h4>

<p>When using certificates the server is required to have at least one
certificate and private key pair. Clients may not hold such
a pair, but a server could require it. In this section we discuss
general issues applying to both client and server certificates. The next
section will elaborate on issues arising from client authentication only.
</p>
<p>In order to use certificate credentials one must first initialize a credentials
structure of type <code>gnutls_certificate_credentials_t</code>. After use this structure must
be freed. This can be done with the following functions.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fcertificate_005fallocate_005fcredentials">gnutls_certificate_allocate_credentials</a> (gnutls_certificate_credentials_t *      <var>res</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005fcertificate_005ffree_005fcredentials">gnutls_certificate_free_credentials</a> (gnutls_certificate_credentials_t <var>sc</var>)</code></dt>
</dl>

<p>After the credentials structures are initialized, the certificate 
and key pair must be loaded. This occurs before any <acronym>TLS</acronym> 
session is initialized, and the same structures are reused for multiple sessions.
Depending on the certificate type different loading functions
are available, as shown below.
For <acronym>X.509</acronym> certificates, the functions will
accept and use a certificate chain that leads to a trusted
authority. The certificate chain must be ordered in such way that every
certificate certifies the one before it. The trusted authority&rsquo;s
certificate need not to be included since the peer should possess it
already.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fcertificate_005fset_005fx509_005fkey_005ffile2">gnutls_certificate_set_x509_key_file2</a> (gnutls_certificate_credentials_t <var>res</var>, const char * <var>certfile</var>, const char * <var>keyfile</var>, gnutls_x509_crt_fmt_t <var>type</var>, const char * <var>pass</var>, unsigned int <var>flags</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fcertificate_005fset_005fx509_005fkey_005fmem2">gnutls_certificate_set_x509_key_mem2</a> (gnutls_certificate_credentials_t <var>res</var>, const gnutls_datum_t * <var>cert</var>, const gnutls_datum_t * <var>key</var>, gnutls_x509_crt_fmt_t <var>type</var>, const char * <var>pass</var>, unsigned int <var>flags</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fcertificate_005fset_005fx509_005fkey">gnutls_certificate_set_x509_key</a> (gnutls_certificate_credentials_t <var>res</var>, gnutls_x509_crt_t * <var>cert_list</var>, int <var>cert_list_size</var>, gnutls_x509_privkey_t <var>key</var>)</code></dt>
</dl>

<p>It is recommended to use the higher level functions such as <a href="#gnutls_005fcertificate_005fset_005fx509_005fkey_005ffile2">gnutls_certificate_set_x509_key_file2</a>
which accept not only file names but URLs that specify objects stored in token,
or system certificates and keys (see <a href="#Application_002dspecific-keys">Application-specific keys</a>). For these cases, another important 
function is <a href="#gnutls_005fcertificate_005fset_005fpin_005ffunction">gnutls_certificate_set_pin_function</a>, that
allows setting a callback function to retrieve a PIN if the input keys are
protected by PIN.
</p>




<dl>
<dt id="index-gnutls_005fcertificate_005fset_005fpin_005ffunction">Function: <em>void</em> <strong>gnutls_certificate_set_pin_function</strong> <em>(gnutls_certificate_credentials_t       <var>cred</var>, gnutls_pin_callback_t <var>fn</var>, void * <var>userdata</var>)</em></dt>
<dd><p><var>cred</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>fn</var>: A PIN callback
</p>
<p><var>userdata</var>: Data to be passed in the callback
</p>
<p>This function will set a callback function to be used when
required to access a protected object. This function overrides any other
global PIN functions.
</p>
<p>Note that this function must be called right after initialization
to have effect.
</p>
<p><strong>Since:</strong> 3.1.0
</p></dd></dl>

<p>If the imported keys and certificates need to be accessed before any TLS session
is established, it is convenient to use <a href="#gnutls_005fcertificate_005fset_005fkey">gnutls_certificate_set_key</a>
in combination with <a href="#gnutls_005fpcert_005fimport_005fx509_005fraw">gnutls_pcert_import_x509_raw</a> and <a href="#gnutls_005fprivkey_005fimport_005fx509_005fraw">gnutls_privkey_import_x509_raw</a>.
</p>



<dl>
<dt id="index-gnutls_005fcertificate_005fset_005fkey">Function: <em>int</em> <strong>gnutls_certificate_set_key</strong> <em>(gnutls_certificate_credentials_t <var>res</var>, const char ** <var>names</var>, int <var>names_size</var>, gnutls_pcert_st * <var>pcert_list</var>, int <var>pcert_list_size</var>, gnutls_privkey_t <var>key</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>names</var>: is an array of DNS names belonging to the public-key (NULL if none)
</p>
<p><var>names_size</var>: holds the size of the names list
</p>
<p><var>pcert_list</var>: contains a certificate list (chain) or raw public-key
</p>
<p><var>pcert_list_size</var>: holds the size of the certificate list
</p>
<p><var>key</var>: is a <code>gnutls_privkey_t</code>  key corresponding to the first public-key in pcert_list
</p>
<p>This function sets a public/private key pair in the
gnutls_certificate_credentials_t type. The given public key may be encapsulated
in a certificate or can be given as a raw key. This function may be
called more than once, in case multiple key pairs exist for
the server. For clients that want to send more than their own end-
entity certificate (e.g., also an intermediate CA cert), the full
certificate chain must be provided in  <code>pcert_list</code> .
</p>
<p>Note that the  <code>key</code> will become part of the credentials structure and must
not be deallocated. It will be automatically deallocated when the  <code>res</code> structure
is deinitialized.
</p>
<p>If this function fails, the  <code>res</code> structure is at an undefined state and it must
not be reused to load other keys or certificates.
</p>
<p>Note that, this function by default returns zero on success and a negative value on error.
Since 3.5.6, when the flag <code>GNUTLS_CERTIFICATE_API_V2</code>  is set using <code>gnutls_certificate_set_flags()</code> 
it returns an index (greater or equal to zero). That index can be used for other functions to refer to the added key-pair.
</p>
<p>Since GnuTLS 3.6.6 this function also handles raw public keys.
</p>
<p><strong>Returns:</strong> On success this functions returns zero, and otherwise a negative value on error (see above for modifying that behavior).
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<p>If multiple certificates are used with the functions above each
client&rsquo;s request will be served with the certificate that matches the
requested name (see <a href="#Server-name-indication">Server name indication</a>).
</p>
<p>As an alternative to loading from files or buffers, a callback may be used for the 
server or the client to specify the certificate and the key at the handshake time.
In that case a certificate should be selected according the peer&rsquo;s signature
algorithm preferences. To get those preferences use
<a href="#gnutls_005fsign_005falgorithm_005fget_005frequested">gnutls_sign_algorithm_get_requested</a>. Both functions are shown below.
</p>
<dl compact="compact">
<dt><code><var>void</var> <a href="#gnutls_005fcertificate_005fset_005fretrieve_005ffunction">gnutls_certificate_set_retrieve_function</a> (gnutls_certificate_credentials_t <var>cred</var>, gnutls_certificate_retrieve_function * <var>func</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005fcertificate_005fset_005fretrieve_005ffunction2">gnutls_certificate_set_retrieve_function2</a> (gnutls_certificate_credentials_t <var>cred</var>, gnutls_certificate_retrieve_function2 * <var>func</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005fcertificate_005fset_005fretrieve_005ffunction3">gnutls_certificate_set_retrieve_function3</a> (gnutls_certificate_credentials_t <var>cred</var>, gnutls_certificate_retrieve_function3 * <var>func</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fsign_005falgorithm_005fget_005frequested">gnutls_sign_algorithm_get_requested</a> (gnutls_session_t <var>session</var>, size_t <var>indx</var>, gnutls_sign_algorithm_t * <var>algo</var>)</code></dt>
</dl>

<p>The functions above do not handle the requested server name automatically.
A server would need to check the name requested by the client
using <a href="#gnutls_005fserver_005fname_005fget">gnutls_server_name_get</a>, and serve the appropriate
certificate. Note that some of these functions require the <code>gnutls_pcert_st</code> structure to be
filled in. Helper functions to fill in the structure are listed below.
</p>
<pre class="verbatim">typedef struct gnutls_pcert_st
{
  gnutls_pubkey_t pubkey;
  gnutls_datum_t cert;
  gnutls_certificate_type_t type;
} gnutls_pcert_st;
</pre>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fpcert_005fimport_005fx509">gnutls_pcert_import_x509</a> (gnutls_pcert_st * <var>pcert</var>, gnutls_x509_crt_t <var>crt</var>, unsigned int <var>flags</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpcert_005fimport_005fx509_005fraw">gnutls_pcert_import_x509_raw</a> (gnutls_pcert_st * <var>pcert</var>, const gnutls_datum_t * <var>cert</var>, gnutls_x509_crt_fmt_t <var>format</var>, unsigned int <var>flags</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005fpcert_005fdeinit">gnutls_pcert_deinit</a> (gnutls_pcert_st * <var>pcert</var>)</code></dt>
</dl>

<p>In a handshake, the negotiated cipher suite depends on the
certificate&rsquo;s parameters, so some key exchange methods might not be
available with all certificates. <acronym>GnuTLS</acronym> will disable
ciphersuites that are not compatible with the key, or the enabled
authentication methods.  For example keys marked as sign-only, will
not be able to access the plain RSA ciphersuites, that require
decryption. It is not recommended to use RSA keys for both
signing and encryption. If possible use a different key for the
<code>DHE-RSA</code> which uses signing and <code>RSA</code> that requires decryption.
All the key exchange methods shown in <a href="#tab_003akey_002dexchange">Table 4.1</a> are
available in certificate authentication.
</p>

<span id="Client-certificate-authentication"></span><h4 class="subsubheading">Client certificate authentication</h4>

<p>If a certificate is to be requested from the client during the handshake, the server
will send a certificate request message. This behavior is controlled by <a href="#gnutls_005fcertificate_005fserver_005fset_005frequest">gnutls_certificate_server_set_request</a>.
The request contains a list of the by the server accepted certificate signers. This list
is constructed using the trusted certificate authorities of the server.
In cases where the server supports a large number of certificate authorities
it makes sense not to advertise all of the names to save bandwidth. That can
be controlled using the function <a href="#gnutls_005fcertificate_005fsend_005fx509_005frdn_005fsequence">gnutls_certificate_send_x509_rdn_sequence</a>. 
This however will have the side-effect of not restricting the client to certificates
signed by server&rsquo;s acceptable signers.
</p>




<dl>
<dt id="index-gnutls_005fcertificate_005fserver_005fset_005frequest">Function: <em>void</em> <strong>gnutls_certificate_server_set_request</strong> <em>(gnutls_session_t <var>session</var>, gnutls_certificate_request_t <var>req</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>req</var>: is one of GNUTLS_CERT_REQUEST, GNUTLS_CERT_REQUIRE, GNUTLS_CERT_IGNORE
</p>
<p>This function specifies if we (in case of a server) are going to
send a certificate request message to the client. If  <code>req</code> is
GNUTLS_CERT_REQUIRE then the server will return the <code>GNUTLS_E_NO_CERTIFICATE_FOUND</code> 
error if the peer does not provide a certificate. If you do not call this
function then the client will not be asked to send a certificate. Invoking
the function with  <code>req</code> GNUTLS_CERT_IGNORE has the same effect.
</p></dd></dl>





<dl>
<dt id="index-gnutls_005fcertificate_005fsend_005fx509_005frdn_005fsequence">Function: <em>void</em> <strong>gnutls_certificate_send_x509_rdn_sequence</strong> <em>(gnutls_session_t <var>session</var>, int <var>status</var>)</em></dt>
<dd><p><var>session</var>: a <code>gnutls_session_t</code>  type.
</p>
<p><var>status</var>: is 0 or 1
</p>
<p>If status is non zero, this function will order gnutls not to send
the rdnSequence in the certificate request message. That is the
server will not advertise its trusted CAs to the peer. If status
is zero then the default behaviour will take effect, which is to
advertise the server&rsquo;s trusted CAs.
</p>
<p>This function has no effect in clients, and in authentication
methods other than certificate with X.509 certificates.
</p></dd></dl>

<p>On the client side, it needs to set its certificates on the credentials
structure, similarly to server side from a file, or via a callback. Once the
certificates are available in the credentials structure, the client will
send them if during the handshake the server requests a certificate signed
by the issuer of its CA.
</p>
<p>In the case a single certificate is available and the server does not
specify a signer&rsquo;s list, then that certificate is always sent. It is,
however possible, to send a certificate even when the advertised CA
list by the server contains CAs other than its signer. That can be achieved
using the <code>GNUTLS_FORCE_CLIENT_CERT</code> flag in <a href="#gnutls_005finit">gnutls_init</a>.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fcertificate_005fset_005fx509_005fkey_005ffile">gnutls_certificate_set_x509_key_file</a> (gnutls_certificate_credentials_t <var>res</var>, const char * <var>certfile</var>, const char * <var>keyfile</var>, gnutls_x509_crt_fmt_t <var>type</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fcertificate_005fset_005fx509_005fsimple_005fpkcs12_005ffile">gnutls_certificate_set_x509_simple_pkcs12_file</a> (gnutls_certificate_credentials_t <var>res</var>, const char * <var>pkcs12file</var>, gnutls_x509_crt_fmt_t <var>type</var>, const char * <var>password</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005fcertificate_005fset_005fretrieve_005ffunction2">gnutls_certificate_set_retrieve_function2</a> (gnutls_certificate_credentials_t <var>cred</var>, gnutls_certificate_retrieve_function2 * <var>func</var>)</code></dt>
</dl>


<span id="Client-or-server-certificate-verification"></span><h4 class="subsubheading">Client or server certificate verification</h4>

<p>Certificate verification is possible by loading the trusted
authorities into the credentials structure by using
the following functions, applicable to X.509 certificates.
In modern systems it is recommended to utilize <a href="#gnutls_005fcertificate_005fset_005fx509_005fsystem_005ftrust">gnutls_certificate_set_x509_system_trust</a>
which will load the trusted authorities from the system store.
</p>




<dl>
<dt id="index-gnutls_005fcertificate_005fset_005fx509_005fsystem_005ftrust">Function: <em>int</em> <strong>gnutls_certificate_set_x509_system_trust</strong> <em>(gnutls_certificate_credentials_t       <var>cred</var>)</em></dt>
<dd><p><var>cred</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p>This function adds the system&rsquo;s default trusted CAs in order to
verify client or server certificates.
</p>
<p>In the case the system is currently unsupported <code>GNUTLS_E_UNIMPLEMENTED_FEATURE</code> 
is returned.
</p>
<p><strong>Returns:</strong> the number of certificates processed or a negative error code
on error.
</p>
<p><strong>Since:</strong> 3.0.20
</p></dd></dl>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fcertificate_005fset_005fx509_005ftrust_005ffile">gnutls_certificate_set_x509_trust_file</a> (gnutls_certificate_credentials_t            <var>cred</var>, const char * <var>cafile</var>, gnutls_x509_crt_fmt_t <var>type</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fcertificate_005fset_005fx509_005ftrust_005fdir">gnutls_certificate_set_x509_trust_dir</a> (gnutls_certificate_credentials_t <var>cred</var>, const char * <var>ca_dir</var>, gnutls_x509_crt_fmt_t <var>type</var>)</code></dt>
</dl>

<p>The peer&rsquo;s certificate will be automatically verified if
<a href="#gnutls_005fsession_005fset_005fverify_005fcert">gnutls_session_set_verify_cert</a> is called prior to handshake.
</p>
<p>Alternatively, one must set a callback function during the handshake
using <a href="#gnutls_005fcertificate_005fset_005fverify_005ffunction">gnutls_certificate_set_verify_function</a>, which
will verify the peer&rsquo;s certificate once received. The verification
should happen using <a href="#gnutls_005fcertificate_005fverify_005fpeers3">gnutls_certificate_verify_peers3</a> within
the callback. It will verify the certificate&rsquo;s signature and the owner 
of the certificate. That will provide a brief verification output. If a
detailed output is required one should call <a href="#gnutls_005fcertificate_005fget_005fpeers">gnutls_certificate_get_peers</a>
to obtain the raw certificate of the peer and verify it using the
functions discussed in <a href="#X_002e509-certificates">X.509 certificates</a>.
</p>
<p>In both the automatic and the manual cases, the verification status returned
can be printed using <a href="#gnutls_005fcertificate_005fverification_005fstatus_005fprint">gnutls_certificate_verification_status_print</a>.
</p>




<dl>
<dt id="index-gnutls_005fsession_005fset_005fverify_005fcert">Function: <em>void</em> <strong>gnutls_session_set_verify_cert</strong> <em>(gnutls_session_t <var>session</var>, const char * <var>hostname</var>, unsigned <var>flags</var>)</em></dt>
<dd><p><var>session</var>: is a gnutls session
</p>
<p><var>hostname</var>: is the expected name of the peer; may be <code>NULL</code> 
</p>
<p><var>flags</var>: flags for certificate verification &ndash; <code>gnutls_certificate_verify_flags</code> 
</p>
<p>This function instructs GnuTLS to verify the peer&rsquo;s certificate
using the provided hostname. If the verification fails the handshake
will also fail with <code>GNUTLS_E_CERTIFICATE_VERIFICATION_ERROR</code> . In that
case the verification result can be obtained using <code>gnutls_session_get_verify_cert_status()</code> .
</p>
<p>The  <code>hostname</code> pointer provided must remain valid for the lifetime
of the session. More precisely it should be available during any subsequent
handshakes. If no hostname is provided, no hostname verification
will be performed. For a more advanced verification function check
<code>gnutls_session_set_verify_cert2()</code> .
</p>
<p>If  <code>flags</code> is provided which contain a profile, this function should be
called after any session priority setting functions.
</p>
<p>The <code>gnutls_session_set_verify_cert()</code>  function is intended to be used by TLS
clients to verify the server&rsquo;s certificate.
</p>
<p><strong>Since:</strong> 3.4.6
</p></dd></dl>

<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fcertificate_005fverify_005fpeers3">gnutls_certificate_verify_peers3</a> (gnutls_session_t <var>session</var>, const char * <var>hostname</var>, unsigned int * <var>status</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005fcertificate_005fset_005fverify_005ffunction">gnutls_certificate_set_verify_function</a> (gnutls_certificate_credentials_t <var>cred</var>, gnutls_certificate_verify_function * <var>func</var>)</code></dt>
</dl>

<p>Note that when using raw public-keys verification will not work because there is no corresponding
certificate body belonging to the raw key that can be verified. In that case the <a href="#gnutls_005fcertificate_005fverify_005fpeers">gnutls_certificate_verify_peers</a>
family of functions will return a GNUTLS_E_INVALID_REQUEST error code. For authenticating raw public-keys
one must use an out-of-band mechanism, e.g. by comparing hashes or using trust on first use
(see <a href="#Verifying-a-certificate-using-trust-on-first-use-authentication">Verifying a certificate using trust on first use authentication</a>).
</p>

<hr>
<span id="Raw-public_002dkey-credentials"></span><div class="header">
<p>
Next: <a href="#SRP-credentials" accesskey="n" rel="next">SRP credentials</a>, Previous: <a href="#Certificate-credentials" accesskey="p" rel="prev">Certificate credentials</a>, Up: <a href="#Associating-the-credentials" accesskey="u" rel="up">Associating the credentials</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Raw-public_002dkeys-2"></span><h4 class="subsection">6.4.2 Raw public-keys</h4>
<p>As of version 3.6.6 GnuTLS supports <a href="#Raw-public_002dkeys">Raw public-keys</a>. With raw public-keys only the
public-key part (that is normally embedded in a certificate) is transmitted to the peer.
In order to load a raw public-key and its corresponding private key in a credentials
structure one can use the following functions.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fcertificate_005fset_005fkey">gnutls_certificate_set_key</a> (gnutls_certificate_credentials_t <var>res</var>, const char ** <var>names</var>, int <var>names_size</var>, gnutls_pcert_st * <var>pcert_list</var>, int <var>pcert_list_size</var>, gnutls_privkey_t <var>key</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fcertificate_005fset_005frawpk_005fkey_005fmem">gnutls_certificate_set_rawpk_key_mem</a> (gnutls_certificate_credentials_t <var>cred</var>, const gnutls_datum_t* <var>spki</var>, const gnutls_datum_t* <var>pkey</var>, gnutls_x509_crt_fmt_t <var>format</var>, const char* <var>pass</var>, unsigned int <var>key_usage</var>, const char ** <var>names</var>, unsigned int <var>names_length</var>, unsigned int <var>flags</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fcertificate_005fset_005frawpk_005fkey_005ffile">gnutls_certificate_set_rawpk_key_file</a> (gnutls_certificate_credentials_t <var>cred</var>, const char* <var>rawpkfile</var>, const char* <var>privkeyfile</var>, gnutls_x509_crt_fmt_t <var>format</var>, const char * <var>pass</var>, unsigned int <var>key_usage</var>, const char ** <var>names</var>, unsigned int <var>names_length</var>, unsigned int <var>privkey_flags</var>, unsigned int <var>pkcs11_flags</var>)</code></dt>
</dl>


<hr>
<span id="SRP-credentials"></span><div class="header">
<p>
Next: <a href="#PSK-credentials" accesskey="n" rel="next">PSK credentials</a>, Previous: <a href="#Raw-public_002dkey-credentials" accesskey="p" rel="prev">Raw public-key credentials</a>, Up: <a href="#Associating-the-credentials" accesskey="u" rel="up">Associating the credentials</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="SRP"></span><h4 class="subsection">6.4.3 SRP</h4>

<p>The initialization functions in SRP credentials differ between
client and server.
Clients supporting <acronym>SRP</acronym> should set the username and password
prior to connection, to the credentials structure.
Alternatively <a href="#gnutls_005fsrp_005fset_005fclient_005fcredentials_005ffunction">gnutls_srp_set_client_credentials_function</a>
may be used instead, to specify a callback function that should return the
SRP username and password.
The callback is called once during the <acronym>TLS</acronym> handshake.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fsrp_005fallocate_005fserver_005fcredentials">gnutls_srp_allocate_server_credentials</a> (gnutls_srp_server_credentials_t *            <var>sc</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fsrp_005fallocate_005fclient_005fcredentials">gnutls_srp_allocate_client_credentials</a> (gnutls_srp_client_credentials_t *            <var>sc</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005fsrp_005ffree_005fserver_005fcredentials">gnutls_srp_free_server_credentials</a> (gnutls_srp_server_credentials_t <var>sc</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005fsrp_005ffree_005fclient_005fcredentials">gnutls_srp_free_client_credentials</a> (gnutls_srp_client_credentials_t <var>sc</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fsrp_005fset_005fclient_005fcredentials">gnutls_srp_set_client_credentials</a> (gnutls_srp_client_credentials_t <var>res</var>, const char * <var>username</var>, const char * <var>password</var>)</code></dt>
</dl>





<dl>
<dt id="index-gnutls_005fsrp_005fset_005fclient_005fcredentials_005ffunction">Function: <em>void</em> <strong>gnutls_srp_set_client_credentials_function</strong> <em>(gnutls_srp_client_credentials_t         <var>cred</var>, gnutls_srp_client_credentials_function         * <var>func</var>)</em></dt>
<dd><p><var>cred</var>: is a <code>gnutls_srp_server_credentials_t</code>  type.
</p>
<p><var>func</var>: is the callback function
</p>
<p>This function can be used to set a callback to retrieve the
username and password for client SRP authentication.  The
callback&rsquo;s function form is:
</p>
<p>int (*callback)(gnutls_session_t, char** username, char**password);
</p>
<p>The  <code>username</code> and  <code>password</code> must be allocated using
<code>gnutls_malloc()</code> .
</p>
<p>The  <code>username</code> should be an ASCII string or UTF-8
string. In case of a UTF-8 string it is recommended to be following
the PRECIS framework for usernames (rfc8265). The password can
be in ASCII format, or normalized using <code>gnutls_utf8_password_normalize()</code> .
</p>
<p>The callback function will be called once per handshake before the
initial hello message is sent.
</p>
<p>The callback should not return a negative error code the second
time called, since the handshake procedure will be aborted.
</p>
<p>The callback function should return 0 on success.
-1 indicates an error.
</p></dd></dl>

<p>In server side the default behavior of <acronym>GnuTLS</acronym> is to read
the usernames and <acronym>SRP</acronym> verifiers from password files. These
password file format is compatible the with the <em>Stanford srp libraries</em>
format.  If a different password file format is to be used, then 
<a href="#gnutls_005fsrp_005fset_005fserver_005fcredentials_005ffunction">gnutls_srp_set_server_credentials_function</a> should be called,
to set an appropriate callback. 
</p>




<dl>
<dt id="index-gnutls_005fsrp_005fset_005fserver_005fcredentials_005ffile">Function: <em>int</em> <strong>gnutls_srp_set_server_credentials_file</strong> <em>(gnutls_srp_server_credentials_t <var>res</var>, const char * <var>password_file</var>, const char * <var>password_conf_file</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_srp_server_credentials_t</code>  type.
</p>
<p><var>password_file</var>: is the SRP password file (tpasswd)
</p>
<p><var>password_conf_file</var>: is the SRP password conf file (tpasswd.conf)
</p>
<p>This function sets the password files, in a
<code>gnutls_srp_server_credentials_t</code>  type.  Those password files
hold usernames and verifiers and will be used for SRP
authentication.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, or an
error code.
</p></dd></dl>





<dl>
<dt id="index-gnutls_005fsrp_005fset_005fserver_005fcredentials_005ffunction">Function: <em>void</em> <strong>gnutls_srp_set_server_credentials_function</strong> <em>(gnutls_srp_server_credentials_t         <var>cred</var>, gnutls_srp_server_credentials_function         * <var>func</var>)</em></dt>
<dd><p><var>cred</var>: is a <code>gnutls_srp_server_credentials_t</code>  type.
</p>
<p><var>func</var>: is the callback function
</p>
<p>This function can be used to set a callback to retrieve the user&rsquo;s
SRP credentials.  The callback&rsquo;s function form is:
</p>
<p>int (*callback)(gnutls_session_t, const char* username,
gnutls_datum_t *salt, gnutls_datum_t *verifier, gnutls_datum_t *generator,
gnutls_datum_t *prime);
</p>
<p><code>username</code> contains the actual username.
The  <code>salt</code> ,  <code>verifier</code> ,  <code>generator</code> and  <code>prime</code> must be filled
in using the <code>gnutls_malloc()</code> . For convenience  <code>prime</code> and  <code>generator</code> may also be one of the static parameters defined in gnutls.h.
</p>
<p>Initially, the data field is NULL in every <code>gnutls_datum_t</code> 
structure that the callback has to fill in. When the
callback is done GnuTLS deallocates all of those buffers
which are non-NULL, regardless of the return value.
</p>
<p>In order to prevent attackers from guessing valid usernames,
if a user does not exist, g and n values should be filled in
using a random user&rsquo;s parameters. In that case the callback must
return the special value (1).
See <code>gnutls_srp_set_server_fake_salt_seed</code>  too.
If this is not required for your application, return a negative
number from the callback to abort the handshake.
</p>
<p>The callback function will only be called once per handshake.
The callback function should return 0 on success, while
-1 indicates an error.
</p></dd></dl>


<hr>
<span id="PSK-credentials"></span><div class="header">
<p>
Next: <a href="#Anonymous-credentials" accesskey="n" rel="next">Anonymous credentials</a>, Previous: <a href="#SRP-credentials" accesskey="p" rel="prev">SRP credentials</a>, Up: <a href="#Associating-the-credentials" accesskey="u" rel="up">Associating the credentials</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="PSK"></span><h4 class="subsection">6.4.4 PSK</h4>
<p>The initialization functions in PSK credentials differ between
client and server.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fpsk_005fallocate_005fserver_005fcredentials">gnutls_psk_allocate_server_credentials</a> (gnutls_psk_server_credentials_t *            <var>sc</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpsk_005fallocate_005fclient_005fcredentials">gnutls_psk_allocate_client_credentials</a> (gnutls_psk_client_credentials_t *            <var>sc</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005fpsk_005ffree_005fserver_005fcredentials">gnutls_psk_free_server_credentials</a> (gnutls_psk_server_credentials_t <var>sc</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005fpsk_005ffree_005fclient_005fcredentials">gnutls_psk_free_client_credentials</a> (gnutls_psk_client_credentials_t <var>sc</var>)</code></dt>
</dl>

<p>Clients supporting <acronym>PSK</acronym> should supply the username and key
before a TLS session is established.  Alternatively 
<a href="#gnutls_005fpsk_005fset_005fclient_005fcredentials_005ffunction">gnutls_psk_set_client_credentials_function</a> can be used to
specify a callback function. This has the
advantage that the callback will be called only if <acronym>PSK</acronym> has
been negotiated.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fpsk_005fset_005fclient_005fcredentials">gnutls_psk_set_client_credentials</a> (gnutls_psk_client_credentials_t <var>res</var>, const char * <var>username</var>, const gnutls_datum_t * <var>key</var>, gnutls_psk_key_flags <var>flags</var>)</code></dt>
</dl>





<dl>
<dt id="index-gnutls_005fpsk_005fset_005fclient_005fcredentials_005ffunction">Function: <em>void</em> <strong>gnutls_psk_set_client_credentials_function</strong> <em>(gnutls_psk_client_credentials_t         <var>cred</var>, gnutls_psk_client_credentials_function         * <var>func</var>)</em></dt>
<dd><p><var>cred</var>: is a <code>gnutls_psk_server_credentials_t</code>  type.
</p>
<p><var>func</var>: is the callback function
</p>
<p>This function can be used to set a callback to retrieve the username and
password for client PSK authentication.
The callback&rsquo;s function form is:
int (*callback)(gnutls_session_t, char** username,
gnutls_datum_t* key);
</p>
<p>The  <code>username</code> and  <code>key</code> -&gt;data must be allocated using <code>gnutls_malloc()</code> .
The  <code>username</code> should be an ASCII string or UTF-8
string. In case of a UTF-8 string it is recommended to be following
the PRECIS framework for usernames (rfc8265).
</p>
<p>The callback function will be called once per handshake.
</p>
<p>The callback function should return 0 on success.
-1 indicates an error.
</p></dd></dl>

<p>In server side the default behavior of <acronym>GnuTLS</acronym> is to read
the usernames and <acronym>PSK</acronym> keys from a password file. The
password file should contain usernames and keys in hexadecimal
format. The name of the password file can be stored to the credentials
structure by calling <a href="#gnutls_005fpsk_005fset_005fserver_005fcredentials_005ffile">gnutls_psk_set_server_credentials_file</a>.  If
a different password file format is to be used, then
a callback should be set instead by <a href="#gnutls_005fpsk_005fset_005fserver_005fcredentials_005ffunction">gnutls_psk_set_server_credentials_function</a>.
</p>
<p>The server can help the client chose a suitable username and password,
by sending a hint. Note that there is no common profile for the PSK hint and applications
are discouraged to use it.
A server, may specify the hint by calling
<a href="#gnutls_005fpsk_005fset_005fserver_005fcredentials_005fhint">gnutls_psk_set_server_credentials_hint</a>.  The client can retrieve
the hint, for example in the callback function, using
<a href="#gnutls_005fpsk_005fclient_005fget_005fhint">gnutls_psk_client_get_hint</a>.
</p>




<dl>
<dt id="index-gnutls_005fpsk_005fset_005fserver_005fcredentials_005ffile">Function: <em>int</em> <strong>gnutls_psk_set_server_credentials_file</strong> <em>(gnutls_psk_server_credentials_t            <var>res</var>, const char * <var>password_file</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_psk_server_credentials_t</code>  type.
</p>
<p><var>password_file</var>: is the PSK password file (passwd.psk)
</p>
<p>This function sets the password file, in a
<code>gnutls_psk_server_credentials_t</code>  type.  This password file
holds usernames and keys and will be used for PSK authentication.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p></dd></dl>

<dl compact="compact">
<dt><code><var>void</var> <a href="#gnutls_005fpsk_005fset_005fserver_005fcredentials_005ffunction">gnutls_psk_set_server_credentials_function</a> (gnutls_psk_server_credentials_t         <var>cred</var>, gnutls_psk_server_credentials_function         * <var>func</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpsk_005fset_005fserver_005fcredentials_005fhint">gnutls_psk_set_server_credentials_hint</a> (gnutls_psk_server_credentials_t <var>res</var>, const char * <var>hint</var>)</code></dt>
<dt><code><var>const char *</var> <a href="#gnutls_005fpsk_005fclient_005fget_005fhint">gnutls_psk_client_get_hint</a> (gnutls_session_t <var>session</var>)</code></dt>
</dl>

<hr>
<span id="Anonymous-credentials"></span><div class="header">
<p>
Previous: <a href="#PSK-credentials" accesskey="p" rel="prev">PSK credentials</a>, Up: <a href="#Associating-the-credentials" accesskey="u" rel="up">Associating the credentials</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Anonymous"></span><h4 class="subsection">6.4.5 Anonymous</h4>
<p>The key exchange methods for anonymous authentication
since GnuTLS 3.6.0 will utilize the RFC7919 parameters, unless
explicit parameters have been provided and associated with an
anonymous credentials structure. Check <a href="#Parameter-generation">Parameter generation</a> for more information.
The initialization functions for the credentials are shown below.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fanon_005fallocate_005fserver_005fcredentials">gnutls_anon_allocate_server_credentials</a> (gnutls_anon_server_credentials_t *      <var>sc</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fanon_005fallocate_005fclient_005fcredentials">gnutls_anon_allocate_client_credentials</a> (gnutls_anon_client_credentials_t *      <var>sc</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005fanon_005ffree_005fserver_005fcredentials">gnutls_anon_free_server_credentials</a> (gnutls_anon_server_credentials_t <var>sc</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005fanon_005ffree_005fclient_005fcredentials">gnutls_anon_free_client_credentials</a> (gnutls_anon_client_credentials_t <var>sc</var>)</code></dt>
</dl>



<hr>
<span id="Setting-up-the-transport-layer"></span><div class="header">
<p>
Next: <a href="#TLS-handshake" accesskey="n" rel="next">TLS handshake</a>, Previous: <a href="#Associating-the-credentials" accesskey="p" rel="prev">Associating the credentials</a>, Up: <a href="#How-to-use-GnuTLS-in-applications" accesskey="u" rel="up">How to use GnuTLS in applications</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Setting-up-the-transport-layer-1"></span><h3 class="section">6.5 Setting up the transport layer</h3>

<p>The next step is to setup the underlying transport layer details. The
Berkeley sockets are implicitly used by GnuTLS, thus a
call to <a href="#gnutls_005ftransport_005fset_005fint">gnutls_transport_set_int</a> would be sufficient to
specify the socket descriptor. 
</p>
<dl compact="compact">
<dt><code><var>void</var> <a href="#gnutls_005ftransport_005fset_005fint">gnutls_transport_set_int</a> (gnutls_session_t <var>session</var>, int <var>fd</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005ftransport_005fset_005fint2">gnutls_transport_set_int2</a> (gnutls_session_t <var>session</var>, int <var>recv_fd</var>, int <var>send_fd</var>)</code></dt>
</dl>

<p>If however another transport layer than TCP is selected, then
a pointer should be used instead to express the parameter to be
passed to custom functions. In that case the following functions should
be used instead.
</p>
<dl compact="compact">
<dt><code><var>void</var> <a href="#gnutls_005ftransport_005fset_005fptr">gnutls_transport_set_ptr</a> (gnutls_session_t <var>session</var>, gnutls_transport_ptr_t <var>ptr</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005ftransport_005fset_005fptr2">gnutls_transport_set_ptr2</a> (gnutls_session_t <var>session</var>, gnutls_transport_ptr_t <var>recv_ptr</var>, gnutls_transport_ptr_t <var>send_ptr</var>)</code></dt>
</dl>

<p>Moreover all of the following push and pull callbacks should be set.
</p>




<dl>
<dt id="index-gnutls_005ftransport_005fset_005fpush_005ffunction">Function: <em>void</em> <strong>gnutls_transport_set_push_function</strong> <em>(gnutls_session_t <var>session</var>, gnutls_push_func <var>push_func</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>push_func</var>: a callback function similar to <code>write()</code> 
</p>
<p>This is the function where you set a push function for gnutls to
use in order to send data.  If you are going to use berkeley style
sockets, you do not need to use this function since the default
send(2) will probably be ok.  Otherwise you should specify this
function for gnutls to be able to send data.
The callback should return a positive number indicating the
bytes sent, and -1 on error.
</p>
<p><code>push_func</code> is of the form,
ssize_t (*gnutls_push_func)(gnutls_transport_ptr_t, const void*, size_t);
</p></dd></dl>




<dl>
<dt id="index-gnutls_005ftransport_005fset_005fvec_005fpush_005ffunction">Function: <em>void</em> <strong>gnutls_transport_set_vec_push_function</strong> <em>(gnutls_session_t <var>session</var>, gnutls_vec_push_func <var>vec_func</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>vec_func</var>: a callback function similar to <code>writev()</code> 
</p>
<p>Using this function you can override the default writev(2)
function for gnutls to send data. Setting this callback 
instead of <code>gnutls_transport_set_push_function()</code>  is recommended
since it introduces less overhead in the TLS handshake process.
</p>
<p><code>vec_func</code> is of the form,
ssize_t (*gnutls_vec_push_func) (gnutls_transport_ptr_t, const giovec_t * iov, int iovcnt);
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>




<dl>
<dt id="index-gnutls_005ftransport_005fset_005fpull_005ffunction">Function: <em>void</em> <strong>gnutls_transport_set_pull_function</strong> <em>(gnutls_session_t <var>session</var>, gnutls_pull_func <var>pull_func</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>pull_func</var>: a callback function similar to <code>read()</code> 
</p>
<p>This is the function where you set a function for gnutls to receive
data.  Normally, if you use berkeley style sockets, do not need to
use this function since the default recv(2) will probably be ok.
The callback should return 0 on connection termination, a positive
number indicating the number of bytes received, and -1 on error.
</p>
<p><code>gnutls_pull_func</code> is of the form,
ssize_t (*gnutls_pull_func)(gnutls_transport_ptr_t, void*, size_t);
</p></dd></dl>




<dl>
<dt id="index-gnutls_005ftransport_005fset_005fpull_005ftimeout_005ffunction">Function: <em>void</em> <strong>gnutls_transport_set_pull_timeout_function</strong> <em>(gnutls_session_t <var>session</var>, gnutls_pull_timeout_func <var>func</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>func</var>: a callback function
</p>
<p>This is the function where you set a function for gnutls to know
whether data are ready to be received. It should wait for data a
given time frame in milliseconds. The callback should return 0 on 
timeout, a positive number if data can be received, and -1 on error.
You&rsquo;ll need to override this function if <code>select()</code>  is not suitable
for the provided transport calls.
</p>
<p>As with <code>select()</code> , if the timeout value is zero the callback should return
zero if no data are immediately available. The special value
<code>GNUTLS_INDEFINITE_TIMEOUT</code>  indicates that the callback should wait indefinitely
for data.
</p>
<p><code>gnutls_pull_timeout_func</code> is of the form,
int (*gnutls_pull_timeout_func)(gnutls_transport_ptr_t, unsigned int ms);
</p>
<p>This callback is necessary when <code>gnutls_handshake_set_timeout()</code>  or 
<code>gnutls_record_set_timeout()</code>  are set, under TLS1.3 and for enforcing the DTLS
mode timeouts when in blocking mode.
</p>
<p>For compatibility with future GnuTLS versions this callback must be set when
a custom pull function is registered. The callback will not be used when the
session is in TLS mode with non-blocking sockets. That is, when <code>GNUTLS_NONBLOCK</code> 
is specified for a TLS session in <code>gnutls_init()</code> .
</p>
<p>The helper function <code>gnutls_system_recv_timeout()</code>  is provided to
simplify writing callbacks. 
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>


<p>The functions above accept a callback function which
should return the number of bytes written, or -1 on
error and should set <code>errno</code> appropriately.
In some environments, setting <code>errno</code> is unreliable. For example
Windows have several errno variables in different CRTs, or in other
systems it may be a non thread-local variable.  If this is a concern to
you, call <a href="#gnutls_005ftransport_005fset_005ferrno">gnutls_transport_set_errno</a> with the intended errno
value instead of setting <code>errno</code> directly.
</p>




<dl>
<dt id="index-gnutls_005ftransport_005fset_005ferrno">Function: <em>void</em> <strong>gnutls_transport_set_errno</strong> <em>(gnutls_session_t <var>session</var>, int <var>err</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>err</var>: error value to store in session-specific errno variable.
</p>
<p>Store  <code>err</code> in the session-specific errno variable.  Useful values
for  <code>err</code> are EINTR, EAGAIN and EMSGSIZE, other values are treated will be
treated as real errors in the push/pull function.
</p>
<p>This function is useful in replacement push and pull functions set by
<code>gnutls_transport_set_push_function()</code>  and
<code>gnutls_transport_set_pull_function()</code>  under Windows, where the
replacements may not have access to the same  <code>errno</code> variable that is used by GnuTLS (e.g., the application is linked to
msvcr71.dll and gnutls is linked to msvcrt.dll).
</p>
<p>This function is unreliable if you are using the same
 <code>session</code> in different threads for sending and receiving.
</p></dd></dl>

<p><acronym>GnuTLS</acronym> currently only interprets the EINTR, EAGAIN and EMSGSIZE errno
values and returns the corresponding <acronym>GnuTLS</acronym> error codes:
</p><ul>
<li> <code>GNUTLS_E_INTERRUPTED</code> 
</li><li> <code>GNUTLS_E_AGAIN</code>
</li><li> <code>GNUTLS_E_LARGE_PACKET</code>
</li></ul>
<p>The EINTR and EAGAIN values are returned by interrupted system calls, 
or when non blocking IO is used.  All <acronym>GnuTLS</acronym> functions can be 
resumed (called again), if any of the above error codes is returned. The
EMSGSIZE value is returned when attempting to send a large datagram.
</p>
<p>In the case of DTLS it is also desirable to override the generic 
transport functions with functions that emulate the operation
of <code>recvfrom</code> and <code>sendto</code>. In addition
<acronym>DTLS</acronym> requires timers during the receive of a handshake
message, set using the <a href="#gnutls_005ftransport_005fset_005fpull_005ftimeout_005ffunction">gnutls_transport_set_pull_timeout_function</a> 
function. To check the retransmission timers the function
<a href="#gnutls_005fdtls_005fget_005ftimeout">gnutls_dtls_get_timeout</a> is provided, which returns the time
remaining until the next retransmission, or better the time until 
<a href="#gnutls_005fhandshake">gnutls_handshake</a> should be called again.
</p>




<dl>
<dt id="index-gnutls_005ftransport_005fset_005fpull_005ftimeout_005ffunction-1">Function: <em>void</em> <strong>gnutls_transport_set_pull_timeout_function</strong> <em>(gnutls_session_t <var>session</var>, gnutls_pull_timeout_func <var>func</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>func</var>: a callback function
</p>
<p>This is the function where you set a function for gnutls to know
whether data are ready to be received. It should wait for data a
given time frame in milliseconds. The callback should return 0 on 
timeout, a positive number if data can be received, and -1 on error.
You&rsquo;ll need to override this function if <code>select()</code>  is not suitable
for the provided transport calls.
</p>
<p>As with <code>select()</code> , if the timeout value is zero the callback should return
zero if no data are immediately available. The special value
<code>GNUTLS_INDEFINITE_TIMEOUT</code>  indicates that the callback should wait indefinitely
for data.
</p>
<p><code>gnutls_pull_timeout_func</code> is of the form,
int (*gnutls_pull_timeout_func)(gnutls_transport_ptr_t, unsigned int ms);
</p>
<p>This callback is necessary when <code>gnutls_handshake_set_timeout()</code>  or 
<code>gnutls_record_set_timeout()</code>  are set, under TLS1.3 and for enforcing the DTLS
mode timeouts when in blocking mode.
</p>
<p>For compatibility with future GnuTLS versions this callback must be set when
a custom pull function is registered. The callback will not be used when the
session is in TLS mode with non-blocking sockets. That is, when <code>GNUTLS_NONBLOCK</code> 
is specified for a TLS session in <code>gnutls_init()</code> .
</p>
<p>The helper function <code>gnutls_system_recv_timeout()</code>  is provided to
simplify writing callbacks. 
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>




<dl>
<dt id="index-gnutls_005fdtls_005fget_005ftimeout">Function: <em>unsigned int</em> <strong>gnutls_dtls_get_timeout</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>This function will return the milliseconds remaining
for a retransmission of the previously sent handshake
message. This function is useful when DTLS is used in
non-blocking mode, to estimate when to call <code>gnutls_handshake()</code> 
if no packets have been received.
</p>
<p><strong>Returns:</strong> the remaining time in milliseconds.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Asynchronous-operation" accesskey="1">Asynchronous operation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Reducing-round_002dtrips" accesskey="2">Reducing round-trips</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Zero_002droundtrip-mode" accesskey="3">Zero-roundtrip mode</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Anti_002dreplay-protection" accesskey="4">Anti-replay protection</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#DTLS-sessions" accesskey="5">DTLS sessions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#DTLS-and-SCTP" accesskey="6">DTLS and SCTP</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Asynchronous-operation"></span><div class="header">
<p>
Next: <a href="#Reducing-round_002dtrips" accesskey="n" rel="next">Reducing round-trips</a>, Up: <a href="#Setting-up-the-transport-layer" accesskey="u" rel="up">Setting up the transport layer</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Asynchronous-operation-1"></span><h4 class="subsection">6.5.1 Asynchronous operation</h4>

<p><acronym>GnuTLS</acronym> can be used with asynchronous socket or event-driven programming.
The approach is similar to using Berkeley sockets under such an environment.
The blocking, due to network interaction, calls such as
<a href="#gnutls_005fhandshake">gnutls_handshake</a>, <a href="#gnutls_005frecord_005frecv">gnutls_record_recv</a>,
can be set to non-blocking by setting the underlying sockets to non-blocking.
If other push and pull functions are setup, then they should behave the same
way as <code>recv</code> and <code>send</code> when used in a non-blocking
way, i.e., return -1 and set errno to <code>EAGAIN</code>. Since, during a TLS protocol session 
<acronym>GnuTLS</acronym> does not block except for network interaction, the non blocking
<code>EAGAIN</code> errno will be propagated and <acronym>GnuTLS</acronym> functions 
will return the <code>GNUTLS_E_AGAIN</code> error code. Such calls can be resumed the 
same way as a system call would. 
The only exception is <a href="#gnutls_005frecord_005fsend">gnutls_record_send</a>,
which if interrupted subsequent calls need not to include the data to be
sent (can be called with NULL argument).
</p>
<p>When using the <code>poll</code> or <code>select</code> system calls though, one should remember
that they only apply to the kernel sockets API. To check for any
available buffered data in a <acronym>GnuTLS</acronym> session, 
utilize <a href="#gnutls_005frecord_005fcheck_005fpending">gnutls_record_check_pending</a>,
either before the <code>poll</code> system call, or after a call to
<a href="#gnutls_005frecord_005frecv">gnutls_record_recv</a>. Data queued by <a href="#gnutls_005frecord_005fsend">gnutls_record_send</a>
(when interrupted) can be discarded using <a href="#gnutls_005frecord_005fdiscard_005fqueued">gnutls_record_discard_queued</a>.
</p>
<p>An example of GnuTLS&rsquo; usage with asynchronous operation can be found
in <code>doc/examples/tlsproxy</code>.
</p>
<p>The following paragraphs describe the detailed requirements for non-blocking
operation when using the TLS or DTLS protocols.
</p>
<span id="TLS-protocol"></span><h4 class="subsubsection">6.5.1.1 TLS protocol</h4>
<p>There are no special requirements for the TLS protocol operation in non-blocking
mode if a non-blocking socket is used.
</p>
<p>It is recommended, however, for future compatibility, when in non-blocking mode, to
call the <a href="#gnutls_005finit">gnutls_init</a> function with the
<code>GNUTLS_NONBLOCK</code> flag set (see <a href="#Session-initialization">Session initialization</a>).
</p>
<span id="Datagram-TLS-protocol"></span><h4 class="subsubsection">6.5.1.2 Datagram TLS protocol</h4>
<p>When in non-blocking mode the function, the <a href="#gnutls_005finit">gnutls_init</a> function 
must be called with the <code>GNUTLS_NONBLOCK</code> flag set (see <a href="#Session-initialization">Session initialization</a>). 
</p>
<p>In contrast with the TLS protocol, the pull timeout function is required,
but will only be called with a timeout of zero. In that case it should indicate
whether there are data to be received or not. When not using the default pull function,
then <a href="#gnutls_005ftransport_005fset_005fpull_005ftimeout_005ffunction">gnutls_transport_set_pull_timeout_function</a> should be called.
</p>
<p>Although in the TLS protocol implementation each call to receive or send
function implies to restoring the same function that was interrupted, in
the DTLS protocol this requirement isn&rsquo;t true.
There are cases where a retransmission is required, which are indicated by
a received message and thus <a href="#gnutls_005frecord_005fget_005fdirection">gnutls_record_get_direction</a> must be called 
to decide which direction to check prior to restoring a function call.
</p>



<dl>
<dt id="index-gnutls_005frecord_005fget_005fdirection">Function: <em>int</em> <strong>gnutls_record_get_direction</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>This function is useful to determine whether a GnuTLS function was interrupted
while sending or receiving, so that <code>select()</code>  or <code>poll()</code>  may be called appropriately.
</p>
<p>It provides information about the internals of the record
protocol and is only useful if a prior gnutls function call,
e.g.  <code>gnutls_handshake()</code> , was interrupted and returned
<code>GNUTLS_E_INTERRUPTED</code>  or <code>GNUTLS_E_AGAIN</code> . After such an interrupt
applications may call <code>select()</code>  or <code>poll()</code>  before restoring the
interrupted GnuTLS function.
</p>
<p>This function&rsquo;s output is unreliable if you are using the same
 <code>session</code> in different threads for sending and receiving.
</p>
<p><strong>Returns:</strong> 0 if interrupted while trying to read data, or 1 while trying to write data.
</p></dd></dl>

<p>When calling <a href="#gnutls_005fhandshake">gnutls_handshake</a> through a multi-plexer,
to be able to handle properly the DTLS handshake retransmission timers,
the function <a href="#gnutls_005fdtls_005fget_005ftimeout">gnutls_dtls_get_timeout</a>
should be used to estimate when to call <a href="#gnutls_005fhandshake">gnutls_handshake</a> if
no data have been received.
</p>
<hr>
<span id="Reducing-round_002dtrips"></span><div class="header">
<p>
Next: <a href="#Zero_002droundtrip-mode" accesskey="n" rel="next">Zero-roundtrip mode</a>, Previous: <a href="#Asynchronous-operation" accesskey="p" rel="prev">Asynchronous operation</a>, Up: <a href="#Setting-up-the-transport-layer" accesskey="u" rel="up">Setting up the transport layer</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Reducing-round_002dtrips-1"></span><h4 class="subsection">6.5.2 Reducing round-trips</h4>

<p>The full TLS 1.2 handshake requires 2 round-trips to complete, and when
combined with TCP&rsquo;s SYN and SYN-ACK negotiation it extends to 3 full
round-trips. While, TLS 1.3 reduces that to two round-trips when under TCP,
it still adds considerable latency, making the protocol unsuitable for
certain applications.
</p>
<p>To optimize the handshake latency, in client side, it is possible to take
advantage of the TCP fast open [<a href="#RFC7413">RFC7413</a>] mechanism on operating
systems that support it. That can be done either by manually crafting the push and pull
callbacks, or by utilizing <a href="#gnutls_005ftransport_005fset_005ffastopen">gnutls_transport_set_fastopen</a>. In that
case the initial TCP handshake is eliminated, reducing the TLS 1.2 handshake round-trip
to 2, and the TLS 1.3 handshake to a single round-trip.
Note, that when this function is used, any connection failures will be reported during the
<a href="#gnutls_005fhandshake">gnutls_handshake</a> function call with error code <code>GNUTLS_E_PUSH_ERROR</code>.
</p>



<dl>
<dt id="index-gnutls_005ftransport_005fset_005ffastopen">Function: <em>void</em> <strong>gnutls_transport_set_fastopen</strong> <em>(gnutls_session_t <var>session</var>, int <var>fd</var>, struct sockaddr * <var>connect_addr</var>, socklen_t <var>connect_addrlen</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>fd</var>: is the session&rsquo;s socket descriptor
</p>
<p><var>connect_addr</var>: is the address we want to connect to
</p>
<p><var>connect_addrlen</var>: is the length of  <code>connect_addr</code> 
</p>
<p><var>flags</var>: must be zero
</p>
<p>Enables TCP Fast Open (TFO) for the specified TLS client session.
That means that TCP connection establishment and the transmission
of the first TLS client hello packet are combined. The
peer&rsquo;s address must be  specified in  <code>connect_addr</code> and  <code>connect_addrlen</code> ,
and the socket specified by  <code>fd</code> should not be connected.
</p>
<p>TFO only works for TCP sockets of type AF_INET and AF_INET6.
If the OS doesn&rsquo;t support TCP fast open this function will result
to gnutls using <code>connect()</code>  transparently during the first write.
</p>
<p><strong>Note:</strong> This function overrides all the transport callback functions.
If this is undesirable, TCP Fast Open must be implemented on the user
callback functions without calling this function. When using
this function, transport callbacks must not be set, and 
<code>gnutls_transport_set_ptr()</code>  or <code>gnutls_transport_set_int()</code> 
must not be called.
</p>
<p>On GNU/Linux TFO has to be enabled at the system layer, that is
in /proc/sys/net/ipv4/tcp_fastopen, bit 0 has to be set.
</p>
<p>This function has no effect on server sessions.
</p>
<p><strong>Since:</strong> 3.5.3
</p></dd></dl>

<p>When restricted to TLS 1.2, and non-resumed sessions, it is possible to further
reduce the round-trips to a single one by taking advantage of the <a href="#False-Start">False Start</a>
TLS extension. This can be enabled by setting the <acronym>GNUTLS_ENABLE_FALSE_START</acronym>
flag on <a href="#gnutls_005finit">gnutls_init</a>.
</p>
<p>Under TLS 1.3, the server side can start transmitting before the handshake
is complete (i.e., while the client Finished message is still in flight),
when no client certificate authentication is requested. This, unlike false
start, is part of protocol design with no known security implications.
It can be enabled by setting the <acronym>GNUTLS_ENABLE_EARLY_START</acronym> on
<a href="#gnutls_005finit">gnutls_init</a>, and the <a href="#gnutls_005fhandshake">gnutls_handshake</a> function will
return early, allowing the server to send data earlier.
</p>

<hr>
<span id="Zero_002droundtrip-mode"></span><div class="header">
<p>
Next: <a href="#Anti_002dreplay-protection" accesskey="n" rel="next">Anti-replay protection</a>, Previous: <a href="#Reducing-round_002dtrips" accesskey="p" rel="prev">Reducing round-trips</a>, Up: <a href="#Setting-up-the-transport-layer" accesskey="u" rel="up">Setting up the transport layer</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Zero_002droundtrip-mode-1"></span><h4 class="subsection">6.5.3 Zero-roundtrip mode</h4>

<p>Under TLS 1.3, when the client has already connected to the server and
is resuming a session, it can start transmitting application data during
handshake.  This is called zero round-trip time (0-RTT) mode, and the
application data sent in this mode is called early data.  The client can
send early data with <a href="#gnutls_005frecord_005fsend_005fearly_005fdata">gnutls_record_send_early_data</a>.  The
client should call this function before calling
<a href="#gnutls_005fhandshake">gnutls_handshake</a> and after calling
<a href="#gnutls_005fsession_005fset_005fdata">gnutls_session_set_data</a>.
</p>
<p>Note, however, that early data has weaker security properties than
normal application data sent after handshake, such as lack of forward
secrecy, no guarantees of non-replay between connections.  Thus it is
disabled on the server side by default.  To enable it, the server
needs to:
</p><ol>
<li> Set <acronym>GNUTLS_ENABLE_EARLY_DATA</acronym> on <a href="#gnutls_005finit">gnutls_init</a>.  Note that this option only has effect on server.

</li><li> Enable anti-replay measure.  See <a href="#Anti_002dreplay-protection">Anti-replay protection</a> for the details.
</li></ol>

<p>The server caches the received early data until it is read.  To set the
maximum amount of data to be stored in the cache, use
<a href="#gnutls_005frecord_005fset_005fmax_005fearly_005fdata_005fsize">gnutls_record_set_max_early_data_size</a>.  After receiving the
EndOfEarlyData handshake message, the server can start retrieving the
received data with <a href="#gnutls_005frecord_005frecv_005fearly_005fdata">gnutls_record_recv_early_data</a>.  You can
call the function either after the handshake is complete, or through a
handshake hook (<a href="#gnutls_005fhandshake_005fset_005fhook_005ffunction">gnutls_handshake_set_hook_function</a>).
</p>
<p>When sending early data, the client should respect the maximum amount
of early data, which may have been previously advertised by the
server.  It can be checked using
<a href="#gnutls_005frecord_005fget_005fmax_005fearly_005fdata_005fsize">gnutls_record_get_max_early_data_size</a>, right after calling
<a href="#gnutls_005fsession_005fset_005fdata">gnutls_session_set_data</a>.
</p>
<p>After sending early data, to check whether the sent early data was
accepted by the server, use <a href="#gnutls_005fsession_005fget_005fflags">gnutls_session_get_flags</a> and
compare the result with <acronym>GNUTLS_SFLAGS_EARLY_DATA</acronym>.
Similarly, on the server side, the same function and flag can be used
to check whether it has actually accepted early data.
</p>

<hr>
<span id="Anti_002dreplay-protection"></span><div class="header">
<p>
Next: <a href="#DTLS-sessions" accesskey="n" rel="next">DTLS sessions</a>, Previous: <a href="#Zero_002droundtrip-mode" accesskey="p" rel="prev">Zero-roundtrip mode</a>, Up: <a href="#Setting-up-the-transport-layer" accesskey="u" rel="up">Setting up the transport layer</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Anti_002dreplay-protection-1"></span><h4 class="subsection">6.5.4 Anti-replay protection</h4>

<p>When 0-RTT mode is used, the server must protect itself from replay
attacks, where adversary client reuses duplicate session ticket to send
early data, before the server authenticates the client.
</p>
<p>GnuTLS provides a simple mechanism against replay attacks, following the
method called ClientHello recording.  When a session ticket is accepted,
the server checks if the ClientHello message has been already seen.  If
there is a duplicate, the server rejects early data.
</p>
<p>The problem of this approach is that the number of recorded messages
grows indefinitely.  To prevent that, the server can limit the recording
to a certain time window, which can be configured with
<a href="#gnutls_005fanti_005freplay_005fset_005fwindow">gnutls_anti_replay_set_window</a>.
</p>
<p>The anti-replay mechanism shall be globally initialized with
<a href="#gnutls_005fanti_005freplay_005finit">gnutls_anti_replay_init</a>, and then attached to a session using
<a href="#gnutls_005fanti_005freplay_005fenable">gnutls_anti_replay_enable</a>.  It can be deinitialized with
<a href="#gnutls_005fanti_005freplay_005fdeinit">gnutls_anti_replay_deinit</a>.
</p>
<p>The server must also set up a database back-end to store ClientHello
messages.  That can be achieved using
<a href="#gnutls_005fanti_005freplay_005fset_005fadd_005ffunction">gnutls_anti_replay_set_add_function</a> and
<a href="#gnutls_005fanti_005freplay_005fset_005fptr">gnutls_anti_replay_set_ptr</a>.
</p>
<p>Note that, if the back-end stores arbitrary number of ClientHello, it
needs to periodically clean up the stored entries based on the time
window set with <a href="#gnutls_005fanti_005freplay_005fset_005fwindow">gnutls_anti_replay_set_window</a>.  The cleanup
can be implemented by iterating through the database entries and calling
<a href="#gnutls_005fdb_005fcheck_005fentry_005fexpire_005ftime">gnutls_db_check_entry_expire_time</a>.  This is similar to session
database cleanup used by TLS1.2 sessions.
</p>
<p>The full set up of the server using early data would be like the
following example:
</p><div class="example">
<pre class="example">#define MAX_EARLY_DATA_SIZE 16384

static int
db_add_func(void *dbf, gnutls_datum_t key, gnutls_datum_t data)
{
    /* Return GNUTLS_E_DB_ENTRY_EXISTS, if KEY is found in the database.
     * Otherwise, store it and return 0.
     */
}

static int
handshake_hook_func(gnutls_session_t session, unsigned int htype,
                    unsigned when, unsigned int incoming, const gnutls_datum_t *msg)
{
    int ret;
    char buf[MAX_EARLY_DATA_SIZE];

    assert(htype == GNUTLS_HANDSHAKE_END_OF_EARLY_DATA);
    assert(when == GNUTLS_HOOK_POST);

    if (gnutls_session_get_flags(session) &amp; GNUTLS_SFLAGS_EARLY_DATA) {
        ret = gnutls_record_recv_early_data(session, buf, sizeof(buf));
        assert(ret &gt;= 0);
    }

    return ret;
}

int main()
{
  ...
  /* Initialize anti-replay measure, which can be shared
   * among multiple sessions.
   */
  gnutls_anti_replay_init(&amp;anti_replay);

  /* Set the database back-end function for the anti-replay data. */
  gnutls_anti_replay_set_add_function(anti_replay, db_add_func);
  gnutls_anti_replay_set_ptr(anti_replay, NULL);

  ...

  gnutls_init(&amp;server, GNUTLS_SERVER | GNUTLS_ENABLE_EARLY_DATA);
  gnutls_record_set_max_early_data_size(server, MAX_EARLY_DATA_SIZE);

  ...

  /* Set the anti-replay measure to the session.
   */
  gnutls_anti_replay_enable(server, anti_replay);
  ...

  /* Retrieve early data in a handshake hook;
   * you can also do that after handshake.
   */
  gnutls_handshake_set_hook_function(server, GNUTLS_HANDSHAKE_END_OF_EARLY_DATA,
                                     GNUTLS_HOOK_POST, handshake_hook_func);
  ...
}
</pre></div>


<hr>
<span id="DTLS-sessions"></span><div class="header">
<p>
Next: <a href="#DTLS-and-SCTP" accesskey="n" rel="next">DTLS and SCTP</a>, Previous: <a href="#Anti_002dreplay-protection" accesskey="p" rel="prev">Anti-replay protection</a>, Up: <a href="#Setting-up-the-transport-layer" accesskey="u" rel="up">Setting up the transport layer</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="DTLS-sessions-1"></span><h4 class="subsection">6.5.5 DTLS sessions</h4>

<p>Because datagram TLS can operate over connections where the client
cannot be reliably verified, functionality in the form of cookies, is available to prevent
denial of service attacks to servers. <acronym>GnuTLS</acronym> requires a server
to generate a secret key that is used to sign a cookie<a id="DOCF19" href="#FOOT19"><sup>19</sup></a>. 
That cookie is sent to the client using <a href="#gnutls_005fdtls_005fcookie_005fsend">gnutls_dtls_cookie_send</a>, and 
the client must reply using the correct cookie. The server side
should verify the initial message sent by client using <a href="#gnutls_005fdtls_005fcookie_005fverify">gnutls_dtls_cookie_verify</a>.
If successful the session should be initialized and associated with
the cookie using <a href="#gnutls_005fdtls_005fprestate_005fset">gnutls_dtls_prestate_set</a>, before proceeding to
the handshake.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fkey_005fgenerate">gnutls_key_generate</a> (gnutls_datum_t * <var>key</var>, unsigned int <var>key_size</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fdtls_005fcookie_005fsend">gnutls_dtls_cookie_send</a> (gnutls_datum_t * <var>key</var>, void * <var>client_data</var>, size_t <var>client_data_size</var>, gnutls_dtls_prestate_st * <var>prestate</var>, gnutls_transport_ptr_t <var>ptr</var>, gnutls_push_func <var>push_func</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fdtls_005fcookie_005fverify">gnutls_dtls_cookie_verify</a> (gnutls_datum_t * <var>key</var>, void * <var>client_data</var>, size_t <var>client_data_size</var>, void * <var>_msg</var>, size_t <var>msg_size</var>, gnutls_dtls_prestate_st * <var>prestate</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005fdtls_005fprestate_005fset">gnutls_dtls_prestate_set</a> (gnutls_session_t <var>session</var>, gnutls_dtls_prestate_st * <var>prestate</var>)</code></dt>
</dl>

<p>Note that the above apply to server side only and they are not mandatory to be
used. Not using them, however, allows denial of service attacks.
The client side cookie handling is part of <a href="#gnutls_005fhandshake">gnutls_handshake</a>. 
</p>
<p>Datagrams are typically restricted by a maximum transfer unit (MTU). For that
both client and server side should set the correct maximum transfer unit for
the layer underneath <acronym>GnuTLS</acronym>. This will allow proper fragmentation
of DTLS messages and prevent messages from being silently discarded by the
transport layer. The &ldquo;correct&rdquo; maximum transfer unit can be obtained through
a path MTU discovery mechanism [<a href="#RFC4821">RFC4821</a>].
</p>
<dl compact="compact">
<dt><code><var>void</var> <a href="#gnutls_005fdtls_005fset_005fmtu">gnutls_dtls_set_mtu</a> (gnutls_session_t <var>session</var>, unsigned int <var>mtu</var>)</code></dt>
<dt><code><var>unsigned int</var> <a href="#gnutls_005fdtls_005fget_005fmtu">gnutls_dtls_get_mtu</a> (gnutls_session_t <var>session</var>)</code></dt>
<dt><code><var>unsigned int</var> <a href="#gnutls_005fdtls_005fget_005fdata_005fmtu">gnutls_dtls_get_data_mtu</a> (gnutls_session_t <var>session</var>)</code></dt>
</dl>

<hr>
<span id="DTLS-and-SCTP"></span><div class="header">
<p>
Previous: <a href="#DTLS-sessions" accesskey="p" rel="prev">DTLS sessions</a>, Up: <a href="#Setting-up-the-transport-layer" accesskey="u" rel="up">Setting up the transport layer</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="DTLS-and-SCTP-1"></span><h4 class="subsection">6.5.6 DTLS and SCTP</h4>

<p>Although DTLS can run under any reliable or unreliable layer, there are
special requirements for SCTP according to [<a href="#RFC6083">RFC6083</a>]. We summarize the
most important below, however for a full treatment we refer to [<a href="#RFC6083">RFC6083</a>].
</p>
<ul>
<li> The MTU set via <a href="#gnutls_005fdtls_005fset_005fmtu">gnutls_dtls_set_mtu</a> must be 2^14.
</li><li> Replay detection must be disabled; use the flag <code>GNUTLS_NO_REPLAY_PROTECTION</code> with <a href="#gnutls_005finit">gnutls_init</a>.
</li><li> Retransmission of messages must be disabled; use <a href="#gnutls_005fdtls_005fset_005ftimeouts">gnutls_dtls_set_timeouts</a>
   with a retransmission timeout larger than the total.
</li><li> Handshake, Alert and ChangeCipherSpec messages must be sent over stream 0 with unlimited reliability
   and with the ordered delivery feature.
</li><li> During a rehandshake, the caching of messages with unknown epoch is
   not handled by GnuTLS; this must be implemented in a special pull function.
</li></ul>

<hr>
<span id="TLS-handshake"></span><div class="header">
<p>
Next: <a href="#Data-transfer-and-termination" accesskey="n" rel="next">Data transfer and termination</a>, Previous: <a href="#Setting-up-the-transport-layer" accesskey="p" rel="prev">Setting up the transport layer</a>, Up: <a href="#How-to-use-GnuTLS-in-applications" accesskey="u" rel="up">How to use GnuTLS in applications</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="TLS-handshake-1"></span><h3 class="section">6.6 TLS handshake</h3>
<p>Once a session has been initialized and a network
connection has been set up, TLS and DTLS protocols
perform a handshake. The handshake is the actual key
exchange.
</p>




<dl>
<dt id="index-gnutls_005fhandshake">Function: <em>int</em> <strong>gnutls_handshake</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>This function performs the handshake of the TLS/SSL protocol, and
initializes the TLS session parameters.
</p>
<p>The non-fatal errors expected by this function are:
<code>GNUTLS_E_INTERRUPTED</code> , <code>GNUTLS_E_AGAIN</code> , 
<code>GNUTLS_E_WARNING_ALERT_RECEIVED</code> . When this function is called
for re-handshake under TLS 1.2 or earlier, the non-fatal error code
<code>GNUTLS_E_GOT_APPLICATION_DATA</code>  may also be returned.
</p>
<p>The former two interrupt the handshake procedure due to the transport
layer being interrupted, and the latter because of a &quot;warning&quot; alert that
was sent by the peer (it is always a good idea to check any
received alerts). On these non-fatal errors call this function again,
until it returns 0; cf.  <code>gnutls_record_get_direction()</code>  and
<code>gnutls_error_is_fatal()</code> . In DTLS sessions the non-fatal error
<code>GNUTLS_E_LARGE_PACKET</code>  is also possible, and indicates that
the MTU should be adjusted.
</p>
<p>When this function is called by a server after a rehandshake request
under TLS 1.2 or earlier the <code>GNUTLS_E_GOT_APPLICATION_DATA</code>  error code indicates
that some data were pending prior to peer initiating the handshake.
Under TLS 1.3 this function when called after a successful handshake, is a no-op
and always succeeds in server side; in client side this function is
equivalent to <code>gnutls_session_key_update()</code>  with <code>GNUTLS_KU_PEER</code>  flag.
</p>
<p>This function handles both full and abbreviated TLS handshakes (resumption).
For abbreviated handshakes, in client side, the <code>gnutls_session_set_data()</code> 
should be called prior to this function to set parameters from a previous session.
In server side, resumption is handled by either setting a DB back-end, or setting
up keys for session tickets.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on a successful handshake, otherwise a negative error code.
</p></dd></dl>





<dl>
<dt id="index-gnutls_005fhandshake_005fset_005ftimeout">Function: <em>void</em> <strong>gnutls_handshake_set_timeout</strong> <em>(gnutls_session_t <var>session</var>, unsigned int <var>ms</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>ms</var>: is a timeout value in milliseconds
</p>
<p>This function sets the timeout for the TLS handshake process
to the provided value. Use an  <code>ms</code> value of zero to disable
timeout, or <code>GNUTLS_DEFAULT_HANDSHAKE_TIMEOUT</code>  for a reasonable
default value. For the DTLS protocol, the more detailed
<code>gnutls_dtls_set_timeouts()</code>  is provided.
</p>
<p>This function requires to set a pull timeout callback. See
<code>gnutls_transport_set_pull_timeout_function()</code> .
</p>
<p><strong>Since:</strong> 3.1.0
</p></dd></dl>

<p>In GnuTLS 3.5.0 and later it is recommended to use <a href="#gnutls_005fsession_005fset_005fverify_005fcert">gnutls_session_set_verify_cert</a>
for the handshake process to ensure the verification of the peer&rsquo;s identity.
That will verify the peer&rsquo;s certificate, against the trusted CA store while
accounting for stapled OCSP responses during the handshake; any error will
be returned as a handshake error.
</p>
<p>In older GnuTLS versions it is required to verify the peer&rsquo;s certificate
during the handshake by setting a callback with <a href="#gnutls_005fcertificate_005fset_005fverify_005ffunction">gnutls_certificate_set_verify_function</a>,
and then using <a href="#gnutls_005fcertificate_005fverify_005fpeers3">gnutls_certificate_verify_peers3</a> from it. See <a href="#Certificate-authentication">Certificate authentication</a>
for more information.
</p>
<dl compact="compact">
<dt><code><var>void</var> <a href="#gnutls_005fsession_005fset_005fverify_005fcert">gnutls_session_set_verify_cert</a> (gnutls_session_t <var>session</var>, const char * <var>hostname</var>, unsigned <var>flags</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fcertificate_005fverify_005fpeers3">gnutls_certificate_verify_peers3</a> (gnutls_session_t <var>session</var>, const char * <var>hostname</var>, unsigned int * <var>status</var>)</code></dt>
</dl>

<hr>
<span id="Data-transfer-and-termination"></span><div class="header">
<p>
Next: <a href="#Buffered-data-transfer" accesskey="n" rel="next">Buffered data transfer</a>, Previous: <a href="#TLS-handshake" accesskey="p" rel="prev">TLS handshake</a>, Up: <a href="#How-to-use-GnuTLS-in-applications" accesskey="u" rel="up">How to use GnuTLS in applications</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Data-transfer-and-termination-1"></span><h3 class="section">6.7 Data transfer and termination</h3>
<p>Once the handshake is complete and peer&rsquo;s identity
has been verified data can be exchanged. The available
functions resemble the POSIX <code>recv</code> and <code>send</code>
functions. It is suggested to use <a href="#gnutls_005ferror_005fis_005ffatal">gnutls_error_is_fatal</a>
to check whether the error codes returned by these functions are
fatal for the protocol or can be ignored.
</p>




<dl>
<dt id="index-gnutls_005frecord_005fsend">Function: <em>ssize_t</em> <strong>gnutls_record_send</strong> <em>(gnutls_session_t <var>session</var>, const void * <var>data</var>, size_t <var>data_size</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>data</var>: contains the data to send
</p>
<p><var>data_size</var>: is the length of the data
</p>
<p>This function has the similar semantics with <code>send()</code> .  The only
difference is that it accepts a GnuTLS session, and uses different
error codes.
Note that if the send buffer is full, <code>send()</code>  will block this
function.  See the <code>send()</code>  documentation for more information.  
</p>
<p>You can replace the default push function which is <code>send()</code> , by using
<code>gnutls_transport_set_push_function()</code> .
</p>
<p>If the EINTR is returned by the internal push function 
then <code>GNUTLS_E_INTERRUPTED</code>  will be returned. If
<code>GNUTLS_E_INTERRUPTED</code>  or <code>GNUTLS_E_AGAIN</code>  is returned, you must
call this function again with the exact same parameters, or provide a
<code>NULL</code>  pointer for  <code>data</code> and 0 for  <code>data_size</code> , in order to write the
same data as before. If you wish to discard the previous data instead
of retrying, you must call <code>gnutls_record_discard_queued()</code>  before
calling this function with different parameters.
cf. <code>gnutls_record_get_direction()</code> . 
</p>
<p>Note that in DTLS this function will return the <code>GNUTLS_E_LARGE_PACKET</code> 
error code if the send data exceed the data MTU value - as returned
by <code>gnutls_dtls_get_data_mtu()</code> . The errno value EMSGSIZE
also maps to <code>GNUTLS_E_LARGE_PACKET</code> . 
Note that since 3.2.13 this function can be called under cork in DTLS
mode, and will refuse to send data over the MTU size by returning
<code>GNUTLS_E_LARGE_PACKET</code> .
</p>
<p><strong>Returns:</strong> The number of bytes sent, or a negative error code.  The
number of bytes sent might be less than  <code>data_size</code> .  The maximum
number of bytes this function can send in a single call depends
on the negotiated maximum record size.
</p></dd></dl>





<dl>
<dt id="index-gnutls_005frecord_005frecv">Function: <em>ssize_t</em> <strong>gnutls_record_recv</strong> <em>(gnutls_session_t <var>session</var>, void * <var>data</var>, size_t <var>data_size</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>data</var>: the buffer that the data will be read into
</p>
<p><var>data_size</var>: the number of requested bytes
</p>
<p>This function has the similar semantics with <code>recv()</code> .  The only
difference is that it accepts a GnuTLS session, and uses different
error codes.
In the special case that the peer requests a renegotiation, the
caller will receive an error code of <code>GNUTLS_E_REHANDSHAKE</code> .  In case
of a client, this message may be simply ignored, replied with an alert
<code>GNUTLS_A_NO_RENEGOTIATION</code> , or replied with a new handshake,
depending on the client&rsquo;s will. A server receiving this error code
can only initiate a new handshake or terminate the session.
</p>
<p>If <code>EINTR</code>  is returned by the internal pull function (the default
is <code>recv()</code> ) then <code>GNUTLS_E_INTERRUPTED</code>  will be returned.  If
<code>GNUTLS_E_INTERRUPTED</code>  or <code>GNUTLS_E_AGAIN</code>  is returned, you must
call this function again to get the data.  See also
<code>gnutls_record_get_direction()</code> .
</p>
<p><strong>Returns:</strong> The number of bytes received and zero on EOF (for stream
connections).  A negative error code is returned in case of an error.  
The number of bytes received might be less than the requested  <code>data_size</code> .
</p></dd></dl>





<dl>
<dt id="index-gnutls_005ferror_005fis_005ffatal">Function: <em>int</em> <strong>gnutls_error_is_fatal</strong> <em>(int <var>error</var>)</em></dt>
<dd><p><var>error</var>: is a GnuTLS error code, a negative error code
</p>
<p>If a GnuTLS function returns a negative error code you may feed that
value to this function to see if the error condition is fatal to
a TLS session (i.e., must be terminated).
</p>
<p>Note that you may also want to check the error code manually, since some
non-fatal errors to the protocol (such as a warning alert or
a rehandshake request) may be fatal for your program.
</p>
<p>This function is only useful if you are dealing with errors from
functions that relate to a TLS session (e.g., record layer or handshake
layer handling functions).
</p>
<p><strong>Returns:</strong> Non-zero value on fatal errors or zero on non-fatal.
</p></dd></dl>

<p>Although, in the TLS protocol the receive function can be called
at any time, when DTLS is used the GnuTLS receive functions must be
called once a message is available for reading, even if no data are
expected. This is because in DTLS various (internal) actions
may be required due to retransmission timers. Moreover,
an extended receive function is shown below, which allows the extraction
of the message&rsquo;s sequence number. Due to the unreliable nature of the
protocol, this field allows distinguishing out-of-order messages.
</p>




<dl>
<dt id="index-gnutls_005frecord_005frecv_005fseq">Function: <em>ssize_t</em> <strong>gnutls_record_recv_seq</strong> <em>(gnutls_session_t <var>session</var>, void * <var>data</var>, size_t <var>data_size</var>, unsigned char * <var>seq</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>data</var>: the buffer that the data will be read into
</p>
<p><var>data_size</var>: the number of requested bytes
</p>
<p><var>seq</var>: is the packet&rsquo;s 64-bit sequence number. Should have space for 8 bytes.
</p>
<p>This function is the same as <code>gnutls_record_recv()</code> , except that
it returns in addition to data, the sequence number of the data.
This is useful in DTLS where record packets might be received
out-of-order. The returned 8-byte sequence number is an
integer in big-endian format and should be
treated as a unique message identification. 
</p>
<p><strong>Returns:</strong> The number of bytes received and zero on EOF.  A negative
error code is returned in case of an error.  The number of bytes
received might be less than  <code>data_size</code> .
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<p>The <a href="#gnutls_005frecord_005fcheck_005fpending">gnutls_record_check_pending</a> helper function is available to 
allow checking whether data are available to be read in a <acronym>GnuTLS</acronym> session 
buffers. Note that this function complements but does not replace <code>poll</code>,
i.e., <a href="#gnutls_005frecord_005fcheck_005fpending">gnutls_record_check_pending</a> reports no data to be read, <code>poll</code>
should be called to check for data in the network buffers.
</p>




<dl>
<dt id="index-gnutls_005frecord_005fcheck_005fpending">Function: <em>size_t</em> <strong>gnutls_record_check_pending</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>This function checks if there are unread data
in the gnutls buffers. If the return value is
non-zero the next call to <code>gnutls_record_recv()</code> 
is guaranteed not to block.
</p>
<p><strong>Returns:</strong> Returns the size of the data or zero.
</p></dd></dl>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005frecord_005fget_005fdirection">gnutls_record_get_direction</a> (gnutls_session_t <var>session</var>)</code></dt>
</dl>

<p>Once a TLS or DTLS session is no longer needed, it is
recommended to use <a href="#gnutls_005fbye">gnutls_bye</a> to terminate the
session. That way the peer is notified securely about the
intention of termination, which allows distinguishing it
from a malicious connection termination.
A session can be deinitialized with the <a href="#gnutls_005fdeinit">gnutls_deinit</a> function.
</p>




<dl>
<dt id="index-gnutls_005fbye">Function: <em>int</em> <strong>gnutls_bye</strong> <em>(gnutls_session_t <var>session</var>, gnutls_close_request_t <var>how</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>how</var>: is an integer
</p>
<p>Terminates the current TLS/SSL connection. The connection should
have been initiated using <code>gnutls_handshake()</code> .   <code>how</code> should be one
of <code>GNUTLS_SHUT_RDWR</code> , <code>GNUTLS_SHUT_WR</code> .
</p>
<p>In case of <code>GNUTLS_SHUT_RDWR</code>  the TLS session gets
terminated and further receives and sends will be disallowed.  If
the return value is zero you may continue using the underlying
transport layer. <code>GNUTLS_SHUT_RDWR</code>  sends an alert containing a close
request and waits for the peer to reply with the same message.
</p>
<p>In case of <code>GNUTLS_SHUT_WR</code>  the TLS session gets terminated
and further sends will be disallowed. In order to reuse the
connection you should wait for an EOF from the peer.
<code>GNUTLS_SHUT_WR</code>  sends an alert containing a close request.
</p>
<p>Note that not all implementations will properly terminate a TLS
connection.  Some of them, usually for performance reasons, will
terminate only the underlying transport layer, and thus not
distinguishing between a malicious party prematurely terminating 
the connection and normal termination. 
</p>
<p>This function may also return <code>GNUTLS_E_AGAIN</code>  or
<code>GNUTLS_E_INTERRUPTED</code> ; cf.  <code>gnutls_record_get_direction()</code> .
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, or an error code, see
function documentation for entire semantics.
</p></dd></dl>




<dl>
<dt id="index-gnutls_005fdeinit">Function: <em>void</em> <strong>gnutls_deinit</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>This function clears all buffers associated with the  <code>session</code> .
This function will also remove session data from the session
database if the session was terminated abnormally.
</p></dd></dl>

<hr>
<span id="Buffered-data-transfer"></span><div class="header">
<p>
Next: <a href="#Handling-alerts" accesskey="n" rel="next">Handling alerts</a>, Previous: <a href="#Data-transfer-and-termination" accesskey="p" rel="prev">Data transfer and termination</a>, Up: <a href="#How-to-use-GnuTLS-in-applications" accesskey="u" rel="up">How to use GnuTLS in applications</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Buffered-data-transfer-1"></span><h3 class="section">6.8 Buffered data transfer</h3>

<p>Although <a href="#gnutls_005frecord_005fsend">gnutls_record_send</a> is sufficient to transmit data
to the peer, when many small chunks of data are to be transmitted
it is inefficient and wastes bandwidth due to the TLS record
overhead. In that case it is preferable to combine the small chunks
before transmission. The following functions provide that functionality.
</p>




<dl>
<dt id="index-gnutls_005frecord_005fcork">Function: <em>void</em> <strong>gnutls_record_cork</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>If called, <code>gnutls_record_send()</code>  will no longer send any records.
Any sent records will be cached until <code>gnutls_record_uncork()</code>  is called.
</p>
<p>This function is safe to use with DTLS after GnuTLS 3.3.0.
</p>
<p><strong>Since:</strong> 3.1.9
</p></dd></dl>





<dl>
<dt id="index-gnutls_005frecord_005funcork">Function: <em>int</em> <strong>gnutls_record_uncork</strong> <em>(gnutls_session_t <var>session</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>flags</var>: Could be zero or <code>GNUTLS_RECORD_WAIT</code> 
</p>
<p>This resets the effect of <code>gnutls_record_cork()</code> , and flushes any pending
data. If the <code>GNUTLS_RECORD_WAIT</code>  flag is specified then this
function will block until the data is sent or a fatal error
occurs (i.e., the function will retry on <code>GNUTLS_E_AGAIN</code>  and
<code>GNUTLS_E_INTERRUPTED</code> ).
</p>
<p>If the flag <code>GNUTLS_RECORD_WAIT</code>  is not specified and the function
is interrupted then the <code>GNUTLS_E_AGAIN</code>  or <code>GNUTLS_E_INTERRUPTED</code> 
errors will be returned. To obtain the data left in the corked
buffer use <code>gnutls_record_check_corked()</code> .
</p>
<p><strong>Returns:</strong> On success the number of transmitted data is returned, or 
otherwise a negative error code. 
</p>
<p><strong>Since:</strong> 3.1.9
</p></dd></dl>


<hr>
<span id="Handling-alerts"></span><div class="header">
<p>
Next: <a href="#Priority-Strings" accesskey="n" rel="next">Priority Strings</a>, Previous: <a href="#Buffered-data-transfer" accesskey="p" rel="prev">Buffered data transfer</a>, Up: <a href="#How-to-use-GnuTLS-in-applications" accesskey="u" rel="up">How to use GnuTLS in applications</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Handling-alerts-1"></span><h3 class="section">6.9 Handling alerts</h3>
<p>During a TLS connection alert messages may be exchanged by the
two peers. Those messages may be fatal, meaning the connection
must be terminated afterwards, or warning when something needs
to be reported to the peer, but without interrupting the session.
The error codes <code>GNUTLS_E_WARNING_ALERT_RECEIVED</code>
or <code>GNUTLS_E_FATAL_ALERT_RECEIVED</code> signal those alerts
when received, and may be returned by all GnuTLS functions that receive 
data from the peer, being <a href="#gnutls_005fhandshake">gnutls_handshake</a> and <a href="#gnutls_005frecord_005frecv">gnutls_record_recv</a>.
</p>
<p>If those error codes are received the alert and its level should be logged
or reported to the peer using the functions below.
</p>



<dl>
<dt id="index-gnutls_005falert_005fget">Function: <em>gnutls_alert_description_t</em> <strong>gnutls_alert_get</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>This function will return the last alert number received.  This
function should be called when <code>GNUTLS_E_WARNING_ALERT_RECEIVED</code>  or
<code>GNUTLS_E_FATAL_ALERT_RECEIVED</code>  errors are returned by a gnutls
function.  The peer may send alerts if he encounters an error.
If no alert has been received the returned value is undefined.
</p>
<p><strong>Returns:</strong> the last alert received, a
<code>gnutls_alert_description_t</code>  value.
</p></dd></dl>




<dl>
<dt id="index-gnutls_005falert_005fget_005fname">Function: <em>const char *</em> <strong>gnutls_alert_get_name</strong> <em>(gnutls_alert_description_t <var>alert</var>)</em></dt>
<dd><p><var>alert</var>: is an alert number.
</p>
<p>This function will return a string that describes the given alert
number, or <code>NULL</code> .  See <code>gnutls_alert_get()</code> .
</p>
<p><strong>Returns:</strong> string corresponding to <code>gnutls_alert_description_t</code>  value.
</p></dd></dl>

<p>The peer may also be warned or notified of a fatal issue
by using one of the functions below. All the available alerts
are listed in <a href="#The-Alert-Protocol">The Alert Protocol</a>.
</p>




<dl>
<dt id="index-gnutls_005falert_005fsend">Function: <em>int</em> <strong>gnutls_alert_send</strong> <em>(gnutls_session_t <var>session</var>, gnutls_alert_level_t <var>level</var>, gnutls_alert_description_t <var>desc</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>level</var>: is the level of the alert
</p>
<p><var>desc</var>: is the alert description
</p>
<p>This function will send an alert to the peer in order to inform
him of something important (eg. his Certificate could not be verified).
If the alert level is Fatal then the peer is expected to close the
connection, otherwise he may ignore the alert and continue.
</p>
<p>The error code of the underlying record send function will be
returned, so you may also receive <code>GNUTLS_E_INTERRUPTED</code>  or
<code>GNUTLS_E_AGAIN</code>  as well.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p></dd></dl>




<dl>
<dt id="index-gnutls_005ferror_005fto_005falert">Function: <em>int</em> <strong>gnutls_error_to_alert</strong> <em>(int <var>err</var>, int * <var>level</var>)</em></dt>
<dd><p><var>err</var>: is a negative integer
</p>
<p><var>level</var>: the alert level will be stored there
</p>
<p>Get an alert depending on the error code returned by a gnutls
function.  All alerts sent by this function should be considered
fatal.  The only exception is when  <code>err</code> is <code>GNUTLS_E_REHANDSHAKE</code> ,
where a warning alert should be sent to the peer indicating that no
renegotiation will be performed.
</p>
<p>If there is no mapping to a valid alert the alert to indicate
internal error (<code>GNUTLS_A_INTERNAL_ERROR</code> ) is returned.
</p>
<p><strong>Returns:</strong> the alert code to use for a particular error code.
</p></dd></dl>


<hr>
<span id="Priority-Strings"></span><div class="header">
<p>
Next: <a href="#Selecting-cryptographic-key-sizes" accesskey="n" rel="next">Selecting cryptographic key sizes</a>, Previous: <a href="#Handling-alerts" accesskey="p" rel="prev">Handling alerts</a>, Up: <a href="#How-to-use-GnuTLS-in-applications" accesskey="u" rel="up">How to use GnuTLS in applications</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Priority-strings"></span><h3 class="section">6.10 Priority strings</h3>
<span id="index-Priority-strings"></span>

<span id="How-to-use-Priority-Strings"></span><h4 class="subheading">How to use Priority Strings</h4>

<p>The GnuTLS priority strings specify the TLS session&rsquo;s handshake
algorithms and options in a compact, easy-to-use format. These
strings are intended as a user-specified override of the library defaults.
</p>
<p>That is, we recommend applications using the default settings
(c.f. <a href="#gnutls_005fset_005fdefault_005fpriority">gnutls_set_default_priority</a> or
<a href="#gnutls_005fset_005fdefault_005fpriority_005fappend">gnutls_set_default_priority_append</a>), and provide the user 
with access to priority strings for overriding the default behavior,
on configuration files, or other UI. Following such a principle,
makes the GnuTLS library as the default settings provider. That is
necessary and a good practice, because TLS protocol hardening and
phasing out of legacy algorithms, is easier to co-ordinate when happens
in a single library.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fset_005fdefault_005fpriority">gnutls_set_default_priority</a> (gnutls_session_t <var>session</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fset_005fdefault_005fpriority_005fappend">gnutls_set_default_priority_append</a> (gnutls_session_t <var>session</var>, const char * <var>add_prio</var>, const char ** <var>err_pos</var>, unsigned <var>flags</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpriority_005fset_005fdirect">gnutls_priority_set_direct</a> (gnutls_session_t <var>session</var>, const char * <var>priorities</var>, const char ** <var>err_pos</var>)</code></dt>
</dl>

<p>The priority string translation to the internal GnuTLS form requires
processing and the generated internal form also occupies some memory.
For that, it is recommended to do that processing once in server side,
and share the generated data across sessions. The following functions
allow the generation of a &quot;priority cache&quot; and the sharing of it across
sessions.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fpriority_005finit2">gnutls_priority_init2</a> (gnutls_priority_t * <var>priority_cache</var>, const char * <var>priorities</var>, const char ** <var>err_pos</var>, unsigned <var>flags</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpriority_005finit">gnutls_priority_init</a> (gnutls_priority_t * <var>priority_cache</var>, const char * <var>priorities</var>, const char ** <var>err_pos</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpriority_005fset">gnutls_priority_set</a> (gnutls_session_t <var>session</var>, gnutls_priority_t <var>priority</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005fpriority_005fdeinit">gnutls_priority_deinit</a> (gnutls_priority_t <var>priority_cache</var>)</code></dt>
</dl>

<span id="Using-Priority-Strings"></span><h4 class="subheading">Using Priority Strings</h4>

<p>A priority string string may contain a single initial keyword such as in
<a href="#tab_003aprio_002dkeywords">Table 6.3</a> and may be followed by additional algorithm or
special keywords. Note that their description is intentionally avoiding
specific algorithm details, as the priority strings are not constant between
gnutls versions (they are periodically updated to account for cryptographic
advances while providing compatibility with old clients and servers).
</p>
<div class="float"><span id="tab_003aprio_002dkeywords"></span>
<table>
<thead><tr><th width="20%">Keyword</th><th width="70%">Description</th></tr></thead>
<tr><td width="20%">@KEYWORD</td><td width="70%">Means that a compile-time specified system configuration file (see <a href="#System_002dwide-configuration-of-the-library">System-wide configuration of the library</a>)
will be used to expand the provided keyword. That is used to impose system-specific policies.
It may be followed by additional options that will be appended to the
system string (e.g., &quot;@SYSTEM:+SRP&quot;). The system file should have the
format &rsquo;KEYWORD=VALUE&rsquo;, e.g., &rsquo;SYSTEM=NORMAL:+ARCFOUR-128&rsquo;.

<p>Since version 3.5.1 it is allowed to specify fallback keywords such
as @KEYWORD1,@KEYWORD2, and the first valid keyword will be used.
</p></td></tr>
<tr><td width="20%">PERFORMANCE</td><td width="70%">All the known to be secure ciphersuites are enabled,
limited to 128 bit ciphers and sorted by terms of speed
performance. The message authenticity security level is of 64 bits or more,
and the certificate verification profile is set to GNUTLS_PROFILE_LOW (80-bits).</td></tr>
<tr><td width="20%">NORMAL</td><td width="70%">Means all the known to be secure ciphersuites. The ciphers are sorted by security
margin, although the 256-bit ciphers are included as a fallback only.
The message authenticity security level is of 64 bits or more,
and the certificate verification profile is set to GNUTLS_PROFILE_LOW (80-bits).

<p>This priority string implicitly enables ECDHE and DHE. The ECDHE ciphersuites
are placed first in the priority order, but due to compatibility 
issues with the DHE ciphersuites they are placed last in the priority order,
after the plain RSA ciphersuites.
</p></td></tr>
<tr><td width="20%">LEGACY</td><td width="70%">This sets the NORMAL settings that were used for GnuTLS 3.2.x or earlier. There is
no verification profile set, and the allowed DH primes are considered
weak today (but are often used by misconfigured servers).</td></tr>
<tr><td width="20%">PFS</td><td width="70%">Means all the known to be secure ciphersuites that support perfect forward
secrecy (ECDHE and DHE). The ciphers are sorted by security
margin, although the 256-bit ciphers are included as a fallback only.
The message authenticity security level is of 80 bits or more,
and the certificate verification profile is set to GNUTLS_PROFILE_LOW (80-bits).
This option is available since 3.2.4 or later.</td></tr>
<tr><td width="20%">SECURE128</td><td width="70%">Means all known to be secure ciphersuites that offer a 
security level 128-bit or more.
The message authenticity security level is of 80 bits or more,
and the certificate verification profile is set to GNUTLS_PROFILE_LOW (80-bits).</td></tr>
<tr><td width="20%">SECURE192</td><td width="70%">Means all the known to be secure ciphersuites that offer a 
security level 192-bit or more.
The message authenticity security level is of 128 bits or more,
and the certificate verification profile is set to GNUTLS_PROFILE_HIGH (128-bits).</td></tr>
<tr><td width="20%">SECURE256</td><td width="70%">Currently alias for SECURE192. This option, will enable ciphers which use a
256-bit key but, due to limitations of the TLS protocol, the overall security
level will be 192-bits (the security level depends on more factors than cipher key size).</td></tr>
<tr><td width="20%">SUITEB128</td><td width="70%">Means all the NSA Suite B cryptography (RFC5430) ciphersuites
with an 128 bit security level, as well as the enabling of the corresponding
verification profile.</td></tr>
<tr><td width="20%">SUITEB192</td><td width="70%">Means all the NSA Suite B cryptography (RFC5430) ciphersuites
with an 192 bit security level, as well as the enabling of the corresponding
verification profile.</td></tr>
<tr><td width="20%">NONE</td><td width="70%">Means nothing is enabled.  This disables even protocol versions.
It should be followed by the algorithms to be enabled. Note that
using this option to build a priority string gives detailed control
into the resulting settings, however with new revisions of the TLS protocol
new priority items are routinely added, and such strings are not
forward compatible with new protocols. As such, we
advice against using that option for applications targeting multiple versions
of the GnuTLS library, and recommend using the defaults (see above) or
adjusting the defaults via <a href="#gnutls_005fset_005fdefault_005fpriority_005fappend">gnutls_set_default_priority_append</a>.</td></tr>
</table>

<div class="float-caption"><p><strong>Table 6.3: </strong>Supported initial keywords.</p></div></div>
<p>Unless the initial keyword is &quot;NONE&quot; the defaults (in preference
order) are for TLS protocols TLS 1.2, TLS1.1, TLS1.0;
for certificate types X.509.
In key exchange algorithms when in NORMAL or SECURE levels the
perfect forward secrecy algorithms take precedence of the other
protocols.  In all cases all the supported key exchange algorithms
are enabled.
</p>
<p>Note that the SECURE levels distinguish between overall security level and
message authenticity security level. That is because the message
authenticity security level requires the adversary to break
the algorithms at real-time during the protocol run, whilst 
the overall security level refers to off-line adversaries 
(e.g. adversaries breaking the ciphertext years after it was captured).
</p>
<p>The NONE keyword, if used, must followed by keywords specifying 
the algorithms and protocols to be enabled. The other initial keywords 
do not require, but may be followed by such keywords. All level keywords
can be combined, and for example a level of &quot;SECURE256:+SECURE128&quot; is
allowed.
</p>
<p>The order with which every algorithm or protocol
is specified is significant. Algorithms specified before others
will take precedence. The supported in the GnuTLS version corresponding
to this document algorithms and protocols are shown in <a href="#tab_003aprio_002dalgorithms">Table 6.4</a>;
to list the supported algorithms in your currently using version use
<code>gnutls-cli -l</code>.
</p>
<p>To avoid collisions in order to specify a protocol version
with &quot;VERS-&quot;, signature algorithms with &quot;SIGN-&quot; and certificate types with &quot;CTYPE-&quot;. 
All other algorithms don&rsquo;t need a prefix. Each specified keyword (except
for <em>special keywords</em>) can be prefixed with any of the following
characters.
</p>
<dl compact="compact">
<dt>&rsquo;!&rsquo; or &rsquo;-&rsquo;</dt>
<dd><p>appended with an algorithm will remove this algorithm.
</p></dd>
<dt>&quot;+&quot;</dt>
<dd><p>appended with an algorithm will add this algorithm.
</p></dd>
</dl>

<div class="float"><span id="tab_003aprio_002dalgorithms"></span>
<table>
<thead><tr><th width="20%">Type</th><th width="70%">Keywords</th></tr></thead>
<tr><td width="20%">Ciphers</td><td width="70%">Examples are AES-128-GCM, AES-256-GCM, AES-256-CBC; see also
<a href="#tab_003aciphers">Table 3.1</a> for more options. Catch all name is CIPHER-ALL which will add
all the algorithms from NORMAL priority.</td></tr>
<tr><td width="20%">Key exchange</td><td width="70%">RSA, DHE-RSA, DHE-DSS, SRP, SRP-RSA, SRP-DSS,
PSK, DHE-PSK, ECDHE-PSK, ECDHE-RSA, ECDHE-ECDSA, ANON-ECDH, ANON-DH. The
Catch all name is KX-ALL which will add all the algorithms from NORMAL
priority. Under TLS1.3, the DHE-PSK and ECDHE-PSK strings are equivalent
and instruct for a Diffie-Hellman key exchange using the enabled groups.</td></tr>
<tr><td width="20%">MAC</td><td width="70%">MD5, SHA1, SHA256, SHA384, AEAD (used with
GCM ciphers only). All algorithms from NORMAL priority can be accessed with MAC-ALL.</td></tr>
<tr><td width="20%">Compression algorithms</td><td width="70%">COMP-NULL, COMP-DEFLATE. Catch all is COMP-ALL.</td></tr>
<tr><td width="20%">TLS versions</td><td width="70%">VERS-TLS1.0, VERS-TLS1.1, VERS-TLS1.2, VERS-TLS1.3,
VERS-DTLS1.0, VERS-DTLS1.2. 
Catch all are VERS-ALL, and will enable
all protocols from NORMAL priority. To distinguish between TLS and DTLS
versions you can use VERS-TLS-ALL and VERS-DTLS-ALL.</td></tr>
<tr><td width="20%">Signature algorithms</td><td width="70%">SIGN-RSA-SHA1, SIGN-RSA-SHA224,
SIGN-RSA-SHA256, SIGN-RSA-SHA384, SIGN-RSA-SHA512, SIGN-DSA-SHA1,
SIGN-DSA-SHA224, SIGN-DSA-SHA256, SIGN-RSA-MD5, SIGN-ECDSA-SHA1,
SIGN-ECDSA-SHA224, SIGN-ECDSA-SHA256, SIGN-ECDSA-SHA384, SIGN-ECDSA-SHA512,
SIGN-RSA-PSS-SHA256, SIGN-RSA-PSS-SHA384, SIGN-RSA-PSS-SHA512.
Catch all which enables all algorithms from NORMAL priority is SIGN-ALL.
This option is only considered for TLS 1.2 and later.</td></tr>
<tr><td width="20%">Groups</td><td width="70%">GROUP-SECP256R1, GROUP-SECP384R1, GROUP-SECP521R1, GROUP-X25519,
GROUP-FFDHE2048, GROUP-FFDHE3072, GROUP-FFDHE4096, GROUP-FFDHE6144, and
GROUP-FFDHE8192.
Groups include both elliptic curve groups, e.g., SECP256R1, as well as 
finite field groups such as FFDHE2048. Catch all which enables all groups
from NORMAL priority is GROUP-ALL. The helper keywords GROUP-DH-ALL and
GROUP-EC-ALL are also available, restricting the groups to finite fields
(DH) and elliptic curves.</td></tr>
<tr><td width="20%">Elliptic curves (legacy)</td><td width="70%">CURVE-SECP192R1, CURVE-SECP224R1, CURVE-SECP256R1, CURVE-SECP384R1,
CURVE-SECP521R1, and CURVE-X25519.
Catch all which enables all curves from NORMAL priority is CURVE-ALL. Note
that the CURVE keyword is kept for backwards compatibility only, for new
applications see the GROUP keyword above.</td></tr>
<tr><td width="20%">Certificate types</td><td width="70%">Certificate types can be given in a symmetric fashion (i.e. the same for
both client and server) or, as of GnuTLS 3.6.4, in an asymmetric fashion
(i.e. different for the client than for the server). Alternative certificate
types must be explicitly enabled via flags in <a href="#gnutls_005finit">gnutls_init</a>.

<p>The currently supported types are CTYPE-X509, CTYPE-RAWPK which apply both to
client and server; catch all is CTYPE-ALL. The types CTYPE-CLI-X509, CTYPE-SRV-X509,
CTYPE-CLI-RAWPK, CTYPE-SRV-RAWPK can be used to specialize on client or server;
catch all is CTYPE-CLI-ALL and CTYPE-SRV-ALL. The type &rsquo;X509&rsquo; is aliased to &rsquo;X.509&rsquo;
for legacy reasons.
</p></td></tr>
</table>

<div class="float-caption"><p><strong>Table 6.4: </strong>The supported algorithm keywords in priority strings.</p></div></div>
<p>Note that the finite field groups (indicated by the FFDHE prefix) and DHE key
exchange methods are generally slower<a id="DOCF20" href="#FOOT20"><sup>20</sup></a> than their elliptic curves counterpart
(ECDHE). 
</p>
<p>The available special keywords are shown in <a href="#tab_003aprio_002dspecial1">Table 6.5</a>
and <a href="#tab_003aprio_002dspecial2">Table 6.6</a>. 
</p>
<div class="float"><span id="tab_003aprio_002dspecial1"></span>
<table>
<thead><tr><th width="45%">Keyword</th><th width="45%">Description</th></tr></thead>
<tr><td width="45%">%COMPAT</td><td width="45%">will enable compatibility mode. It might mean that violations
of the protocols are allowed as long as maximum compatibility with
problematic clients and servers is achieved. More specifically this
string will tolerate packets over the maximum allowed TLS record,
and add a padding to TLS Client Hello packet to prevent it being in the
256-512 range which is known to be causing issues with a commonly used
firewall (see the %DUMBFW option).</td></tr>
<tr><td width="45%">%DUMBFW</td><td width="45%">will add a private extension with bogus data that make the client
hello exceed 512 bytes. This avoids a black hole behavior in some
firewalls. This is the [<a href="#RFC7685">RFC7685</a>] client hello padding extension, also enabled
with %COMPAT.</td></tr>
<tr><td width="45%">%NO_EXTENSIONS</td><td width="45%">will prevent the sending of any TLS extensions in client side. Note
that TLS 1.2 requires extensions to be used, as well as safe
renegotiation thus this option must be used with care. When this option
is set no versions later than TLS1.2 can be negotiated.</td></tr>
<tr><td width="45%">%NO_TICKETS</td><td width="45%">will prevent the advertizing of the TLS session ticket extension.
This is implied by the PFS keyword.</td></tr>
<tr><td width="45%">%NO_SESSION_HASH</td><td width="45%">will prevent the advertizing the TLS extended master secret (session hash)
extension.</td></tr>
<tr><td width="45%">%SERVER_PRECEDENCE</td><td width="45%">The ciphersuite will be selected according to server priorities
and not the client&rsquo;s.</td></tr>
<tr><td width="45%">%SSL3_RECORD_VERSION</td><td width="45%">will use SSL3.0 record version in client hello.
By default GnuTLS will set the minimum supported version as the
client hello record version (do not confuse that version with the
proposed handshake version at the client hello).</td></tr>
<tr><td width="45%">%LATEST_RECORD_VERSION</td><td width="45%">will use the latest TLS version record version in client hello.</td></tr>
</table>

<div class="float-caption"><p><strong>Table 6.5: </strong>Special priority string keywords.</p></div></div>
<div class="float"><span id="tab_003aprio_002dspecial2"></span>
<table>
<thead><tr><th width="45%">Keyword</th><th width="45%">Description</th></tr></thead>
<tr><td width="45%">%STATELESS_COMPRESSION</td><td width="45%">ignored; no longer used.</td></tr>
<tr><td width="45%">%DISABLE_WILDCARDS</td><td width="45%">will disable matching wildcards when comparing hostnames
in certificates.</td></tr>
<tr><td width="45%">%NO_ETM</td><td width="45%">will disable the encrypt-then-mac TLS extension (RFC7366). This is
implied by the %COMPAT keyword.</td></tr>
<tr><td width="45%">%FORCE_ETM</td><td width="45%">negotiate CBC ciphersuites only when both sides of the connection support
encrypt-then-mac TLS extension (RFC7366).</td></tr>
<tr><td width="45%">%DISABLE_SAFE_RENEGOTIATION</td><td width="45%">will completely disable safe renegotiation
completely.  Do not use unless you know what you are doing.</td></tr>
<tr><td width="45%">%UNSAFE_RENEGOTIATION</td><td width="45%">will allow handshakes and re-handshakes
without the safe renegotiation extension.  Note that for clients
this mode is insecure (you may be under attack), and for servers it
will allow insecure clients to connect (which could be fooled by an
attacker).  Do not use unless you know what you are doing and want
maximum compatibility.</td></tr>
<tr><td width="45%">%PARTIAL_RENEGOTIATION</td><td width="45%">will allow initial handshakes to proceed,
but not re-handshakes.  This leaves the client vulnerable to attack,
and servers will be compatible with non-upgraded clients for
initial handshakes.  This is currently the default for clients and
servers, for compatibility reasons.</td></tr>
<tr><td width="45%">%SAFE_RENEGOTIATION</td><td width="45%">will enforce safe renegotiation.  Clients and
servers will refuse to talk to an insecure peer.  Currently this
causes interoperability problems, but is required for full protection.</td></tr>
<tr><td width="45%">%FALLBACK_SCSV</td><td width="45%">will enable the use of the fallback signaling cipher suite value in the
client hello.  Note that this should be set only by applications that
try to reconnect with a downgraded protocol version. See RFC7507 for
details.</td></tr>
<tr><td width="45%">%VERIFY_ALLOW_BROKEN</td><td width="45%">will allow signatures with known to be broken algorithms (such as MD5 or
SHA1) in certificate chains.</td></tr>
<tr><td width="45%">%VERIFY_ALLOW_SIGN_RSA_MD5</td><td width="45%">will allow RSA-MD5 signatures in certificate chains.</td></tr>
<tr><td width="45%">%VERIFY_ALLOW_SIGN_WITH_SHA1</td><td width="45%">will allow signatures with SHA1 hash algorithm in certificate chains.</td></tr>
<tr><td width="45%">%VERIFY_DISABLE_CRL_CHECKS</td><td width="45%">will disable CRL or OCSP checks in the verification of the certificate chain.</td></tr>
<tr><td width="45%">%VERIFY_ALLOW_X509_V1_CA_CRT</td><td width="45%">will allow V1 CAs in chains.</td></tr>
<tr><td width="45%">%PROFILE_(LOW|LEGACY|MEDIUM|HIGH|ULTRA|FUTURE)</td><td width="45%">require a certificate verification profile the corresponds to the specified
security level, see <a href="#tab_003akey_002dsizes">Table 6.7</a> for the mappings to values.</td></tr>
<tr><td width="45%">%PROFILE_(SUITEB128|SUITEB192)</td><td width="45%">require a certificate verification profile the corresponds to SUITEB. Note
that an initial keyword that enables SUITEB automatically sets the profile.</td></tr>
</table>

<div class="float-caption"><p><strong>Table 6.6: </strong>More priority string keywords.</p></div></div>
<p>Finally the ciphersuites enabled by any priority string can be
listed using the <code>gnutls-cli</code> application (see <a href="#gnutls_002dcli-Invocation">gnutls-cli Invocation</a>), 
or by using the priority functions as in <a href="#Listing-the-ciphersuites-in-a-priority-string">Listing the ciphersuites in a priority string</a>.
</p>
<p>Example priority strings are:
</p><div class="example">
<pre class="example">The system imposed security level:
    &quot;SYSTEM&quot;

The default priority without the HMAC-MD5:
    &quot;NORMAL:-MD5&quot;

Specifying RSA with AES-128-CBC:
    &quot;NONE:+VERS-TLS-ALL:+MAC-ALL:+RSA:+AES-128-CBC:+SIGN-ALL:+COMP-NULL&quot;

Specifying the defaults plus ARCFOUR-128:
    &quot;NORMAL:+ARCFOUR-128&quot;

Enabling the 128-bit secure ciphers, while disabling TLS 1.0:
    &quot;SECURE128:-VERS-TLS1.0&quot;

Enabling the 128-bit and 192-bit secure ciphers, while disabling all TLS versions 
except TLS 1.2:
    &quot;SECURE128:+SECURE192:-VERS-ALL:+VERS-TLS1.2&quot;
</pre></div>

<hr>
<span id="Selecting-cryptographic-key-sizes"></span><div class="header">
<p>
Next: <a href="#Advanced-topics" accesskey="n" rel="next">Advanced topics</a>, Previous: <a href="#Priority-Strings" accesskey="p" rel="prev">Priority Strings</a>, Up: <a href="#How-to-use-GnuTLS-in-applications" accesskey="u" rel="up">How to use GnuTLS in applications</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Selecting-cryptographic-key-sizes-1"></span><h3 class="section">6.11 Selecting cryptographic key sizes</h3>
<span id="index-key-sizes"></span>

<p>Because many algorithms are involved in TLS, it is not easy to set
a consistent security level.  For this reason in <a href="#tab_003akey_002dsizes">Table 6.7</a> we
present some correspondence between key sizes of symmetric algorithms
and public key algorithms based on [<a href="#ECRYPT">ECRYPT</a>]. 
Those can be used to generate certificates with
appropriate key sizes as well as select parameters for Diffie-Hellman and SRP
authentication.
</p>
<div class="float"><span id="tab_003akey_002dsizes"></span>
<table>
<thead><tr><th width="10%">Security bits</th><th width="12%">RSA, DH and SRP parameter size</th><th width="10%">ECC key size</th><th width="20%">Security parameter (profile)</th><th width="32%">Description</th></tr></thead>
<tr><td width="10%">&lt;64</td><td width="12%">&lt;768</td><td width="10%">&lt;128</td><td width="20%"><code>INSECURE</code></td><td width="32%">Considered to be insecure</td></tr>
<tr><td width="10%">64</td><td width="12%">768</td><td width="10%">128</td><td width="20%"><code>VERY WEAK</code></td><td width="32%">Short term protection against individuals</td></tr>
<tr><td width="10%">72</td><td width="12%">1008</td><td width="10%">160</td><td width="20%"><code>WEAK</code></td><td width="32%">Short term protection against small organizations</td></tr>
<tr><td width="10%">80</td><td width="12%">1024</td><td width="10%">160</td><td width="20%"><code>LOW</code></td><td width="32%">Very short term protection against agencies (corresponds to ENISA legacy level)</td></tr>
<tr><td width="10%">96</td><td width="12%">1776</td><td width="10%">192</td><td width="20%"><code>LEGACY</code></td><td width="32%">Legacy standard level</td></tr>
<tr><td width="10%">112</td><td width="12%">2048</td><td width="10%">224</td><td width="20%"><code>MEDIUM</code></td><td width="32%">Medium-term protection</td></tr>
<tr><td width="10%">128</td><td width="12%">3072</td><td width="10%">256</td><td width="20%"><code>HIGH</code></td><td width="32%">Long term protection (corresponds to ENISA future level)</td></tr>
<tr><td width="10%">192</td><td width="12%">8192</td><td width="10%">384</td><td width="20%"><code>ULTRA</code></td><td width="32%">Even longer term protection</td></tr>
<tr><td width="10%">256</td><td width="12%">15424</td><td width="10%">512</td><td width="20%"><code>FUTURE</code></td><td width="32%">Foreseeable future</td></tr>
</table>

<div class="float-caption"><p><strong>Table 6.7: </strong>Key sizes and security parameters.</p></div></div>
<p>The first column  provides a security parameter in a number of bits. This
gives an indication of the number of combinations to be tried by an adversary
to brute force a key. For example to test all possible keys in a 112 bit security parameter
<em>2^{112}</em> combinations have to be tried. For today&rsquo;s technology this is infeasible.
The next two columns correlate the security
parameter with actual bit sizes of parameters for DH, RSA, SRP and ECC algorithms.
A mapping to <code>gnutls_sec_param_t</code> value is given for each security parameter, on
the next column, and finally a brief description of the level.
</p>

<p>Note, however, that the values suggested here are nothing more than an
educated guess that is valid today. There are no guarantees that an
algorithm will remain unbreakable or that these values will remain
constant in time. There could be scientific breakthroughs that cannot
be predicted or total failure of the current public key systems by
quantum computers. On the other hand though the cryptosystems used in
TLS are selected in a conservative way and such catastrophic
breakthroughs or failures are believed to be unlikely.
The NIST publication SP 800-57 [<a href="#NISTSP80057">NISTSP80057</a>] contains a similar
table.
</p>
<p>When using <acronym>GnuTLS</acronym> and a decision on bit sizes for a public
key algorithm is required, use of the following functions is  
recommended:
</p>




<dl>
<dt id="index-gnutls_005fsec_005fparam_005fto_005fpk_005fbits">Function: <em>unsigned int</em> <strong>gnutls_sec_param_to_pk_bits</strong> <em>(gnutls_pk_algorithm_t <var>algo</var>, gnutls_sec_param_t <var>param</var>)</em></dt>
<dd><p><var>algo</var>: is a public key algorithm
</p>
<p><var>param</var>: is a security parameter
</p>
<p>When generating private and public key pairs a difficult question
is which size of &quot;bits&quot; the modulus will be in RSA and the group size
in DSA. The easy answer is 1024, which is also wrong. This function
will convert a human understandable security parameter to an
appropriate size for the specific algorithm.
</p>
<p><strong>Returns:</strong> The number of bits, or (0).
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>





<dl>
<dt id="index-gnutls_005fpk_005fbits_005fto_005fsec_005fparam">Function: <em>gnutls_sec_param_t</em> <strong>gnutls_pk_bits_to_sec_param</strong> <em>(gnutls_pk_algorithm_t <var>algo</var>, unsigned int <var>bits</var>)</em></dt>
<dd><p><var>algo</var>: is a public key algorithm
</p>
<p><var>bits</var>: is the number of bits
</p>
<p>This is the inverse of <code>gnutls_sec_param_to_pk_bits()</code> . Given an algorithm
and the number of bits, it will return the security parameter. This is
a rough indication.
</p>
<p><strong>Returns:</strong> The security parameter.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<p>Those functions will convert a human understandable security parameter
of <code>gnutls_sec_param_t</code> type, to a number of bits suitable for a public 
key algorithm.
</p>
<dl compact="compact">
<dt><code><var>const char *</var> <a href="#gnutls_005fsec_005fparam_005fget_005fname">gnutls_sec_param_get_name</a> (gnutls_sec_param_t <var>param</var>)</code></dt>
</dl>

<p>The following functions will set the minimum acceptable group size for Diffie-Hellman
and SRP authentication. 
</p><dl compact="compact">
<dt><code><var>void</var> <a href="#gnutls_005fdh_005fset_005fprime_005fbits">gnutls_dh_set_prime_bits</a> (gnutls_session_t <var>session</var>, unsigned int <var>bits</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005fsrp_005fset_005fprime_005fbits">gnutls_srp_set_prime_bits</a> (gnutls_session_t <var>session</var>, unsigned int <var>bits</var>)</code></dt>
</dl>


<hr>
<span id="Advanced-topics"></span><div class="header">
<p>
Previous: <a href="#Selecting-cryptographic-key-sizes" accesskey="p" rel="prev">Selecting cryptographic key sizes</a>, Up: <a href="#How-to-use-GnuTLS-in-applications" accesskey="u" rel="up">How to use GnuTLS in applications</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Advanced-topics-1"></span><h3 class="section">6.12 Advanced topics</h3>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Virtual-hosts-and-credentials" accesskey="1">Virtual hosts and credentials</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Session-resumption" accesskey="2">Session resumption</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Certificate-verification" accesskey="3">Certificate verification</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#TLS-1_002e2-re_002dauthentication" accesskey="4">TLS 1.2 re-authentication</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#TLS-1_002e3-re_002dauthentication-and-re_002dkey" accesskey="5">TLS 1.3 re-authentication and re-key</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Parameter-generation" accesskey="6">Parameter generation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Deriving-keys-for-other-applications_002fprotocols" accesskey="7">Deriving keys for other applications/protocols</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Channel-Bindings" accesskey="8">Channel Bindings</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Interoperability" accesskey="9">Interoperability</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Compatibility-with-the-OpenSSL-library">Compatibility with the OpenSSL library</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Virtual-hosts-and-credentials"></span><div class="header">
<p>
Next: <a href="#Session-resumption" accesskey="n" rel="next">Session resumption</a>, Up: <a href="#Advanced-topics" accesskey="u" rel="up">Advanced topics</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Virtual-hosts-and-credentials-1"></span><h4 class="subsection">6.12.1 Virtual hosts and credentials</h4>
<span id="index-virtual-hosts"></span>
<span id="index-credentials"></span>

<p>Often when operating with virtual hosts, one may not want to associate
a particular certificate set to the credentials function early, before
the virtual host is known. That can be achieved by calling
<a href="#gnutls_005fcredentials_005fset">gnutls_credentials_set</a> within a handshake pre-hook for client
hello. That message contains the peer&rsquo;s intended hostname, and if read,
and the appropriate credentials are set, gnutls will be able to
continue in the handshake process. A brief usage example is shown
below.
</p>
<div class="example">
<pre class="example">static int ext_hook_func(void *ctx, unsigned tls_id,
                         const unsigned char *data, unsigned size)
{
	if (tls_id == 0) { /* server name */
		/* figure the advertized name - the following hack
                 * relies on the fact that this extension only supports
                 * DNS names, and due to a protocol bug cannot be extended
                 * to support anything else. */
		if (name &lt; 5) return 0;
		name = data+5;
		name_size = size-5;
	}
	return 0;
}

static int
handshake_hook_func(gnutls_session_t session, unsigned int htype,
                    unsigned when, unsigned int incoming, const gnutls_datum_t *msg)
{
    int ret;

    assert(htype == GNUTLS_HANDSHAKE_CLIENT_HELLO);
    assert(when == GNUTLS_HOOK_PRE);

    ret = gnutls_ext_raw_parse(NULL, ext_hook_func, msg,
                               GNUTLS_EXT_RAW_FLAG_TLS_CLIENT_HELLO);
    assert(ret &gt;= 0);

    gnutls_credentials_set(session, GNUTLS_CRD_CERTIFICATE, cred);

    return ret;
}

int main()
{
  ...

  gnutls_handshake_set_hook_function(server, GNUTLS_HANDSHAKE_CLIENT_HELLO,
                                     GNUTLS_HOOK_PRE, handshake_hook_func);
  ...
}
</pre></div>





<dl>
<dt id="index-gnutls_005fhandshake_005fset_005fhook_005ffunction">Function: <em>void</em> <strong>gnutls_handshake_set_hook_function</strong> <em>(gnutls_session_t <var>session</var>, unsigned int <var>htype</var>, int <var>when</var>, gnutls_handshake_hook_func <var>func</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type
</p>
<p><var>htype</var>: the <code>gnutls_handshake_description_t</code>  of the message to hook at
</p>
<p><var>when</var>: <code>GNUTLS_HOOK_</code> * depending on when the hook function should be called
</p>
<p><var>func</var>: is the function to be called
</p>
<p>This function will set a callback to be called after or before the specified
handshake message has been received or generated. This is a
generalization of <code>gnutls_handshake_set_post_client_hello_function()</code> .
</p>
<p>To call the hook function prior to the message being generated or processed
use <code>GNUTLS_HOOK_PRE</code>  as  <code>when</code> parameter, <code>GNUTLS_HOOK_POST</code>  to call
after, and <code>GNUTLS_HOOK_BOTH</code>  for both cases.
</p>
<p>This callback must return 0 on success or a gnutls error code to
terminate the handshake.
</p>
<p>To hook at all handshake messages use an  <code>htype</code> of <code>GNUTLS_HANDSHAKE_ANY</code> .
</p>
<p><strong>Warning:</strong> You should not use this function to terminate the
handshake based on client input unless you know what you are
doing. Before the handshake is finished there is no way to know if
there is a man-in-the-middle attack being performed.
</p></dd></dl>

<hr>
<span id="Session-resumption"></span><div class="header">
<p>
Next: <a href="#Certificate-verification" accesskey="n" rel="next">Certificate verification</a>, Previous: <a href="#Virtual-hosts-and-credentials" accesskey="p" rel="prev">Virtual hosts and credentials</a>, Up: <a href="#Advanced-topics" accesskey="u" rel="up">Advanced topics</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Session-resumption-1"></span><h4 class="subsection">6.12.2 Session resumption</h4>
<span id="index-resuming-sessions-1"></span>
<span id="index-session-resumption-1"></span>

<p>To reduce time and network traffic spent in a handshake the client can
request session resumption from a server that previously shared a
session with the client.
</p>
<p>Under TLS 1.2, in order to support resumption a server can either store
the session security parameters in a local database or use session
tickets (see <a href="#Session-tickets">Session tickets</a>) to delegate storage to the client.
</p>
<p>Under TLS 1.3, session resumption is only available through session
tickets, and multiple tickets could be sent from server to client. That
provides the following advantages:
</p><ul>
<li> When tickets are not re-used the subsequent client sessions cannot be associated with each other by an eavesdropper
</li><li> On post-handshake authentication the server may send different tickets asynchronously for each identity used by client.
</li></ul>

<span id="Client-side-1"></span><h4 class="subsubheading">Client side</h4>

<p>The client has to retrieve and store the session parameters. Before
establishing a new session to the same server the parameters must be
re-associated with the GnuTLS session using
<a href="#gnutls_005fsession_005fset_005fdata">gnutls_session_set_data</a>.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fsession_005fget_005fdata2">gnutls_session_get_data2</a> (gnutls_session_t <var>session</var>, gnutls_datum_t * <var>data</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fsession_005fset_005fdata">gnutls_session_set_data</a> (gnutls_session_t <var>session</var>, const void * <var>session_data</var>, size_t <var>session_data_size</var>)</code></dt>
</dl>

<p>Keep in mind that sessions will be expired after some time, depending
on the server, and a server may choose not to resume a session
even when requested to.  The expiration is to prevent temporal session keys
from becoming long-term keys. Also note that as a client you must enable, 
using the priority functions, at least the algorithms used in the last session.
</p>




<dl>
<dt id="index-gnutls_005fsession_005fis_005fresumed">Function: <em>int</em> <strong>gnutls_session_is_resumed</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Checks whether session is resumed or not. This is functional
for both server and client side.
</p>
<p><strong>Returns:</strong> non zero if this session is resumed, or a zero if this is
a new session.
</p></dd></dl>





<dl>
<dt id="index-gnutls_005fsession_005fget_005fid2">Function: <em>int</em> <strong>gnutls_session_get_id2</strong> <em>(gnutls_session_t <var>session</var>, gnutls_datum_t * <var>session_id</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>session_id</var>: will point to the session ID.
</p>
<p>Returns the TLS session identifier. The session ID is selected by the
server, and in older versions of TLS was a unique identifier shared
between client and server which was persistent across resumption.
In the latest version of TLS (1.3) or TLS 1.2 with session tickets, the
notion of session identifiers is undefined and cannot be relied for uniquely
identifying sessions across client and server.
</p>
<p>In client side this function returns the identifier returned by the
server, and cannot be assumed to have any relation to session resumption.
In server side this function is guaranteed to return a persistent
identifier of the session since GnuTLS 3.6.4, which may not necessarily
map into the TLS session ID value. Prior to that version the value
could only be considered a persistent identifier, under TLS1.2 or earlier
and when no session tickets were in use.
</p>
<p>The session identifier value returned is always less than
<code>GNUTLS_MAX_SESSION_ID_SIZE</code>  and should be treated as constant.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p>
<p><strong>Since:</strong> 3.1.4
</p></dd></dl>

<span id="Server-side-1"></span><h4 class="subsubheading">Server side</h4>

<p>A server enabling both session tickets and a storage for session data
would use session tickets when clients support it and the storage otherwise.
</p>
<p>A storing server needs to specify callback functions to store, retrieve and delete session data. These can be
registered with the functions below. The stored sessions in the database can be checked using <a href="#gnutls_005fdb_005fcheck_005fentry">gnutls_db_check_entry</a>
for expiration.
</p>
<dl compact="compact">
<dt><code><var>void</var> <a href="#gnutls_005fdb_005fset_005fretrieve_005ffunction">gnutls_db_set_retrieve_function</a> (gnutls_session_t <var>session</var>, gnutls_db_retr_func <var>retr_func</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005fdb_005fset_005fstore_005ffunction">gnutls_db_set_store_function</a> (gnutls_session_t <var>session</var>, gnutls_db_store_func <var>store_func</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005fdb_005fset_005fptr">gnutls_db_set_ptr</a> (gnutls_session_t <var>session</var>, void * <var>ptr</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005fdb_005fset_005fremove_005ffunction">gnutls_db_set_remove_function</a> (gnutls_session_t <var>session</var>, gnutls_db_remove_func <var>rem_func</var>)</code></dt>
</dl>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fdb_005fcheck_005fentry">gnutls_db_check_entry</a> (gnutls_session_t <var>session</var>, gnutls_datum_t <var>session_entry</var>)</code></dt>
</dl>

<p>A server supporting session tickets must generate ticket encryption
and authentication keys using <a href="#gnutls_005fsession_005fticket_005fkey_005fgenerate">gnutls_session_ticket_key_generate</a>.
Those keys should be associated with the GnuTLS session using
<a href="#gnutls_005fsession_005fticket_005fenable_005fserver">gnutls_session_ticket_enable_server</a>.
</p>
<p>Those will be the initial keys, but GnuTLS will rotate them regularly. The key rotation interval
can be changed with <a href="#gnutls_005fdb_005fset_005fcache_005fexpiration">gnutls_db_set_cache_expiration</a> and will be set to
three times the ticket expiration time (ie. three times the value given in that function).
Every such interval, new keys will be generated from those initial keys. This is a necessary mechanism
to prevent the keys from becoming long-term keys
and as such preserve forward-secrecy in the issued session tickets. If no explicit key rotation interval
is provided, GnuTLS will rotate them every 18 hours by default.
</p>
<p>The master key can be shared between processes or between systems. Processes which share the same master key
will generate the same rotated subkeys, assuming they share the same time (irrespective of timezone differences).
</p>




<dl>
<dt id="index-gnutls_005fsession_005fticket_005fenable_005fserver">Function: <em>int</em> <strong>gnutls_session_ticket_enable_server</strong> <em>(gnutls_session_t <var>session</var>, const gnutls_datum_t * <var>key</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>key</var>: key to encrypt session parameters.
</p>
<p>Request that the server should attempt session resumption using
session tickets, i.e., by delegating storage to the client.
 <code>key</code> must be initialized using <code>gnutls_session_ticket_key_generate()</code> .
To avoid leaking that key, use <code>gnutls_memset()</code>  prior to
releasing it.
</p>
<p>The default ticket expiration time can be overridden using
<code>gnutls_db_set_cache_expiration()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, or an
error code.
</p>
<p><strong>Since:</strong> 2.10.0
</p></dd></dl>




<dl>
<dt id="index-gnutls_005fsession_005fticket_005fkey_005fgenerate">Function: <em>int</em> <strong>gnutls_session_ticket_key_generate</strong> <em>(gnutls_datum_t * <var>key</var>)</em></dt>
<dd><p><var>key</var>: is a pointer to a <code>gnutls_datum_t</code>  which will contain a newly
created key.
</p>
<p>Generate a random key to encrypt security parameters within
SessionTicket.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, or an
error code.
</p>
<p><strong>Since:</strong> 2.10.0
</p></dd></dl>




<dl>
<dt id="index-gnutls_005fsession_005fresumption_005frequested">Function: <em>int</em> <strong>gnutls_session_resumption_requested</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Check whether the client has asked for session resumption.
This function is valid only on server side.
</p>
<p><strong>Returns:</strong> non zero if session resumption was asked, or a zero if not.
</p></dd></dl>

<p>The expiration time for session resumption, either in tickets or stored data
is set using <a href="#gnutls_005fdb_005fset_005fcache_005fexpiration">gnutls_db_set_cache_expiration</a>. This function also controls
the ticket key rotation period. Currently, the session key rotation interval is set
to 3 times the expiration time set by this function.
</p>
<p>Under TLS 1.3, the server sends by default 2 tickets, and can send
additional session tickets at any time using <a href="#gnutls_005fsession_005fticket_005fsend">gnutls_session_ticket_send</a>.
</p>




<dl>
<dt id="index-gnutls_005fsession_005fticket_005fsend">Function: <em>int</em> <strong>gnutls_session_ticket_send</strong> <em>(gnutls_session_t <var>session</var>, unsigned <var>nr</var>, unsigned <var>flags</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>nr</var>: the number of tickets to send
</p>
<p><var>flags</var>: must be zero
</p>
<p>Sends a fresh session ticket to the peer. This is relevant only
in server side under TLS1.3. This function may also return <code>GNUTLS_E_AGAIN</code> 
or <code>GNUTLS_E_INTERRUPTED</code>  and in that case it must be called again.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, or a negative error code.
</p></dd></dl>

<hr>
<span id="Certificate-verification"></span><div class="header">
<p>
Next: <a href="#TLS-1_002e2-re_002dauthentication" accesskey="n" rel="next">TLS 1.2 re-authentication</a>, Previous: <a href="#Session-resumption" accesskey="p" rel="prev">Session resumption</a>, Up: <a href="#Advanced-topics" accesskey="u" rel="up">Advanced topics</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Certificate-verification-1"></span><h4 class="subsection">6.12.3 Certificate verification</h4>
<span id="index-DANE-1"></span>
<span id="index-DNSSEC-1"></span>
<span id="index-SSH_002dstyle-authentication-1"></span>
<span id="index-Trust-on-first-use-1"></span>
<span id="index-Key-pinning-1"></span>
<span id="index-gnutls_005fcertificate_005fverify_005fflags-1"></span>

<p>In this section the functionality for additional certificate verification methods is listed. 
These methods are intended to be used in addition to normal PKI verification, in order to reduce 
the risk of a compromised CA being undetected.
</p>
<span id="Trust-on-first-use"></span><h4 class="subsubsection">6.12.3.1 Trust on first use</h4>

<p>The GnuTLS library includes functionality to use an SSH-like trust on first use authentication.
The available functions to store and verify public keys are listed below.
</p>




<dl>
<dt id="index-gnutls_005fverify_005fstored_005fpubkey">Function: <em>int</em> <strong>gnutls_verify_stored_pubkey</strong> <em>(const char * <var>db_name</var>, gnutls_tdb_t <var>tdb</var>, const char * <var>host</var>, const char * <var>service</var>, gnutls_certificate_type_t <var>cert_type</var>, const gnutls_datum_t * <var>cert</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>db_name</var>: A file specifying the stored keys (use NULL for the default)
</p>
<p><var>tdb</var>: A storage structure or NULL to use the default
</p>
<p><var>host</var>: The peer&rsquo;s name
</p>
<p><var>service</var>: non-NULL if this key is specific to a service (e.g. http)
</p>
<p><var>cert_type</var>: The type of the certificate
</p>
<p><var>cert</var>: The raw (der) data of the certificate
</p>
<p><var>flags</var>: should be 0.
</p>
<p>This function will try to verify a raw public-key or a public-key provided via
a raw (DER-encoded) certificate using a list of stored public keys.
The  <code>service</code> field if non-NULL should be a port number.
</p>
<p>The  <code>db_name</code> variable if non-null specifies a custom backend for
the retrieval of entries. If it is NULL then the
default file backend will be used. In POSIX-like systems the
file backend uses the $HOME/.gnutls/known_hosts file.
</p>
<p>Note that if the custom storage backend is provided the
retrieval function should return <code>GNUTLS_E_CERTIFICATE_KEY_MISMATCH</code> 
if the host/service pair is found but key doesn&rsquo;t match,
<code>GNUTLS_E_NO_CERTIFICATE_FOUND</code>  if no such host/service with
the given key is found, and 0 if it was found. The storage
function should return 0 on success.
</p>
<p>As of GnuTLS 3.6.6 this function also verifies raw public keys.
</p>
<p><strong>Returns:</strong> If no associated public key is found
then <code>GNUTLS_E_NO_CERTIFICATE_FOUND</code>  will be returned. If a key
is found but does not match <code>GNUTLS_E_CERTIFICATE_KEY_MISMATCH</code> 
is returned. On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
or a negative error value on other errors.
</p>
<p><strong>Since:</strong> 3.0.13
</p></dd></dl>




<dl>
<dt id="index-gnutls_005fstore_005fpubkey">Function: <em>int</em> <strong>gnutls_store_pubkey</strong> <em>(const char * <var>db_name</var>, gnutls_tdb_t <var>tdb</var>, const char * <var>host</var>, const char * <var>service</var>, gnutls_certificate_type_t <var>cert_type</var>, const gnutls_datum_t * <var>cert</var>, time_t <var>expiration</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>db_name</var>: A file specifying the stored keys (use NULL for the default)
</p>
<p><var>tdb</var>: A storage structure or NULL to use the default
</p>
<p><var>host</var>: The peer&rsquo;s name
</p>
<p><var>service</var>: non-NULL if this key is specific to a service (e.g. http)
</p>
<p><var>cert_type</var>: The type of the certificate
</p>
<p><var>cert</var>: The data of the certificate
</p>
<p><var>expiration</var>: The expiration time (use 0 to disable expiration)
</p>
<p><var>flags</var>: should be 0.
</p>
<p>This function will store a raw public-key or a public-key provided via
a raw (DER-encoded) certificate to the list of stored public keys. The key
will be considered valid until the provided expiration time.
</p>
<p>The  <code>tdb</code> variable if non-null specifies a custom backend for
the storage of entries. If it is NULL then the
default file backend will be used.
</p>
<p>Unless an alternative  <code>tdb</code> is provided, the storage format is a textual format
consisting of a line for each host with fields separated by &rsquo;|&rsquo;. The contents of
the fields are a format-identifier which is set to &rsquo;g0&rsquo;, the hostname that the
rest of the data applies to, the numeric port or host name, the expiration
time in seconds since the epoch (0 for no expiration), and a base64
encoding of the raw (DER) public key information (SPKI) of the peer.
</p>
<p>As of GnuTLS 3.6.6 this function also accepts raw public keys.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.0.13
</p></dd></dl>

<p>In addition to the above the <a href="#gnutls_005fstore_005fcommitment">gnutls_store_commitment</a> can be 
used to implement a key-pinning architecture as in [<a href="#KEYPIN">KEYPIN</a>]. 
This provides a way for web server to commit on a public key that is
not yet active.
</p>




<dl>
<dt id="index-gnutls_005fstore_005fcommitment">Function: <em>int</em> <strong>gnutls_store_commitment</strong> <em>(const char * <var>db_name</var>, gnutls_tdb_t <var>tdb</var>, const char * <var>host</var>, const char * <var>service</var>, gnutls_digest_algorithm_t <var>hash_algo</var>, const gnutls_datum_t * <var>hash</var>, time_t <var>expiration</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>db_name</var>: A file specifying the stored keys (use NULL for the default)
</p>
<p><var>tdb</var>: A storage structure or NULL to use the default
</p>
<p><var>host</var>: The peer&rsquo;s name
</p>
<p><var>service</var>: non-NULL if this key is specific to a service (e.g. http)
</p>
<p><var>hash_algo</var>: The hash algorithm type
</p>
<p><var>hash</var>: The raw hash
</p>
<p><var>expiration</var>: The expiration time (use 0 to disable expiration)
</p>
<p><var>flags</var>: should be 0 or <code>GNUTLS_SCOMMIT_FLAG_ALLOW_BROKEN</code> .
</p>
<p>This function will store the provided hash commitment to
the list of stored public keys. The key with the given
hash will be considered valid until the provided expiration time.
</p>
<p>The  <code>tdb</code> variable if non-null specifies a custom backend for
the storage of entries. If it is NULL then the
default file backend will be used.
</p>
<p>Note that this function is not thread safe with the default backend.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<p>The storage and verification functions may be used with the default
text file based back-end, or another back-end may be specified. That
should contain storage and retrieval functions and specified as below.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005ftdb_005finit">gnutls_tdb_init</a> (gnutls_tdb_t * <var>tdb</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005ftdb_005fdeinit">gnutls_tdb_deinit</a> (gnutls_tdb_t <var>tdb</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005ftdb_005fset_005fverify_005ffunc">gnutls_tdb_set_verify_func</a> (gnutls_tdb_t <var>tdb</var>, gnutls_tdb_verify_func <var>verify</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005ftdb_005fset_005fstore_005ffunc">gnutls_tdb_set_store_func</a> (gnutls_tdb_t <var>tdb</var>, gnutls_tdb_store_func <var>store</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005ftdb_005fset_005fstore_005fcommitment_005ffunc">gnutls_tdb_set_store_commitment_func</a> (gnutls_tdb_t <var>tdb</var>, gnutls_tdb_store_commitment_func        <var>cstore</var>)</code></dt>
</dl>

<span id="DANE-verification"></span><h4 class="subsubsection">6.12.3.2 DANE verification</h4>
<p>Since the DANE library is not included in GnuTLS it requires programs
to be linked against it. This can be achieved with the following commands.
</p>
<div class="example">
<pre class="example">gcc -o foo foo.c `pkg-config gnutls-dane --cflags --libs`
</pre></div>

<p>When a program uses the GNU autoconf system, then the following
line or similar can be used to detect the presence of the library.
</p>
<div class="example">
<pre class="example">PKG_CHECK_MODULES([LIBDANE], [gnutls-dane &gt;= 3.0.0])

AC_SUBST([LIBDANE_CFLAGS])
AC_SUBST([LIBDANE_LIBS])
</pre></div>

<p>The high level functionality provided by the DANE library is shown below.
</p>




<dl>
<dt id="index-dane_005fverify_005fcrt">Function: <em>int</em> <strong>dane_verify_crt</strong> <em>(dane_state_t <var>s</var>, const gnutls_datum_t * <var>chain</var>, unsigned <var>chain_size</var>, gnutls_certificate_type_t <var>chain_type</var>, const char * <var>hostname</var>, const char * <var>proto</var>, unsigned int <var>port</var>, unsigned int <var>sflags</var>, unsigned int <var>vflags</var>, unsigned int * <var>verify</var>)</em></dt>
<dd><p><var>s</var>: A DANE state structure (may be NULL)
</p>
<p><var>chain</var>: A certificate chain
</p>
<p><var>chain_size</var>: The size of the chain
</p>
<p><var>chain_type</var>: The type of the certificate chain
</p>
<p><var>hostname</var>: The hostname associated with the chain
</p>
<p><var>proto</var>: The protocol of the service connecting (e.g. tcp)
</p>
<p><var>port</var>: The port of the service connecting (e.g. 443)
</p>
<p><var>sflags</var>: Flags for the initialization of  <code>s</code> (if NULL)
</p>
<p><var>vflags</var>: Verification flags; an OR&rsquo;ed list of <code>dane_verify_flags_t</code> .
</p>
<p><var>verify</var>: An OR&rsquo;ed list of <code>dane_verify_status_t</code> .
</p>
<p>This function will verify the given certificate chain against the
CA constrains and/or the certificate available via DANE.
If no information via DANE can be obtained the flag <code>DANE_VERIFY_NO_DANE_INFO</code> 
is set. If a DNSSEC signature is not available for the DANE
record then the verify flag <code>DANE_VERIFY_NO_DNSSEC_DATA</code>  is set.
</p>
<p>Due to the many possible options of DANE, there is no single threat
model countered. When notifying the user about DANE verification results
it may be better to mention: DANE verification did not reject the certificate,
rather than mentioning a successful DANE verication.
</p>
<p>Note that this function is designed to be run in addition to
PKIX - certificate chain - verification. To be run independently
the <code>DANE_VFLAG_ONLY_CHECK_EE_USAGE</code>  flag should be specified;
then the function will check whether the key of the peer matches the
key advertized in the DANE entry.
</p>
<p><strong>Returns:</strong> a negative error code on error and <code>DANE_E_SUCCESS</code>  (0)
when the DANE entries were successfully parsed, irrespective of
whether they were verified (see  <code>verify</code> for that information). If
no usable entries were encountered <code>DANE_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
will be returned.
</p></dd></dl>

<dl compact="compact">
<dt><code><var>int</var> <a href="#dane_005fverify_005fsession_005fcrt">dane_verify_session_crt</a> (dane_state_t <var>s</var>, gnutls_session_t <var>session</var>, const char * <var>hostname</var>, const char * <var>proto</var>, unsigned int <var>port</var>, unsigned int <var>sflags</var>, unsigned int <var>vflags</var>, unsigned int * <var>verify</var>)</code></dt>
<dt><code><var>const char *</var> <a href="#dane_005fstrerror">dane_strerror</a> (int <var>error</var>)</code></dt>
</dl>

<p>Note that the <code>dane_state_t</code> structure that is accepted by both
verification functions is optional. It is required when many queries
are performed to optimize against multiple re-initializations of the
resolving back-end and loading of DNSSEC keys.
</p>
<p>The following flags are returned by the verify functions to
indicate the status of the verification.
</p>
<div class="float"><span id="dane_005fverify_005fstatus_005ft"></span>


<dl compact="compact">
<dt><code>DANE_VERIFY_CA_CONSTRAINTS_VIOLATED</code></dt>
<dd><p>The CA constraints were violated.
</p></dd>
<dt><code>DANE_VERIFY_CERT_DIFFERS</code></dt>
<dd><p>The certificate obtained via DNS differs.
</p></dd>
<dt><code>DANE_VERIFY_UNKNOWN_DANE_INFO</code></dt>
<dd><p>No known DANE data was found in the DNS record.
</p></dd>
</dl>

<div class="float-caption"><p><strong>Figure 6.3: </strong>The DANE verification status flags.</p></div></div>
<p>In order to generate a DANE TLSA entry to use in a DNS server 
you may use danetool (see <a href="#danetool-Invocation">danetool Invocation</a>).
</p>


<hr>
<span id="TLS-1_002e2-re_002dauthentication"></span><div class="header">
<p>
Next: <a href="#TLS-1_002e3-re_002dauthentication-and-re_002dkey" accesskey="n" rel="next">TLS 1.3 re-authentication and re-key</a>, Previous: <a href="#Certificate-verification" accesskey="p" rel="prev">Certificate verification</a>, Up: <a href="#Advanced-topics" accesskey="u" rel="up">Advanced topics</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="TLS-1_002e2-re_002dauthentication-1"></span><h4 class="subsection">6.12.4 TLS 1.2 re-authentication</h4>
<span id="index-re_002dnegotiation"></span>
<span id="index-re_002dauthentication"></span>

<p>In TLS 1.2 or earlier there is no distinction between re-key, re-authentication, and re-negotiation.
All of these use cases are handled by the TLS&rsquo; rehandshake process. For that reason
in GnuTLS rehandshake is not transparent to the application, and the application
must explicitly take control of that process. In addition GnuTLS since version 3.5.0 will not
allow the peer to switch identities during a rehandshake.
The threat addressed by that behavior depends on the application protocol,
but primarily it protects applications from being misled
by a rehandshake which switches the peer&rsquo;s identity. Applications can
disable this protection by using the <code>GNUTLS_ALLOW_ID_CHANGE</code> flag in
<a href="#gnutls_005finit">gnutls_init</a>.
</p>
<p>The following paragraphs explain how to safely use the rehandshake process.
</p>
<span id="Client-side"></span><h4 class="subsubsection">6.12.4.1 Client side</h4>

<p>According to the TLS specification a client may initiate a rehandshake at any
time. That can be achieved by calling <a href="#gnutls_005fhandshake">gnutls_handshake</a> and rely on its
return value for the outcome of the handshake (the server may deny a rehandshake).
If a server requests a re-handshake, then a call to <a href="#gnutls_005frecord_005frecv">gnutls_record_recv</a> will
return GNUTLS_E_REHANDSHAKE in the client, instructing it to call <a href="#gnutls_005fhandshake">gnutls_handshake</a>.
To deny a rehandshake request by the server it is recommended to send a warning alert
of type GNUTLS_A_NO_RENEGOTIATION.
</p>
<p>Due to limitations of early protocol versions, it is required to check whether
safe renegotiation is in place, i.e., using <a href="#gnutls_005fsafe_005frenegotiation_005fstatus">gnutls_safe_renegotiation_status</a>,
which ensures that the server remains the same as the initial.
</p>
<p>To make re-authentication transparent to the application when requested
by the server, use the <code>GNUTLS_AUTO_REAUTH</code> flag on the
<a href="#gnutls_005finit">gnutls_init</a> call. In that case the re-authentication will happen
in the call of <a href="#gnutls_005frecord_005frecv">gnutls_record_recv</a> that received the
reauthentication request.
</p>




<dl>
<dt id="index-gnutls_005fsafe_005frenegotiation_005fstatus">Function: <em>unsigned</em> <strong>gnutls_safe_renegotiation_status</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Can be used to check whether safe renegotiation is being used
in the current session.
</p>
<p><strong>Returns:</strong> 0 when safe renegotiation is not used and non (0) when
safe renegotiation is used.
</p>
<p><strong>Since:</strong> 2.10.0
</p></dd></dl>

<span id="Server-side"></span><h4 class="subsubsection">6.12.4.2 Server side</h4>

<p>A server which wants to instruct the client to re-authenticate, should call
<a href="#gnutls_005frehandshake">gnutls_rehandshake</a> and wait for the client to re-authenticate.
It is recommended to only request re-handshake when safe renegotiation is
enabled for that session (see <a href="#gnutls_005fsafe_005frenegotiation_005fstatus">gnutls_safe_renegotiation_status</a> and
the discussion in <a href="#Safe-renegotiation">Safe renegotiation</a>). A server could also encounter
the GNUTLS_E_REHANDSHAKE error code while receiving data. That indicates
a client-initiated re-handshake request. In that case the server could
ignore that request, perform handshake (unsafe when done generally), or
even drop the connection.
</p>




<dl>
<dt id="index-gnutls_005frehandshake">Function: <em>int</em> <strong>gnutls_rehandshake</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>This function can only be called in server side, and
instructs a TLS 1.2 or earlier client to renegotiate
parameters (perform a handshake), by sending a 
hello request message.
</p>
<p>If this function succeeds, the calling application
should call <code>gnutls_record_recv()</code>  until <code>GNUTLS_E_REHANDSHAKE</code> 
is returned to clear any pending data. If the <code>GNUTLS_E_REHANDSHAKE</code> 
error code is not seen, then the handshake request was
not followed by the peer (the TLS protocol does not require
the client to do, and such compliance should be handled
by the application protocol).
</p>
<p>Once the <code>GNUTLS_E_REHANDSHAKE</code>  error code is seen, the
calling application should proceed to calling
<code>gnutls_handshake()</code>  to negotiate the new
parameters.
</p>
<p>If the client does not wish to renegotiate parameters he 
may reply with an alert message, and in that case the return code seen
by subsequent <code>gnutls_record_recv()</code>  will be
<code>GNUTLS_E_WARNING_ALERT_RECEIVED</code>  with the specific alert being
<code>GNUTLS_A_NO_RENEGOTIATION</code> .  A client may also choose to ignore
this request.
</p>
<p>Under TLS 1.3 this function is equivalent to <code>gnutls_session_key_update()</code> 
with the <code>GNUTLS_KU_PEER</code>  flag. In that case subsequent calls to
<code>gnutls_record_recv()</code>  will not return <code>GNUTLS_E_REHANDSHAKE</code> , and
calls to <code>gnutls_handshake()</code>  in server side are a no-op.
</p>
<p>This function always fails with <code>GNUTLS_E_INVALID_REQUEST</code>  when
called in client side.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p></dd></dl>

<hr>
<span id="TLS-1_002e3-re_002dauthentication-and-re_002dkey"></span><div class="header">
<p>
Next: <a href="#Parameter-generation" accesskey="n" rel="next">Parameter generation</a>, Previous: <a href="#TLS-1_002e2-re_002dauthentication" accesskey="p" rel="prev">TLS 1.2 re-authentication</a>, Up: <a href="#Advanced-topics" accesskey="u" rel="up">Advanced topics</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="TLS-1_002e3-re_002dauthentication-and-re_002dkey-1"></span><h4 class="subsection">6.12.5 TLS 1.3 re-authentication and re-key</h4>
<span id="index-re_002dkey"></span>
<span id="index-re_002dnegotiation-1"></span>
<span id="index-re_002dauthentication-1"></span>
<span id="index-post_002dhandshake-authentication"></span>

<p>The TLS 1.3 protocol distinguishes between re-key and re-authentication.
The re-key process ensures that fresh keys are supplied to the already
negotiated parameters, and on GnuTLS can be initiated using
<a href="#gnutls_005fsession_005fkey_005fupdate">gnutls_session_key_update</a>. The re-key process can be one-way
(i.e., the calling party only changes its keys), or two-way where the peer
is requested to change keys as well.
</p>
<p>The re-authentication process, allows the connected client to switch
identity by presenting a new certificate. Unlike TLS 1.2, the server
is not allowed to change identities. That client re-authentication, or
post-handshake authentication can be initiated only by the server using
<a href="#gnutls_005freauth">gnutls_reauth</a>, and only if a client has advertized support for it.
Both server and client have to explicitly enable support for post handshake
authentication using the <code>GNUTLS_POST_HANDSHAKE_AUTH</code> flag at <a href="#gnutls_005finit">gnutls_init</a>.
</p>
<p>A client receiving a re-authentication request will &quot;see&quot; the error code
<code>GNUTLS_E_REAUTH_REQUEST</code> at <a href="#gnutls_005frecord_005frecv">gnutls_record_recv</a>. At this
point, it should also call <a href="#gnutls_005freauth">gnutls_reauth</a>.
</p>
<p>To make re-authentication transparent to the application when requested
by the server, use the <code>GNUTLS_AUTO_REAUTH</code> and <code>GNUTLS_POST_HANDSHAKE_AUTH</code>
flags on the <a href="#gnutls_005finit">gnutls_init</a> call. In that case the re-authentication will happen
in the call of <a href="#gnutls_005frecord_005frecv">gnutls_record_recv</a> that received the
reauthentication request.
</p>
<hr>
<span id="Parameter-generation"></span><div class="header">
<p>
Next: <a href="#Deriving-keys-for-other-applications_002fprotocols" accesskey="n" rel="next">Deriving keys for other applications/protocols</a>, Previous: <a href="#TLS-1_002e3-re_002dauthentication-and-re_002dkey" accesskey="p" rel="prev">TLS 1.3 re-authentication and re-key</a>, Up: <a href="#Advanced-topics" accesskey="u" rel="up">Advanced topics</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Parameter-generation-1"></span><h4 class="subsection">6.12.6 Parameter generation</h4>
<span id="index-parameter-generation"></span>
<span id="index-generating-parameters"></span>

<p>Prior to GnuTLS 3.6.0 for the ephemeral or anonymous Diffie-Hellman (DH) TLS ciphersuites
the application was required to generate or provide
DH parameters. That is no longer necessary as GnuTLS utilizes DH parameters
and negotiation from [<a href="#RFC7919">RFC7919</a>].
</p>
<p>Applications can tune the used parameters by explicitly specifying them
in the priority string. In server side applications can set the
minimum acceptable level of DH parameters by calling
<a href="#gnutls_005fcertificate_005fset_005fknown_005fdh_005fparams">gnutls_certificate_set_known_dh_params</a>,
<a href="#gnutls_005fanon_005fset_005fserver_005fknown_005fdh_005fparams">gnutls_anon_set_server_known_dh_params</a>, or
<a href="#gnutls_005fpsk_005fset_005fserver_005fknown_005fdh_005fparams">gnutls_psk_set_server_known_dh_params</a>, depending on the type
of the credentials, to set the lower acceptable parameter limits. Typical
applications should rely on the default settings.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fcertificate_005fset_005fknown_005fdh_005fparams">gnutls_certificate_set_known_dh_params</a> (gnutls_certificate_credentials_t <var>res</var>, gnutls_sec_param_t <var>sec_param</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fanon_005fset_005fserver_005fknown_005fdh_005fparams">gnutls_anon_set_server_known_dh_params</a> (gnutls_anon_server_credentials_t <var>res</var>, gnutls_sec_param_t <var>sec_param</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpsk_005fset_005fserver_005fknown_005fdh_005fparams">gnutls_psk_set_server_known_dh_params</a> (gnutls_psk_server_credentials_t <var>res</var>, gnutls_sec_param_t <var>sec_param</var>)</code></dt>
</dl>


<span id="Legacy-parameter-generation"></span><h4 class="subsubsection">6.12.6.1 Legacy parameter generation</h4>
<p>Note that older than 3.5.6 versions of GnuTLS provided functions
to generate or import arbitrary DH parameters from a file. This
practice is still supported but discouraged in current versions.
There is no known advantage from using random parameters, while there
have been several occasions where applications were utilizing incorrect,
weak or insecure parameters. This is the main reason GnuTLS includes the
well-known parameters of [<a href="#RFC7919">RFC7919</a>] and recommends applications
utilizing them.
</p>
<p>In older applications which require to specify explicit DH parameters, we recommend
using <code>certtool</code> (of GnuTLS 3.5.6 or later) with the <code>--get-dh-params</code>
option to obtain the FFDHE parameters discussed above. The output
parameters of the tool are in PKCS#3 format and can be imported by
most existing applications.
</p>
<p>The following functions are still supported but considered obsolete.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fdh_005fparams_005fgenerate2">gnutls_dh_params_generate2</a> (gnutls_dh_params_t <var>dparams</var>, unsigned int <var>bits</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fdh_005fparams_005fimport_005fpkcs3">gnutls_dh_params_import_pkcs3</a> (gnutls_dh_params_t <var>params</var>, const gnutls_datum_t * <var>pkcs3_params</var>, gnutls_x509_crt_fmt_t <var>format</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005fcertificate_005fset_005fdh_005fparams">gnutls_certificate_set_dh_params</a> (gnutls_certificate_credentials_t <var>res</var>, gnutls_dh_params_t <var>dh_params</var>)</code></dt>
</dl>


<hr>
<span id="Deriving-keys-for-other-applications_002fprotocols"></span><div class="header">
<p>
Next: <a href="#Channel-Bindings" accesskey="n" rel="next">Channel Bindings</a>, Previous: <a href="#Parameter-generation" accesskey="p" rel="prev">Parameter generation</a>, Up: <a href="#Advanced-topics" accesskey="u" rel="up">Advanced topics</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Deriving-keys-for-other-applications_002fprotocols-1"></span><h4 class="subsection">6.12.7 Deriving keys for other applications/protocols</h4>
<span id="index-keying-material-exporters"></span>
<span id="index-exporting-keying-material"></span>
<span id="index-deriving-keys"></span>
<span id="index-key-extraction"></span>

<p>In several cases, after a TLS connection is established, it is desirable
to derive keys to be used in another application or protocol (e.g., in an
other TLS session using pre-shared keys). The following describe GnuTLS&rsquo;
implementation of RFC5705 to extract keys based on a session&rsquo;s master secret.
</p>
<p>The API to use is <a href="#gnutls_005fprf_005frfc5705">gnutls_prf_rfc5705</a>.  The 
function needs to be provided with a label,
and additional context data to mix in the <code>context</code> parameter. 
</p>




<dl>
<dt id="index-gnutls_005fprf_005frfc5705">Function: <em>int</em> <strong>gnutls_prf_rfc5705</strong> <em>(gnutls_session_t <var>session</var>, size_t <var>label_size</var>, const char * <var>label</var>, size_t <var>context_size</var>, const char * <var>context</var>, size_t <var>outsize</var>, char * <var>out</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>label_size</var>: length of the  <code>label</code> variable.
</p>
<p><var>label</var>: label used in PRF computation, typically a short string.
</p>
<p><var>context_size</var>: length of the  <code>extra</code> variable.
</p>
<p><var>context</var>: optional extra data to seed the PRF with.
</p>
<p><var>outsize</var>: size of pre-allocated output buffer to hold the output.
</p>
<p><var>out</var>: pre-allocated buffer to hold the generated data.
</p>
<p>Exports keying material from TLS/DTLS session to an application, as
specified in RFC5705.
</p>
<p>In the TLS versions prior to 1.3, it applies the TLS
Pseudo-Random-Function (PRF) on the master secret and the provided
data, seeded with the client and server random fields.
</p>
<p>In TLS 1.3, it applies HKDF on the exporter master secret derived
from the master secret.
</p>
<p>The  <code>label</code> variable usually contains a string denoting the purpose
for the generated data.
</p>
<p>The  <code>context</code> variable can be used to add more data to the seed, after
the random variables.  It can be used to make sure the
generated output is strongly connected to some additional data
(e.g., a string used in user authentication). 
</p>
<p>The output is placed in  <code>out</code> , which must be pre-allocated.
</p>
<p>Note that, to provide the RFC5705 context, the  <code>context</code> variable
must be non-null.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, or an error code.
</p>
<p><strong>Since:</strong> 3.4.4
</p></dd></dl>

<p>For example, after establishing a TLS session using
<a href="#gnutls_005fhandshake">gnutls_handshake</a>, you can obtain 32-bytes to be used as key, using this call:
</p>
<div class="example">
<pre class="example">#define MYLABEL &quot;EXPORTER-My-protocol-name&quot;
#define MYCONTEXT &quot;my-protocol's-1st-session&quot;

char out[32];
rc = gnutls_prf_rfc5705 (session, sizeof(MYLABEL)-1, MYLABEL,
                         sizeof(MYCONTEXT)-1, MYCONTEXT, 32, out);
</pre></div>

<p>The output key depends on TLS&rsquo; master secret, and is the same on both client
and server.
</p>
<p>For legacy applications which need to use a more flexible API, there is
<a href="#gnutls_005fprf">gnutls_prf</a>, which in addition, allows to switch the mix of the
client and server random nonces, using the <code>server_random_first</code> parameter.
For additional flexibility and low-level access to the TLS1.2 PRF,
there is a low-level TLS PRF interface called <a href="#gnutls_005fprf_005fraw">gnutls_prf_raw</a>.
That however is not functional under newer protocol versions.
</p>
<hr>
<span id="Channel-Bindings"></span><div class="header">
<p>
Next: <a href="#Interoperability" accesskey="n" rel="next">Interoperability</a>, Previous: <a href="#Deriving-keys-for-other-applications_002fprotocols" accesskey="p" rel="prev">Deriving keys for other applications/protocols</a>, Up: <a href="#Advanced-topics" accesskey="u" rel="up">Advanced topics</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Channel-bindings"></span><h4 class="subsection">6.12.8 Channel bindings</h4>
<span id="index-channel-bindings"></span>

<p>In user authentication protocols (e.g., EAP or SASL mechanisms) it is
useful to have a unique string that identifies the secure channel that
is used, to bind together the user authentication with the secure
channel.  This can protect against man-in-the-middle attacks in some
situations.  That unique string is called a &ldquo;channel binding&rdquo;.  For
background and discussion see [<a href="#RFC5056">RFC5056</a>].
</p>
<p>In <acronym>GnuTLS</acronym> you can extract a channel binding using the
<a href="#gnutls_005fsession_005fchannel_005fbinding">gnutls_session_channel_binding</a> function.  Currently only the
type <code>GNUTLS_CB_TLS_UNIQUE</code> is supported, which corresponds to
the <code>tls-unique</code> channel binding for TLS defined in
[<a href="#RFC5929">RFC5929</a>].
</p>
<p>The following example describes how to print the channel binding data.
Note that it must be run after a successful TLS handshake.
</p>
<div class="example">
<pre class="example">{
  gnutls_datum_t cb;
  int rc;

  rc = gnutls_session_channel_binding (session,
                                       GNUTLS_CB_TLS_UNIQUE,
                                       &amp;cb);
  if (rc)
    fprintf (stderr, &quot;Channel binding error: %s\n&quot;,
             gnutls_strerror (rc));
  else
    {
      size_t i;
      printf (&quot;- Channel binding 'tls-unique': &quot;);
      for (i = 0; i &lt; cb.size; i++)
        printf (&quot;%02x&quot;, cb.data[i]);
      printf (&quot;\n&quot;);
    }
}
</pre></div>

<hr>
<span id="Interoperability"></span><div class="header">
<p>
Next: <a href="#Compatibility-with-the-OpenSSL-library" accesskey="n" rel="next">Compatibility with the OpenSSL library</a>, Previous: <a href="#Channel-Bindings" accesskey="p" rel="prev">Channel Bindings</a>, Up: <a href="#Advanced-topics" accesskey="u" rel="up">Advanced topics</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Interoperability-1"></span><h4 class="subsection">6.12.9 Interoperability</h4>

<p>The <acronym>TLS</acronym> protocols support many ciphersuites, extensions and version
numbers. As a result, few implementations are 
not able to properly interoperate once faced with extensions or version protocols
they do not support and understand. The <acronym>TLS</acronym> protocol allows for a
graceful downgrade to the commonly supported options, but practice shows 
it is not always implemented correctly. 
</p>
<p>Because there is no way to achieve maximum interoperability with broken peers
without sacrificing security, <acronym>GnuTLS</acronym> ignores such peers by default. 
This might not be acceptable in cases where maximum compatibility
is required. Thus we allow enabling compatibility with broken peers using
priority strings (see <a href="#Priority-Strings">Priority Strings</a>). A conservative priority
string that would disable certain <acronym>TLS</acronym> protocol
options that are known to cause compatibility problems, is shown below. 
</p><pre class="verbatim">NORMAL:%COMPAT
</pre>
<p>For very old broken peers that do not tolerate TLS version numbers over TLS 1.0
another priority string is:
</p><pre class="verbatim">NORMAL:-VERS-ALL:+VERS-TLS1.0:+VERS-SSL3.0:%COMPAT
</pre><p>This priority string will in addition to above, only enable SSL 3.0 and 
TLS 1.0 as protocols. 
</p>

<hr>
<span id="Compatibility-with-the-OpenSSL-library"></span><div class="header">
<p>
Previous: <a href="#Interoperability" accesskey="p" rel="prev">Interoperability</a>, Up: <a href="#Advanced-topics" accesskey="u" rel="up">Advanced topics</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Compatibility-with-the-OpenSSL-library-1"></span><h4 class="subsection">6.12.10 Compatibility with the OpenSSL library</h4>
<span id="index-OpenSSL"></span>

<p>To ease <acronym>GnuTLS</acronym>&rsquo; integration with existing applications, a
compatibility layer with the OpenSSL library is included
in the <code>gnutls-openssl</code> library. This compatibility layer is not
complete and it is not intended to completely re-implement the OpenSSL
API with <acronym>GnuTLS</acronym>.  It only provides limited source-level
compatibility. 
</p>
<p>The prototypes for the compatibility functions are in the
<samp>gnutls/openssl.h</samp> header file. The limitations 
imposed by the compatibility layer include:
</p>
<ul>
<li> Error handling is not thread safe.

</li></ul>


<hr>
<span id="GnuTLS-application-examples"></span><div class="header">
<p>
Next: <a href="#System_002dwide-configuration-of-the-library" accesskey="n" rel="next">System-wide configuration of the library</a>, Previous: <a href="#How-to-use-GnuTLS-in-applications" accesskey="p" rel="prev">How to use GnuTLS in applications</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="GnuTLS-application-examples-1"></span><h2 class="chapter">7 GnuTLS application examples</h2>
<span id="examples"></span><span id="index-example-programs"></span>
<span id="index-examples"></span>

<p>In this chapter several examples of real-world use cases are listed.
The examples are simplified to promote readability and contain little or 
no error checking.  
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Client-examples" accesskey="1">Client examples</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Server-examples" accesskey="2">Server examples</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#More-advanced-client-and-servers" accesskey="3">More advanced client and servers</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#OCSP-example" accesskey="4">OCSP example</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Miscellaneous-examples" accesskey="5">Miscellaneous examples</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Client-examples"></span><div class="header">
<p>
Next: <a href="#Server-examples" accesskey="n" rel="next">Server examples</a>, Up: <a href="#GnuTLS-application-examples" accesskey="u" rel="up">GnuTLS application examples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Client-examples-1"></span><h3 class="section">7.1 Client examples</h3>

<p>This section contains examples of <acronym>TLS</acronym> and <acronym>SSL</acronym>
clients, using <acronym>GnuTLS</acronym>. Note that some of the examples require functions
implemented by another example.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Client-example-with-X_002e509-certificate-support" accesskey="1">Client example with X.509 certificate support</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Datagram-TLS-client-example" accesskey="2">Datagram TLS client example</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Client-using-a-smart-card-with-TLS" accesskey="3">Client using a smart card with TLS</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Client-with-Resume-capability-example" accesskey="4">Client with Resume capability example</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Client-example-with-SSH_002dstyle-certificate-verification" accesskey="5">Client example with SSH-style certificate verification</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Client-example-with-X_002e509-certificate-support"></span><div class="header">
<p>
Next: <a href="#Datagram-TLS-client-example" accesskey="n" rel="next">Datagram TLS client example</a>, Up: <a href="#Client-examples" accesskey="u" rel="up">Client examples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Client-example-with-X_002e509-certificate-support-1"></span><h4 class="subsection">7.1.1 Client example with <acronym>X.509</acronym> certificate support</h4>
<span id="ex_002dverify"></span>
<p>Let&rsquo;s assume now that we want to create a TCP client which
communicates with servers that use <acronym>X.509</acronym> certificate authentication.
The following client is a very simple <acronym>TLS</acronym> client, which uses
the high level verification functions for certificates, but does not support session
resumption.
</p>
<p>Note that this client utilizes functionality present in the latest GnuTLS
version. For a reasonably portable version see <a href="#Legacy-client-example-with-X_002e509-certificate-support">Legacy client example with X.509 certificate support</a>.
</p>
<pre class="verbatim">/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;gnutls/gnutls.h&gt;
#include &lt;gnutls/x509.h&gt;
#include &quot;examples.h&quot;

/* A very basic TLS client, with X.509 authentication and server certificate
 * verification. Note that error recovery is minimal for simplicity.
 */

#define CHECK(x) assert((x)&gt;=0)
#define LOOP_CHECK(rval, cmd) \
        do { \
                rval = cmd; \
        } while(rval == GNUTLS_E_AGAIN || rval == GNUTLS_E_INTERRUPTED); \
        assert(rval &gt;= 0)

#define MAX_BUF 1024
#define MSG &quot;GET / HTTP/1.0\r\n\r\n&quot;

extern int tcp_connect(void);
extern void tcp_close(int sd);

int main(void)
{
        int ret, sd, ii;
        gnutls_session_t session;
        char buffer[MAX_BUF + 1], *desc;
        gnutls_datum_t out;
        int type;
        unsigned status;
        gnutls_certificate_credentials_t xcred;

        if (gnutls_check_version(&quot;3.4.6&quot;) == NULL) {
                fprintf(stderr, &quot;GnuTLS 3.4.6 or later is required for this example\n&quot;);
                exit(1);
        }

        /* for backwards compatibility with gnutls &lt; 3.3.0 */
        CHECK(gnutls_global_init());

        /* X509 stuff */
        CHECK(gnutls_certificate_allocate_credentials(&amp;xcred));

        /* sets the system trusted CAs for Internet PKI */
        CHECK(gnutls_certificate_set_x509_system_trust(xcred));

        /* If client holds a certificate it can be set using the following:
         *
         gnutls_certificate_set_x509_key_file (xcred, &quot;cert.pem&quot;, &quot;key.pem&quot;, 
         GNUTLS_X509_FMT_PEM); 
         */

        /* Initialize TLS session */
        CHECK(gnutls_init(&amp;session, GNUTLS_CLIENT));

        CHECK(gnutls_server_name_set(session, GNUTLS_NAME_DNS, &quot;www.example.com&quot;,
                                     strlen(&quot;www.example.com&quot;)));

        /* It is recommended to use the default priorities */
        CHECK(gnutls_set_default_priority(session));

        /* put the x509 credentials to the current session
         */
        CHECK(gnutls_credentials_set(session, GNUTLS_CRD_CERTIFICATE, xcred));
        gnutls_session_set_verify_cert(session, &quot;www.example.com&quot;, 0);

        /* connect to the peer
         */
        sd = tcp_connect();

        gnutls_transport_set_int(session, sd);
        gnutls_handshake_set_timeout(session,
                                     GNUTLS_DEFAULT_HANDSHAKE_TIMEOUT);

        /* Perform the TLS handshake
         */
        do {
                ret = gnutls_handshake(session);
        }
        while (ret &lt; 0 &amp;&amp; gnutls_error_is_fatal(ret) == 0);
        if (ret &lt; 0) {
                if (ret == GNUTLS_E_CERTIFICATE_VERIFICATION_ERROR) {
                        /* check certificate verification status */
                        type = gnutls_certificate_type_get(session);
                        status = gnutls_session_get_verify_cert_status(session);
                        CHECK(gnutls_certificate_verification_status_print(status,
                              type, &amp;out, 0));
                        printf(&quot;cert verify output: %s\n&quot;, out.data);
                        gnutls_free(out.data);
                }
                fprintf(stderr, &quot;*** Handshake failed: %s\n&quot;, gnutls_strerror(ret));
                goto end;
        } else {
                desc = gnutls_session_get_desc(session);
                printf(&quot;- Session info: %s\n&quot;, desc);
                gnutls_free(desc);
        }

	/* send data */
        LOOP_CHECK(ret, gnutls_record_send(session, MSG, strlen(MSG)));

        LOOP_CHECK(ret, gnutls_record_recv(session, buffer, MAX_BUF));
        if (ret == 0) {
                printf(&quot;- Peer has closed the TLS connection\n&quot;);
                goto end;
        } else if (ret &lt; 0 &amp;&amp; gnutls_error_is_fatal(ret) == 0) {
                fprintf(stderr, &quot;*** Warning: %s\n&quot;, gnutls_strerror(ret));
        } else if (ret &lt; 0) {
                fprintf(stderr, &quot;*** Error: %s\n&quot;, gnutls_strerror(ret));
                goto end;
        }

        if (ret &gt; 0) {
                printf(&quot;- Received %d bytes: &quot;, ret);
                for (ii = 0; ii &lt; ret; ii++) {
                        fputc(buffer[ii], stdout);
                }
                fputs(&quot;\n&quot;, stdout);
        }

        CHECK(gnutls_bye(session, GNUTLS_SHUT_RDWR));

      end:

        tcp_close(sd);

        gnutls_deinit(session);

        gnutls_certificate_free_credentials(xcred);

        gnutls_global_deinit();

        return 0;
}
</pre>

<hr>
<span id="Datagram-TLS-client-example"></span><div class="header">
<p>
Next: <a href="#Client-using-a-smart-card-with-TLS" accesskey="n" rel="next">Client using a smart card with TLS</a>, Previous: <a href="#Client-example-with-X_002e509-certificate-support" accesskey="p" rel="prev">Client example with X.509 certificate support</a>, Up: <a href="#Client-examples" accesskey="u" rel="up">Client examples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Datagram-TLS-client-example-1"></span><h4 class="subsection">7.1.2 Datagram <acronym>TLS</acronym> client example</h4>

<p>This is a client that uses <acronym>UDP</acronym> to connect to a
server. This is the <acronym>DTLS</acronym> equivalent to the TLS example
with X.509 certificates.
</p>
<pre class="verbatim">/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;assert.h&gt;
#include &lt;unistd.h&gt;
#include &lt;gnutls/gnutls.h&gt;
#include &lt;gnutls/dtls.h&gt;

/* A very basic Datagram TLS client, over UDP with X.509 authentication.
 */

#define CHECK(x) assert((x)&gt;=0)
#define LOOP_CHECK(rval, cmd) \
        do { \
                rval = cmd; \
        } while(rval == GNUTLS_E_AGAIN || rval == GNUTLS_E_INTERRUPTED); \
        assert(rval &gt;= 0)

#define MAX_BUF 1024
#define MSG &quot;GET / HTTP/1.0\r\n\r\n&quot;

extern int udp_connect(void);
extern void udp_close(int sd);
extern int verify_certificate_callback(gnutls_session_t session);

int main(void)
{
        int ret, sd, ii;
        gnutls_session_t session;
        char buffer[MAX_BUF + 1];
        gnutls_certificate_credentials_t xcred;

        if (gnutls_check_version(&quot;3.1.4&quot;) == NULL) {
                fprintf(stderr, &quot;GnuTLS 3.1.4 or later is required for this example\n&quot;);
                exit(1);
        }

        /* for backwards compatibility with gnutls &lt; 3.3.0 */
        CHECK(gnutls_global_init());

        /* X509 stuff */
        CHECK(gnutls_certificate_allocate_credentials(&amp;xcred));

        /* sets the system trusted CAs for Internet PKI */
        CHECK(gnutls_certificate_set_x509_system_trust(xcred));

        /* Initialize TLS session */
        CHECK(gnutls_init(&amp;session, GNUTLS_CLIENT | GNUTLS_DATAGRAM));

        /* Use default priorities */
        CHECK(gnutls_set_default_priority(session));

        /* put the x509 credentials to the current session */
        CHECK(gnutls_credentials_set(session, GNUTLS_CRD_CERTIFICATE, xcred));
        CHECK(gnutls_server_name_set(session, GNUTLS_NAME_DNS, &quot;www.example.com&quot;,
                                     strlen(&quot;www.example.com&quot;)));

        gnutls_session_set_verify_cert(session, &quot;www.example.com&quot;, 0);

        /* connect to the peer */
        sd = udp_connect();

        gnutls_transport_set_int(session, sd);

        /* set the connection MTU */
        gnutls_dtls_set_mtu(session, 1000);
        /* gnutls_dtls_set_timeouts(session, 1000, 60000); */

        /* Perform the TLS handshake */
        do {
                ret = gnutls_handshake(session);
        }
        while (ret == GNUTLS_E_INTERRUPTED || ret == GNUTLS_E_AGAIN);
        /* Note that DTLS may also receive GNUTLS_E_LARGE_PACKET */

        if (ret &lt; 0) {
                fprintf(stderr, &quot;*** Handshake failed\n&quot;);
                gnutls_perror(ret);
                goto end;
        } else {
                char *desc;

                desc = gnutls_session_get_desc(session);
                printf(&quot;- Session info: %s\n&quot;, desc);
                gnutls_free(desc);
        }

        LOOP_CHECK(ret, gnutls_record_send(session, MSG, strlen(MSG)));

        LOOP_CHECK(ret, gnutls_record_recv(session, buffer, MAX_BUF));
        if (ret == 0) {
                printf(&quot;- Peer has closed the TLS connection\n&quot;);
                goto end;
        } else if (ret &lt; 0 &amp;&amp; gnutls_error_is_fatal(ret) == 0) {
                fprintf(stderr, &quot;*** Warning: %s\n&quot;, gnutls_strerror(ret));
        } else if (ret &lt; 0) {
                fprintf(stderr, &quot;*** Error: %s\n&quot;, gnutls_strerror(ret));
                goto end;
        }

        if (ret &gt; 0) {
                printf(&quot;- Received %d bytes: &quot;, ret);
                for (ii = 0; ii &lt; ret; ii++) {
                        fputc(buffer[ii], stdout);
                }
                fputs(&quot;\n&quot;, stdout);
        }

        /* It is suggested not to use GNUTLS_SHUT_RDWR in DTLS
         * connections because the peer's closure message might
         * be lost */
        CHECK(gnutls_bye(session, GNUTLS_SHUT_WR));

      end:

        udp_close(sd);

        gnutls_deinit(session);

        gnutls_certificate_free_credentials(xcred);

        gnutls_global_deinit();

        return 0;
}
</pre>

<hr>
<span id="Client-using-a-smart-card-with-TLS"></span><div class="header">
<p>
Next: <a href="#Client-with-Resume-capability-example" accesskey="n" rel="next">Client with Resume capability example</a>, Previous: <a href="#Datagram-TLS-client-example" accesskey="p" rel="prev">Datagram TLS client example</a>, Up: <a href="#Client-examples" accesskey="u" rel="up">Client examples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Using-a-smart-card-with-TLS"></span><h4 class="subsection">7.1.3 Using a smart card with TLS</h4>
<span id="ex_002dpkcs11_002dclient"></span><span id="index-Smart-card-example"></span>

<p>This example will demonstrate how to load keys and certificates
from a smart-card or any other <acronym>PKCS</acronym> #11 token, and 
use it in a TLS connection. The difference between this and the
<a href="#Client-example-with-X_002e509-certificate-support">Client example with X.509 certificate support</a> is that the
client keys are provided as PKCS #11 URIs instead of files.
</p>
<pre class="verbatim">/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;unistd.h&gt;
#include &lt;gnutls/gnutls.h&gt;
#include &lt;gnutls/x509.h&gt;
#include &lt;gnutls/pkcs11.h&gt;
#include &lt;assert.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;getpass.h&gt;            /* for getpass() */

/* A TLS client that loads the certificate and key.
 */

#define CHECK(x) assert((x)&gt;=0)

#define MAX_BUF 1024
#define MSG &quot;GET / HTTP/1.0\r\n\r\n&quot;
#define MIN(x,y) (((x)&lt;(y))?(x):(y))

#define CAFILE &quot;/etc/ssl/certs/ca-certificates.crt&quot;

/* The URLs of the objects can be obtained
 * using p11tool --list-all --login
 */
#define KEY_URL &quot;pkcs11:manufacturer=SomeManufacturer;object=Private%20Key&quot; \
  &quot;;objecttype=private;id=%db%5b%3e%b5%72%33&quot;
#define CERT_URL &quot;pkcs11:manufacturer=SomeManufacturer;object=Certificate;&quot; \
  &quot;objecttype=cert;id=db%5b%3e%b5%72%33&quot;

extern int tcp_connect(void);
extern void tcp_close(int sd);

static int
pin_callback(void *user, int attempt, const char *token_url,
             const char *token_label, unsigned int flags, char *pin,
             size_t pin_max)
{
        const char *password;
        int len;

        printf(&quot;PIN required for token '%s' with URL '%s'\n&quot;, token_label,
               token_url);
        if (flags &amp; GNUTLS_PIN_FINAL_TRY)
                printf(&quot;*** This is the final try before locking!\n&quot;);
        if (flags &amp; GNUTLS_PIN_COUNT_LOW)
                printf(&quot;*** Only few tries left before locking!\n&quot;);
        if (flags &amp; GNUTLS_PIN_WRONG)
                printf(&quot;*** Wrong PIN\n&quot;);

        password = getpass(&quot;Enter pin: &quot;);
        /* FIXME: ensure that we are in UTF-8 locale */
        if (password == NULL || password[0] == 0) {
                fprintf(stderr, &quot;No password given\n&quot;);
                exit(1);
        }

        len = MIN(pin_max - 1, strlen(password));
        memcpy(pin, password, len);
        pin[len] = 0;

        return 0;
}

int main(void)
{
        int ret, sd, ii;
        gnutls_session_t session;
        char buffer[MAX_BUF + 1];
        gnutls_certificate_credentials_t xcred;
        /* Allow connections to servers that have OpenPGP keys as well.
         */

        if (gnutls_check_version(&quot;3.1.4&quot;) == NULL) {
                fprintf(stderr, &quot;GnuTLS 3.1.4 or later is required for this example\n&quot;);
                exit(1);
        }

        /* for backwards compatibility with gnutls &lt; 3.3.0 */
        CHECK(gnutls_global_init());

        /* The PKCS11 private key operations may require PIN.
         * Register a callback. */
        gnutls_pkcs11_set_pin_function(pin_callback, NULL);

        /* X509 stuff */
        CHECK(gnutls_certificate_allocate_credentials(&amp;xcred));

        /* sets the trusted cas file
         */
        CHECK(gnutls_certificate_set_x509_trust_file(xcred, CAFILE,
                                                     GNUTLS_X509_FMT_PEM));

        CHECK(gnutls_certificate_set_x509_key_file(xcred, CERT_URL, KEY_URL,
                                                   GNUTLS_X509_FMT_DER));

        /* Note that there is no server certificate verification in this example
         */


        /* Initialize TLS session
         */
        CHECK(gnutls_init(&amp;session, GNUTLS_CLIENT));

        /* Use default priorities */
        CHECK(gnutls_set_default_priority(session));

        /* put the x509 credentials to the current session
         */
        CHECK(gnutls_credentials_set(session, GNUTLS_CRD_CERTIFICATE, xcred));

        /* connect to the peer
         */
        sd = tcp_connect();

        gnutls_transport_set_int(session, sd);

        /* Perform the TLS handshake
         */
        ret = gnutls_handshake(session);

        if (ret &lt; 0) {
                fprintf(stderr, &quot;*** Handshake failed\n&quot;);
                gnutls_perror(ret);
                goto end;
        } else {
                char *desc;

                desc = gnutls_session_get_desc(session);
                printf(&quot;- Session info: %s\n&quot;, desc);
                gnutls_free(desc);
        }

        CHECK(gnutls_record_send(session, MSG, strlen(MSG)));

        ret = gnutls_record_recv(session, buffer, MAX_BUF);
        if (ret == 0) {
                printf(&quot;- Peer has closed the TLS connection\n&quot;);
                goto end;
        } else if (ret &lt; 0) {
                fprintf(stderr, &quot;*** Error: %s\n&quot;, gnutls_strerror(ret));
                goto end;
        }

        printf(&quot;- Received %d bytes: &quot;, ret);
        for (ii = 0; ii &lt; ret; ii++) {
                fputc(buffer[ii], stdout);
        }
        fputs(&quot;\n&quot;, stdout);

        CHECK(gnutls_bye(session, GNUTLS_SHUT_RDWR));

      end:

        tcp_close(sd);

        gnutls_deinit(session);

        gnutls_certificate_free_credentials(xcred);

        gnutls_global_deinit();

        return 0;
}
</pre>

<hr>
<span id="Client-with-Resume-capability-example"></span><div class="header">
<p>
Next: <a href="#Client-example-with-SSH_002dstyle-certificate-verification" accesskey="n" rel="next">Client example with SSH-style certificate verification</a>, Previous: <a href="#Client-using-a-smart-card-with-TLS" accesskey="p" rel="prev">Client using a smart card with TLS</a>, Up: <a href="#Client-examples" accesskey="u" rel="up">Client examples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Client-with-resume-capability-example"></span><h4 class="subsection">7.1.4 Client with resume capability example</h4>
<span id="ex_002dresume_002dclient"></span>
<p>This is a modification of the simple client example. Here we
demonstrate the use of session resumption. The client tries to connect
once using <acronym>TLS</acronym>, close the connection and then try to
establish a new connection using the previously negotiated data.
</p>
<pre class="verbatim">/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif

#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;gnutls/gnutls.h&gt;

extern void check_alert(gnutls_session_t session, int ret);
extern int tcp_connect(void);
extern void tcp_close(int sd);

/* A very basic TLS client, with X.509 authentication and server certificate
 * verification as well as session resumption.
 *
 * Note that error recovery is minimal for simplicity.
 */

#define CHECK(x) assert((x)&gt;=0)
#define LOOP_CHECK(rval, cmd) \
        do { \
                rval = cmd; \
        } while(rval == GNUTLS_E_AGAIN || rval == GNUTLS_E_INTERRUPTED); \
        assert(rval &gt;= 0)

#define MAX_BUF 1024
#define MSG &quot;GET / HTTP/1.0\r\n\r\n&quot;

int main(void)
{
        int ret;
        int sd, ii;
        gnutls_session_t session;
        char buffer[MAX_BUF + 1];
        gnutls_certificate_credentials_t xcred;

        /* variables used in session resuming 
         */
        int t;
        gnutls_datum_t sdata;

        /* for backwards compatibility with gnutls &lt; 3.3.0 */
        CHECK(gnutls_global_init());

        CHECK(gnutls_certificate_allocate_credentials(&amp;xcred));
        CHECK(gnutls_certificate_set_x509_system_trust(xcred));

        for (t = 0; t &lt; 2; t++) {       /* connect 2 times to the server */

                sd = tcp_connect();

                CHECK(gnutls_init(&amp;session, GNUTLS_CLIENT));

                CHECK(gnutls_server_name_set(session, GNUTLS_NAME_DNS,
                                             &quot;www.example.com&quot;,
                                             strlen(&quot;www.example.com&quot;)));
                gnutls_session_set_verify_cert(session, &quot;www.example.com&quot;, 0);

                CHECK(gnutls_set_default_priority(session));

                gnutls_transport_set_int(session, sd);
                gnutls_handshake_set_timeout(session,
                                             GNUTLS_DEFAULT_HANDSHAKE_TIMEOUT);

                gnutls_credentials_set(session, GNUTLS_CRD_CERTIFICATE,
                                       xcred);

                if (t &gt; 0) {
                        /* if this is not the first time we connect */
                        CHECK(gnutls_session_set_data(session, sdata.data,
                                                      sdata.size));
                        gnutls_free(sdata.data);
                }

                /* Perform the TLS handshake
                 */
                do {
                        ret = gnutls_handshake(session);
                }
                while (ret &lt; 0 &amp;&amp; gnutls_error_is_fatal(ret) == 0);

                if (ret &lt; 0) {
                        fprintf(stderr, &quot;*** Handshake failed\n&quot;);
                        gnutls_perror(ret);
                        goto end;
                } else {
                        printf(&quot;- Handshake was completed\n&quot;);
                }

                if (t == 0) {   /* the first time we connect */
                        /* get the session data */
                        CHECK(gnutls_session_get_data2(session, &amp;sdata));
                } else { /* the second time we connect */

                        /* check if we actually resumed the previous session */
                        if (gnutls_session_is_resumed(session) != 0) {
                                printf(&quot;- Previous session was resumed\n&quot;);
                        } else {
                                fprintf(stderr,
                                        &quot;*** Previous session was NOT resumed\n&quot;);
                        }
                }

                LOOP_CHECK(ret, gnutls_record_send(session, MSG, strlen(MSG)));

                LOOP_CHECK(ret, gnutls_record_recv(session, buffer, MAX_BUF));
                if (ret == 0) {
                        printf(&quot;- Peer has closed the TLS connection\n&quot;);
                        goto end;
                } else if (ret &lt; 0 &amp;&amp; gnutls_error_is_fatal(ret) == 0) {
                        fprintf(stderr, &quot;*** Warning: %s\n&quot;,
                                gnutls_strerror(ret));
                } else if (ret &lt; 0) {
                        fprintf(stderr, &quot;*** Error: %s\n&quot;,
                                gnutls_strerror(ret));
                        goto end;
                }

                if (ret &gt; 0) {
                        printf(&quot;- Received %d bytes: &quot;, ret);
                        for (ii = 0; ii &lt; ret; ii++) {
                                fputc(buffer[ii], stdout);
                        }
                        fputs(&quot;\n&quot;, stdout);
                }

                gnutls_bye(session, GNUTLS_SHUT_RDWR);

              end:

                tcp_close(sd);

                gnutls_deinit(session);

        }                       /* for() */

        gnutls_certificate_free_credentials(xcred);

        gnutls_global_deinit();

        return 0;
}
</pre>



<hr>
<span id="Client-example-with-SSH_002dstyle-certificate-verification"></span><div class="header">
<p>
Previous: <a href="#Client-with-Resume-capability-example" accesskey="p" rel="prev">Client with Resume capability example</a>, Up: <a href="#Client-examples" accesskey="u" rel="up">Client examples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Client-example-with-SSH_002dstyle-certificate-verification-1"></span><h4 class="subsection">7.1.5 Client example with SSH-style certificate verification</h4>

<p>This is an alternative verification function that will use the
X.509 certificate authorities for verification, but also assume an
trust on first use (SSH-like) authentication system. That is the user is 
prompted on unknown public keys and known public keys are considered 
trusted.
</p>
<pre class="verbatim">/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;gnutls/gnutls.h&gt;
#include &lt;gnutls/x509.h&gt;
#include &lt;assert.h&gt;
#include &quot;examples.h&quot;

#define CHECK(x) assert((x)&gt;=0)

/* This function will verify the peer's certificate, check
 * if the hostname matches. In addition it will perform an
 * SSH-style authentication, where ultimately trusted keys
 * are only the keys that have been seen before.
 */
int _ssh_verify_certificate_callback(gnutls_session_t session)
{
        unsigned int status;
        const gnutls_datum_t *cert_list;
        unsigned int cert_list_size;
        int ret, type;
        gnutls_datum_t out;
        const char *hostname;

        /* read hostname */
        hostname = gnutls_session_get_ptr(session);

        /* This verification function uses the trusted CAs in the credentials
         * structure. So you must have installed one or more CA certificates.
         */
        CHECK(gnutls_certificate_verify_peers3(session, hostname, &amp;status));

        type = gnutls_certificate_type_get(session);

        CHECK(gnutls_certificate_verification_status_print(status,
                                                           type, &amp;out, 0));
        printf(&quot;%s&quot;, out.data);

        gnutls_free(out.data);

        if (status != 0)        /* Certificate is not trusted */
                return GNUTLS_E_CERTIFICATE_ERROR;

        /* Do SSH verification */
        cert_list = gnutls_certificate_get_peers(session, &amp;cert_list_size);
        if (cert_list == NULL) {
                printf(&quot;No certificate was found!\n&quot;);
                return GNUTLS_E_CERTIFICATE_ERROR;
        }

        /* service may be obtained alternatively using getservbyport() */
        ret = gnutls_verify_stored_pubkey(NULL, NULL, hostname, &quot;https&quot;,
                                          type, &amp;cert_list[0], 0);
        if (ret == GNUTLS_E_NO_CERTIFICATE_FOUND) {
                printf(&quot;Host %s is not known.&quot;, hostname);
                if (status == 0)
                        printf(&quot;Its certificate is valid for %s.\n&quot;,
                               hostname);

                /* the certificate must be printed and user must be asked on
                 * whether it is trustworthy. --see gnutls_x509_crt_print() */

                /* if not trusted */
                return GNUTLS_E_CERTIFICATE_ERROR;
        } else if (ret == GNUTLS_E_CERTIFICATE_KEY_MISMATCH) {
                printf
                    (&quot;Warning: host %s is known but has another key associated.&quot;,
                     hostname);
                printf
                    (&quot;It might be that the server has multiple keys, or you are under attack\n&quot;);
                if (status == 0)
                        printf(&quot;Its certificate is valid for %s.\n&quot;,
                               hostname);

                /* the certificate must be printed and user must be asked on
                 * whether it is trustworthy. --see gnutls_x509_crt_print() */

                /* if not trusted */
                return GNUTLS_E_CERTIFICATE_ERROR;
        } else if (ret &lt; 0) {
                printf(&quot;gnutls_verify_stored_pubkey: %s\n&quot;,
                       gnutls_strerror(ret));
                return ret;
        }

        /* user trusts the key -&gt; store it */
        if (ret != 0) {
                CHECK(gnutls_store_pubkey(NULL, NULL, hostname, &quot;https&quot;,
                                          type, &amp;cert_list[0], 0, 0));
        }

        /* notify gnutls to continue handshake normally */
        return 0;
}
</pre>
<hr>
<span id="Server-examples"></span><div class="header">
<p>
Next: <a href="#More-advanced-client-and-servers" accesskey="n" rel="next">More advanced client and servers</a>, Previous: <a href="#Client-examples" accesskey="p" rel="prev">Client examples</a>, Up: <a href="#GnuTLS-application-examples" accesskey="u" rel="up">GnuTLS application examples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Server-examples-1"></span><h3 class="section">7.2 Server examples</h3>

<p>This section contains examples of <acronym>TLS</acronym> and <acronym>SSL</acronym>
servers, using <acronym>GnuTLS</acronym>.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Echo-server-with-X_002e509-authentication" accesskey="1">Echo server with X.509 authentication</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#DTLS-echo-server-with-X_002e509-authentication" accesskey="2">DTLS echo server with X.509 authentication</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Echo-server-with-X_002e509-authentication"></span><div class="header">
<p>
Next: <a href="#DTLS-echo-server-with-X_002e509-authentication" accesskey="n" rel="next">DTLS echo server with X.509 authentication</a>, Up: <a href="#Server-examples" accesskey="u" rel="up">Server examples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Echo-server-with-X_002e509-authentication-1"></span><h4 class="subsection">7.2.1 Echo server with <acronym>X.509</acronym> authentication</h4>

<p>This example is a very simple echo server which supports
<acronym>X.509</acronym> authentication.
</p>
<pre class="verbatim">/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;gnutls/gnutls.h&gt;
#include &lt;assert.h&gt;

#define KEYFILE &quot;key.pem&quot;
#define CERTFILE &quot;cert.pem&quot;
#define CAFILE &quot;/etc/ssl/certs/ca-certificates.crt&quot;
#define CRLFILE &quot;crl.pem&quot;

#define CHECK(x) assert((x)&gt;=0)
#define LOOP_CHECK(rval, cmd) \
        do { \
                rval = cmd; \
        } while(rval == GNUTLS_E_AGAIN || rval == GNUTLS_E_INTERRUPTED)

/* The OCSP status file contains up to date information about revocation
 * of the server's certificate. That can be periodically be updated
 * using:
 * $ ocsptool --ask --load-cert your_cert.pem --load-issuer your_issuer.pem
 *            --load-signer your_issuer.pem --outfile ocsp-status.der
 */
#define OCSP_STATUS_FILE &quot;ocsp-status.der&quot;

/* This is a sample TLS 1.0 echo server, using X.509 authentication and
 * OCSP stapling support.
 */

#define MAX_BUF 1024
#define PORT 5556               /* listen to 5556 port */

int main(void)
{
        int listen_sd;
        int sd, ret;
        gnutls_certificate_credentials_t x509_cred;
        gnutls_priority_t priority_cache;
        struct sockaddr_in sa_serv;
        struct sockaddr_in sa_cli;
        socklen_t client_len;
        char topbuf[512];
        gnutls_session_t session;
        char buffer[MAX_BUF + 1];
        int optval = 1;

        /* for backwards compatibility with gnutls &lt; 3.3.0 */
        CHECK(gnutls_global_init());

        CHECK(gnutls_certificate_allocate_credentials(&amp;x509_cred));

        CHECK(gnutls_certificate_set_x509_trust_file(x509_cred, CAFILE,
                                                     GNUTLS_X509_FMT_PEM));

        CHECK(gnutls_certificate_set_x509_crl_file(x509_cred, CRLFILE,
                                                   GNUTLS_X509_FMT_PEM));

        /* The following code sets the certificate key pair as well as, 
         * an OCSP response which corresponds to it. It is possible
         * to set multiple key-pairs and multiple OCSP status responses
         * (the latter since 3.5.6). See the manual pages of the individual
         * functions for more information.
         */
        CHECK(gnutls_certificate_set_x509_key_file(x509_cred, CERTFILE,
                                                   KEYFILE,
                                                   GNUTLS_X509_FMT_PEM));

        CHECK(gnutls_certificate_set_ocsp_status_request_file(x509_cred,
                                                              OCSP_STATUS_FILE,
                                                              0));

        CHECK(gnutls_priority_init(&amp;priority_cache, NULL, NULL));

        /* Instead of the default options as shown above one could specify
         * additional options such as server precedence in ciphersuite selection
         * as follows:
         * gnutls_priority_init2(&amp;priority_cache,
         *                       &quot;%SERVER_PRECEDENCE&quot;,
         *                       NULL, GNUTLS_PRIORITY_INIT_DEF_APPEND);
	 */

#if GNUTLS_VERSION_NUMBER &gt;= 0x030506
        /* only available since GnuTLS 3.5.6, on previous versions see
         * gnutls_certificate_set_dh_params(). */
        gnutls_certificate_set_known_dh_params(x509_cred, GNUTLS_SEC_PARAM_MEDIUM);
#endif

        /* Socket operations
         */
        listen_sd = socket(AF_INET, SOCK_STREAM, 0);

        memset(&amp;sa_serv, '\0', sizeof(sa_serv));
        sa_serv.sin_family = AF_INET;
        sa_serv.sin_addr.s_addr = INADDR_ANY;
        sa_serv.sin_port = htons(PORT); /* Server Port number */

        setsockopt(listen_sd, SOL_SOCKET, SO_REUSEADDR, (void *) &amp;optval,
                   sizeof(int));

        bind(listen_sd, (struct sockaddr *) &amp;sa_serv, sizeof(sa_serv));

        listen(listen_sd, 1024);

        printf(&quot;Server ready. Listening to port '%d'.\n\n&quot;, PORT);

        client_len = sizeof(sa_cli);
        for (;;) {
                CHECK(gnutls_init(&amp;session, GNUTLS_SERVER));
                CHECK(gnutls_priority_set(session, priority_cache));
                CHECK(gnutls_credentials_set(session, GNUTLS_CRD_CERTIFICATE,
                                             x509_cred));

                /* We don't request any certificate from the client.
                 * If we did we would need to verify it. One way of
                 * doing that is shown in the &quot;Verifying a certificate&quot;
                 * example.
                 */
                gnutls_certificate_server_set_request(session,
                                                      GNUTLS_CERT_IGNORE);
                gnutls_handshake_set_timeout(session,
                                             GNUTLS_DEFAULT_HANDSHAKE_TIMEOUT);

                sd = accept(listen_sd, (struct sockaddr *) &amp;sa_cli,
                            &amp;client_len);

                printf(&quot;- connection from %s, port %d\n&quot;,
                       inet_ntop(AF_INET, &amp;sa_cli.sin_addr, topbuf,
                                 sizeof(topbuf)), ntohs(sa_cli.sin_port));

                gnutls_transport_set_int(session, sd);

                LOOP_CHECK(ret, gnutls_handshake(session));
                if (ret &lt; 0) {
                        close(sd);
                        gnutls_deinit(session);
                        fprintf(stderr,
                                &quot;*** Handshake has failed (%s)\n\n&quot;,
                                gnutls_strerror(ret));
                        continue;
                }
                printf(&quot;- Handshake was completed\n&quot;);

                /* see the Getting peer's information example */
                /* print_info(session); */

                for (;;) {
                        LOOP_CHECK(ret, gnutls_record_recv(session, buffer, MAX_BUF));

                        if (ret == 0) {
                                printf
                                    (&quot;\n- Peer has closed the GnuTLS connection\n&quot;);
                                break;
                        } else if (ret &lt; 0
                                   &amp;&amp; gnutls_error_is_fatal(ret) == 0) {
                                fprintf(stderr, &quot;*** Warning: %s\n&quot;,
                                        gnutls_strerror(ret));
                        } else if (ret &lt; 0) {
                                fprintf(stderr, &quot;\n*** Received corrupted &quot;
                                        &quot;data(%d). Closing the connection.\n\n&quot;,
                                        ret);
                                break;
                        } else if (ret &gt; 0) {
                                /* echo data back to the client
                                 */
                                CHECK(gnutls_record_send(session, buffer, ret));
                        }
                }
                printf(&quot;\n&quot;);
                /* do not wait for the peer to close the connection.
                 */
                LOOP_CHECK(ret, gnutls_bye(session, GNUTLS_SHUT_WR));

                close(sd);
                gnutls_deinit(session);

        }
        close(listen_sd);

        gnutls_certificate_free_credentials(x509_cred);
        gnutls_priority_deinit(priority_cache);

        gnutls_global_deinit();

        return 0;

}
</pre>

<hr>
<span id="DTLS-echo-server-with-X_002e509-authentication"></span><div class="header">
<p>
Previous: <a href="#Echo-server-with-X_002e509-authentication" accesskey="p" rel="prev">Echo server with X.509 authentication</a>, Up: <a href="#Server-examples" accesskey="u" rel="up">Server examples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="DTLS-echo-server-with-X_002e509-authentication-1"></span><h4 class="subsection">7.2.2 DTLS echo server with <acronym>X.509</acronym> authentication</h4>

<p>This example is a very simple echo server using Datagram TLS and 
<acronym>X.509</acronym> authentication.
</p>
<pre class="verbatim">/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;sys/select.h&gt;
#include &lt;netdb.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;gnutls/gnutls.h&gt;
#include &lt;gnutls/dtls.h&gt;

#define KEYFILE &quot;key.pem&quot;
#define CERTFILE &quot;cert.pem&quot;
#define CAFILE &quot;/etc/ssl/certs/ca-certificates.crt&quot;
#define CRLFILE &quot;crl.pem&quot;

/* This is a sample DTLS echo server, using X.509 authentication.
 * Note that error checking is minimal to simplify the example.
 */

#define LOOP_CHECK(rval, cmd) \
        do { \
                rval = cmd; \
        } while(rval == GNUTLS_E_AGAIN || rval == GNUTLS_E_INTERRUPTED)

#define MAX_BUFFER 1024
#define PORT 5557

typedef struct {
        gnutls_session_t session;
        int fd;
        struct sockaddr *cli_addr;
        socklen_t cli_addr_size;
} priv_data_st;

static int pull_timeout_func(gnutls_transport_ptr_t ptr, unsigned int ms);
static ssize_t push_func(gnutls_transport_ptr_t p, const void *data,
                         size_t size);
static ssize_t pull_func(gnutls_transport_ptr_t p, void *data,
                         size_t size);
static const char *human_addr(const struct sockaddr *sa, socklen_t salen,
                              char *buf, size_t buflen);
static int wait_for_connection(int fd);

/* Use global credentials and parameters to simplify
 * the example. */
static gnutls_certificate_credentials_t x509_cred;
static gnutls_priority_t priority_cache;

int main(void)
{
        int listen_sd;
        int sock, ret;
        struct sockaddr_in sa_serv;
        struct sockaddr_in cli_addr;
        socklen_t cli_addr_size;
        gnutls_session_t session;
        char buffer[MAX_BUFFER];
        priv_data_st priv;
        gnutls_datum_t cookie_key;
        gnutls_dtls_prestate_st prestate;
        int mtu = 1400;
        unsigned char sequence[8];

        /* this must be called once in the program
         */
        gnutls_global_init();

        gnutls_certificate_allocate_credentials(&amp;x509_cred);
        gnutls_certificate_set_x509_trust_file(x509_cred, CAFILE,
                                               GNUTLS_X509_FMT_PEM);

        gnutls_certificate_set_x509_crl_file(x509_cred, CRLFILE,
                                             GNUTLS_X509_FMT_PEM);

        ret =
            gnutls_certificate_set_x509_key_file(x509_cred, CERTFILE,
                                                 KEYFILE,
                                                 GNUTLS_X509_FMT_PEM);
        if (ret &lt; 0) {
                printf(&quot;No certificate or key were found\n&quot;);
                exit(1);
        }

        gnutls_certificate_set_known_dh_params(x509_cred, GNUTLS_SEC_PARAM_MEDIUM);

        /* pre-3.6.3 equivalent:
         * gnutls_priority_init(&amp;priority_cache,
         *                      &quot;NORMAL:-VERS-TLS-ALL:+VERS-DTLS1.0:%SERVER_PRECEDENCE&quot;,
         *                      NULL);
         */
        gnutls_priority_init2(&amp;priority_cache,
                              &quot;%SERVER_PRECEDENCE&quot;,
                              NULL, GNUTLS_PRIORITY_INIT_DEF_APPEND);

        gnutls_key_generate(&amp;cookie_key, GNUTLS_COOKIE_KEY_SIZE);

        /* Socket operations
         */
        listen_sd = socket(AF_INET, SOCK_DGRAM, 0);

        memset(&amp;sa_serv, '\0', sizeof(sa_serv));
        sa_serv.sin_family = AF_INET;
        sa_serv.sin_addr.s_addr = INADDR_ANY;
        sa_serv.sin_port = htons(PORT);

        {                       /* DTLS requires the IP don't fragment (DF) bit to be set */
#if defined(IP_DONTFRAG)
                int optval = 1;
                setsockopt(listen_sd, IPPROTO_IP, IP_DONTFRAG,
                           (const void *) &amp;optval, sizeof(optval));
#elif defined(IP_MTU_DISCOVER)
                int optval = IP_PMTUDISC_DO;
                setsockopt(listen_sd, IPPROTO_IP, IP_MTU_DISCOVER,
                           (const void *) &amp;optval, sizeof(optval));
#endif
        }

        bind(listen_sd, (struct sockaddr *) &amp;sa_serv, sizeof(sa_serv));

        printf(&quot;UDP server ready. Listening to port '%d'.\n\n&quot;, PORT);

        for (;;) {
                printf(&quot;Waiting for connection...\n&quot;);
                sock = wait_for_connection(listen_sd);
                if (sock &lt; 0)
                        continue;

                cli_addr_size = sizeof(cli_addr);
                ret = recvfrom(sock, buffer, sizeof(buffer), MSG_PEEK,
                               (struct sockaddr *) &amp;cli_addr,
                               &amp;cli_addr_size);
                if (ret &gt; 0) {
                        memset(&amp;prestate, 0, sizeof(prestate));
                        ret =
                            gnutls_dtls_cookie_verify(&amp;cookie_key,
                                                      &amp;cli_addr,
                                                      sizeof(cli_addr),
                                                      buffer, ret,
                                                      &amp;prestate);
                        if (ret &lt; 0) {  /* cookie not valid */
                                priv_data_st s;

                                memset(&amp;s, 0, sizeof(s));
                                s.fd = sock;
                                s.cli_addr = (void *) &amp;cli_addr;
                                s.cli_addr_size = sizeof(cli_addr);

                                printf
                                    (&quot;Sending hello verify request to %s\n&quot;,
                                     human_addr((struct sockaddr *)
                                                &amp;cli_addr,
                                                sizeof(cli_addr), buffer,
                                                sizeof(buffer)));

                                gnutls_dtls_cookie_send(&amp;cookie_key,
                                                        &amp;cli_addr,
                                                        sizeof(cli_addr),
                                                        &amp;prestate,
                                                        (gnutls_transport_ptr_t)
                                                        &amp; s, push_func);

                                /* discard peeked data */
                                recvfrom(sock, buffer, sizeof(buffer), 0,
                                         (struct sockaddr *) &amp;cli_addr,
                                         &amp;cli_addr_size);
                                usleep(100);
                                continue;
                        }
                        printf(&quot;Accepted connection from %s\n&quot;,
                               human_addr((struct sockaddr *)
                                          &amp;cli_addr, sizeof(cli_addr),
                                          buffer, sizeof(buffer)));
                } else
                        continue;

                gnutls_init(&amp;session, GNUTLS_SERVER | GNUTLS_DATAGRAM);
                gnutls_priority_set(session, priority_cache);
                gnutls_credentials_set(session, GNUTLS_CRD_CERTIFICATE,
                                       x509_cred);

                gnutls_dtls_prestate_set(session, &amp;prestate);
                gnutls_dtls_set_mtu(session, mtu);

                priv.session = session;
                priv.fd = sock;
                priv.cli_addr = (struct sockaddr *) &amp;cli_addr;
                priv.cli_addr_size = sizeof(cli_addr);

                gnutls_transport_set_ptr(session, &amp;priv);
                gnutls_transport_set_push_function(session, push_func);
                gnutls_transport_set_pull_function(session, pull_func);
                gnutls_transport_set_pull_timeout_function(session,
                                                           pull_timeout_func);

                LOOP_CHECK(ret, gnutls_handshake(session));
                /* Note that DTLS may also receive GNUTLS_E_LARGE_PACKET.
                 * In that case the MTU should be adjusted.
                 */

                if (ret &lt; 0) {
                        fprintf(stderr, &quot;Error in handshake(): %s\n&quot;,
                                gnutls_strerror(ret));
                        gnutls_deinit(session);
                        continue;
                }

                printf(&quot;- Handshake was completed\n&quot;);

                for (;;) {
                        LOOP_CHECK(ret,
                                    gnutls_record_recv_seq(session, buffer,
                                                           MAX_BUFFER,
                                                           sequence));

                        if (ret &lt; 0 &amp;&amp; gnutls_error_is_fatal(ret) == 0) {
                                fprintf(stderr, &quot;*** Warning: %s\n&quot;,
                                        gnutls_strerror(ret));
                                continue;
                        } else if (ret &lt; 0) {
                                fprintf(stderr, &quot;Error in recv(): %s\n&quot;,
                                        gnutls_strerror(ret));
                                break;
                        }

                        if (ret == 0) {
                                printf(&quot;EOF\n\n&quot;);
                                break;
                        }

                        buffer[ret] = 0;
                        printf
                            (&quot;received[%.2x%.2x%.2x%.2x%.2x%.2x%.2x%.2x]: %s\n&quot;,
                             sequence[0], sequence[1], sequence[2],
                             sequence[3], sequence[4], sequence[5],
                             sequence[6], sequence[7], buffer);

                        /* reply back */
                        LOOP_CHECK(ret, gnutls_record_send(session, buffer, ret));
                        if (ret &lt; 0) {
                                fprintf(stderr, &quot;Error in send(): %s\n&quot;,
                                        gnutls_strerror(ret));
                                break;
                        }
                }

                LOOP_CHECK(ret, gnutls_bye(session, GNUTLS_SHUT_WR));
                gnutls_deinit(session);

        }
        close(listen_sd);

        gnutls_certificate_free_credentials(x509_cred);
        gnutls_priority_deinit(priority_cache);

        gnutls_global_deinit();

        return 0;

}

static int wait_for_connection(int fd)
{
        fd_set rd, wr;
        int n;

        FD_ZERO(&amp;rd);
        FD_ZERO(&amp;wr);

        FD_SET(fd, &amp;rd);

        /* waiting part */
        n = select(fd + 1, &amp;rd, &amp;wr, NULL, NULL);
        if (n == -1 &amp;&amp; errno == EINTR)
                return -1;
        if (n &lt; 0) {
                perror(&quot;select()&quot;);
                exit(1);
        }

        return fd;
}

/* Wait for data to be received within a timeout period in milliseconds
 */
static int pull_timeout_func(gnutls_transport_ptr_t ptr, unsigned int ms)
{
        fd_set rfds;
        struct timeval tv;
        priv_data_st *priv = ptr;
        struct sockaddr_in cli_addr;
        socklen_t cli_addr_size;
        int ret;
        char c;

        FD_ZERO(&amp;rfds);
        FD_SET(priv-&gt;fd, &amp;rfds);

        tv.tv_sec = ms / 1000;
        tv.tv_usec = (ms % 1000) * 1000;

        ret = select(priv-&gt;fd + 1, &amp;rfds, NULL, NULL, &amp;tv);

        if (ret &lt;= 0)
                return ret;

        /* only report ok if the next message is from the peer we expect
         * from 
         */
        cli_addr_size = sizeof(cli_addr);
        ret =
            recvfrom(priv-&gt;fd, &amp;c, 1, MSG_PEEK,
                     (struct sockaddr *) &amp;cli_addr, &amp;cli_addr_size);
        if (ret &gt; 0) {
                if (cli_addr_size == priv-&gt;cli_addr_size
                    &amp;&amp; memcmp(&amp;cli_addr, priv-&gt;cli_addr,
                              sizeof(cli_addr)) == 0)
                        return 1;
        }

        return 0;
}

static ssize_t
push_func(gnutls_transport_ptr_t p, const void *data, size_t size)
{
        priv_data_st *priv = p;

        return sendto(priv-&gt;fd, data, size, 0, priv-&gt;cli_addr,
                      priv-&gt;cli_addr_size);
}

static ssize_t pull_func(gnutls_transport_ptr_t p, void *data, size_t size)
{
        priv_data_st *priv = p;
        struct sockaddr_in cli_addr;
        socklen_t cli_addr_size;
        char buffer[64];
        int ret;

        cli_addr_size = sizeof(cli_addr);
        ret =
            recvfrom(priv-&gt;fd, data, size, 0,
                     (struct sockaddr *) &amp;cli_addr, &amp;cli_addr_size);
        if (ret == -1)
                return ret;

        if (cli_addr_size == priv-&gt;cli_addr_size
            &amp;&amp; memcmp(&amp;cli_addr, priv-&gt;cli_addr, sizeof(cli_addr)) == 0)
                return ret;

        printf(&quot;Denied connection from %s\n&quot;,
               human_addr((struct sockaddr *)
                          &amp;cli_addr, sizeof(cli_addr), buffer,
                          sizeof(buffer)));

        gnutls_transport_set_errno(priv-&gt;session, EAGAIN);
        return -1;
}

static const char *human_addr(const struct sockaddr *sa, socklen_t salen,
                              char *buf, size_t buflen)
{
        const char *save_buf = buf;
        size_t l;

        if (!buf || !buflen)
                return NULL;

        *buf = '\0';

        switch (sa-&gt;sa_family) {
#if HAVE_IPV6
        case AF_INET6:
                snprintf(buf, buflen, &quot;IPv6 &quot;);
                break;
#endif

        case AF_INET:
                snprintf(buf, buflen, &quot;IPv4 &quot;);
                break;
        }

        l = strlen(buf);
        buf += l;
        buflen -= l;

        if (getnameinfo(sa, salen, buf, buflen, NULL, 0, NI_NUMERICHOST) !=
            0)
                return NULL;

        l = strlen(buf);
        buf += l;
        buflen -= l;

        strncat(buf, &quot; port &quot;, buflen);

        l = strlen(buf);
        buf += l;
        buflen -= l;

        if (getnameinfo(sa, salen, NULL, 0, buf, buflen, NI_NUMERICSERV) !=
            0)
                return NULL;

        return save_buf;
}

</pre>



<hr>
<span id="More-advanced-client-and-servers"></span><div class="header">
<p>
Next: <a href="#OCSP-example" accesskey="n" rel="next">OCSP example</a>, Previous: <a href="#Server-examples" accesskey="p" rel="prev">Server examples</a>, Up: <a href="#GnuTLS-application-examples" accesskey="u" rel="up">GnuTLS application examples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="More-advanced-client-and-servers-1"></span><h3 class="section">7.3 More advanced client and servers</h3>

<p>This section has various, more advanced topics in client and servers.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Client-example-with-anonymous-authentication" accesskey="1">Client example with anonymous authentication</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Using-a-callback-to-select-the-certificate-to-use" accesskey="2">Using a callback to select the certificate to use</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Obtaining-session-information" accesskey="3">Obtaining session information</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Advanced-certificate-verification-example" accesskey="4">Advanced certificate verification example</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Client-example-with-PSK-authentication" accesskey="5">Client example with PSK authentication</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Client-example-with-SRP-authentication" accesskey="6">Client example with SRP authentication</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Legacy-client-example-with-X_002e509-certificate-support" accesskey="7">Legacy client example with X.509 certificate support</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Client-example-in-C_002b_002b" accesskey="8">Client example in C++</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Echo-server-with-PSK-authentication" accesskey="9">Echo server with PSK authentication</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Echo-server-with-SRP-authentication">Echo server with SRP authentication</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Echo-server-with-anonymous-authentication">Echo server with anonymous authentication</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Helper-functions-for-TCP-connections">Helper functions for TCP connections</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Helper-functions-for-UDP-connections">Helper functions for UDP connections</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Client-example-with-anonymous-authentication"></span><div class="header">
<p>
Next: <a href="#Using-a-callback-to-select-the-certificate-to-use" accesskey="n" rel="next">Using a callback to select the certificate to use</a>, Up: <a href="#More-advanced-client-and-servers" accesskey="u" rel="up">More advanced client and servers</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Client-example-with-anonymous-authentication-1"></span><h4 class="subsection">7.3.1 Client example with anonymous authentication</h4>

<p>The simplest client using TLS is the one that doesn&rsquo;t do any
authentication.  This means no external certificates or passwords are
needed to set up the connection.  As could be expected, the connection
is vulnerable to man-in-the-middle (active or redirection) attacks.
However, the data are integrity protected and encrypted from
passive eavesdroppers.
</p>
<p>Note that due to the vulnerable nature of this method very few public
servers support it.
</p>
<pre class="verbatim">/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;unistd.h&gt;
#include &lt;assert.h&gt;
#include &lt;gnutls/gnutls.h&gt;

/* A very basic TLS client, with anonymous authentication.
 */

#define LOOP_CHECK(rval, cmd) \
        do { \
                rval = cmd; \
        } while(rval == GNUTLS_E_AGAIN || rval == GNUTLS_E_INTERRUPTED); \
        assert(rval &gt;= 0)

#define MAX_BUF 1024
#define MSG &quot;GET / HTTP/1.0\r\n\r\n&quot;

extern int tcp_connect(void);
extern void tcp_close(int sd);

int main(void)
{
        int ret, sd, ii;
        gnutls_session_t session;
        char buffer[MAX_BUF + 1];
        gnutls_anon_client_credentials_t anoncred;
        /* Need to enable anonymous KX specifically. */

        gnutls_global_init();

        gnutls_anon_allocate_client_credentials(&amp;anoncred);

        /* Initialize TLS session 
         */
        gnutls_init(&amp;session, GNUTLS_CLIENT);

        /* Use default priorities */
        gnutls_priority_set_direct(session,
                                   &quot;PERFORMANCE:+ANON-ECDH:+ANON-DH&quot;,
                                   NULL);

        /* put the anonymous credentials to the current session
         */
        gnutls_credentials_set(session, GNUTLS_CRD_ANON, anoncred);

        /* connect to the peer
         */
        sd = tcp_connect();

        gnutls_transport_set_int(session, sd);
        gnutls_handshake_set_timeout(session,
                                     GNUTLS_DEFAULT_HANDSHAKE_TIMEOUT);

        /* Perform the TLS handshake
         */
        do {
                ret = gnutls_handshake(session);
        }
        while (ret &lt; 0 &amp;&amp; gnutls_error_is_fatal(ret) == 0);

        if (ret &lt; 0) {
                fprintf(stderr, &quot;*** Handshake failed\n&quot;);
                gnutls_perror(ret);
                goto end;
        } else {
                char *desc;

                desc = gnutls_session_get_desc(session);
                printf(&quot;- Session info: %s\n&quot;, desc);
                gnutls_free(desc);
        }

        LOOP_CHECK(ret, gnutls_record_send(session, MSG, strlen(MSG)));

        LOOP_CHECK(ret, gnutls_record_recv(session, buffer, MAX_BUF));
        if (ret == 0) {
                printf(&quot;- Peer has closed the TLS connection\n&quot;);
                goto end;
        } else if (ret &lt; 0 &amp;&amp; gnutls_error_is_fatal(ret) == 0) {
                fprintf(stderr, &quot;*** Warning: %s\n&quot;, gnutls_strerror(ret));
        } else if (ret &lt; 0) {
                fprintf(stderr, &quot;*** Error: %s\n&quot;, gnutls_strerror(ret));
                goto end;
        }

        if (ret &gt; 0) {
                printf(&quot;- Received %d bytes: &quot;, ret);
                for (ii = 0; ii &lt; ret; ii++) {
                        fputc(buffer[ii], stdout);
                }
                fputs(&quot;\n&quot;, stdout);
        }

        LOOP_CHECK(ret, gnutls_bye(session, GNUTLS_SHUT_RDWR));

      end:

        tcp_close(sd);

        gnutls_deinit(session);

        gnutls_anon_free_client_credentials(anoncred);

        gnutls_global_deinit();

        return 0;
}
</pre>
<hr>
<span id="Using-a-callback-to-select-the-certificate-to-use"></span><div class="header">
<p>
Next: <a href="#Obtaining-session-information" accesskey="n" rel="next">Obtaining session information</a>, Previous: <a href="#Client-example-with-anonymous-authentication" accesskey="p" rel="prev">Client example with anonymous authentication</a>, Up: <a href="#More-advanced-client-and-servers" accesskey="u" rel="up">More advanced client and servers</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Using-a-callback-to-select-the-certificate-to-use-1"></span><h4 class="subsection">7.3.2 Using a callback to select the certificate to use</h4>

<p>There are cases where a client holds several certificate and key
pairs, and may not want to load all of them in the credentials
structure.  The following example demonstrates the use of the
certificate selection callback.
</p>
<pre class="verbatim">/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;unistd.h&gt;
#include &lt;assert.h&gt;
#include &lt;gnutls/gnutls.h&gt;
#include &lt;gnutls/x509.h&gt;
#include &lt;gnutls/abstract.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;

/* A TLS client that loads the certificate and key.
 */

#define CHECK(x) assert((x)&gt;=0)

#define MAX_BUF 1024
#define MSG &quot;GET / HTTP/1.0\r\n\r\n&quot;

#define CERT_FILE &quot;cert.pem&quot;
#define KEY_FILE &quot;key.pem&quot;
#define CAFILE &quot;/etc/ssl/certs/ca-certificates.crt&quot;

extern int tcp_connect(void);
extern void tcp_close(int sd);

static int
cert_callback(gnutls_session_t session,
              const gnutls_datum_t * req_ca_rdn, int nreqs,
              const gnutls_pk_algorithm_t * sign_algos,
              int sign_algos_length, gnutls_pcert_st ** pcert,
              unsigned int *pcert_length, gnutls_privkey_t * pkey);

gnutls_pcert_st pcrt;
gnutls_privkey_t key;

/* Load the certificate and the private key.
 */
static void load_keys(void)
{
        gnutls_datum_t data;

        CHECK(gnutls_load_file(CERT_FILE, &amp;data));

        CHECK(gnutls_pcert_import_x509_raw(&amp;pcrt, &amp;data,
                                           GNUTLS_X509_FMT_PEM, 0));

        gnutls_free(data.data);

        CHECK(gnutls_load_file(KEY_FILE, &amp;data));

        CHECK(gnutls_privkey_init(&amp;key));

        CHECK(gnutls_privkey_import_x509_raw(key, &amp;data,
                                             GNUTLS_X509_FMT_PEM,
                                             NULL, 0));
        gnutls_free(data.data);
}

int main(void)
{
        int ret, sd, ii;
        gnutls_session_t session;
        char buffer[MAX_BUF + 1];
        gnutls_certificate_credentials_t xcred;
        
        if (gnutls_check_version(&quot;3.1.4&quot;) == NULL) {
                fprintf(stderr, &quot;GnuTLS 3.1.4 or later is required for this example\n&quot;);
                exit(1);
        }

        /* for backwards compatibility with gnutls &lt; 3.3.0 */
        CHECK(gnutls_global_init());

        load_keys();

        /* X509 stuff */
        CHECK(gnutls_certificate_allocate_credentials(&amp;xcred));

        /* sets the trusted cas file
         */
        CHECK(gnutls_certificate_set_x509_trust_file(xcred, CAFILE,
                                                     GNUTLS_X509_FMT_PEM));

        gnutls_certificate_set_retrieve_function2(xcred, cert_callback);

        /* Initialize TLS session 
         */
        CHECK(gnutls_init(&amp;session, GNUTLS_CLIENT));

        /* Use default priorities */
        CHECK(gnutls_set_default_priority(session));

        /* put the x509 credentials to the current session
         */
        CHECK(gnutls_credentials_set(session, GNUTLS_CRD_CERTIFICATE, xcred));

        /* connect to the peer
         */
        sd = tcp_connect();

        gnutls_transport_set_int(session, sd);

        /* Perform the TLS handshake
         */
        ret = gnutls_handshake(session);

        if (ret &lt; 0) {
                fprintf(stderr, &quot;*** Handshake failed\n&quot;);
                gnutls_perror(ret);
                goto end;
        } else {
                char *desc;

                desc = gnutls_session_get_desc(session);
                printf(&quot;- Session info: %s\n&quot;, desc);
                gnutls_free(desc);
        }

        CHECK(gnutls_record_send(session, MSG, strlen(MSG)));

        ret = gnutls_record_recv(session, buffer, MAX_BUF);
        if (ret == 0) {
                printf(&quot;- Peer has closed the TLS connection\n&quot;);
                goto end;
        } else if (ret &lt; 0) {
                fprintf(stderr, &quot;*** Error: %s\n&quot;, gnutls_strerror(ret));
                goto end;
        }

        printf(&quot;- Received %d bytes: &quot;, ret);
        for (ii = 0; ii &lt; ret; ii++) {
                fputc(buffer[ii], stdout);
        }
        fputs(&quot;\n&quot;, stdout);

        CHECK(gnutls_bye(session, GNUTLS_SHUT_RDWR));

      end:

        tcp_close(sd);

        gnutls_deinit(session);

        gnutls_certificate_free_credentials(xcred);

        gnutls_global_deinit();

        return 0;
}



/* This callback should be associated with a session by calling
 * gnutls_certificate_client_set_retrieve_function( session, cert_callback),
 * before a handshake.
 */

static int
cert_callback(gnutls_session_t session,
              const gnutls_datum_t * req_ca_rdn, int nreqs,
              const gnutls_pk_algorithm_t * sign_algos,
              int sign_algos_length, gnutls_pcert_st ** pcert,
              unsigned int *pcert_length, gnutls_privkey_t * pkey)
{
        char issuer_dn[256];
        int i, ret;
        size_t len;
        gnutls_certificate_type_t type;

        /* Print the server's trusted CAs
         */
        if (nreqs &gt; 0)
                printf(&quot;- Server's trusted authorities:\n&quot;);
        else
                printf
                    (&quot;- Server did not send us any trusted authorities names.\n&quot;);

        /* print the names (if any) */
        for (i = 0; i &lt; nreqs; i++) {
                len = sizeof(issuer_dn);
                ret = gnutls_x509_rdn_get(&amp;req_ca_rdn[i], issuer_dn, &amp;len);
                if (ret &gt;= 0) {
                        printf(&quot;   [%d]: &quot;, i);
                        printf(&quot;%s\n&quot;, issuer_dn);
                }
        }

        /* Select a certificate and return it.
         * The certificate must be of any of the &quot;sign algorithms&quot;
         * supported by the server.
         */
        type = gnutls_certificate_type_get(session);
        if (type == GNUTLS_CRT_X509) {
                *pcert_length = 1;
                *pcert = &amp;pcrt;
                *pkey = key;
        } else {
                return -1;
        }

        return 0;

}
</pre>

<hr>
<span id="Obtaining-session-information"></span><div class="header">
<p>
Next: <a href="#Advanced-certificate-verification-example" accesskey="n" rel="next">Advanced certificate verification example</a>, Previous: <a href="#Using-a-callback-to-select-the-certificate-to-use" accesskey="p" rel="prev">Using a callback to select the certificate to use</a>, Up: <a href="#More-advanced-client-and-servers" accesskey="u" rel="up">More advanced client and servers</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Obtaining-session-information-1"></span><h4 class="subsection">7.3.3 Obtaining session information</h4>

<p>Most of the times it is desirable to know the security properties of
the current established session.  This includes the underlying ciphers
and the protocols involved.  That is the purpose of the following
function.  Note that this function will print meaningful values only
if called after a successful <a href="#gnutls_005fhandshake">gnutls_handshake</a>.
</p>
<pre class="verbatim">/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;gnutls/gnutls.h&gt;
#include &lt;gnutls/x509.h&gt;

#include &quot;examples.h&quot;

/* This function will print some details of the
 * given session.
 */
int print_info(gnutls_session_t session)
{
        gnutls_credentials_type_t cred;
        gnutls_kx_algorithm_t kx;
        int dhe, ecdh, group;
        char *desc;

        /* get a description of the session connection, protocol,
         * cipher/key exchange */
        desc = gnutls_session_get_desc(session);
        if (desc != NULL) {
                printf(&quot;- Session: %s\n&quot;, desc);
        }

        dhe = ecdh = 0;

        kx = gnutls_kx_get(session);

        /* Check the authentication type used and switch
         * to the appropriate.
         */
        cred = gnutls_auth_get_type(session);
        switch (cred) {
#ifdef ENABLE_SRP
        case GNUTLS_CRD_SRP:
                printf(&quot;- SRP session with username %s\n&quot;,
                       gnutls_srp_server_get_username(session));
                break;
#endif

        case GNUTLS_CRD_PSK:
                /* This returns NULL in server side.
                 */
                if (gnutls_psk_client_get_hint(session) != NULL)
                        printf(&quot;- PSK authentication. PSK hint '%s'\n&quot;,
                               gnutls_psk_client_get_hint(session));
                /* This returns NULL in client side.
                 */
                if (gnutls_psk_server_get_username(session) != NULL)
                        printf(&quot;- PSK authentication. Connected as '%s'\n&quot;,
                               gnutls_psk_server_get_username(session));

                if (kx == GNUTLS_KX_ECDHE_PSK)
                        ecdh = 1;
                else if (kx == GNUTLS_KX_DHE_PSK)
                        dhe = 1;
                break;

        case GNUTLS_CRD_ANON:  /* anonymous authentication */

                printf(&quot;- Anonymous authentication.\n&quot;);
                if (kx == GNUTLS_KX_ANON_ECDH)
                        ecdh = 1;
                else if (kx == GNUTLS_KX_ANON_DH)
                        dhe = 1;
                break;

        case GNUTLS_CRD_CERTIFICATE:   /* certificate authentication */

                /* Check if we have been using ephemeral Diffie-Hellman.
                 */
                if (kx == GNUTLS_KX_DHE_RSA || kx == GNUTLS_KX_DHE_DSS)
                        dhe = 1;
                else if (kx == GNUTLS_KX_ECDHE_RSA
                         || kx == GNUTLS_KX_ECDHE_ECDSA)
                        ecdh = 1;

                /* if the certificate list is available, then
                 * print some information about it.
                 */
                print_x509_certificate_info(session);
                break;
	default:
		break;
        }                       /* switch */

        /* read the negotiated group - if any */
        group = gnutls_group_get(session);
        if (group != 0) {
                printf(&quot;- Negotiated group %s\n&quot;,
                       gnutls_group_get_name(group));
        } else {
                if (ecdh != 0)
                        printf(&quot;- Ephemeral ECDH using curve %s\n&quot;,
	                       gnutls_ecc_curve_get_name(gnutls_ecc_curve_get
                                                         (session)));
                else if (dhe != 0)
                        printf(&quot;- Ephemeral DH using prime of %d bits\n&quot;,
                               gnutls_dh_get_prime_bits(session));
        }

        return 0;
}
</pre>


<hr>
<span id="Advanced-certificate-verification-example"></span><div class="header">
<p>
Next: <a href="#Client-example-with-PSK-authentication" accesskey="n" rel="next">Client example with PSK authentication</a>, Previous: <a href="#Obtaining-session-information" accesskey="p" rel="prev">Obtaining session information</a>, Up: <a href="#More-advanced-client-and-servers" accesskey="u" rel="up">More advanced client and servers</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Advanced-certificate-verification-2"></span><h4 class="subsection">7.3.4 Advanced certificate verification</h4>
<span id="ex_002dverify2"></span>
<p>An example is listed below which uses the high level verification
functions to verify a given certificate chain against a set of CAs
and CRLs.
</p>
<pre class="verbatim">/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;gnutls/gnutls.h&gt;
#include &lt;gnutls/x509.h&gt;

#include &quot;examples.h&quot;

#define CHECK(x) assert((x)&gt;=0)

/* All the available CRLs
 */
gnutls_x509_crl_t *crl_list;
int crl_list_size;

/* All the available trusted CAs
 */
gnutls_x509_crt_t *ca_list;
int ca_list_size;

static int print_details_func(gnutls_x509_crt_t cert,
                              gnutls_x509_crt_t issuer,
                              gnutls_x509_crl_t crl,
                              unsigned int verification_output);

/* This function will try to verify the peer's certificate chain, and
 * also check if the hostname matches.
 */
void
verify_certificate_chain(const char *hostname,
                         const gnutls_datum_t * cert_chain,
                         int cert_chain_length)
{
        int i;
        gnutls_x509_trust_list_t tlist;
        gnutls_x509_crt_t *cert;
        gnutls_datum_t txt;
        unsigned int output;

        /* Initialize the trusted certificate list. This should be done
         * once on initialization. gnutls_x509_crt_list_import2() and
         * gnutls_x509_crl_list_import2() can be used to load them.
         */
        CHECK(gnutls_x509_trust_list_init(&amp;tlist, 0));

        CHECK(gnutls_x509_trust_list_add_cas(tlist, ca_list, ca_list_size, 0));
        CHECK(gnutls_x509_trust_list_add_crls(tlist, crl_list, crl_list_size,
                                              GNUTLS_TL_VERIFY_CRL, 0));

        cert = malloc(sizeof(*cert) * cert_chain_length);
        assert(cert != NULL);

        /* Import all the certificates in the chain to
         * native certificate format.
         */
        for (i = 0; i &lt; cert_chain_length; i++) {
                CHECK(gnutls_x509_crt_init(&amp;cert[i]));
                CHECK(gnutls_x509_crt_import(cert[i], &amp;cert_chain[i],
                                             GNUTLS_X509_FMT_DER));
        }

        CHECK(gnutls_x509_trust_list_verify_named_crt(tlist, cert[0],
                                                hostname,
                                                strlen(hostname),
                                                GNUTLS_VERIFY_DISABLE_CRL_CHECKS,
                                                &amp;output,
                                                print_details_func));

        /* if this certificate is not explicitly trusted verify against CAs 
         */
        if (output != 0) {
                CHECK(gnutls_x509_trust_list_verify_crt(tlist, cert,
                                                  cert_chain_length, 0,
                                                  &amp;output,
                                                  print_details_func));
        }



        if (output &amp; GNUTLS_CERT_INVALID) {
                fprintf(stderr, &quot;Not trusted\n&quot;);
                CHECK(gnutls_certificate_verification_status_print(
                                                     output,
                                                     GNUTLS_CRT_X509,
                                                     &amp;txt, 0));

                fprintf(stderr, &quot;Error: %s\n&quot;, txt.data);
                gnutls_free(txt.data);
        } else
                fprintf(stderr, &quot;Trusted\n&quot;);

        /* Check if the name in the first certificate matches our destination!
         */
        if (!gnutls_x509_crt_check_hostname(cert[0], hostname)) {
                printf
                    (&quot;The certificate's owner does not match hostname '%s'\n&quot;,
                     hostname);
        }

        gnutls_x509_trust_list_deinit(tlist, 1);

        return;
}

static int
print_details_func(gnutls_x509_crt_t cert,
                   gnutls_x509_crt_t issuer, gnutls_x509_crl_t crl,
                   unsigned int verification_output)
{
        char name[512];
        char issuer_name[512];
        size_t name_size;
        size_t issuer_name_size;

        issuer_name_size = sizeof(issuer_name);
        gnutls_x509_crt_get_issuer_dn(cert, issuer_name,
                                      &amp;issuer_name_size);

        name_size = sizeof(name);
        gnutls_x509_crt_get_dn(cert, name, &amp;name_size);

        fprintf(stdout, &quot;\tSubject: %s\n&quot;, name);
        fprintf(stdout, &quot;\tIssuer: %s\n&quot;, issuer_name);

        if (issuer != NULL) {
                issuer_name_size = sizeof(issuer_name);
                gnutls_x509_crt_get_dn(issuer, issuer_name,
                                       &amp;issuer_name_size);

                fprintf(stdout, &quot;\tVerified against: %s\n&quot;, issuer_name);
        }

        if (crl != NULL) {
                issuer_name_size = sizeof(issuer_name);
                gnutls_x509_crl_get_issuer_dn(crl, issuer_name,
                                              &amp;issuer_name_size);

                fprintf(stdout, &quot;\tVerified against CRL of: %s\n&quot;,
                        issuer_name);
        }

        fprintf(stdout, &quot;\tVerification output: %x\n\n&quot;,
                verification_output);

        return 0;
}
</pre>

<hr>
<span id="Client-example-with-PSK-authentication"></span><div class="header">
<p>
Next: <a href="#Client-example-with-SRP-authentication" accesskey="n" rel="next">Client example with SRP authentication</a>, Previous: <a href="#Advanced-certificate-verification-example" accesskey="p" rel="prev">Advanced certificate verification example</a>, Up: <a href="#More-advanced-client-and-servers" accesskey="u" rel="up">More advanced client and servers</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Client-example-with-PSK-authentication-1"></span><h4 class="subsection">7.3.5 Client example with <acronym>PSK</acronym> authentication</h4>

<p>The following client is a very simple <acronym>PSK</acronym> <acronym>TLS</acronym>
client which connects to a server and authenticates using a
<em>username</em> and a <em>key</em>.
</p>
<pre class="verbatim">/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;unistd.h&gt;
#include &lt;assert.h&gt;
#include &lt;gnutls/gnutls.h&gt;

/* A very basic TLS client, with PSK authentication.
 */

#define CHECK(x) assert((x)&gt;=0)
#define LOOP_CHECK(rval, cmd) \
        do { \
                rval = cmd; \
        } while(rval == GNUTLS_E_AGAIN || rval == GNUTLS_E_INTERRUPTED); \
        assert(rval &gt;= 0)

#define MAX_BUF 1024
#define MSG &quot;GET / HTTP/1.0\r\n\r\n&quot;

extern int tcp_connect(void);
extern void tcp_close(int sd);

int main(void)
{
        int ret, sd, ii;
        gnutls_session_t session;
        char buffer[MAX_BUF + 1];
        const char *err;
        gnutls_psk_client_credentials_t pskcred;
        const gnutls_datum_t key = { (void *) &quot;DEADBEEF&quot;, 8 };

        if (gnutls_check_version(&quot;3.6.3&quot;) == NULL) {
                fprintf(stderr, &quot;GnuTLS 3.6.3 or later is required for this example\n&quot;);
                exit(1);
        }

        CHECK(gnutls_global_init());

        CHECK(gnutls_psk_allocate_client_credentials(&amp;pskcred));
        CHECK(gnutls_psk_set_client_credentials(pskcred, &quot;test&quot;, &amp;key,
                                                GNUTLS_PSK_KEY_HEX));

        /* Initialize TLS session
         */
        CHECK(gnutls_init(&amp;session, GNUTLS_CLIENT));

        ret =
            gnutls_set_default_priority_append(session,
                                         &quot;-KX-ALL:+ECDHE-PSK:+DHE-PSK:+PSK&quot;,
                                         &amp;err, 0);

        /* Alternative for pre-3.6.3 versions:
         * gnutls_priority_set_direct(session, &quot;NORMAL:+ECDHE-PSK:+DHE-PSK:+PSK&quot;, &amp;err)
         */
        if (ret &lt; 0) {
                if (ret == GNUTLS_E_INVALID_REQUEST) {
                        fprintf(stderr, &quot;Syntax error at: %s\n&quot;, err);
                }
                exit(1);
        }

        /* put the x509 credentials to the current session
         */
        CHECK(gnutls_credentials_set(session, GNUTLS_CRD_PSK, pskcred));

        /* connect to the peer
         */
        sd = tcp_connect();

        gnutls_transport_set_int(session, sd);
        gnutls_handshake_set_timeout(session,
                                     GNUTLS_DEFAULT_HANDSHAKE_TIMEOUT);

        /* Perform the TLS handshake
         */
        do {
                ret = gnutls_handshake(session);
        }
        while (ret &lt; 0 &amp;&amp; gnutls_error_is_fatal(ret) == 0);

        if (ret &lt; 0) {
                fprintf(stderr, &quot;*** Handshake failed\n&quot;);
                gnutls_perror(ret);
                goto end;
        } else {
                char *desc;

                desc = gnutls_session_get_desc(session);
                printf(&quot;- Session info: %s\n&quot;, desc);
                gnutls_free(desc);
        }

        LOOP_CHECK(ret, gnutls_record_send(session, MSG, strlen(MSG)));

        LOOP_CHECK(ret, gnutls_record_recv(session, buffer, MAX_BUF));
        if (ret == 0) {
                printf(&quot;- Peer has closed the TLS connection\n&quot;);
                goto end;
        } else if (ret &lt; 0 &amp;&amp; gnutls_error_is_fatal(ret) == 0) {
                fprintf(stderr, &quot;*** Warning: %s\n&quot;, gnutls_strerror(ret));
        } else if (ret &lt; 0) {
                fprintf(stderr, &quot;*** Error: %s\n&quot;, gnutls_strerror(ret));
                goto end;
        }

        if (ret &gt; 0) {
                printf(&quot;- Received %d bytes: &quot;, ret);
                for (ii = 0; ii &lt; ret; ii++) {
                        fputc(buffer[ii], stdout);
                }
                fputs(&quot;\n&quot;, stdout);
        }

        CHECK(gnutls_bye(session, GNUTLS_SHUT_RDWR));

      end:

        tcp_close(sd);

        gnutls_deinit(session);

        gnutls_psk_free_client_credentials(pskcred);

        gnutls_global_deinit();

        return 0;
}
</pre>

<hr>
<span id="Client-example-with-SRP-authentication"></span><div class="header">
<p>
Next: <a href="#Legacy-client-example-with-X_002e509-certificate-support" accesskey="n" rel="next">Legacy client example with X.509 certificate support</a>, Previous: <a href="#Client-example-with-PSK-authentication" accesskey="p" rel="prev">Client example with PSK authentication</a>, Up: <a href="#More-advanced-client-and-servers" accesskey="u" rel="up">More advanced client and servers</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Client-example-with-SRP-authentication-1"></span><h4 class="subsection">7.3.6 Client example with <acronym>SRP</acronym> authentication</h4>

<p>The following client is a very simple <acronym>SRP</acronym> <acronym>TLS</acronym>
client which connects to a server and authenticates using a
<em>username</em> and a <em>password</em>. The server may authenticate
itself using a certificate, and in that case it has to be verified.
</p>
<pre class="verbatim">/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;gnutls/gnutls.h&gt;

/* Those functions are defined in other examples.
 */
extern void check_alert(gnutls_session_t session, int ret);
extern int tcp_connect(void);
extern void tcp_close(int sd);

#define MAX_BUF 1024
#define USERNAME &quot;user&quot;
#define PASSWORD &quot;pass&quot;
#define CAFILE &quot;/etc/ssl/certs/ca-certificates.crt&quot;
#define MSG &quot;GET / HTTP/1.0\r\n\r\n&quot;

int main(void)
{
        int ret;
        int sd, ii;
        gnutls_session_t session;
        char buffer[MAX_BUF + 1];
        gnutls_srp_client_credentials_t srp_cred;
        gnutls_certificate_credentials_t cert_cred;

        if (gnutls_check_version(&quot;3.1.4&quot;) == NULL) {
                fprintf(stderr, &quot;GnuTLS 3.1.4 or later is required for this example\n&quot;);
                exit(1);
        }

        /* for backwards compatibility with gnutls &lt; 3.3.0 */
        gnutls_global_init();

        gnutls_srp_allocate_client_credentials(&amp;srp_cred);
        gnutls_certificate_allocate_credentials(&amp;cert_cred);

        gnutls_certificate_set_x509_trust_file(cert_cred, CAFILE,
                                               GNUTLS_X509_FMT_PEM);
        gnutls_srp_set_client_credentials(srp_cred, USERNAME, PASSWORD);

        /* connects to server
         */
        sd = tcp_connect();

        /* Initialize TLS session
         */
        gnutls_init(&amp;session, GNUTLS_CLIENT);


        /* Set the priorities.
         */
        gnutls_priority_set_direct(session,
                                   &quot;NORMAL:+SRP:+SRP-RSA:+SRP-DSS&quot;,
                                   NULL);

        /* put the SRP credentials to the current session
         */
        gnutls_credentials_set(session, GNUTLS_CRD_SRP, srp_cred);
        gnutls_credentials_set(session, GNUTLS_CRD_CERTIFICATE, cert_cred);

        gnutls_transport_set_int(session, sd);
        gnutls_handshake_set_timeout(session,
                                     GNUTLS_DEFAULT_HANDSHAKE_TIMEOUT);

        /* Perform the TLS handshake
         */
        do {
                ret = gnutls_handshake(session);
        }
        while (ret &lt; 0 &amp;&amp; gnutls_error_is_fatal(ret) == 0);

        if (ret &lt; 0) {
                fprintf(stderr, &quot;*** Handshake failed\n&quot;);
                gnutls_perror(ret);
                goto end;
        } else {
                char *desc;

                desc = gnutls_session_get_desc(session);
                printf(&quot;- Session info: %s\n&quot;, desc);
                gnutls_free(desc);
        }

        gnutls_record_send(session, MSG, strlen(MSG));

        ret = gnutls_record_recv(session, buffer, MAX_BUF);
        if (gnutls_error_is_fatal(ret) != 0 || ret == 0) {
                if (ret == 0) {
                        printf
                            (&quot;- Peer has closed the GnuTLS connection\n&quot;);
                        goto end;
                } else {
                        fprintf(stderr, &quot;*** Error: %s\n&quot;,
                                gnutls_strerror(ret));
                        goto end;
                }
        } else
                check_alert(session, ret);

        if (ret &gt; 0) {
                printf(&quot;- Received %d bytes: &quot;, ret);
                for (ii = 0; ii &lt; ret; ii++) {
                        fputc(buffer[ii], stdout);
                }
                fputs(&quot;\n&quot;, stdout);
        }
        gnutls_bye(session, GNUTLS_SHUT_RDWR);

      end:

        tcp_close(sd);

        gnutls_deinit(session);

        gnutls_srp_free_client_credentials(srp_cred);
        gnutls_certificate_free_credentials(cert_cred);

        gnutls_global_deinit();

        return 0;
}
</pre>

<hr>
<span id="Legacy-client-example-with-X_002e509-certificate-support"></span><div class="header">
<p>
Next: <a href="#Client-example-in-C_002b_002b" accesskey="n" rel="next">Client example in C++</a>, Previous: <a href="#Client-example-with-SRP-authentication" accesskey="p" rel="prev">Client example with SRP authentication</a>, Up: <a href="#More-advanced-client-and-servers" accesskey="u" rel="up">More advanced client and servers</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Legacy-client-example-with-X_002e509-certificate-support-1"></span><h4 class="subsection">7.3.7 Legacy client example with <acronym>X.509</acronym> certificate support</h4>
<span id="ex_002dverify_002dlegacy"></span>
<p>For applications that need to maintain compatibility with the GnuTLS 3.1.x
library, this client example is identical to <a href="#Client-example-with-X_002e509-certificate-support">Client example with X.509 certificate support</a>
but utilizes APIs that were available in GnuTLS 3.1.4. 
</p>
<pre class="verbatim">/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;gnutls/gnutls.h&gt;
#include &lt;gnutls/x509.h&gt;
#include &quot;examples.h&quot;

/* A very basic TLS client, with X.509 authentication and server certificate
 * verification utilizing the GnuTLS 3.1.x API. 
 * Note that error recovery is minimal for simplicity.
 */

#define CHECK(x) assert((x)&gt;=0)
#define LOOP_CHECK(rval, cmd) \
        do { \
                rval = cmd; \
        } while(rval == GNUTLS_E_AGAIN || rval == GNUTLS_E_INTERRUPTED); \
        assert(rval &gt;= 0)

#define MAX_BUF 1024
#define CAFILE &quot;/etc/ssl/certs/ca-certificates.crt&quot;
#define MSG &quot;GET / HTTP/1.0\r\n\r\n&quot;

extern int tcp_connect(void);
extern void tcp_close(int sd);
static int _verify_certificate_callback(gnutls_session_t session);

int main(void)
{
        int ret, sd, ii;
        gnutls_session_t session;
        char buffer[MAX_BUF + 1];
        gnutls_certificate_credentials_t xcred;

        if (gnutls_check_version(&quot;3.1.4&quot;) == NULL) {
                fprintf(stderr, &quot;GnuTLS 3.1.4 or later is required for this example\n&quot;);
                exit(1);
        }

        CHECK(gnutls_global_init());

        /* X509 stuff */
        CHECK(gnutls_certificate_allocate_credentials(&amp;xcred));

        /* sets the trusted cas file
         */
        CHECK(gnutls_certificate_set_x509_trust_file(xcred, CAFILE,
                                                     GNUTLS_X509_FMT_PEM));
        gnutls_certificate_set_verify_function(xcred,
                                               _verify_certificate_callback);

        /* If client holds a certificate it can be set using the following:
         *
         gnutls_certificate_set_x509_key_file (xcred, 
         &quot;cert.pem&quot;, &quot;key.pem&quot;, 
         GNUTLS_X509_FMT_PEM); 
         */

        /* Initialize TLS session 
         */
        CHECK(gnutls_init(&amp;session, GNUTLS_CLIENT));

        gnutls_session_set_ptr(session, (void *) &quot;www.example.com&quot;);

        gnutls_server_name_set(session, GNUTLS_NAME_DNS, &quot;www.example.com&quot;,
                               strlen(&quot;www.example.com&quot;));

        /* use default priorities */
        CHECK(gnutls_set_default_priority(session));
#if 0
	/* if more fine-graned control is required */
        ret = gnutls_priority_set_direct(session, 
                                         &quot;NORMAL&quot;, &amp;err);
        if (ret &lt; 0) {
                if (ret == GNUTLS_E_INVALID_REQUEST) {
                        fprintf(stderr, &quot;Syntax error at: %s\n&quot;, err);
                }
                exit(1);
        }
#endif

        /* put the x509 credentials to the current session
         */
        CHECK(gnutls_credentials_set(session, GNUTLS_CRD_CERTIFICATE, xcred));

        /* connect to the peer
         */
        sd = tcp_connect();

        gnutls_transport_set_int(session, sd);
        gnutls_handshake_set_timeout(session,
                                     GNUTLS_DEFAULT_HANDSHAKE_TIMEOUT);

        /* Perform the TLS handshake
         */
        do {
                ret = gnutls_handshake(session);
        }
        while (ret &lt; 0 &amp;&amp; gnutls_error_is_fatal(ret) == 0);

        if (ret &lt; 0) {
                fprintf(stderr, &quot;*** Handshake failed\n&quot;);
                gnutls_perror(ret);
                goto end;
        } else {
                char *desc;

                desc = gnutls_session_get_desc(session);
                printf(&quot;- Session info: %s\n&quot;, desc);
                gnutls_free(desc);
        }

        LOOP_CHECK(ret, gnutls_record_send(session, MSG, strlen(MSG)));

        LOOP_CHECK(ret, gnutls_record_recv(session, buffer, MAX_BUF));
        if (ret == 0) {
                printf(&quot;- Peer has closed the TLS connection\n&quot;);
                goto end;
        } else if (ret &lt; 0 &amp;&amp; gnutls_error_is_fatal(ret) == 0) {
                fprintf(stderr, &quot;*** Warning: %s\n&quot;, gnutls_strerror(ret));
        } else if (ret &lt; 0) {
                fprintf(stderr, &quot;*** Error: %s\n&quot;, gnutls_strerror(ret));
                goto end;
        }

        if (ret &gt; 0) {
                printf(&quot;- Received %d bytes: &quot;, ret);
                for (ii = 0; ii &lt; ret; ii++) {
                        fputc(buffer[ii], stdout);
                }
                fputs(&quot;\n&quot;, stdout);
        }

        CHECK(gnutls_bye(session, GNUTLS_SHUT_RDWR));

      end:

        tcp_close(sd);

        gnutls_deinit(session);

        gnutls_certificate_free_credentials(xcred);

        gnutls_global_deinit();

        return 0;
}

/* This function will verify the peer's certificate, and check
 * if the hostname matches, as well as the activation, expiration dates.
 */
static int _verify_certificate_callback(gnutls_session_t session)
{
        unsigned int status;
        int type;
        const char *hostname;
        gnutls_datum_t out;

        /* read hostname */
        hostname = gnutls_session_get_ptr(session);

        /* This verification function uses the trusted CAs in the credentials
         * structure. So you must have installed one or more CA certificates.
         */

        CHECK(gnutls_certificate_verify_peers3(session, hostname,
					       &amp;status));

        type = gnutls_certificate_type_get(session);

        CHECK(gnutls_certificate_verification_status_print(status, type,
                                                           &amp;out, 0));

        printf(&quot;%s&quot;, out.data);

        gnutls_free(out.data);

        if (status != 0)        /* Certificate is not trusted */
                return GNUTLS_E_CERTIFICATE_ERROR;

        /* notify gnutls to continue handshake normally */
        return 0;
}
</pre>
<hr>
<span id="Client-example-in-C_002b_002b"></span><div class="header">
<p>
Next: <a href="#Echo-server-with-PSK-authentication" accesskey="n" rel="next">Echo server with PSK authentication</a>, Previous: <a href="#Legacy-client-example-with-X_002e509-certificate-support" accesskey="p" rel="prev">Legacy client example with X.509 certificate support</a>, Up: <a href="#More-advanced-client-and-servers" accesskey="u" rel="up">More advanced client and servers</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Client-example-using-the-C_002b_002b-API"></span><h4 class="subsection">7.3.8 Client example using the C++ API</h4>

<p>The following client is a simple example of a client client utilizing
the GnuTLS C++ API.
</p>
<pre class="verbatim">#include &lt;config.h&gt;
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;gnutls/gnutls.h&gt;
#include &lt;gnutls/gnutlsxx.h&gt;
#include &lt;cstring&gt; /* for strlen */

/* A very basic TLS client, with anonymous authentication.
 * written by Eduardo Villanueva Che.
 */

#define MAX_BUF 1024
#define SA struct sockaddr

#define CAFILE &quot;ca.pem&quot;
#define MSG &quot;GET / HTTP/1.0\r\n\r\n&quot;

extern &quot;C&quot;
{
    int tcp_connect(void);
    void tcp_close(int sd);
}


int main(void)
{
    int sd = -1;
    gnutls_global_init();

    try
    {

        /* Allow connections to servers that have OpenPGP keys as well.
         */
        gnutls::client_session session;

        /* X509 stuff */
        gnutls::certificate_credentials credentials;


        /* sets the trusted cas file
         */
        credentials.set_x509_trust_file(CAFILE, GNUTLS_X509_FMT_PEM);
        /* put the x509 credentials to the current session
         */
        session.set_credentials(credentials);

        /* Use default priorities */
        session.set_priority (&quot;NORMAL&quot;, NULL);

        /* connect to the peer
         */
        sd = tcp_connect();
        session.set_transport_ptr((gnutls_transport_ptr_t) (ptrdiff_t)sd);

        /* Perform the TLS handshake
         */
        int ret = session.handshake();
        if (ret &lt; 0)
        {
            throw std::runtime_error(&quot;Handshake failed&quot;);
        }
        else
        {
            std::cout &lt;&lt; &quot;- Handshake was completed&quot; &lt;&lt; std::endl;
        }

        session.send(MSG, strlen(MSG));
        char buffer[MAX_BUF + 1];
        ret = session.recv(buffer, MAX_BUF);
        if (ret == 0)
        {
            throw std::runtime_error(&quot;Peer has closed the TLS connection&quot;);
        }
        else if (ret &lt; 0)
        {
            throw std::runtime_error(gnutls_strerror(ret));
        }

        std::cout &lt;&lt; &quot;- Received &quot; &lt;&lt; ret &lt;&lt; &quot; bytes:&quot; &lt;&lt; std::endl;
        std::cout.write(buffer, ret);
        std::cout &lt;&lt; std::endl;

        session.bye(GNUTLS_SHUT_RDWR);
    }
    catch (std::exception &amp;ex)
    {
        std::cerr &lt;&lt; &quot;Exception caught: &quot; &lt;&lt; ex.what() &lt;&lt; std::endl;
    }

    if (sd != -1)
        tcp_close(sd);

    gnutls_global_deinit();

    return 0;
}
</pre>

<hr>
<span id="Echo-server-with-PSK-authentication"></span><div class="header">
<p>
Next: <a href="#Echo-server-with-SRP-authentication" accesskey="n" rel="next">Echo server with SRP authentication</a>, Previous: <a href="#Client-example-in-C_002b_002b" accesskey="p" rel="prev">Client example in C++</a>, Up: <a href="#More-advanced-client-and-servers" accesskey="u" rel="up">More advanced client and servers</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Echo-server-with-PSK-authentication-1"></span><h4 class="subsection">7.3.9 Echo server with <acronym>PSK</acronym> authentication</h4>

<p>This is a server which supports <acronym>PSK</acronym> authentication.
</p>
<pre class="verbatim">/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;gnutls/gnutls.h&gt;

#define KEYFILE &quot;key.pem&quot;
#define CERTFILE &quot;cert.pem&quot;
#define CAFILE &quot;/etc/ssl/certs/ca-certificates.crt&quot;
#define CRLFILE &quot;crl.pem&quot;

#define LOOP_CHECK(rval, cmd) \
        do { \
                rval = cmd; \
        } while(rval == GNUTLS_E_AGAIN || rval == GNUTLS_E_INTERRUPTED)

/* This is a sample TLS echo server, supporting X.509 and PSK
   authentication.
 */

#define SOCKET_ERR(err,s) if(err==-1) {perror(s);return(1);}
#define MAX_BUF 1024
#define PORT 5556               /* listen to 5556 port */

static int
pskfunc(gnutls_session_t session, const char *username,
        gnutls_datum_t * key)
{
        printf(&quot;psk: username %s\n&quot;, username);
        key-&gt;data = gnutls_malloc(4);
        key-&gt;data[0] = 0xDE;
        key-&gt;data[1] = 0xAD;
        key-&gt;data[2] = 0xBE;
        key-&gt;data[3] = 0xEF;
        key-&gt;size = 4;
        return 0;
}

int main(void)
{
        int err, listen_sd;
        int sd, ret;
        struct sockaddr_in sa_serv;
        struct sockaddr_in sa_cli;
        socklen_t client_len;
        char topbuf[512];
        gnutls_session_t session;
        gnutls_certificate_credentials_t x509_cred;
        gnutls_psk_server_credentials_t psk_cred;
        gnutls_priority_t priority_cache;
        char buffer[MAX_BUF + 1];
        int optval = 1;
        int kx;

        if (gnutls_check_version(&quot;3.1.4&quot;) == NULL) {
                fprintf(stderr, &quot;GnuTLS 3.1.4 or later is required for this example\n&quot;);
                exit(1);
        }

        /* for backwards compatibility with gnutls &lt; 3.3.0 */
        gnutls_global_init();

        gnutls_certificate_allocate_credentials(&amp;x509_cred);
        gnutls_certificate_set_x509_trust_file(x509_cred, CAFILE,
                                               GNUTLS_X509_FMT_PEM);

        gnutls_certificate_set_x509_crl_file(x509_cred, CRLFILE,
                                             GNUTLS_X509_FMT_PEM);

        gnutls_certificate_set_x509_key_file(x509_cred, CERTFILE, KEYFILE,
                                             GNUTLS_X509_FMT_PEM);

        gnutls_psk_allocate_server_credentials(&amp;psk_cred);
        gnutls_psk_set_server_credentials_function(psk_cred, pskfunc);

        /* pre-3.6.3 equivalent:
         * gnutls_priority_init(&amp;priority_cache,
         *                      &quot;NORMAL:+PSK:+ECDHE-PSK:+DHE-PSK&quot;,
         *                      NULL);
         */
        gnutls_priority_init2(&amp;priority_cache,
                              &quot;+ECDHE-PSK:+DHE-PSK:+PSK&quot;,
                              NULL, GNUTLS_PRIORITY_INIT_DEF_APPEND);

        gnutls_certificate_set_known_dh_params(x509_cred, GNUTLS_SEC_PARAM_MEDIUM);

        /* Socket operations
         */
        listen_sd = socket(AF_INET, SOCK_STREAM, 0);
        SOCKET_ERR(listen_sd, &quot;socket&quot;);

        memset(&amp;sa_serv, '\0', sizeof(sa_serv));
        sa_serv.sin_family = AF_INET;
        sa_serv.sin_addr.s_addr = INADDR_ANY;
        sa_serv.sin_port = htons(PORT); /* Server Port number */

        setsockopt(listen_sd, SOL_SOCKET, SO_REUSEADDR, (void *) &amp;optval,
                   sizeof(int));

        err =
            bind(listen_sd, (struct sockaddr *) &amp;sa_serv, sizeof(sa_serv));
        SOCKET_ERR(err, &quot;bind&quot;);
        err = listen(listen_sd, 1024);
        SOCKET_ERR(err, &quot;listen&quot;);

        printf(&quot;Server ready. Listening to port '%d'.\n\n&quot;, PORT);

        client_len = sizeof(sa_cli);
        for (;;) {
                gnutls_init(&amp;session, GNUTLS_SERVER);
                gnutls_priority_set(session, priority_cache);
                gnutls_credentials_set(session, GNUTLS_CRD_CERTIFICATE,
                                       x509_cred);
                gnutls_credentials_set(session, GNUTLS_CRD_PSK, psk_cred);

                /* request client certificate if any.
                 */
                gnutls_certificate_server_set_request(session,
                                                      GNUTLS_CERT_REQUEST);

                sd = accept(listen_sd, (struct sockaddr *) &amp;sa_cli,
                            &amp;client_len);

                printf(&quot;- connection from %s, port %d\n&quot;,
                       inet_ntop(AF_INET, &amp;sa_cli.sin_addr, topbuf,
                                 sizeof(topbuf)), ntohs(sa_cli.sin_port));

                gnutls_transport_set_int(session, sd);
                LOOP_CHECK(ret, gnutls_handshake(session));
                if (ret &lt; 0) {
                        close(sd);
                        gnutls_deinit(session);
                        fprintf(stderr,
                                &quot;*** Handshake has failed (%s)\n\n&quot;,
                                gnutls_strerror(ret));
                        continue;
                }
                printf(&quot;- Handshake was completed\n&quot;);

                kx = gnutls_kx_get(session);
                if (kx == GNUTLS_KX_PSK || kx == GNUTLS_KX_DHE_PSK ||
                    kx == GNUTLS_KX_ECDHE_PSK) {
                        printf(&quot;- User %s was connected\n&quot;,
                               gnutls_psk_server_get_username(session));
                }

                /* see the Getting peer's information example */
                /* print_info(session); */

                for (;;) {
                        LOOP_CHECK(ret, gnutls_record_recv(session, buffer, MAX_BUF));

                        if (ret == 0) {
                                printf
                                    (&quot;\n- Peer has closed the GnuTLS connection\n&quot;);
                                break;
                        } else if (ret &lt; 0
                                   &amp;&amp; gnutls_error_is_fatal(ret) == 0) {
                                fprintf(stderr, &quot;*** Warning: %s\n&quot;,
                                        gnutls_strerror(ret));
                        } else if (ret &lt; 0) {
                                fprintf(stderr, &quot;\n*** Received corrupted &quot;
                                        &quot;data(%d). Closing the connection.\n\n&quot;,
                                        ret);
                                break;
                        } else if (ret &gt; 0) {
                                /* echo data back to the client
                                 */
                                gnutls_record_send(session, buffer, ret);
                        }
                }
                printf(&quot;\n&quot;);
                /* do not wait for the peer to close the connection.
                 */
                LOOP_CHECK(ret, gnutls_bye(session, GNUTLS_SHUT_WR));

                close(sd);
                gnutls_deinit(session);

        }
        close(listen_sd);

        gnutls_certificate_free_credentials(x509_cred);
        gnutls_psk_free_server_credentials(psk_cred);

        gnutls_priority_deinit(priority_cache);

        gnutls_global_deinit();

        return 0;

}
</pre>

<hr>
<span id="Echo-server-with-SRP-authentication"></span><div class="header">
<p>
Next: <a href="#Echo-server-with-anonymous-authentication" accesskey="n" rel="next">Echo server with anonymous authentication</a>, Previous: <a href="#Echo-server-with-PSK-authentication" accesskey="p" rel="prev">Echo server with PSK authentication</a>, Up: <a href="#More-advanced-client-and-servers" accesskey="u" rel="up">More advanced client and servers</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Echo-server-with-SRP-authentication-1"></span><h4 class="subsection">7.3.10 Echo server with <acronym>SRP</acronym> authentication</h4>

<p>This is a server which supports <acronym>SRP</acronym> authentication. It is
also possible to combine this functionality with a certificate
server. Here it is separate for simplicity.
</p>
<pre class="verbatim">/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;gnutls/gnutls.h&gt;

#define SRP_PASSWD &quot;tpasswd&quot;
#define SRP_PASSWD_CONF &quot;tpasswd.conf&quot;

#define KEYFILE &quot;key.pem&quot;
#define CERTFILE &quot;cert.pem&quot;
#define CAFILE &quot;/etc/ssl/certs/ca-certificates.crt&quot;

#define LOOP_CHECK(rval, cmd) \
        do { \
                rval = cmd; \
        } while(rval == GNUTLS_E_AGAIN || rval == GNUTLS_E_INTERRUPTED)

/* This is a sample TLS-SRP echo server.
 */

#define SOCKET_ERR(err,s) if(err==-1) {perror(s);return(1);}
#define MAX_BUF 1024
#define PORT 5556               /* listen to 5556 port */

int main(void)
{
        int err, listen_sd;
        int sd, ret;
        struct sockaddr_in sa_serv;
        struct sockaddr_in sa_cli;
        socklen_t client_len;
        char topbuf[512];
        gnutls_session_t session;
        gnutls_srp_server_credentials_t srp_cred;
        gnutls_certificate_credentials_t cert_cred;
        char buffer[MAX_BUF + 1];
        int optval = 1;
        char name[256];

        strcpy(name, &quot;Echo Server&quot;);

        if (gnutls_check_version(&quot;3.1.4&quot;) == NULL) {
                fprintf(stderr, &quot;GnuTLS 3.1.4 or later is required for this example\n&quot;);
                exit(1);
        }

        /* for backwards compatibility with gnutls &lt; 3.3.0 */
        gnutls_global_init();

        /* SRP_PASSWD a password file (created with the included srptool utility) 
         */
        gnutls_srp_allocate_server_credentials(&amp;srp_cred);
        gnutls_srp_set_server_credentials_file(srp_cred, SRP_PASSWD,
                                               SRP_PASSWD_CONF);

        gnutls_certificate_allocate_credentials(&amp;cert_cred);
        gnutls_certificate_set_x509_trust_file(cert_cred, CAFILE,
                                               GNUTLS_X509_FMT_PEM);
        gnutls_certificate_set_x509_key_file(cert_cred, CERTFILE, KEYFILE,
                                             GNUTLS_X509_FMT_PEM);

        /* TCP socket operations
         */
        listen_sd = socket(AF_INET, SOCK_STREAM, 0);
        SOCKET_ERR(listen_sd, &quot;socket&quot;);

        memset(&amp;sa_serv, '\0', sizeof(sa_serv));
        sa_serv.sin_family = AF_INET;
        sa_serv.sin_addr.s_addr = INADDR_ANY;
        sa_serv.sin_port = htons(PORT); /* Server Port number */

        setsockopt(listen_sd, SOL_SOCKET, SO_REUSEADDR, (void *) &amp;optval,
                   sizeof(int));

        err =
            bind(listen_sd, (struct sockaddr *) &amp;sa_serv, sizeof(sa_serv));
        SOCKET_ERR(err, &quot;bind&quot;);
        err = listen(listen_sd, 1024);
        SOCKET_ERR(err, &quot;listen&quot;);

        printf(&quot;%s ready. Listening to port '%d'.\n\n&quot;, name, PORT);

        client_len = sizeof(sa_cli);
        for (;;) {
                gnutls_init(&amp;session, GNUTLS_SERVER);
                gnutls_priority_set_direct(session,
                                           &quot;NORMAL&quot;
                                           &quot;:-KX-ALL:+SRP:+SRP-DSS:+SRP-RSA&quot;,
                                           NULL);
                gnutls_credentials_set(session, GNUTLS_CRD_SRP, srp_cred);
                /* for the certificate authenticated ciphersuites.
                 */
                gnutls_credentials_set(session, GNUTLS_CRD_CERTIFICATE,
                                       cert_cred);

                /* We don't request any certificate from the client.
                 * If we did we would need to verify it. One way of
                 * doing that is shown in the &quot;Verifying a certificate&quot;
                 * example.
                 */
                gnutls_certificate_server_set_request(session,
                                                      GNUTLS_CERT_IGNORE);

                sd = accept(listen_sd, (struct sockaddr *) &amp;sa_cli,
                            &amp;client_len);

                printf(&quot;- connection from %s, port %d\n&quot;,
                       inet_ntop(AF_INET, &amp;sa_cli.sin_addr, topbuf,
                                 sizeof(topbuf)), ntohs(sa_cli.sin_port));

                gnutls_transport_set_int(session, sd);

                LOOP_CHECK(ret, gnutls_handshake(session));
                if (ret &lt; 0) {
                        close(sd);
                        gnutls_deinit(session);
                        fprintf(stderr,
                                &quot;*** Handshake has failed (%s)\n\n&quot;,
                                gnutls_strerror(ret));
                        continue;
                }
                printf(&quot;- Handshake was completed\n&quot;);
                printf(&quot;- User %s was connected\n&quot;,
                       gnutls_srp_server_get_username(session));

                /* print_info(session); */

                for (;;) {
                        LOOP_CHECK(ret, gnutls_record_recv(session, buffer, MAX_BUF));

                        if (ret == 0) {
                                printf
                                    (&quot;\n- Peer has closed the GnuTLS connection\n&quot;);
                                break;
                        } else if (ret &lt; 0
                                   &amp;&amp; gnutls_error_is_fatal(ret) == 0) {
                                fprintf(stderr, &quot;*** Warning: %s\n&quot;,
                                        gnutls_strerror(ret));
                        } else if (ret &lt; 0) {
                                fprintf(stderr, &quot;\n*** Received corrupted &quot;
                                        &quot;data(%d). Closing the connection.\n\n&quot;,
                                        ret);
                                break;
                        } else if (ret &gt; 0) {
                                /* echo data back to the client
                                 */
                                gnutls_record_send(session, buffer, ret);
                        }
                }
                printf(&quot;\n&quot;);
                /* do not wait for the peer to close the connection. */
                LOOP_CHECK(ret, gnutls_bye(session, GNUTLS_SHUT_WR));

                close(sd);
                gnutls_deinit(session);

        }
        close(listen_sd);

        gnutls_srp_free_server_credentials(srp_cred);
        gnutls_certificate_free_credentials(cert_cred);

        gnutls_global_deinit();

        return 0;

}
</pre>

<hr>
<span id="Echo-server-with-anonymous-authentication"></span><div class="header">
<p>
Next: <a href="#Helper-functions-for-TCP-connections" accesskey="n" rel="next">Helper functions for TCP connections</a>, Previous: <a href="#Echo-server-with-SRP-authentication" accesskey="p" rel="prev">Echo server with SRP authentication</a>, Up: <a href="#More-advanced-client-and-servers" accesskey="u" rel="up">More advanced client and servers</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Echo-server-with-anonymous-authentication-1"></span><h4 class="subsection">7.3.11 Echo server with anonymous authentication</h4>

<p>This example server supports anonymous authentication, and could be
used to serve the example client for anonymous authentication.
</p>
<pre class="verbatim">/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;gnutls/gnutls.h&gt;

/* This is a sample TLS 1.0 echo server, for anonymous authentication only.
 */


#define SOCKET_ERR(err,s) if(err==-1) {perror(s);return(1);}
#define MAX_BUF 1024
#define PORT 5556               /* listen to 5556 port */

int main(void)
{
        int err, listen_sd;
        int sd, ret;
        struct sockaddr_in sa_serv;
        struct sockaddr_in sa_cli;
        socklen_t client_len;
        char topbuf[512];
        gnutls_session_t session;
        gnutls_anon_server_credentials_t anoncred;
        char buffer[MAX_BUF + 1];
        int optval = 1;

        if (gnutls_check_version(&quot;3.1.4&quot;) == NULL) {
                fprintf(stderr, &quot;GnuTLS 3.1.4 or later is required for this example\n&quot;);
                exit(1);
        }

        /* for backwards compatibility with gnutls &lt; 3.3.0 */
        gnutls_global_init();

        gnutls_anon_allocate_server_credentials(&amp;anoncred);

        gnutls_anon_set_server_known_dh_params(anoncred, GNUTLS_SEC_PARAM_MEDIUM);

        /* Socket operations
         */
        listen_sd = socket(AF_INET, SOCK_STREAM, 0);
        SOCKET_ERR(listen_sd, &quot;socket&quot;);

        memset(&amp;sa_serv, '\0', sizeof(sa_serv));
        sa_serv.sin_family = AF_INET;
        sa_serv.sin_addr.s_addr = INADDR_ANY;
        sa_serv.sin_port = htons(PORT); /* Server Port number */

        setsockopt(listen_sd, SOL_SOCKET, SO_REUSEADDR, (void *) &amp;optval,
                   sizeof(int));

        err =
            bind(listen_sd, (struct sockaddr *) &amp;sa_serv, sizeof(sa_serv));
        SOCKET_ERR(err, &quot;bind&quot;);
        err = listen(listen_sd, 1024);
        SOCKET_ERR(err, &quot;listen&quot;);

        printf(&quot;Server ready. Listening to port '%d'.\n\n&quot;, PORT);

        client_len = sizeof(sa_cli);
        for (;;) {
                gnutls_init(&amp;session, GNUTLS_SERVER);
                gnutls_priority_set_direct(session,
                                           &quot;NORMAL:+ANON-ECDH:+ANON-DH&quot;,
                                           NULL);
                gnutls_credentials_set(session, GNUTLS_CRD_ANON, anoncred);

                sd = accept(listen_sd, (struct sockaddr *) &amp;sa_cli,
                            &amp;client_len);

                printf(&quot;- connection from %s, port %d\n&quot;,
                       inet_ntop(AF_INET, &amp;sa_cli.sin_addr, topbuf,
                                 sizeof(topbuf)), ntohs(sa_cli.sin_port));

                gnutls_transport_set_int(session, sd);

                do {
                        ret = gnutls_handshake(session);
                }
                while (ret &lt; 0 &amp;&amp; gnutls_error_is_fatal(ret) == 0);

                if (ret &lt; 0) {
                        close(sd);
                        gnutls_deinit(session);
                        fprintf(stderr,
                                &quot;*** Handshake has failed (%s)\n\n&quot;,
                                gnutls_strerror(ret));
                        continue;
                }
                printf(&quot;- Handshake was completed\n&quot;);

                /* see the Getting peer's information example */
                /* print_info(session); */

                for (;;) {
                        ret = gnutls_record_recv(session, buffer, MAX_BUF);

                        if (ret == 0) {
                                printf
                                    (&quot;\n- Peer has closed the GnuTLS connection\n&quot;);
                                break;
                        } else if (ret &lt; 0
                                   &amp;&amp; gnutls_error_is_fatal(ret) == 0) {
                                fprintf(stderr, &quot;*** Warning: %s\n&quot;,
                                        gnutls_strerror(ret));
                        } else if (ret &lt; 0) {
                                fprintf(stderr, &quot;\n*** Received corrupted &quot;
                                        &quot;data(%d). Closing the connection.\n\n&quot;,
                                        ret);
                                break;
                        } else if (ret &gt; 0) {
                                /* echo data back to the client
                                 */
                                gnutls_record_send(session, buffer, ret);
                        }
                }
                printf(&quot;\n&quot;);
                /* do not wait for the peer to close the connection.
                 */
                gnutls_bye(session, GNUTLS_SHUT_WR);

                close(sd);
                gnutls_deinit(session);

        }
        close(listen_sd);

        gnutls_anon_free_server_credentials(anoncred);

        gnutls_global_deinit();

        return 0;

}
</pre>


<hr>
<span id="Helper-functions-for-TCP-connections"></span><div class="header">
<p>
Next: <a href="#Helper-functions-for-UDP-connections" accesskey="n" rel="next">Helper functions for UDP connections</a>, Previous: <a href="#Echo-server-with-anonymous-authentication" accesskey="p" rel="prev">Echo server with anonymous authentication</a>, Up: <a href="#More-advanced-client-and-servers" accesskey="u" rel="up">More advanced client and servers</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Helper-functions-for-TCP-connections-1"></span><h4 class="subsection">7.3.12 Helper functions for TCP connections</h4>

<p>Those helper function abstract away TCP connection handling from the
other examples.  It is required to build some examples.
</p>
<pre class="verbatim">/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;unistd.h&gt;

/* tcp.c */
int tcp_connect(void);
void tcp_close(int sd);

/* Connects to the peer and returns a socket
 * descriptor.
 */
extern int tcp_connect(void)
{
        const char *PORT = &quot;5556&quot;;
        const char *SERVER = &quot;127.0.0.1&quot;;
        int err, sd;
        struct sockaddr_in sa;

        /* connects to server
         */
        sd = socket(AF_INET, SOCK_STREAM, 0);

        memset(&amp;sa, '\0', sizeof(sa));
        sa.sin_family = AF_INET;
        sa.sin_port = htons(atoi(PORT));
        inet_pton(AF_INET, SERVER, &amp;sa.sin_addr);

        err = connect(sd, (struct sockaddr *) &amp;sa, sizeof(sa));
        if (err &lt; 0) {
                fprintf(stderr, &quot;Connect error\n&quot;);
                exit(1);
        }

        return sd;
}

/* closes the given socket descriptor.
 */
extern void tcp_close(int sd)
{
        shutdown(sd, SHUT_RDWR);        /* no more receptions */
        close(sd);
}
</pre>
<hr>
<span id="Helper-functions-for-UDP-connections"></span><div class="header">
<p>
Previous: <a href="#Helper-functions-for-TCP-connections" accesskey="p" rel="prev">Helper functions for TCP connections</a>, Up: <a href="#More-advanced-client-and-servers" accesskey="u" rel="up">More advanced client and servers</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Helper-functions-for-UDP-connections-1"></span><h4 class="subsection">7.3.13 Helper functions for UDP connections</h4>

<p>The UDP helper functions abstract away UDP connection handling from the
other examples.  It is required to build the examples using UDP.
</p>
<pre class="verbatim">/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;unistd.h&gt;

/* udp.c */
int udp_connect(void);
void udp_close(int sd);

/* Connects to the peer and returns a socket
 * descriptor.
 */
extern int udp_connect(void)
{
        const char *PORT = &quot;5557&quot;;
        const char *SERVER = &quot;127.0.0.1&quot;;
        int err, sd;
#if defined(IP_DONTFRAG) || defined(IP_MTU_DISCOVER)
        int optval;
#endif
        struct sockaddr_in sa;

        /* connects to server
         */
        sd = socket(AF_INET, SOCK_DGRAM, 0);

        memset(&amp;sa, '\0', sizeof(sa));
        sa.sin_family = AF_INET;
        sa.sin_port = htons(atoi(PORT));
        inet_pton(AF_INET, SERVER, &amp;sa.sin_addr);

#if defined(IP_DONTFRAG)
        optval = 1;
        setsockopt(sd, IPPROTO_IP, IP_DONTFRAG,
                   (const void *) &amp;optval, sizeof(optval));
#elif defined(IP_MTU_DISCOVER)
        optval = IP_PMTUDISC_DO;
        setsockopt(sd, IPPROTO_IP, IP_MTU_DISCOVER,
                   (const void *) &amp;optval, sizeof(optval));
#endif

        err = connect(sd, (struct sockaddr *) &amp;sa, sizeof(sa));
        if (err &lt; 0) {
                fprintf(stderr, &quot;Connect error\n&quot;);
                exit(1);
        }

        return sd;
}

/* closes the given socket descriptor.
 */
extern void udp_close(int sd)
{
        close(sd);
}
</pre>


<hr>
<span id="OCSP-example"></span><div class="header">
<p>
Next: <a href="#Miscellaneous-examples" accesskey="n" rel="next">Miscellaneous examples</a>, Previous: <a href="#More-advanced-client-and-servers" accesskey="p" rel="prev">More advanced client and servers</a>, Up: <a href="#GnuTLS-application-examples" accesskey="u" rel="up">GnuTLS application examples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="OCSP-example-1"></span><h3 class="section">7.4 OCSP example</h3>

<span id="Generate-OCSP-request"></span><span id="Generate-OCSP-request-1"></span><h4 class="subheading">Generate <acronym>OCSP</acronym> request</h4>

<p>A small tool to generate OCSP requests.
</p>
<pre class="verbatim">/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;gnutls/gnutls.h&gt;
#include &lt;gnutls/crypto.h&gt;
#include &lt;gnutls/ocsp.h&gt;
#ifndef NO_LIBCURL
#include &lt;curl/curl.h&gt;
#endif
#include &quot;read-file.h&quot;

size_t get_data(void *buffer, size_t size, size_t nmemb, void *userp);
static gnutls_x509_crt_t load_cert(const char *cert_file);
static void _response_info(const gnutls_datum_t * data);
static void
_generate_request(gnutls_datum_t * rdata, gnutls_x509_crt_t cert,
                  gnutls_x509_crt_t issuer, gnutls_datum_t *nonce);
static int
_verify_response(gnutls_datum_t * data, gnutls_x509_crt_t cert,
                 gnutls_x509_crt_t signer, gnutls_datum_t *nonce);

/* This program queries an OCSP server.
   It expects three files. argv[1] containing the certificate to
   be checked, argv[2] holding the issuer for this certificate,
   and argv[3] holding a trusted certificate to verify OCSP's response.
   argv[4] is optional and should hold the server host name.
   
   For simplicity the libcurl library is used.
 */

int main(int argc, char *argv[])
{
        gnutls_datum_t ud, tmp;
        int ret;
        gnutls_datum_t req;
        gnutls_x509_crt_t cert, issuer, signer;
#ifndef NO_LIBCURL
        CURL *handle;
        struct curl_slist *headers = NULL;
#endif
        int v, seq;
        const char *cert_file = argv[1];
        const char *issuer_file = argv[2];
        const char *signer_file = argv[3];
        char *hostname = NULL;
        unsigned char noncebuf[23];
        gnutls_datum_t nonce = { noncebuf, sizeof(noncebuf) };

        gnutls_global_init();

        if (argc &gt; 4)
                hostname = argv[4];

        ret = gnutls_rnd(GNUTLS_RND_NONCE, nonce.data, nonce.size);
        if (ret &lt; 0)
                exit(1);

        cert = load_cert(cert_file);
        issuer = load_cert(issuer_file);
        signer = load_cert(signer_file);

        if (hostname == NULL) {

                for (seq = 0;; seq++) {
                        ret =
                            gnutls_x509_crt_get_authority_info_access(cert,
                                                                      seq,
                                                                      GNUTLS_IA_OCSP_URI,
                                                                      &amp;tmp,
                                                                      NULL);
                        if (ret == GNUTLS_E_UNKNOWN_ALGORITHM)
                                continue;
                        if (ret == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE) {
                                fprintf(stderr,
                                        &quot;No URI was found in the certificate.\n&quot;);
                                exit(1);
                        }
                        if (ret &lt; 0) {
                                fprintf(stderr, &quot;error: %s\n&quot;,
                                        gnutls_strerror(ret));
                                exit(1);
                        }

                        printf(&quot;CA issuers URI: %.*s\n&quot;, tmp.size,
                               tmp.data);

                        hostname = malloc(tmp.size + 1);
                        memcpy(hostname, tmp.data, tmp.size);
                        hostname[tmp.size] = 0;

                        gnutls_free(tmp.data);
                        break;
                }

        }

        /* Note that the OCSP servers hostname might be available
         * using gnutls_x509_crt_get_authority_info_access() in the issuer's
         * certificate */

        memset(&amp;ud, 0, sizeof(ud));
        fprintf(stderr, &quot;Connecting to %s\n&quot;, hostname);

        _generate_request(&amp;req, cert, issuer, &amp;nonce);

#ifndef NO_LIBCURL
        curl_global_init(CURL_GLOBAL_ALL);

        handle = curl_easy_init();
        if (handle == NULL)
                exit(1);

        headers =
            curl_slist_append(headers,
                              &quot;Content-Type: application/ocsp-request&quot;);

        curl_easy_setopt(handle, CURLOPT_HTTPHEADER, headers);
        curl_easy_setopt(handle, CURLOPT_POSTFIELDS, (void *) req.data);
        curl_easy_setopt(handle, CURLOPT_POSTFIELDSIZE, req.size);
        curl_easy_setopt(handle, CURLOPT_URL, hostname);
        curl_easy_setopt(handle, CURLOPT_WRITEFUNCTION, get_data);
        curl_easy_setopt(handle, CURLOPT_WRITEDATA, &amp;ud);

        ret = curl_easy_perform(handle);
        if (ret != 0) {
                fprintf(stderr, &quot;curl[%d] error %d\n&quot;, __LINE__, ret);
                exit(1);
        }

        curl_easy_cleanup(handle);
#endif

        _response_info(&amp;ud);

        v = _verify_response(&amp;ud, cert, signer, &amp;nonce);

        gnutls_x509_crt_deinit(cert);
        gnutls_x509_crt_deinit(issuer);
        gnutls_x509_crt_deinit(signer);
        gnutls_global_deinit();

        return v;
}

static void _response_info(const gnutls_datum_t * data)
{
        gnutls_ocsp_resp_t resp;
        int ret;
        gnutls_datum buf;

        ret = gnutls_ocsp_resp_init(&amp;resp);
        if (ret &lt; 0)
                exit(1);

        ret = gnutls_ocsp_resp_import(resp, data);
        if (ret &lt; 0)
                exit(1);

        ret = gnutls_ocsp_resp_print(resp, GNUTLS_OCSP_PRINT_FULL, &amp;buf);
        if (ret != 0)
                exit(1);

        printf(&quot;%.*s&quot;, buf.size, buf.data);
        gnutls_free(buf.data);

        gnutls_ocsp_resp_deinit(resp);
}

static gnutls_x509_crt_t load_cert(const char *cert_file)
{
        gnutls_x509_crt_t crt;
        int ret;
        gnutls_datum_t data;
        size_t size;

        ret = gnutls_x509_crt_init(&amp;crt);
        if (ret &lt; 0)
                exit(1);

        data.data = (void *) read_binary_file(cert_file, &amp;size);
        data.size = size;

        if (!data.data) {
                fprintf(stderr, &quot;Cannot open file: %s\n&quot;, cert_file);
                exit(1);
        }

        ret = gnutls_x509_crt_import(crt, &amp;data, GNUTLS_X509_FMT_PEM);
        free(data.data);
        if (ret &lt; 0) {
                fprintf(stderr, &quot;Cannot import certificate in %s: %s\n&quot;,
                        cert_file, gnutls_strerror(ret));
                exit(1);
        }

        return crt;
}

static void
_generate_request(gnutls_datum_t * rdata, gnutls_x509_crt_t cert,
                  gnutls_x509_crt_t issuer, gnutls_datum_t *nonce)
{
        gnutls_ocsp_req_t req;
        int ret;

        ret = gnutls_ocsp_req_init(&amp;req);
        if (ret &lt; 0)
                exit(1);

        ret = gnutls_ocsp_req_add_cert(req, GNUTLS_DIG_SHA1, issuer, cert);
        if (ret &lt; 0)
                exit(1);


        ret = gnutls_ocsp_req_set_nonce(req, 0, nonce);
        if (ret &lt; 0)
                exit(1);

        ret = gnutls_ocsp_req_export(req, rdata);
        if (ret != 0)
                exit(1);

        gnutls_ocsp_req_deinit(req);

        return;
}

static int
_verify_response(gnutls_datum_t * data, gnutls_x509_crt_t cert,
                 gnutls_x509_crt_t signer, gnutls_datum_t *nonce)
{
        gnutls_ocsp_resp_t resp;
        int ret;
        unsigned verify;
        gnutls_datum_t rnonce;

        ret = gnutls_ocsp_resp_init(&amp;resp);
        if (ret &lt; 0)
                exit(1);

        ret = gnutls_ocsp_resp_import(resp, data);
        if (ret &lt; 0)
                exit(1);

        ret = gnutls_ocsp_resp_check_crt(resp, 0, cert);
        if (ret &lt; 0)
                exit(1);

	ret = gnutls_ocsp_resp_get_nonce(resp, NULL, &amp;rnonce);
	if (ret &lt; 0)
		exit(1);

	if (rnonce.size != nonce-&gt;size || memcmp(nonce-&gt;data, rnonce.data,
		nonce-&gt;size) != 0) {
		exit(1);
	}

        ret = gnutls_ocsp_resp_verify_direct(resp, signer, &amp;verify, 0);
        if (ret &lt; 0)
                exit(1);

        printf(&quot;Verifying OCSP Response: &quot;);
        if (verify == 0)
                printf(&quot;Verification success!\n&quot;);
        else
                printf(&quot;Verification error!\n&quot;);

        if (verify &amp; GNUTLS_OCSP_VERIFY_SIGNER_NOT_FOUND)
                printf(&quot;Signer cert not found\n&quot;);

        if (verify &amp; GNUTLS_OCSP_VERIFY_SIGNER_KEYUSAGE_ERROR)
                printf(&quot;Signer cert keyusage error\n&quot;);

        if (verify &amp; GNUTLS_OCSP_VERIFY_UNTRUSTED_SIGNER)
                printf(&quot;Signer cert is not trusted\n&quot;);

        if (verify &amp; GNUTLS_OCSP_VERIFY_INSECURE_ALGORITHM)
                printf(&quot;Insecure algorithm\n&quot;);

        if (verify &amp; GNUTLS_OCSP_VERIFY_SIGNATURE_FAILURE)
                printf(&quot;Signature failure\n&quot;);

        if (verify &amp; GNUTLS_OCSP_VERIFY_CERT_NOT_ACTIVATED)
                printf(&quot;Signer cert not yet activated\n&quot;);

        if (verify &amp; GNUTLS_OCSP_VERIFY_CERT_EXPIRED)
                printf(&quot;Signer cert expired\n&quot;);

        gnutls_free(rnonce.data);
        gnutls_ocsp_resp_deinit(resp);

        return verify;
}

size_t get_data(void *buffer, size_t size, size_t nmemb, void *userp)
{
        gnutls_datum_t *ud = userp;

        size *= nmemb;

        ud-&gt;data = realloc(ud-&gt;data, size + ud-&gt;size);
        if (ud-&gt;data == NULL) {
                fprintf(stderr, &quot;Not enough memory for the request\n&quot;);
                exit(1);
        }

        memcpy(&amp;ud-&gt;data[ud-&gt;size], buffer, size);
        ud-&gt;size += size;

        return size;
}
</pre>
<hr>
<span id="Miscellaneous-examples"></span><div class="header">
<p>
Previous: <a href="#OCSP-example" accesskey="p" rel="prev">OCSP example</a>, Up: <a href="#GnuTLS-application-examples" accesskey="u" rel="up">GnuTLS application examples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Miscellaneous-examples-1"></span><h3 class="section">7.5 Miscellaneous examples</h3>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Checking-for-an-alert" accesskey="1">Checking for an alert</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#X_002e509-certificate-parsing-example" accesskey="2">X.509 certificate parsing example</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Listing-the-ciphersuites-in-a-priority-string" accesskey="3">Listing the ciphersuites in a priority string</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#PKCS12-structure-generation-example" accesskey="4">PKCS12 structure generation example</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Checking-for-an-alert"></span><div class="header">
<p>
Next: <a href="#X_002e509-certificate-parsing-example" accesskey="n" rel="next">X.509 certificate parsing example</a>, Up: <a href="#Miscellaneous-examples" accesskey="u" rel="up">Miscellaneous examples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Checking-for-an-alert-1"></span><h4 class="subsection">7.5.1 Checking for an alert</h4>

<p>This is a function that checks if an alert has been received in the
current session.
</p>
<pre class="verbatim">/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;gnutls/gnutls.h&gt;

#include &quot;examples.h&quot;

/* This function will check whether the given return code from
 * a gnutls function (recv/send), is an alert, and will print
 * that alert.
 */
void check_alert(gnutls_session_t session, int ret)
{
        int last_alert;

        if (ret == GNUTLS_E_WARNING_ALERT_RECEIVED
            || ret == GNUTLS_E_FATAL_ALERT_RECEIVED) {
                last_alert = gnutls_alert_get(session);

                /* The check for renegotiation is only useful if we are 
                 * a server, and we had requested a rehandshake.
                 */
                if (last_alert == GNUTLS_A_NO_RENEGOTIATION &amp;&amp;
                    ret == GNUTLS_E_WARNING_ALERT_RECEIVED)
                        printf(&quot;* Received NO_RENEGOTIATION alert. &quot;
                               &quot;Client Does not support renegotiation.\n&quot;);
                else
                        printf(&quot;* Received alert '%d': %s.\n&quot;, last_alert,
                               gnutls_alert_get_name(last_alert));
        }
}
</pre>
<hr>
<span id="X_002e509-certificate-parsing-example"></span><div class="header">
<p>
Next: <a href="#Listing-the-ciphersuites-in-a-priority-string" accesskey="n" rel="next">Listing the ciphersuites in a priority string</a>, Previous: <a href="#Checking-for-an-alert" accesskey="p" rel="prev">Checking for an alert</a>, Up: <a href="#Miscellaneous-examples" accesskey="u" rel="up">Miscellaneous examples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="X_002e509-certificate-parsing-example-1"></span><h4 class="subsection">7.5.2 <acronym>X.509</acronym> certificate parsing example</h4>
<span id="ex_002dx509_002dinfo"></span>
<p>To demonstrate the <acronym>X.509</acronym> parsing capabilities an example program is
listed below.  That program reads the peer&rsquo;s certificate, and prints
information about it.
</p>
<pre class="verbatim">/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;gnutls/gnutls.h&gt;
#include &lt;gnutls/x509.h&gt;

#include &quot;examples.h&quot;

static const char *bin2hex(const void *bin, size_t bin_size)
{
        static char printable[110];
        const unsigned char *_bin = bin;
        char *print;
        size_t i;

        if (bin_size &gt; 50)
                bin_size = 50;

        print = printable;
        for (i = 0; i &lt; bin_size; i++) {
                sprintf(print, &quot;%.2x &quot;, _bin[i]);
                print += 2;
        }

        return printable;
}

/* This function will print information about this session's peer
 * certificate.
 */
void print_x509_certificate_info(gnutls_session_t session)
{
        char serial[40];
        char dn[256];
        size_t size;
        unsigned int algo, bits;
        time_t expiration_time, activation_time;
        const gnutls_datum_t *cert_list;
        unsigned int cert_list_size = 0;
        gnutls_x509_crt_t cert;
        gnutls_datum_t cinfo;

        /* This function only works for X.509 certificates.
         */
        if (gnutls_certificate_type_get(session) != GNUTLS_CRT_X509)
                return;

        cert_list = gnutls_certificate_get_peers(session, &amp;cert_list_size);

        printf(&quot;Peer provided %d certificates.\n&quot;, cert_list_size);

        if (cert_list_size &gt; 0) {
                int ret;

                /* we only print information about the first certificate.
                 */
                gnutls_x509_crt_init(&amp;cert);

                gnutls_x509_crt_import(cert, &amp;cert_list[0],
                                       GNUTLS_X509_FMT_DER);

                printf(&quot;Certificate info:\n&quot;);

                /* This is the preferred way of printing short information about
                   a certificate. */

                ret =
                    gnutls_x509_crt_print(cert, GNUTLS_CRT_PRINT_ONELINE,
                                          &amp;cinfo);
                if (ret == 0) {
                        printf(&quot;\t%s\n&quot;, cinfo.data);
                        gnutls_free(cinfo.data);
                }

                /* If you want to extract fields manually for some other reason,
                   below are popular example calls. */

                expiration_time =
                    gnutls_x509_crt_get_expiration_time(cert);
                activation_time =
                    gnutls_x509_crt_get_activation_time(cert);

                printf(&quot;\tCertificate is valid since: %s&quot;,
                       ctime(&amp;activation_time));
                printf(&quot;\tCertificate expires: %s&quot;,
                       ctime(&amp;expiration_time));

                /* Print the serial number of the certificate.
                 */
                size = sizeof(serial);
                gnutls_x509_crt_get_serial(cert, serial, &amp;size);

                printf(&quot;\tCertificate serial number: %s\n&quot;,
                       bin2hex(serial, size));

                /* Extract some of the public key algorithm's parameters
                 */
                algo = gnutls_x509_crt_get_pk_algorithm(cert, &amp;bits);

                printf(&quot;Certificate public key: %s&quot;,
                       gnutls_pk_algorithm_get_name(algo));

                /* Print the version of the X.509
                 * certificate.
                 */
                printf(&quot;\tCertificate version: #%d\n&quot;,
                       gnutls_x509_crt_get_version(cert));

                size = sizeof(dn);
                gnutls_x509_crt_get_dn(cert, dn, &amp;size);
                printf(&quot;\tDN: %s\n&quot;, dn);

                size = sizeof(dn);
                gnutls_x509_crt_get_issuer_dn(cert, dn, &amp;size);
                printf(&quot;\tIssuer's DN: %s\n&quot;, dn);

                gnutls_x509_crt_deinit(cert);

        }
}
</pre>
<hr>
<span id="Listing-the-ciphersuites-in-a-priority-string"></span><div class="header">
<p>
Next: <a href="#PKCS12-structure-generation-example" accesskey="n" rel="next">PKCS12 structure generation example</a>, Previous: <a href="#X_002e509-certificate-parsing-example" accesskey="p" rel="prev">X.509 certificate parsing example</a>, Up: <a href="#Miscellaneous-examples" accesskey="u" rel="up">Miscellaneous examples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Listing-the-ciphersuites-in-a-priority-string-1"></span><h4 class="subsection">7.5.3 Listing the ciphersuites in a priority string</h4>

<p>This is a small program to list the enabled ciphersuites by a 
priority string.
</p>
<pre class="verbatim">/* This example code is placed in the public domain. */

#include &lt;config.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;gnutls/gnutls.h&gt;

static void print_cipher_suite_list(const char *priorities)
{
        size_t i;
        int ret;
        unsigned int idx;
        const char *name;
        const char *err;
        unsigned char id[2];
        gnutls_protocol_t version;
        gnutls_priority_t pcache;

        if (priorities != NULL) {
                printf(&quot;Cipher suites for %s\n&quot;, priorities);

                ret = gnutls_priority_init(&amp;pcache, priorities, &amp;err);
                if (ret &lt; 0) {
                        fprintf(stderr, &quot;Syntax error at: %s\n&quot;, err);
                        exit(1);
                }

                for (i = 0;; i++) {
                        ret =
                            gnutls_priority_get_cipher_suite_index(pcache,
                                                                   i,
                                                                   &amp;idx);
                        if (ret == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE)
                                break;
                        if (ret == GNUTLS_E_UNKNOWN_CIPHER_SUITE)
                                continue;

                        name =
                            gnutls_cipher_suite_info(idx, id, NULL, NULL,
                                                     NULL, &amp;version);

                        if (name != NULL)
                                printf(&quot;%-50s\t0x%02x, 0x%02x\t%s\n&quot;,
                                       name, (unsigned char) id[0],
                                       (unsigned char) id[1],
                                       gnutls_protocol_get_name(version));
                }

                return;
        }
}

int main(int argc, char **argv)
{
        if (argc &gt; 1)
                print_cipher_suite_list(argv[1]);
        return 0;
}
</pre>
<hr>
<span id="PKCS12-structure-generation-example"></span><div class="header">
<p>
Previous: <a href="#Listing-the-ciphersuites-in-a-priority-string" accesskey="p" rel="prev">Listing the ciphersuites in a priority string</a>, Up: <a href="#Miscellaneous-examples" accesskey="u" rel="up">Miscellaneous examples</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="PKCS-_002312-structure-generation-example"></span><h4 class="subsection">7.5.4 PKCS #12 structure generation example</h4>

<p>This small program demonstrates the usage of the PKCS #12 API, by generating
such a structure.
</p>
<pre class="verbatim">/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;gnutls/gnutls.h&gt;
#include &lt;gnutls/pkcs12.h&gt;

#include &quot;examples.h&quot;

#define OUTFILE &quot;out.p12&quot;

/* This function will write a pkcs12 structure into a file.
 * cert: is a DER encoded certificate
 * pkcs8_key: is a PKCS #8 encrypted key (note that this must be
 *  encrypted using a PKCS #12 cipher, or some browsers will crash)
 * password: is the password used to encrypt the PKCS #12 packet.
 */
int
write_pkcs12(const gnutls_datum_t * cert,
             const gnutls_datum_t * pkcs8_key, const char *password)
{
        gnutls_pkcs12_t pkcs12;
        int ret, bag_index;
        gnutls_pkcs12_bag_t bag, key_bag;
        char pkcs12_struct[10 * 1024];
        size_t pkcs12_struct_size;
        FILE *fd;

        /* A good idea might be to use gnutls_x509_privkey_get_key_id()
         * to obtain a unique ID.
         */
        gnutls_datum_t key_id = { (void *) &quot;\x00\x00\x07&quot;, 3 };

        gnutls_global_init();

        /* Firstly we create two helper bags, which hold the certificate,
         * and the (encrypted) key.
         */

        gnutls_pkcs12_bag_init(&amp;bag);
        gnutls_pkcs12_bag_init(&amp;key_bag);

        ret =
            gnutls_pkcs12_bag_set_data(bag, GNUTLS_BAG_CERTIFICATE, cert);
        if (ret &lt; 0) {
                fprintf(stderr, &quot;ret: %s\n&quot;, gnutls_strerror(ret));
                return 1;
        }

        /* ret now holds the bag's index.
         */
        bag_index = ret;

        /* Associate a friendly name with the given certificate. Used
         * by browsers.
         */
        gnutls_pkcs12_bag_set_friendly_name(bag, bag_index, &quot;My name&quot;);

        /* Associate the certificate with the key using a unique key
         * ID.
         */
        gnutls_pkcs12_bag_set_key_id(bag, bag_index, &amp;key_id);

        /* use weak encryption for the certificate. 
         */
        gnutls_pkcs12_bag_encrypt(bag, password,
                                  GNUTLS_PKCS_USE_PKCS12_RC2_40);

        /* Now the key.
         */

        ret = gnutls_pkcs12_bag_set_data(key_bag,
                                         GNUTLS_BAG_PKCS8_ENCRYPTED_KEY,
                                         pkcs8_key);
        if (ret &lt; 0) {
                fprintf(stderr, &quot;ret: %s\n&quot;, gnutls_strerror(ret));
                return 1;
        }

        /* Note that since the PKCS #8 key is already encrypted we don't
         * bother encrypting that bag.
         */
        bag_index = ret;

        gnutls_pkcs12_bag_set_friendly_name(key_bag, bag_index, &quot;My name&quot;);

        gnutls_pkcs12_bag_set_key_id(key_bag, bag_index, &amp;key_id);


        /* The bags were filled. Now create the PKCS #12 structure.
         */
        gnutls_pkcs12_init(&amp;pkcs12);

        /* Insert the two bags in the PKCS #12 structure.
         */

        gnutls_pkcs12_set_bag(pkcs12, bag);
        gnutls_pkcs12_set_bag(pkcs12, key_bag);


        /* Generate a message authentication code for the PKCS #12
         * structure.
         */
        gnutls_pkcs12_generate_mac(pkcs12, password);

        pkcs12_struct_size = sizeof(pkcs12_struct);
        ret =
            gnutls_pkcs12_export(pkcs12, GNUTLS_X509_FMT_DER,
                                 pkcs12_struct, &amp;pkcs12_struct_size);
        if (ret &lt; 0) {
                fprintf(stderr, &quot;ret: %s\n&quot;, gnutls_strerror(ret));
                return 1;
        }

        fd = fopen(OUTFILE, &quot;w&quot;);
        if (fd == NULL) {
                fprintf(stderr, &quot;cannot open file\n&quot;);
                return 1;
        }
        fwrite(pkcs12_struct, 1, pkcs12_struct_size, fd);
        fclose(fd);

        gnutls_pkcs12_bag_deinit(bag);
        gnutls_pkcs12_bag_deinit(key_bag);
        gnutls_pkcs12_deinit(pkcs12);

        return 0;
}
</pre>

<hr>
<span id="System_002dwide-configuration-of-the-library"></span><div class="header">
<p>
Next: <a href="#Using-GnuTLS-as-a-cryptographic-library" accesskey="n" rel="next">Using GnuTLS as a cryptographic library</a>, Previous: <a href="#GnuTLS-application-examples" accesskey="p" rel="prev">GnuTLS application examples</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="System_002dwide-configuration-of-the-library-1"></span><h2 class="chapter">8 System-wide configuration of the library</h2>
<span id="index-System_002dwide-configuration"></span>

<p><acronym>GnuTLS</acronym> 3.6.9 introduced a system-wide configuration of the library
which can be used to disable or mark algorithms and protocols as insecure
system-wide, overriding the library defaults. The format of this
configuration file is of an INI file, with the hash (&rsquo;#&rsquo;) allowed for
commenting. It intentionally does not allow switching algorithms or protocols
which were disabled or marked as insecure during compile time to the secure
set. This is to prevent the feature from being used to attack the system.
Unknown options or sections in the configuration file are skipped unless
the environment variable <code>GNUTLS_SYSTEM_PRIORITY_FAIL_ON_INVALID</code> is
set to 1, where it would cause the library to exit on unknown options.
</p>
<p>The location of the default configuration file is <code>/etc/gnutls/config</code>,
but its actual location may be overriden during compile time or at run-time
using the <code>GNUTLS_SYSTEM_PRIORITY_FILE</code> environment variable. The file
used can be queried using <a href="#gnutls_005fget_005fsystem_005fconfig_005ffile">gnutls_get_system_config_file</a>.
</p>




<dl>
<dt id="index-gnutls_005fget_005fsystem_005fconfig_005ffile">Function: <em>const char *</em> <strong>gnutls_get_system_config_file</strong> <em>( <var>void</var>)</em></dt>
<dd>
<p>Returns the filename of the system wide configuration
file loaded by the library. The returned pointer is valid
until the library is unloaded.
</p>
<p><strong>Returns:</strong> a constant pointer to the config file loaded, or <code>NULL</code>  if none
</p>
<p><strong>Since:</strong> 3.6.9
</p></dd></dl>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Application_002dspecific-priority-strings" accesskey="1">Application-specific priority strings</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Disabling-algorithms-and-protocols" accesskey="2">Disabling algorithms and protocols</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Querying-for-disabled-algorithms-and-protocols" accesskey="3">Querying for disabled algorithms and protocols</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Overriding-the-parameter-verification-profile" accesskey="4">Overriding the parameter verification profile</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Application_002dspecific-priority-strings"></span><div class="header">
<p>
Next: <a href="#Disabling-algorithms-and-protocols" accesskey="n" rel="next">Disabling algorithms and protocols</a>, Up: <a href="#System_002dwide-configuration-of-the-library" accesskey="u" rel="up">System-wide configuration of the library</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Application_002dspecific-priority-strings-1"></span><h3 class="section">8.1 Application-specific priority strings</h3>

<p>It is possible to specify custom cipher priority strings, in addition to the
default priority strings (<code>NORMAL</code>, <code>PERFORMANCE</code>, etc.). These can
be used either by individual applications, or even as the default option if
the library is compiled with the configuration option
<code>--with-default-priority-string</code>. In the latter case the defined
priority string will be used for applications using <a href="#gnutls_005fset_005fdefault_005fpriority">gnutls_set_default_priority</a>
or <a href="#gnutls_005fset_005fdefault_005fpriority_005fappend">gnutls_set_default_priority_append</a>.
</p>
<p>The priority strings can be specified in the global section of the
configuration file, or in the section named <code>[priorities]</code>.
The format is &rsquo;<code>KEYWORD = VALUE</code>&rsquo;, e.g.,
</p>
<p>When used they may be followed by additional options that will be appended to the
system string (e.g., &rsquo;<code>@EXAMPLE-PRIORITY:+SRP</code>&rsquo;). &rsquo;<code>EXAMPLE-PRIORITY=NORMAL:+ARCFOUR-128</code>&rsquo;.
Since version 3.5.1 applications are allowed to specify fallback keywords such as
@KEYWORD1,@KEYWORD2, and the first valid keyword will be used.
</p>
<p>The following example configuration defines a priority string called <code>@SYSTEM</code>.
When set, its full settings can be queried using <code>gnutls-cli --priority @SYSTEM --list</code>.
</p>
<div class="example">
<pre class="example">[priorities]
SYSTEM = NORMAL:-AES-128-CBC:-AES-256-CBC
</pre></div>


<hr>
<span id="Disabling-algorithms-and-protocols"></span><div class="header">
<p>
Next: <a href="#Querying-for-disabled-algorithms-and-protocols" accesskey="n" rel="next">Querying for disabled algorithms and protocols</a>, Previous: <a href="#Application_002dspecific-priority-strings" accesskey="p" rel="prev">Application-specific priority strings</a>, Up: <a href="#System_002dwide-configuration-of-the-library" accesskey="u" rel="up">System-wide configuration of the library</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Disabling-algorithms-and-protocols-1"></span><h3 class="section">8.2 Disabling algorithms and protocols</h3>

<p>The approach above works well to create consistent system-wide settings
for cooperative GnuTLS applications. When an application however does not
use the <a href="#gnutls_005fset_005fdefault_005fpriority">gnutls_set_default_priority</a> or <a href="#gnutls_005fset_005fdefault_005fpriority_005fappend">gnutls_set_default_priority_append</a>
functions, the method is not sufficient to prevent applications from using
protocols or algorithms forbidden by a local policy.
The override method described below enables the deprecation of algorithms and
protocols system-wide for all applications.
</p>
<p>The available options must be set in the <code>[overrides]</code> section of the
configuration file and can be
</p><ul>
<li> <code>insecure-sig-for-cert</code>: to mark the signature algorithm as insecure when used in certificates.
</li><li> <code>insecure-sig</code>: to mark the signature algorithm as insecure for any use.
</li><li> <code>insecure-hash</code>: to mark the hash algorithm as insecure for digital signature use (provides a more generic way to disable digital signatures for broken hash algorithms).
</li><li> <code>disabled-version</code>: to disable the specified TLS versions.
</li><li> <code>tls-disabled-cipher</code>: to disable the specified ciphers for use in the TLS or DTLS protocols.
</li><li> <code>tls-disabled-mac</code>: to disable the specified MAC algorithms for use in the TLS or DTLS protocols.
</li><li> <code>tls-disabled-group</code>: to disable the specified group for use in the TLS or DTLS protocols.
</li><li> <code>tls-disabled-kx</code>: to disable the specified key exchange algorithms for use in the TLS or DTLS protocols (applies to TLS1.2 or earlier).
</li></ul>

<p>Each of the options can be repeated multiple times when multiple values need
to be disabled.
</p>
<p>The valid values for the options above can be found in the &rsquo;Protocols&rsquo;, &rsquo;Digests&rsquo;
&rsquo;PK-signatures&rsquo;, &rsquo;Protocols&rsquo;, &rsquo;Ciphrers&rsquo;, and &rsquo;MACs&rsquo; fields of the output of <code>gnutls-cli --list</code>.
</p>
<span id="Examples"></span><h4 class="subsection">8.2.1 Examples</h4>

<p>The following example marks as insecure all digital signature algorithms
which depend on SHA384, as well as the RSA-SHA1 signature algorithm.
</p>
<div class="example">
<pre class="example">[overrides]
insecure-hash = sha384
insecure-sig = rsa-sha1
</pre></div>

<p>The following example marks RSA-SHA256 as insecure for use in certificates
and disables the TLS1.0 and TLS1.1 protocols.
</p>
<div class="example">
<pre class="example">[overrides]
insecure-sig-for-cert = rsa-sha256
disabled-version = tls1.0
disabled-version = tls1.1
</pre></div>

<p>The following example disables the <code>AES-128-CBC</code> and <code>AES-256-CBC</code>
ciphers, the <code>HMAC-SHA1</code> MAC algorithm and the <code>GROUP-FFDHE8192</code>
group for TLS and DTLS protocols.
</p>
<div class="example">
<pre class="example">[overrides]
tls-disabled-cipher = aes-128-cbc
tls-disabled-cipher = aes-256-cbc
tls-disabled-mac = sha1
tls-disabled-group = group-ffdhe8192
</pre></div>

<hr>
<span id="Querying-for-disabled-algorithms-and-protocols"></span><div class="header">
<p>
Next: <a href="#Overriding-the-parameter-verification-profile" accesskey="n" rel="next">Overriding the parameter verification profile</a>, Previous: <a href="#Disabling-algorithms-and-protocols" accesskey="p" rel="prev">Disabling algorithms and protocols</a>, Up: <a href="#System_002dwide-configuration-of-the-library" accesskey="u" rel="up">System-wide configuration of the library</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Querying-for-disabled-algorithms-and-protocols-1"></span><h3 class="section">8.3 Querying for disabled algorithms and protocols</h3>

<p>When necessary applications can query whether a particular algorithm
or protocol has been marked as insecure or disabled system-wide.
Digital signatures can be queried using the following algorithms.
</p><dl compact="compact">
<dt><code><var>unsigned</var> <a href="#gnutls_005fsign_005fis_005fsecure">gnutls_sign_is_secure</a> (gnutls_sign_algorithm_t <var>algorithm</var>)</code></dt>
<dt><code><var>unsigned</var> <a href="#gnutls_005fsign_005fis_005fsecure2">gnutls_sign_is_secure2</a> (gnutls_sign_algorithm_t <var>algorithm</var>, unsigned int <var>flags</var>)</code></dt>
</dl>

<p>Any disabled protocol versions or elliptic curves will not show up in the
lists provided by the following functions.
</p>
<dl compact="compact">
<dt><code><var>const gnutls_protocol_t *</var> <a href="#gnutls_005fprotocol_005flist">gnutls_protocol_list</a> ( <var>void</var>)</code></dt>
<dt><code><var>const gnutls_group_t *</var> <a href="#gnutls_005fgroup_005flist">gnutls_group_list</a> ( <var>void</var>)</code></dt>
<dt><code><var>const gnutls_ecc_curve_t *</var> <a href="#gnutls_005fecc_005fcurve_005flist">gnutls_ecc_curve_list</a> ( <var>void</var>)</code></dt>
</dl>

<p>It is not possible to query for insecure hash algorithms directly
(only indirectly through the signature API).
</p>

<hr>
<span id="Overriding-the-parameter-verification-profile"></span><div class="header">
<p>
Previous: <a href="#Querying-for-disabled-algorithms-and-protocols" accesskey="p" rel="prev">Querying for disabled algorithms and protocols</a>, Up: <a href="#System_002dwide-configuration-of-the-library" accesskey="u" rel="up">System-wide configuration of the library</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Overriding-the-parameter-verification-profile-1"></span><h3 class="section">8.4 Overriding the parameter verification profile</h3>

<p>When verifying a certificate or TLS session parameters, GnuTLS uses a set
of profiles associated with the session to determine whether the parameters
seen in the session are acceptable. For example, whether the RSA public key
size as seen on the wire, or the Diffie-Hellman parameters for the session.
These profiles are normally set using the <code>%PROFILE</code> priority string
(see <a href="#Priority-Strings">Priority Strings</a> and <a href="#Selecting-cryptographic-key-sizes">Selecting cryptographic key sizes</a>).
</p>
<p>It is possible to set the low bar profile that applications cannot override
using the following.
</p>
<div class="example">
<pre class="example">[overrides]

# do not allow applications use the LOW or VERY-WEAK profiles.
min-verification-profile = legacy

</pre></div>

<hr>
<span id="Using-GnuTLS-as-a-cryptographic-library"></span><div class="header">
<p>
Next: <a href="#Other-included-programs" accesskey="n" rel="next">Other included programs</a>, Previous: <a href="#System_002dwide-configuration-of-the-library" accesskey="p" rel="prev">System-wide configuration of the library</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Using-GnuTLS-as-a-cryptographic-library-1"></span><h2 class="chapter">9 Using GnuTLS as a cryptographic library</h2>

<p><acronym>GnuTLS</acronym> is not a low-level cryptographic library, i.e., 
it does not provide access to basic cryptographic primitives. However
it abstracts the internal cryptographic back-end (see <a href="#Cryptographic-Backend">Cryptographic Backend</a>),
providing symmetric crypto, hash and HMAC algorithms, as well access
to the random number generation. For a low-level crypto API the usage of nettle
<a id="DOCF21" href="#FOOT21"><sup>21</sup></a> library is recommended.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Symmetric-algorithms" accesskey="1">Symmetric algorithms</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Public-key-algorithms" accesskey="2">Public key algorithms</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Cryptographic-Message-Syntax-_002f-PKCS7" accesskey="3">Cryptographic Message Syntax / PKCS7</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Hash-and-MAC-functions" accesskey="4">Hash and MAC functions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Random-number-generation" accesskey="5">Random number generation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Overriding-algorithms" accesskey="6">Overriding algorithms</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Symmetric-algorithms"></span><div class="header">
<p>
Next: <a href="#Public-key-algorithms" accesskey="n" rel="next">Public key algorithms</a>, Up: <a href="#Using-GnuTLS-as-a-cryptographic-library" accesskey="u" rel="up">Using GnuTLS as a cryptographic library</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Symmetric-algorithms-1"></span><h3 class="section">9.1 Symmetric algorithms</h3>
<span id="index-symmetric-algorithms"></span>
<span id="index-symmetric-cryptography"></span>

<p>The available functions to access symmetric crypto algorithms operations
are listed in the sections below. The supported algorithms are the algorithms required by the TLS protocol.
They are listed in <a href="#gnutls_005fcipher_005falgorithm_005ft">Figure 9.1</a>. Note that there two
types of ciphers, the ones providing an authenticated-encryption with
associated data (AEAD), and the legacy ciphers which provide raw access
to the ciphers. We recommend the use of the AEAD ciphers under the AEAD APIs
for new applications as they are designed to minimize the misuse of
cryptographic primitives.
</p>
<div class="float"><span id="gnutls_005fcipher_005falgorithm_005ft"></span>


<dl compact="compact">
<dt><code>GNUTLS_CIPHER_UNKNOWN</code></dt>
<dd><p>Value to identify an unknown/unsupported algorithm.
</p></dd>
<dt><code>GNUTLS_CIPHER_NULL</code></dt>
<dd><p>The NULL (identity) encryption algorithm.
</p></dd>
<dt><code>GNUTLS_CIPHER_ARCFOUR_128</code></dt>
<dd><p>ARCFOUR stream cipher with 128-bit keys.
</p></dd>
<dt><code>GNUTLS_CIPHER_3DES_CBC</code></dt>
<dd><p>3DES in CBC mode.
</p></dd>
<dt><code>GNUTLS_CIPHER_AES_128_CBC</code></dt>
<dd><p>AES in CBC mode with 128-bit keys.
</p></dd>
<dt><code>GNUTLS_CIPHER_AES_256_CBC</code></dt>
<dd><p>AES in CBC mode with 256-bit keys.
</p></dd>
<dt><code>GNUTLS_CIPHER_ARCFOUR_40</code></dt>
<dd><p>ARCFOUR stream cipher with 40-bit keys.
</p></dd>
<dt><code>GNUTLS_CIPHER_CAMELLIA_128_CBC</code></dt>
<dd><p>Camellia in CBC mode with 128-bit keys.
</p></dd>
<dt><code>GNUTLS_CIPHER_CAMELLIA_256_CBC</code></dt>
<dd><p>Camellia in CBC mode with 256-bit keys.
</p></dd>
<dt><code>GNUTLS_CIPHER_AES_192_CBC</code></dt>
<dd><p>AES in CBC mode with 192-bit keys.
</p></dd>
<dt><code>GNUTLS_CIPHER_AES_128_GCM</code></dt>
<dd><p>AES in GCM mode with 128-bit keys (AEAD).
</p></dd>
<dt><code>GNUTLS_CIPHER_AES_256_GCM</code></dt>
<dd><p>AES in GCM mode with 256-bit keys (AEAD).
</p></dd>
<dt><code>GNUTLS_CIPHER_CAMELLIA_192_CBC</code></dt>
<dd><p>Camellia in CBC mode with 192-bit keys.
</p></dd>
<dt><code>GNUTLS_CIPHER_SALSA20_256</code></dt>
<dd><p>Salsa20 with 256-bit keys.
</p></dd>
<dt><code>GNUTLS_CIPHER_ESTREAM_SALSA20_256</code></dt>
<dd><p>Estream&rsquo;s Salsa20 variant with 256-bit keys.
</p></dd>
<dt><code>GNUTLS_CIPHER_CAMELLIA_128_GCM</code></dt>
<dd><p>CAMELLIA in GCM mode with 128-bit keys (AEAD).
</p></dd>
<dt><code>GNUTLS_CIPHER_CAMELLIA_256_GCM</code></dt>
<dd><p>CAMELLIA in GCM mode with 256-bit keys (AEAD).
</p></dd>
<dt><code>GNUTLS_CIPHER_RC2_40_CBC</code></dt>
<dd><p>RC2 in CBC mode with 40-bit keys.
</p></dd>
<dt><code>GNUTLS_CIPHER_DES_CBC</code></dt>
<dd><p>DES in CBC mode (56-bit keys).
</p></dd>
<dt><code>GNUTLS_CIPHER_AES_128_CCM</code></dt>
<dd><p>AES in CCM mode with 128-bit keys (AEAD).
</p></dd>
<dt><code>GNUTLS_CIPHER_AES_256_CCM</code></dt>
<dd><p>AES in CCM mode with 256-bit keys (AEAD).
</p></dd>
<dt><code>GNUTLS_CIPHER_AES_128_CCM_8</code></dt>
<dd><p>AES in CCM mode with 64-bit tag and 128-bit keys (AEAD).
</p></dd>
<dt><code>GNUTLS_CIPHER_AES_256_CCM_8</code></dt>
<dd><p>AES in CCM mode with 64-bit tag and 256-bit keys (AEAD).
</p></dd>
<dt><code>GNUTLS_CIPHER_CHACHA20_POLY1305</code></dt>
<dd><p>The Chacha20 cipher with the Poly1305 authenticator (AEAD).
</p></dd>
<dt><code>GNUTLS_CIPHER_GOST28147_TC26Z_CFB</code></dt>
<dd><p>GOST 28147-89 (Magma) cipher in CFB mode with TC26 Z S-box.
</p></dd>
<dt><code>GNUTLS_CIPHER_GOST28147_CPA_CFB</code></dt>
<dd><p>GOST 28147-89 (Magma) cipher in CFB mode with CryptoPro A S-box.
</p></dd>
<dt><code>GNUTLS_CIPHER_GOST28147_CPB_CFB</code></dt>
<dd><p>GOST 28147-89 (Magma) cipher in CFB mode with CryptoPro B S-box.
</p></dd>
<dt><code>GNUTLS_CIPHER_GOST28147_CPC_CFB</code></dt>
<dd><p>GOST 28147-89 (Magma) cipher in CFB mode with CryptoPro C S-box.
</p></dd>
<dt><code>GNUTLS_CIPHER_GOST28147_CPD_CFB</code></dt>
<dd><p>GOST 28147-89 (Magma) cipher in CFB mode with CryptoPro D S-box.
</p></dd>
<dt><code>GNUTLS_CIPHER_AES_128_CFB8</code></dt>
<dd><p>AES in CFB8 mode with 128-bit keys.
</p></dd>
<dt><code>GNUTLS_CIPHER_AES_192_CFB8</code></dt>
<dd><p>AES in CFB8 mode with 192-bit keys.
</p></dd>
<dt><code>GNUTLS_CIPHER_AES_256_CFB8</code></dt>
<dd><p>AES in CFB8 mode with 256-bit keys.
</p></dd>
<dt><code>GNUTLS_CIPHER_AES_128_XTS</code></dt>
<dd><p>AES in XTS mode with 128-bit key + 128bit tweak key.
</p></dd>
<dt><code>GNUTLS_CIPHER_AES_256_XTS</code></dt>
<dd><p>AES in XTS mode with 256-bit key + 256bit tweak key.
Note that the XTS ciphers are message oriented.
The whole message needs to be provided with a single call, because
cipher-stealing requires to know where the message actually terminates
in order to be able to compute where the stealing occurs.
</p></dd>
<dt><code>GNUTLS_CIPHER_GOST28147_TC26Z_CNT</code></dt>
<dd><p>GOST 28147-89 (Magma) cipher in CNT mode with TC26 Z S-box.
</p></dd>
<dt><code>GNUTLS_CIPHER_IDEA_PGP_CFB</code></dt>
<dd><p>IDEA in CFB mode (placeholder - unsupported).
</p></dd>
<dt><code>GNUTLS_CIPHER_3DES_PGP_CFB</code></dt>
<dd><p>3DES in CFB mode (placeholder - unsupported).
</p></dd>
<dt><code>GNUTLS_CIPHER_CAST5_PGP_CFB</code></dt>
<dd><p>CAST5 in CFB mode (placeholder - unsupported).
</p></dd>
<dt><code>GNUTLS_CIPHER_BLOWFISH_PGP_CFB</code></dt>
<dd><p>Blowfish in CFB mode (placeholder - unsupported).
</p></dd>
<dt><code>GNUTLS_CIPHER_SAFER_SK128_PGP_CFB</code></dt>
<dd><p>Safer-SK in CFB mode with 128-bit keys (placeholder - unsupported).
</p></dd>
<dt><code>GNUTLS_CIPHER_AES128_PGP_CFB</code></dt>
<dd><p>AES in CFB mode with 128-bit keys (placeholder - unsupported).
</p></dd>
<dt><code>GNUTLS_CIPHER_AES192_PGP_CFB</code></dt>
<dd><p>AES in CFB mode with 192-bit keys (placeholder - unsupported).
</p></dd>
<dt><code>GNUTLS_CIPHER_AES256_PGP_CFB</code></dt>
<dd><p>AES in CFB mode with 256-bit keys (placeholder - unsupported).
</p></dd>
<dt><code>GNUTLS_CIPHER_TWOFISH_PGP_CFB</code></dt>
<dd><p>Twofish in CFB mode (placeholder - unsupported).
</p></dd>
</dl>

<div class="float-caption"><p><strong>Figure 9.1: </strong>The supported ciphers.</p></div></div>
<span id="Authenticated_002dencryption-API"></span><h4 class="subheading">Authenticated-encryption API</h4>

<p>The AEAD API provides access to all ciphers supported by GnuTLS which support
authenticated encryption with associated data; these ciphers are marked with
the AEAD keyword on the table above. The AEAD cipher API is
particularly suitable for message or packet-encryption as it provides
authentication and encryption on the same API. See <code>RFC5116</code> for more
information on authenticated encryption.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005faead_005fcipher_005finit">gnutls_aead_cipher_init</a> (gnutls_aead_cipher_hd_t * <var>handle</var>, gnutls_cipher_algorithm_t <var>cipher</var>, const gnutls_datum_t * <var>key</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005faead_005fcipher_005fencrypt">gnutls_aead_cipher_encrypt</a> (gnutls_aead_cipher_hd_t <var>handle</var>, const void * <var>nonce</var>, size_t <var>nonce_len</var>, const void * <var>auth</var>, size_t <var>auth_len</var>, size_t <var>tag_size</var>, const void * <var>ptext</var>, size_t <var>ptext_len</var>, void * <var>ctext</var>, size_t * <var>ctext_len</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005faead_005fcipher_005fdecrypt">gnutls_aead_cipher_decrypt</a> (gnutls_aead_cipher_hd_t <var>handle</var>, const void * <var>nonce</var>, size_t <var>nonce_len</var>, const void * <var>auth</var>, size_t <var>auth_len</var>, size_t <var>tag_size</var>, const void * <var>ctext</var>, size_t <var>ctext_len</var>, void * <var>ptext</var>, size_t * <var>ptext_len</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005faead_005fcipher_005fdeinit">gnutls_aead_cipher_deinit</a> (gnutls_aead_cipher_hd_t <var>handle</var>)</code></dt>
</dl>

<p>Because the encryption function above may be difficult to use with
scattered data, we provide the following API.
</p>




<dl>
<dt id="index-gnutls_005faead_005fcipher_005fencryptv">Function: <em>int</em> <strong>gnutls_aead_cipher_encryptv</strong> <em>(gnutls_aead_cipher_hd_t <var>handle</var>, const void * <var>nonce</var>, size_t <var>nonce_len</var>, const giovec_t * <var>auth_iov</var>, int <var>auth_iovcnt</var>, size_t <var>tag_size</var>, const giovec_t * <var>iov</var>, int <var>iovcnt</var>, void * <var>ctext</var>, size_t * <var>ctext_len</var>)</em></dt>
<dd><p><var>handle</var>: is a <code>gnutls_aead_cipher_hd_t</code>  type.
</p>
<p><var>nonce</var>: the nonce to set
</p>
<p><var>nonce_len</var>: The length of the nonce
</p>
<p><var>auth_iov</var>: additional data to be authenticated
</p>
<p><var>auth_iovcnt</var>: The number of buffers in  <code>auth_iov</code> 
</p>
<p><var>tag_size</var>: The size of the tag to use (use zero for the default)
</p>
<p><var>iov</var>: the data to be encrypted
</p>
<p><var>iovcnt</var>: The number of buffers in  <code>iov</code> 
</p>
<p><var>ctext</var>: the encrypted data including authentication tag
</p>
<p><var>ctext_len</var>: the length of encrypted data (initially must hold the maximum available size, including space for tag)
</p>
<p>This function will encrypt the provided data buffers using the algorithm
specified by the context. The output data will contain the
authentication tag.
</p>
<p><strong>Returns:</strong> Zero or a negative error code on error.
</p>
<p><strong>Since:</strong> 3.6.3
</p></dd></dl>

<span id="Legacy-API"></span><h4 class="subheading">Legacy API</h4>

<p>The legacy API provides low-level access to all legacy ciphers supported by GnuTLS,
and some of the AEAD ciphers (e.g., AES-GCM and CHACHA20). The restrictions
of the nettle library implementation of the ciphers apply verbatim to this
API<a id="DOCF22" href="#FOOT22"><sup>22</sup></a>.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fcipher_005finit">gnutls_cipher_init</a> (gnutls_cipher_hd_t * <var>handle</var>, gnutls_cipher_algorithm_t <var>cipher</var>, const gnutls_datum_t * <var>key</var>, const gnutls_datum_t * <var>iv</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fcipher_005fencrypt2">gnutls_cipher_encrypt2</a> (gnutls_cipher_hd_t <var>handle</var>, const void * <var>ptext</var>, size_t <var>ptext_len</var>, void * <var>ctext</var>, size_t <var>ctext_len</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fcipher_005fdecrypt2">gnutls_cipher_decrypt2</a> (gnutls_cipher_hd_t <var>handle</var>, const void * <var>ctext</var>, size_t <var>ctext_len</var>, void * <var>ptext</var>, size_t <var>ptext_len</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005fcipher_005fset_005fiv">gnutls_cipher_set_iv</a> (gnutls_cipher_hd_t <var>handle</var>, void * <var>iv</var>, size_t <var>ivlen</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005fcipher_005fdeinit">gnutls_cipher_deinit</a> (gnutls_cipher_hd_t <var>handle</var>)</code></dt>
</dl>

<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fcipher_005fadd_005fauth">gnutls_cipher_add_auth</a> (gnutls_cipher_hd_t <var>handle</var>, const void * <var>ptext</var>, size_t <var>ptext_size</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fcipher_005ftag">gnutls_cipher_tag</a> (gnutls_cipher_hd_t <var>handle</var>, void * <var>tag</var>, size_t <var>tag_size</var>)</code></dt>
</dl>
<p>While the latter two functions allow the same API can be used with authenticated encryption ciphers, 
it is recommended to use the following functions which are solely for AEAD ciphers. The latter
API is designed to be simple to use and also hard to misuse, by handling the tag verification
and addition in transparent way.
</p>
<hr>
<span id="Public-key-algorithms"></span><div class="header">
<p>
Next: <a href="#Cryptographic-Message-Syntax-_002f-PKCS7" accesskey="n" rel="next">Cryptographic Message Syntax / PKCS7</a>, Previous: <a href="#Symmetric-algorithms" accesskey="p" rel="prev">Symmetric algorithms</a>, Up: <a href="#Using-GnuTLS-as-a-cryptographic-library" accesskey="u" rel="up">Using GnuTLS as a cryptographic library</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Public-key-algorithms-1"></span><h3 class="section">9.2 Public key algorithms</h3>
<span id="index-public-key-algorithms"></span>

<p>Public key cryptography algorithms such as RSA, DSA and ECDSA, are
accessed using the abstract key API in <a href="#Abstract-key-types">Abstract key types</a>. This
is a high level API with the advantage of transparently handling keys
stored in memory and keys present in smart cards.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fprivkey_005finit">gnutls_privkey_init</a> (gnutls_privkey_t * <var>key</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fprivkey_005fimport_005furl">gnutls_privkey_import_url</a> (gnutls_privkey_t <var>key</var>, const char * <var>url</var>, unsigned int <var>flags</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fprivkey_005fimport_005fx509_005fraw">gnutls_privkey_import_x509_raw</a> (gnutls_privkey_t <var>pkey</var>, const gnutls_datum_t * <var>data</var>, gnutls_x509_crt_fmt_t <var>format</var>, const char * <var>password</var>, unsigned int <var>flags</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fprivkey_005fsign_005fdata">gnutls_privkey_sign_data</a> (gnutls_privkey_t <var>signer</var>, gnutls_digest_algorithm_t <var>hash</var>, unsigned int <var>flags</var>, const gnutls_datum_t * <var>data</var>, gnutls_datum_t * <var>signature</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fprivkey_005fsign_005fhash">gnutls_privkey_sign_hash</a> (gnutls_privkey_t <var>signer</var>, gnutls_digest_algorithm_t <var>hash_algo</var>, unsigned int <var>flags</var>, const gnutls_datum_t * <var>hash_data</var>, gnutls_datum_t * <var>signature</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005fprivkey_005fdeinit">gnutls_privkey_deinit</a> (gnutls_privkey_t <var>key</var>)</code></dt>
</dl>

<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fpubkey_005finit">gnutls_pubkey_init</a> (gnutls_pubkey_t * <var>key</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpubkey_005fimport_005furl">gnutls_pubkey_import_url</a> (gnutls_pubkey_t <var>key</var>, const char * <var>url</var>, unsigned int <var>flags</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpubkey_005fimport_005fx509">gnutls_pubkey_import_x509</a> (gnutls_pubkey_t <var>key</var>, gnutls_x509_crt_t <var>crt</var>, unsigned int <var>flags</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpubkey_005fverify_005fdata2">gnutls_pubkey_verify_data2</a> (gnutls_pubkey_t <var>pubkey</var>, gnutls_sign_algorithm_t <var>algo</var>, unsigned int <var>flags</var>, const gnutls_datum_t * <var>data</var>, const gnutls_datum_t * <var>signature</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpubkey_005fverify_005fhash2">gnutls_pubkey_verify_hash2</a> (gnutls_pubkey_t <var>key</var>, gnutls_sign_algorithm_t <var>algo</var>, unsigned int <var>flags</var>, const gnutls_datum_t * <var>hash</var>, const gnutls_datum_t * <var>signature</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005fpubkey_005fdeinit">gnutls_pubkey_deinit</a> (gnutls_pubkey_t <var>key</var>)</code></dt>
</dl>

<p>Keys stored in memory can be imported using functions like
<a href="#gnutls_005fprivkey_005fimport_005fx509_005fraw">gnutls_privkey_import_x509_raw</a>, while keys on smart cards or HSMs
should be imported using their PKCS#11 URL with
<a href="#gnutls_005fprivkey_005fimport_005furl">gnutls_privkey_import_url</a>.
</p>
<p>If any of the smart card operations require PIN, that should be provided
either by setting the global PIN function
(<a href="#gnutls_005fpkcs11_005fset_005fpin_005ffunction">gnutls_pkcs11_set_pin_function</a>), or better with the targeted to
structures functions such as <a href="#gnutls_005fprivkey_005fset_005fpin_005ffunction">gnutls_privkey_set_pin_function</a>.
</p>

<span id="Key-generation-2"></span><h4 class="subsection">9.2.1 Key generation</h4>

<p>All supported key types (including RSA, DSA, ECDSA, Ed25519) can be generated
with GnuTLS. They can be generated with the simpler <a href="#gnutls_005fprivkey_005fgenerate">gnutls_privkey_generate</a>
or with the more advanced <a href="#gnutls_005fprivkey_005fgenerate2">gnutls_privkey_generate2</a>.
</p>




<dl>
<dt id="index-gnutls_005fprivkey_005fgenerate2">Function: <em>int</em> <strong>gnutls_privkey_generate2</strong> <em>(gnutls_privkey_t <var>pkey</var>, gnutls_pk_algorithm_t <var>algo</var>, unsigned int <var>bits</var>, unsigned int <var>flags</var>, const gnutls_keygen_data_st * <var>data</var>, unsigned <var>data_size</var>)</em></dt>
<dd><p><var>pkey</var>: The private key
</p>
<p><var>algo</var>: is one of the algorithms in <code>gnutls_pk_algorithm_t</code> .
</p>
<p><var>bits</var>: the size of the modulus
</p>
<p><var>flags</var>: Must be zero or flags from <code>gnutls_privkey_flags_t</code> .
</p>
<p><var>data</var>: Allow specifying <code>gnutls_keygen_data_st</code>  types such as the seed to be used.
</p>
<p><var>data_size</var>: The number of  <code>data</code> available.
</p>
<p>This function will generate a random private key. Note that this
function must be called on an initialized private key.
</p>
<p>The flag <code>GNUTLS_PRIVKEY_FLAG_PROVABLE</code> 
instructs the key generation process to use algorithms like Shawe-Taylor
(from FIPS PUB186-4) which generate provable parameters out of a seed
for RSA and DSA keys. On DSA keys the PQG parameters are generated using the
seed, while on RSA the two primes. To specify an explicit seed
(by default a random seed is used), use the  <code>data</code> with a <code>GNUTLS_KEYGEN_SEED</code> 
type.
</p>
<p>Note that when generating an elliptic curve key, the curve
can be substituted in the place of the bits parameter using the
<code>GNUTLS_CURVE_TO_BITS()</code>  macro.
</p>
<p>To export the generated keys in memory or in files it is recommended to use the
PKCS<code>8</code>  form as it can handle all key types, and can store additional parameters
such as the seed, in case of provable RSA or DSA keys.
Generated keys can be exported in memory using <code>gnutls_privkey_export_x509()</code> ,
and then with <code>gnutls_x509_privkey_export2_pkcs8()</code> .
</p>
<p>If key generation is part of your application, avoid setting the number
of bits directly, and instead use <code>gnutls_sec_param_to_pk_bits()</code> .
That way the generated keys will adapt to the security levels
of the underlying GnuTLS library.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.5.0
</p></dd></dl>

<hr>
<span id="Cryptographic-Message-Syntax-_002f-PKCS7"></span><div class="header">
<p>
Next: <a href="#Hash-and-MAC-functions" accesskey="n" rel="next">Hash and MAC functions</a>, Previous: <a href="#Public-key-algorithms" accesskey="p" rel="prev">Public key algorithms</a>, Up: <a href="#Using-GnuTLS-as-a-cryptographic-library" accesskey="u" rel="up">Using GnuTLS as a cryptographic library</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Cryptographic-Message-Syntax-_002f-PKCS7-1"></span><h3 class="section">9.3 Cryptographic Message Syntax / PKCS7</h3>
<span id="index-public-key-algorithms-1"></span>
<span id="index-cryptographic-message-syntax"></span>
<span id="index-file-signing"></span>
<span id="index-CMS"></span>
<span id="index-PKCS-_00237"></span>

<p>The CMS or PKCS #7 format is a commonly used format for digital signatures.
PKCS #7 is the name of the original standard when published by RSA, though
today the standard is adopted by IETF under the name CMS.
</p>
<p>The standards include multiple ways of signing a digital document, e.g.,
by embedding the data into the signature, or creating detached signatures of the data,
including a timestamp, additional certificates etc. In certain cases the
same format is also used to transport lists of certificates and CRLs.
</p>
<p>It is a relatively popular standard to sign structures, and is being used to
sign in PDF files, as well as for signing kernel modules and other
structures.
</p>
<p>In GnuTLS, the basic functions to initialize, deinitialize, import, export or print information
about a PKCS #7 structure are listed below.
</p><dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fpkcs7_005finit">gnutls_pkcs7_init</a> (gnutls_pkcs7_t * <var>pkcs7</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005fpkcs7_005fdeinit">gnutls_pkcs7_deinit</a> (gnutls_pkcs7_t <var>pkcs7</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpkcs7_005fexport2">gnutls_pkcs7_export2</a> (gnutls_pkcs7_t <var>pkcs7</var>, gnutls_x509_crt_fmt_t <var>format</var>, gnutls_datum_t * <var>out</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpkcs7_005fimport">gnutls_pkcs7_import</a> (gnutls_pkcs7_t <var>pkcs7</var>, const gnutls_datum_t * <var>data</var>, gnutls_x509_crt_fmt_t <var>format</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpkcs7_005fprint">gnutls_pkcs7_print</a> (gnutls_pkcs7_t <var>pkcs7</var>, gnutls_certificate_print_formats_t <var>format</var>, gnutls_datum_t * <var>out</var>)</code></dt>
</dl>

<p>The following functions allow the verification of a structure using either a trust list, or
individual certificates. The <a href="#gnutls_005fpkcs7_005fsign">gnutls_pkcs7_sign</a> function is the data signing function.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fpkcs7_005fverify_005fdirect">gnutls_pkcs7_verify_direct</a> (gnutls_pkcs7_t <var>pkcs7</var>, gnutls_x509_crt_t <var>signer</var>, unsigned <var>idx</var>, const gnutls_datum_t * <var>data</var>, unsigned <var>flags</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpkcs7_005fverify">gnutls_pkcs7_verify</a> (gnutls_pkcs7_t <var>pkcs7</var>, gnutls_x509_trust_list_t <var>tl</var>, gnutls_typed_vdata_st * <var>vdata</var>, unsigned int <var>vdata_size</var>, unsigned <var>idx</var>, const gnutls_datum_t * <var>data</var>, unsigned <var>flags</var>)</code></dt>
</dl>





<dl>
<dt id="index-gnutls_005fpkcs7_005fsign">Function: <em>int</em> <strong>gnutls_pkcs7_sign</strong> <em>(gnutls_pkcs7_t <var>pkcs7</var>, gnutls_x509_crt_t <var>signer</var>, gnutls_privkey_t <var>signer_key</var>, const gnutls_datum_t * <var>data</var>, gnutls_pkcs7_attrs_t <var>signed_attrs</var>, gnutls_pkcs7_attrs_t <var>unsigned_attrs</var>, gnutls_digest_algorithm_t <var>dig</var>, unsigned <var>flags</var>)</em></dt>
<dd><p><var>pkcs7</var>: should contain a <code>gnutls_pkcs7_t</code>  type
</p>
<p><var>signer</var>: the certificate to sign the structure
</p>
<p><var>signer_key</var>: the key to sign the structure
</p>
<p><var>data</var>: The data to be signed or <code>NULL</code>  if the data are already embedded
</p>
<p><var>signed_attrs</var>: Any additional attributes to be included in the signed ones (or <code>NULL</code> )
</p>
<p><var>unsigned_attrs</var>: Any additional attributes to be included in the unsigned ones (or <code>NULL</code> )
</p>
<p><var>dig</var>: The digest algorithm to use for signing
</p>
<p><var>flags</var>: Should be zero or one of <code>GNUTLS_PKCS7</code>  flags
</p>
<p>This function will add a signature in the provided PKCS <code>7</code>  structure
for the provided data. Multiple signatures can be made with different
signers.
</p>
<p>The available flags are:
<code>GNUTLS_PKCS7_EMBED_DATA</code> , <code>GNUTLS_PKCS7_INCLUDE_TIME</code> , <code>GNUTLS_PKCS7_INCLUDE_CERT</code> ,
and <code>GNUTLS_PKCS7_WRITE_SPKI</code> . They are explained in the <code>gnutls_pkcs7_sign_flags</code> 
definition.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.4.2
</p></dd></dl>

<div class="float"><span id="gnutls_005fpkcs7_005fsign_005fflags"></span>


<dl compact="compact">
<dt><code>GNUTLS_PKCS7_EMBED_DATA</code></dt>
<dd><p>The signed data will be embedded in the structure.
</p></dd>
<dt><code>GNUTLS_PKCS7_INCLUDE_TIME</code></dt>
<dd><p>The signing time will be included in the structure.
</p></dd>
<dt><code>GNUTLS_PKCS7_INCLUDE_CERT</code></dt>
<dd><p>The signer&rsquo;s certificate will be included in the cert list.
</p></dd>
<dt><code>GNUTLS_PKCS7_WRITE_SPKI</code></dt>
<dd><p>Use the signer&rsquo;s key identifier instead of name.
</p></dd>
</dl>

<div class="float-caption"><p><strong>Figure 9.2: </strong>Flags applicable to gnutls_pkcs7_sign()</p></div></div>
<p>Other helper functions which allow to access the signatures, or certificates attached
in the structure are listed below.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fpkcs7_005fget_005fsignature_005fcount">gnutls_pkcs7_get_signature_count</a> (gnutls_pkcs7_t <var>pkcs7</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpkcs7_005fget_005fsignature_005finfo">gnutls_pkcs7_get_signature_info</a> (gnutls_pkcs7_t <var>pkcs7</var>, unsigned <var>idx</var>, gnutls_pkcs7_signature_info_st * <var>info</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpkcs7_005fget_005fcrt_005fcount">gnutls_pkcs7_get_crt_count</a> (gnutls_pkcs7_t <var>pkcs7</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpkcs7_005fget_005fcrt_005fraw2">gnutls_pkcs7_get_crt_raw2</a> (gnutls_pkcs7_t <var>pkcs7</var>, unsigned <var>indx</var>, gnutls_datum_t * <var>cert</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpkcs7_005fget_005fcrl_005fcount">gnutls_pkcs7_get_crl_count</a> (gnutls_pkcs7_t <var>pkcs7</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpkcs7_005fget_005fcrl_005fraw2">gnutls_pkcs7_get_crl_raw2</a> (gnutls_pkcs7_t <var>pkcs7</var>, unsigned <var>indx</var>, gnutls_datum_t * <var>crl</var>)</code></dt>
</dl>

<p>To append certificates, or CRLs in the structure the following functions are provided.
</p><dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fpkcs7_005fset_005fcrt_005fraw">gnutls_pkcs7_set_crt_raw</a> (gnutls_pkcs7_t <var>pkcs7</var>, const gnutls_datum_t * <var>crt</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpkcs7_005fset_005fcrt">gnutls_pkcs7_set_crt</a> (gnutls_pkcs7_t <var>pkcs7</var>, gnutls_x509_crt_t <var>crt</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpkcs7_005fset_005fcrl_005fraw">gnutls_pkcs7_set_crl_raw</a> (gnutls_pkcs7_t <var>pkcs7</var>, const gnutls_datum_t * <var>crl</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fpkcs7_005fset_005fcrl">gnutls_pkcs7_set_crl</a> (gnutls_pkcs7_t <var>pkcs7</var>, gnutls_x509_crl_t <var>crl</var>)</code></dt>
</dl>

<hr>
<span id="Hash-and-MAC-functions"></span><div class="header">
<p>
Next: <a href="#Random-number-generation" accesskey="n" rel="next">Random number generation</a>, Previous: <a href="#Cryptographic-Message-Syntax-_002f-PKCS7" accesskey="p" rel="prev">Cryptographic Message Syntax / PKCS7</a>, Up: <a href="#Using-GnuTLS-as-a-cryptographic-library" accesskey="u" rel="up">Using GnuTLS as a cryptographic library</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Hash-and-MAC-functions-1"></span><h3 class="section">9.4 Hash and MAC functions</h3>
<span id="index-hash-functions"></span>
<span id="index-HMAC-functions"></span>
<span id="index-MAC-functions"></span>

<p>The available operations to access hash functions and hash-MAC (HMAC) algorithms
are shown below. HMAC algorithms provided keyed hash functionality. The supported MAC and HMAC
algorithms are listed in <a href="#gnutls_005fmac_005falgorithm_005ft">Figure 9.3</a>. Note that, despite the <code>hmac</code> part 
in the name of the MAC functions listed below, they can be used either for HMAC or MAC operations.
</p>
<div class="float"><span id="gnutls_005fmac_005falgorithm_005ft"></span>


<dl compact="compact">
<dt><code>GNUTLS_MAC_UNKNOWN</code></dt>
<dd><p>Unknown MAC algorithm.
</p></dd>
<dt><code>GNUTLS_MAC_NULL</code></dt>
<dd><p>NULL MAC algorithm (empty output).
</p></dd>
<dt><code>GNUTLS_MAC_MD5</code></dt>
<dd><p>HMAC-MD5 algorithm.
</p></dd>
<dt><code>GNUTLS_MAC_SHA1</code></dt>
<dd><p>HMAC-SHA-1 algorithm.
</p></dd>
<dt><code>GNUTLS_MAC_RMD160</code></dt>
<dd><p>HMAC-RMD160 algorithm.
</p></dd>
<dt><code>GNUTLS_MAC_MD2</code></dt>
<dd><p>HMAC-MD2 algorithm.
</p></dd>
<dt><code>GNUTLS_MAC_SHA256</code></dt>
<dd><p>HMAC-SHA-256 algorithm.
</p></dd>
<dt><code>GNUTLS_MAC_SHA384</code></dt>
<dd><p>HMAC-SHA-384 algorithm.
</p></dd>
<dt><code>GNUTLS_MAC_SHA512</code></dt>
<dd><p>HMAC-SHA-512 algorithm.
</p></dd>
<dt><code>GNUTLS_MAC_SHA224</code></dt>
<dd><p>HMAC-SHA-224 algorithm.
</p></dd>
<dt><code>GNUTLS_MAC_SHA3_224</code></dt>
<dd><p>Reserved; unimplemented.
</p></dd>
<dt><code>GNUTLS_MAC_SHA3_256</code></dt>
<dd><p>Reserved; unimplemented.
</p></dd>
<dt><code>GNUTLS_MAC_SHA3_384</code></dt>
<dd><p>Reserved; unimplemented.
</p></dd>
<dt><code>GNUTLS_MAC_SHA3_512</code></dt>
<dd><p>Reserved; unimplemented.
</p></dd>
<dt><code>GNUTLS_MAC_MD5_SHA1</code></dt>
<dd><p>Combined MD5+SHA1 MAC placeholder.
</p></dd>
<dt><code>GNUTLS_MAC_GOSTR_94</code></dt>
<dd><p>HMAC GOST R 34.11-94 algorithm.
</p></dd>
<dt><code>GNUTLS_MAC_STREEBOG_256</code></dt>
<dd><p>HMAC GOST R 34.11-2001 (Streebog) algorithm, 256 bit.
</p></dd>
<dt><code>GNUTLS_MAC_STREEBOG_512</code></dt>
<dd><p>HMAC GOST R 34.11-2001 (Streebog) algorithm, 512 bit.
</p></dd>
<dt><code>GNUTLS_MAC_AEAD</code></dt>
<dd><p>MAC implicit through AEAD cipher.
</p></dd>
<dt><code>GNUTLS_MAC_UMAC_96</code></dt>
<dd><p>The UMAC-96 MAC algorithm (requires nonce).
</p></dd>
<dt><code>GNUTLS_MAC_UMAC_128</code></dt>
<dd><p>The UMAC-128 MAC algorithm (requires nonce).
</p></dd>
<dt><code>GNUTLS_MAC_AES_CMAC_128</code></dt>
<dd><p>The AES-CMAC-128 MAC algorithm.
</p></dd>
<dt><code>GNUTLS_MAC_AES_CMAC_256</code></dt>
<dd><p>The AES-CMAC-256 MAC algorithm.
</p></dd>
<dt><code>GNUTLS_MAC_AES_GMAC_128</code></dt>
<dd><p>The AES-GMAC-128 MAC algorithm (requires nonce).
</p></dd>
<dt><code>GNUTLS_MAC_AES_GMAC_192</code></dt>
<dd><p>The AES-GMAC-192 MAC algorithm (requires nonce).
</p></dd>
<dt><code>GNUTLS_MAC_AES_GMAC_256</code></dt>
<dd><p>The AES-GMAC-256 MAC algorithm (requires nonce).
</p></dd>
<dt><code>GNUTLS_MAC_GOST28147_TC26Z_IMIT</code></dt>
<dd><p>The GOST 28147-89 working in IMIT mode with TC26 Z S-box.
</p></dd>
</dl>

<div class="float-caption"><p><strong>Figure 9.3: </strong>The supported MAC and HMAC algorithms.</p></div></div>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fhmac_005finit">gnutls_hmac_init</a> (gnutls_hmac_hd_t * <var>dig</var>, gnutls_mac_algorithm_t <var>algorithm</var>, const void * <var>key</var>, size_t <var>keylen</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fhmac">gnutls_hmac</a> (gnutls_hmac_hd_t <var>handle</var>, const void * <var>ptext</var>, size_t <var>ptext_len</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005fhmac_005foutput">gnutls_hmac_output</a> (gnutls_hmac_hd_t <var>handle</var>, void * <var>digest</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005fhmac_005fdeinit">gnutls_hmac_deinit</a> (gnutls_hmac_hd_t <var>handle</var>, void * <var>digest</var>)</code></dt>
<dt><code><var>unsigned</var> <a href="#gnutls_005fhmac_005fget_005flen">gnutls_hmac_get_len</a> (gnutls_mac_algorithm_t <var>algorithm</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fhmac_005ffast">gnutls_hmac_fast</a> (gnutls_mac_algorithm_t <var>algorithm</var>, const void * <var>key</var>, size_t <var>keylen</var>, const void * <var>ptext</var>, size_t <var>ptext_len</var>, void * <var>digest</var>)</code></dt>
</dl>

<p>The available functions to access hash functions are shown below. The supported hash functions
are shown in <a href="#gnutls_005fdigest_005falgorithm_005ft">Figure 9.4</a>.
</p>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005fhash_005finit">gnutls_hash_init</a> (gnutls_hash_hd_t * <var>dig</var>, gnutls_digest_algorithm_t <var>algorithm</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fhash">gnutls_hash</a> (gnutls_hash_hd_t <var>handle</var>, const void * <var>ptext</var>, size_t <var>ptext_len</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005fhash_005foutput">gnutls_hash_output</a> (gnutls_hash_hd_t <var>handle</var>, void * <var>digest</var>)</code></dt>
<dt><code><var>void</var> <a href="#gnutls_005fhash_005fdeinit">gnutls_hash_deinit</a> (gnutls_hash_hd_t <var>handle</var>, void * <var>digest</var>)</code></dt>
<dt><code><var>unsigned</var> <a href="#gnutls_005fhash_005fget_005flen">gnutls_hash_get_len</a> (gnutls_digest_algorithm_t <var>algorithm</var>)</code></dt>
<dt><code><var>int</var> <a href="#gnutls_005fhash_005ffast">gnutls_hash_fast</a> (gnutls_digest_algorithm_t <var>algorithm</var>, const void * <var>ptext</var>, size_t <var>ptext_len</var>, void * <var>digest</var>)</code></dt>
</dl>
<dl compact="compact">
<dt><code><var>int</var> <a href="#gnutls_005ffingerprint">gnutls_fingerprint</a> (gnutls_digest_algorithm_t <var>algo</var>, const gnutls_datum_t * <var>data</var>, void * <var>result</var>, size_t * <var>result_size</var>)</code></dt>
</dl>

<div class="float"><span id="gnutls_005fdigest_005falgorithm_005ft"></span>


<dl compact="compact">
<dt><code>GNUTLS_DIG_UNKNOWN</code></dt>
<dd><p>Unknown hash algorithm.
</p></dd>
<dt><code>GNUTLS_DIG_NULL</code></dt>
<dd><p>NULL hash algorithm (empty output).
</p></dd>
<dt><code>GNUTLS_DIG_MD5</code></dt>
<dd><p>MD5 algorithm.
</p></dd>
<dt><code>GNUTLS_DIG_SHA1</code></dt>
<dd><p>SHA-1 algorithm.
</p></dd>
<dt><code>GNUTLS_DIG_RMD160</code></dt>
<dd><p>RMD160 algorithm.
</p></dd>
<dt><code>GNUTLS_DIG_MD2</code></dt>
<dd><p>MD2 algorithm.
</p></dd>
<dt><code>GNUTLS_DIG_SHA256</code></dt>
<dd><p>SHA-256 algorithm.
</p></dd>
<dt><code>GNUTLS_DIG_SHA384</code></dt>
<dd><p>SHA-384 algorithm.
</p></dd>
<dt><code>GNUTLS_DIG_SHA512</code></dt>
<dd><p>SHA-512 algorithm.
</p></dd>
<dt><code>GNUTLS_DIG_SHA224</code></dt>
<dd><p>SHA-224 algorithm.
</p></dd>
<dt><code>GNUTLS_DIG_SHA3_224</code></dt>
<dd><p>SHA3-224 algorithm.
</p></dd>
<dt><code>GNUTLS_DIG_SHA3_256</code></dt>
<dd><p>SHA3-256 algorithm.
</p></dd>
<dt><code>GNUTLS_DIG_SHA3_384</code></dt>
<dd><p>SHA3-384 algorithm.
</p></dd>
<dt><code>GNUTLS_DIG_SHA3_512</code></dt>
<dd><p>SHA3-512 algorithm.
</p></dd>
<dt><code>GNUTLS_DIG_MD5_SHA1</code></dt>
<dd><p>Combined MD5+SHA1 algorithm.
</p></dd>
<dt><code>GNUTLS_DIG_GOSTR_94</code></dt>
<dd><p>GOST R 34.11-94 algorithm.
</p></dd>
<dt><code>GNUTLS_DIG_STREEBOG_256</code></dt>
<dd><p>GOST R 34.11-2001 (Streebog) algorithm, 256 bit.
</p></dd>
<dt><code>GNUTLS_DIG_STREEBOG_512</code></dt>
<dd><p>GOST R 34.11-2001 (Streebog) algorithm, 512 bit.
</p></dd>
</dl>

<div class="float-caption"><p><strong>Figure 9.4: </strong>The supported hash algorithms.</p></div></div>
<hr>
<span id="Random-number-generation"></span><div class="header">
<p>
Next: <a href="#Overriding-algorithms" accesskey="n" rel="next">Overriding algorithms</a>, Previous: <a href="#Hash-and-MAC-functions" accesskey="p" rel="prev">Hash and MAC functions</a>, Up: <a href="#Using-GnuTLS-as-a-cryptographic-library" accesskey="u" rel="up">Using GnuTLS as a cryptographic library</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Random-number-generation-1"></span><h3 class="section">9.5 Random number generation</h3>
<span id="index-random-numbers"></span>

<p>Access to the random number generator is provided using the <a href="#gnutls_005frnd">gnutls_rnd</a>
function. It allows obtaining random data of various levels.
</p>
<div class="float"><span id="gnutls_005frnd_005flevel_005ft"></span>


<dl compact="compact">
<dt><code>GNUTLS_RND_NONCE</code></dt>
<dd><p>Non-predictable random number.  Fatal in parts
of session if broken, i.e., vulnerable to statistical analysis.
</p></dd>
<dt><code>GNUTLS_RND_RANDOM</code></dt>
<dd><p>Pseudo-random cryptographic random number.
Fatal in session if broken. Example use: temporal keys.
</p></dd>
<dt><code>GNUTLS_RND_KEY</code></dt>
<dd><p>Fatal in many sessions if broken. Example use:
Long-term keys.
</p></dd>
</dl>

<div class="float-caption"><p><strong>Figure 9.5: </strong>The random number levels.</p></div></div>



<dl>
<dt id="index-gnutls_005frnd">Function: <em>int</em> <strong>gnutls_rnd</strong> <em>(gnutls_rnd_level_t <var>level</var>, void * <var>data</var>, size_t <var>len</var>)</em></dt>
<dd><p><var>level</var>: a security level
</p>
<p><var>data</var>: place to store random bytes
</p>
<p><var>len</var>: The requested size
</p>
<p>This function will generate random data and store it to output
buffer. The value of  <code>level</code> should be one of <code>GNUTLS_RND_NONCE</code> ,
<code>GNUTLS_RND_RANDOM</code>  and <code>GNUTLS_RND_KEY</code> . See the manual and
<code>gnutls_rnd_level_t</code>  for detailed information.
</p>
<p>This function is thread-safe and also fork-safe.
</p>
<p><strong>Returns:</strong> Zero on success, or a negative error code on error.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<p>See <a href="#Random-Number-Generators_002dinternals">Random Number Generators-internals</a> for more information
on the random number generator operation.
</p>
<hr>
<span id="Overriding-algorithms"></span><div class="header">
<p>
Previous: <a href="#Random-number-generation" accesskey="p" rel="prev">Random number generation</a>, Up: <a href="#Using-GnuTLS-as-a-cryptographic-library" accesskey="u" rel="up">Using GnuTLS as a cryptographic library</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Overriding-algorithms-1"></span><h3 class="section">9.6 Overriding algorithms</h3>
<span id="index-overriding-algorithms"></span>

<p>In systems which provide a hardware accelerated cipher implementation
that is not directly supported by GnuTLS, it is possible to utilize it.
There are functions which allow overriding the default cipher, digest and MAC
implementations. Those are described below.
</p>
<p>To override public key operations see <a href="#Abstract-private-keys">Abstract private keys</a>.
</p>




<dl>
<dt id="index-gnutls_005fcrypto_005fregister_005fcipher">Function: <em>int</em> <strong>gnutls_crypto_register_cipher</strong> <em>(gnutls_cipher_algorithm_t <var>algorithm</var>, int <var>priority</var>, gnutls_cipher_init_func <var>init</var>, gnutls_cipher_setkey_func <var>setkey</var>, gnutls_cipher_setiv_func <var>setiv</var>, gnutls_cipher_encrypt_func <var>encrypt</var>, gnutls_cipher_decrypt_func <var>decrypt</var>, gnutls_cipher_deinit_func <var>deinit</var>)</em></dt>
<dd><p><var>algorithm</var>: is the gnutls algorithm identifier
</p>
<p><var>priority</var>: is the priority of the algorithm
</p>
<p><var>init</var>: A function which initializes the cipher
</p>
<p><var>setkey</var>: A function which sets the key of the cipher
</p>
<p><var>setiv</var>: A function which sets the nonce/IV of the cipher (non-AEAD)
</p>
<p><var>encrypt</var>: A function which performs encryption (non-AEAD)
</p>
<p><var>decrypt</var>: A function which performs decryption (non-AEAD)
</p>
<p><var>deinit</var>: A function which deinitializes the cipher
</p>
<p>This function will register a cipher algorithm to be used by
gnutls.  Any algorithm registered will override the included
algorithms and by convention kernel implemented algorithms have
priority of 90 and CPU-assisted of 80.  The algorithm with the lowest priority will be
used by gnutls.
</p>
<p>In the case the registered init or setkey functions return <code>GNUTLS_E_NEED_FALLBACK</code> ,
GnuTLS will attempt to use the next in priority registered cipher.
</p>
<p>The functions which are marked as non-AEAD they are not required when
registering a cipher to be used with the new AEAD API introduced in
GnuTLS 3.4.0. Internally GnuTLS uses the new AEAD API.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>




<dl>
<dt id="index-gnutls_005fcrypto_005fregister_005faead_005fcipher">Function: <em>int</em> <strong>gnutls_crypto_register_aead_cipher</strong> <em>(gnutls_cipher_algorithm_t <var>algorithm</var>, int <var>priority</var>, gnutls_cipher_init_func <var>init</var>, gnutls_cipher_setkey_func <var>setkey</var>, gnutls_cipher_aead_encrypt_func <var>aead_encrypt</var>, gnutls_cipher_aead_decrypt_func <var>aead_decrypt</var>, gnutls_cipher_deinit_func <var>deinit</var>)</em></dt>
<dd><p><var>algorithm</var>: is the gnutls AEAD cipher identifier
</p>
<p><var>priority</var>: is the priority of the algorithm
</p>
<p><var>init</var>: A function which initializes the cipher
</p>
<p><var>setkey</var>: A function which sets the key of the cipher
</p>
<p><var>aead_encrypt</var>: Perform the AEAD encryption
</p>
<p><var>aead_decrypt</var>: Perform the AEAD decryption
</p>
<p><var>deinit</var>: A function which deinitializes the cipher
</p>
<p>This function will register a cipher algorithm to be used by
gnutls.  Any algorithm registered will override the included
algorithms and by convention kernel implemented algorithms have
priority of 90 and CPU-assisted of 80.  The algorithm with the lowest priority will be
used by gnutls.
</p>
<p>In the case the registered init or setkey functions return <code>GNUTLS_E_NEED_FALLBACK</code> ,
GnuTLS will attempt to use the next in priority registered cipher.
</p>
<p>The functions registered will be used with the new AEAD API introduced in
GnuTLS 3.4.0. Internally GnuTLS uses the new AEAD API.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>




<dl>
<dt id="index-gnutls_005fcrypto_005fregister_005fmac">Function: <em>int</em> <strong>gnutls_crypto_register_mac</strong> <em>(gnutls_mac_algorithm_t <var>algorithm</var>, int <var>priority</var>, gnutls_mac_init_func <var>init</var>, gnutls_mac_setkey_func <var>setkey</var>, gnutls_mac_setnonce_func <var>setnonce</var>, gnutls_mac_hash_func <var>hash</var>, gnutls_mac_output_func <var>output</var>, gnutls_mac_deinit_func <var>deinit</var>, gnutls_mac_fast_func <var>hash_fast</var>)</em></dt>
<dd><p><var>algorithm</var>: is the gnutls MAC identifier
</p>
<p><var>priority</var>: is the priority of the algorithm
</p>
<p><var>init</var>: A function which initializes the MAC
</p>
<p><var>setkey</var>: A function which sets the key of the MAC
</p>
<p><var>setnonce</var>: A function which sets the nonce for the mac (may be <code>NULL</code>  for common MAC algorithms)
</p>
<p><var>hash</var>: Perform the hash operation
</p>
<p><var>output</var>: Provide the output of the MAC
</p>
<p><var>deinit</var>: A function which deinitializes the MAC
</p>
<p><var>hash_fast</var>: Perform the MAC operation in one go
</p>
<p>This function will register a MAC algorithm to be used by gnutls.
Any algorithm registered will override the included algorithms and
by convention kernel implemented algorithms have priority of 90
and CPU-assisted of 80.
The algorithm with the lowest priority will be used by gnutls.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>




<dl>
<dt id="index-gnutls_005fcrypto_005fregister_005fdigest">Function: <em>int</em> <strong>gnutls_crypto_register_digest</strong> <em>(gnutls_digest_algorithm_t <var>algorithm</var>, int <var>priority</var>, gnutls_digest_init_func <var>init</var>, gnutls_digest_hash_func <var>hash</var>, gnutls_digest_output_func <var>output</var>, gnutls_digest_deinit_func <var>deinit</var>, gnutls_digest_fast_func <var>hash_fast</var>)</em></dt>
<dd><p><var>algorithm</var>: is the gnutls digest identifier
</p>
<p><var>priority</var>: is the priority of the algorithm
</p>
<p><var>init</var>: A function which initializes the digest
</p>
<p><var>hash</var>: Perform the hash operation
</p>
<p><var>output</var>: Provide the output of the digest
</p>
<p><var>deinit</var>: A function which deinitializes the digest
</p>
<p><var>hash_fast</var>: Perform the digest operation in one go
</p>
<p>This function will register a digest algorithm to be used by gnutls.
Any algorithm registered will override the included algorithms and
by convention kernel implemented algorithms have priority of 90
and CPU-assisted of 80.
The algorithm with the lowest priority will be used by gnutls.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<hr>
<span id="Other-included-programs"></span><div class="header">
<p>
Next: <a href="#Internal-architecture-of-GnuTLS" accesskey="n" rel="next">Internal architecture of GnuTLS</a>, Previous: <a href="#Using-GnuTLS-as-a-cryptographic-library" accesskey="p" rel="prev">Using GnuTLS as a cryptographic library</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Other-included-programs-1"></span><h2 class="chapter">10 Other included programs</h2>

<p>Included with <acronym>GnuTLS</acronym> are also a few command line tools that
let you use the library for common tasks without writing an
application.  The applications are discussed in this chapter.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#gnutls_002dcli-Invocation" accesskey="1">gnutls-cli Invocation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Invoking gnutls-cli
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#gnutls_002dserv-Invocation" accesskey="2">gnutls-serv Invocation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Invoking gnutls-serv
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#gnutls_002dcli_002ddebug-Invocation" accesskey="3">gnutls-cli-debug Invocation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Invoking gnutls-cli-debug
</td></tr>
</table>

<hr>
<span id="gnutls_002dcli-Invocation"></span><div class="header">
<p>
Next: <a href="#gnutls_002dserv-Invocation" accesskey="n" rel="next">gnutls-serv Invocation</a>, Up: <a href="#Other-included-programs" accesskey="u" rel="up">Other included programs</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Invoking-gnutls_002dcli"></span><h3 class="section">10.1 Invoking gnutls-cli</h3>
<span id="index-gnutls_002dcli"></span>


<p>Simple client program to set up a TLS connection to some other computer. 
It sets up a TLS connection and forwards data from the standard input to the secured socket and vice versa.
</p>
<p>This section was generated by <strong>AutoGen</strong>,
using the <code>agtexi-cmd</code> template and the option descriptions for the <code>gnutls-cli</code> program.
This software is released under the GNU General Public License, version 3 or later.
</p>

<span id="gnutls_002dcli-usage"></span><span id="gnutls_002dcli-help_002fusage-_0028_002d_002dhelp_0029"></span><h4 class="subheading">gnutls-cli help/usage (<samp>--help</samp>)</h4>
<span id="index-gnutls_002dcli-help"></span>

<p>This is the automatically generated usage text for gnutls-cli.
</p>
<p>The text printed is the same whether selected with the <code>help</code> option
(<samp>--help</samp>) or the <code>more-help</code> option (<samp>--more-help</samp>).  <code>more-help</code> will print
the usage text by passing it through a pager program.
<code>more-help</code> is disabled on platforms without a working
<code>fork(2)</code> function.  The <code>PAGER</code> environment variable is
used to select the program, defaulting to <samp>more</samp>.  Both will exit
with a status code of 0.
</p>
<div class="example">
<pre class="example">gnutls-cli - GnuTLS client
Usage:  gnutls-cli [ -&lt;flag&gt; [&lt;val&gt;] | --&lt;name&gt;[{=| }&lt;val&gt;] ]... [hostname]

   -d, --debug=num            Enable debugging
                                - it must be in the range:
                                  0 to 9999
   -V, --verbose              More verbose output
                                - may appear multiple times
       --tofu                 Enable trust on first use authentication
                                - disabled as '--no-tofu'
       --strict-tofu          Fail to connect if a certificate is unknown or a known certificate has
changed
                                - disabled as '--no-strict-tofu'
       --dane                 Enable DANE certificate verification (DNSSEC)
                                - disabled as '--no-dane'
       --local-dns            Use the local DNS server for DNSSEC resolving
                                - disabled as '--no-local-dns'
       --ca-verification      Enable CA certificate verification
                                - disabled as '--no-ca-verification'
                                - enabled by default
       --ocsp                 Enable OCSP certificate verification
                                - disabled as '--no-ocsp'
   -r, --resume               Establish a session and resume
       --earlydata=str        Send early data on resumption from the specified file
   -e, --rehandshake          Establish a session and rehandshake
       --sni-hostname=str     Server's hostname for server name indication extension
       --verify-hostname=str  Server's hostname to use for validation
   -s, --starttls             Connect, establish a plain session and start TLS
       --app-proto=str        an alias for the 'starttls-proto' option
       --starttls-proto=str   The application protocol to be used to obtain the server's certificate
(https, ftp, smtp, imap, ldap, xmpp, lmtp, pop3, nntp, sieve, postgres)
                                - prohibits the option 'starttls'
   -u, --udp                  Use DTLS (datagram TLS) over UDP
       --mtu=num              Set MTU for datagram TLS
                                - it must be in the range:
                                  0 to 17000
       --crlf                 Send CR LF instead of LF
       --fastopen             Enable TCP Fast Open
       --x509fmtder           Use DER format for certificates to read from
       --print-cert           Print peer's certificate in PEM format
       --save-cert=str        Save the peer's certificate chain in the specified file in PEM format
       --save-ocsp=str        Save the peer's OCSP status response in the provided file
       --save-server-trace=str Save the server-side TLS message trace in the provided file
       --save-client-trace=str Save the client-side TLS message trace in the provided file
       --dh-bits=num          The minimum number of bits allowed for DH
       --priority=str         Priorities string
       --x509cafile=str       Certificate file or PKCS #11 URL to use
       --x509crlfile=file     CRL file to use
                                - file must pre-exist
       --x509keyfile=str      X.509 key file or PKCS #11 URL to use
       --x509certfile=str     X.509 Certificate file or PKCS #11 URL to use
                                - requires the option 'x509keyfile'
       --srpusername=str      SRP username to use
       --srppasswd=str        SRP password to use
       --pskusername=str      PSK username to use
       --pskkey=str           PSK key (in hex) to use
   -p, --port=str             The port or service to connect to
       --insecure             Don't abort program if server certificate can't be validated
       --verify-allow-broken  Allow broken algorithms, such as MD5 for certificate verification
   -&quot;, --benchmark-ciphers    Benchmark individual ciphers
   -#, --benchmark-tls-kx     Benchmark TLS key exchange methods
   -$, --benchmark-tls-ciphers  Benchmark TLS ciphers
   -l, --list                 Print a list of the supported algorithms and modes
                                - prohibits the option 'port'
   -%, --priority-list        Print a list of the supported priority strings
   -&amp;, --noticket             Don't allow session tickets
   -', --srtp-profiles=str    Offer SRTP profiles
   -(, --alpn=str             Application layer protocol
                                - may appear multiple times
   -b, --heartbeat            Activate heartbeat support
   -), --recordsize=num       The maximum record size to advertize
                                - it must be in the range:
                                  0 to 4096
   -*, --disable-sni          Do not send a Server Name Indication (SNI)
   -,, --single-key-share     Send a single key share under TLS1.3
   --, --post-handshake-auth  Enable post-handshake authentication under TLS1.3
   -., --inline-commands      Inline commands of the form ^&lt;cmd&gt;^
   -/, --inline-commands-prefix=str Change the default delimiter for inline commands.
   -0, --provider=file        Specify the PKCS #11 provider library
                                - file must pre-exist
   -1, --fips140-mode         Reports the status of the FIPS140-2 mode in gnutls library
   -2, --logfile=str          Redirect informational messages to a specific file.
   -3, --keymatexport=str     Label used for exporting keying material
   -4, --keymatexportsize=num Size of the exported keying material
   -v, --version[=arg]        output version information and exit
   -h, --help                 display extended usage information and exit
   -!, --more-help            extended usage information passed thru pager

Options are specified by doubled hyphens and their name or by a single
hyphen and the flag character.
Operands and options may be intermixed.  They will be reordered.

Simple client program to set up a TLS connection to some other computer.  It
sets up a TLS connection and forwards data from the standard input to the
secured socket and vice versa.

</pre></div>

<span id="gnutls_002dcli-debug"></span><span id="debug-option-_0028_002dd_0029-5"></span><h4 class="subheading">debug option (-d)</h4>

<p>This is the &ldquo;enable debugging&rdquo; option.
This option takes a number argument.
Specifies the debug level.
<span id="gnutls_002dcli-tofu"></span></p><span id="tofu-option"></span><h4 class="subheading">tofu option</h4>

<p>This is the &ldquo;enable trust on first use authentication&rdquo; option.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> can be disabled with &ndash;no-tofu.
</li></ul>

<p>This option will, in addition to certificate authentication, perform authentication
based on previously seen public keys, a model similar to SSH authentication. Note that when tofu 
is specified (PKI) and DANE authentication will become advisory to assist the public key acceptance
process.
<span id="gnutls_002dcli-strict_002dtofu"></span></p><span id="strict_002dtofu-option"></span><h4 class="subheading">strict-tofu option</h4>

<p>This is the &ldquo;fail to connect if a certificate is unknown or a known certificate has changed&rdquo; option.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> can be disabled with &ndash;no-strict-tofu.
</li></ul>

<p>This option will perform authentication as with option &ndash;tofu; however, no questions shall be asked whatsoever, neither to accept an unknown certificate nor a changed one.
<span id="gnutls_002dcli-dane"></span></p><span id="dane-option"></span><h4 class="subheading">dane option</h4>

<p>This is the &ldquo;enable dane certificate verification (dnssec)&rdquo; option.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> can be disabled with &ndash;no-dane.
</li></ul>

<p>This option will, in addition to certificate authentication using 
the trusted CAs, verify the server certificates using on the DANE information
available via DNSSEC.
<span id="gnutls_002dcli-local_002ddns"></span></p><span id="local_002ddns-option-1"></span><h4 class="subheading">local-dns option</h4>

<p>This is the &ldquo;use the local dns server for dnssec resolving&rdquo; option.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> can be disabled with &ndash;no-local-dns.
</li></ul>

<p>This option will use the local DNS server for DNSSEC.
This is disabled by default due to many servers not allowing DNSSEC.
<span id="gnutls_002dcli-ca_002dverification"></span></p><span id="ca_002dverification-option"></span><h4 class="subheading">ca-verification option</h4>

<p>This is the &ldquo;enable ca certificate verification&rdquo; option.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> can be disabled with &ndash;no-ca-verification.
</li><li> It is enabled by default.
</li></ul>

<p>This option can be used to enable or disable CA certificate verification. It is to be used with the &ndash;dane or &ndash;tofu options.
<span id="gnutls_002dcli-ocsp"></span></p><span id="ocsp-option"></span><h4 class="subheading">ocsp option</h4>

<p>This is the &ldquo;enable ocsp certificate verification&rdquo; option.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> can be disabled with &ndash;no-ocsp.
</li></ul>

<p>This option will enable verification of the peer&rsquo;s certificate using ocsp
<span id="gnutls_002dcli-resume"></span></p><span id="resume-option-_0028_002dr_0029"></span><h4 class="subheading">resume option (-r)</h4>

<p>This is the &ldquo;establish a session and resume&rdquo; option.
Connect, establish a session, reconnect and resume.
<span id="gnutls_002dcli-rehandshake"></span></p><span id="rehandshake-option-_0028_002de_0029"></span><h4 class="subheading">rehandshake option (-e)</h4>

<p>This is the &ldquo;establish a session and rehandshake&rdquo; option.
Connect, establish a session and rehandshake immediately.
<span id="gnutls_002dcli-sni_002dhostname"></span></p><span id="sni_002dhostname-option"></span><h4 class="subheading">sni-hostname option</h4>

<p>This is the &ldquo;server&rsquo;s hostname for server name indication extension&rdquo; option.
This option takes a string argument.
Set explicitly the server name used in the TLS server name indication extension. That is useful when testing with servers setup on different DNS name than the intended. If not specified, the provided hostname is used. Even with this option server certificate verification still uses the hostname passed on the main commandline. Use &ndash;verify-hostname to change this.
<span id="gnutls_002dcli-verify_002dhostname"></span></p><span id="verify_002dhostname-option"></span><h4 class="subheading">verify-hostname option</h4>

<p>This is the &ldquo;server&rsquo;s hostname to use for validation&rdquo; option.
This option takes a string argument.
Set explicitly the server name to be used when validating the server&rsquo;s certificate.
<span id="gnutls_002dcli-starttls"></span></p><span id="starttls-option-_0028_002ds_0029"></span><h4 class="subheading">starttls option (-s)</h4>

<p>This is the &ldquo;connect, establish a plain session and start tls&rdquo; option.
The TLS session will be initiated when EOF or a SIGALRM is received.
<span id="gnutls_002dcli-app_002dproto"></span></p><span id="app_002dproto-option-1"></span><h4 class="subheading">app-proto option</h4>

<p>This is an alias for the <code>starttls-proto</code> option,
see <a href="#gnutls_002dcli-starttls_002dproto">the starttls-proto option documentation</a>.
</p>
<span id="gnutls_002dcli-starttls_002dproto"></span><span id="starttls_002dproto-option-1"></span><h4 class="subheading">starttls-proto option</h4>

<p>This is the &ldquo;the application protocol to be used to obtain the server&rsquo;s certificate (https, ftp, smtp, imap, ldap, xmpp, lmtp, pop3, nntp, sieve, postgres)&rdquo; option.
This option takes a string argument.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> must not appear in combination with any of the following options:
starttls.
</li></ul>

<p>Specify the application layer protocol for STARTTLS. If the protocol is supported, gnutls-cli will proceed to the TLS negotiation.
<span id="gnutls_002dcli-dh_002dbits"></span></p><span id="dh_002dbits-option"></span><h4 class="subheading">dh-bits option</h4>

<p>This is the &ldquo;the minimum number of bits allowed for dh&rdquo; option.
This option takes a number argument.
This option sets the minimum number of bits allowed for a Diffie-Hellman key exchange. You may want to lower the default value if the peer sends a weak prime and you get an connection error with unacceptable prime.
<span id="gnutls_002dcli-priority"></span></p><span id="priority-option"></span><h4 class="subheading">priority option</h4>

<p>This is the &ldquo;priorities string&rdquo; option.
This option takes a string argument.
TLS algorithms and protocols to enable. You can
use predefined sets of ciphersuites such as PERFORMANCE,
NORMAL, PFS, SECURE128, SECURE256. The default is NORMAL.
</p>
<p>Check  the  GnuTLS  manual  on  section  &ldquo;Priority strings&rdquo; for more
information on the allowed keywords
<span id="gnutls_002dcli-ranges"></span></p><span id="ranges-option"></span><h4 class="subheading">ranges option</h4>

<p>This is the &ldquo;use length-hiding padding to prevent traffic analysis&rdquo; option.
When possible (e.g., when using CBC ciphersuites), use length-hiding padding to prevent traffic analysis.
</p>
<p><strong>NOTE</strong><strong>: THIS OPTION IS DEPRECATED</strong>
<span id="gnutls_002dcli-benchmark_002dciphers"></span></p><span id="benchmark_002dciphers-option"></span><h4 class="subheading">benchmark-ciphers option</h4>

<p>This is the &ldquo;benchmark individual ciphers&rdquo; option.
By default the benchmarked ciphers will utilize any capabilities of the local CPU to improve performance. To test against the raw software implementation set the environment variable GNUTLS_CPUID_OVERRIDE to 0x1.
<span id="gnutls_002dcli-benchmark_002dtls_002dciphers"></span></p><span id="benchmark_002dtls_002dciphers-option"></span><h4 class="subheading">benchmark-tls-ciphers option</h4>

<p>This is the &ldquo;benchmark tls ciphers&rdquo; option.
By default the benchmarked ciphers will utilize any capabilities of the local CPU to improve performance. To test against the raw software implementation set the environment variable GNUTLS_CPUID_OVERRIDE to 0x1.
<span id="gnutls_002dcli-list"></span></p><span id="list-option-_0028_002dl_0029"></span><h4 class="subheading">list option (-l)</h4>

<p>This is the &ldquo;print a list of the supported algorithms and modes&rdquo; option.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> must not appear in combination with any of the following options:
port.
</li></ul>

<p>Print a list of the supported algorithms and modes. If a priority string is given then only the enabled ciphersuites are shown.
<span id="gnutls_002dcli-priority_002dlist"></span></p><span id="priority_002dlist-option"></span><h4 class="subheading">priority-list option</h4>

<p>This is the &ldquo;print a list of the supported priority strings&rdquo; option.
Print a list of the supported priority strings. The ciphersuites corresponding to each priority string can be examined using -l -p.
<span id="gnutls_002dcli-noticket"></span></p><span id="noticket-option"></span><h4 class="subheading">noticket option</h4>

<p>This is the &ldquo;don&rsquo;t allow session tickets&rdquo; option.
Disable the request of receiving of session tickets under TLS1.2 or earlier
<span id="gnutls_002dcli-alpn"></span></p><span id="alpn-option"></span><h4 class="subheading">alpn option</h4>

<p>This is the &ldquo;application layer protocol&rdquo; option.
This option takes a string argument.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> may appear an unlimited number of times.
</li></ul>

<p>This option will set and enable the Application Layer Protocol Negotiation  (ALPN) in the TLS protocol.
<span id="gnutls_002dcli-disable_002dextensions"></span></p><span id="disable_002dextensions-option"></span><h4 class="subheading">disable-extensions option</h4>

<p>This is the &ldquo;disable all the tls extensions&rdquo; option.
This option disables all TLS extensions. Deprecated option. Use the priority string.
</p>
<p><strong>NOTE</strong><strong>: THIS OPTION IS DEPRECATED</strong>
<span id="gnutls_002dcli-single_002dkey_002dshare"></span></p><span id="single_002dkey_002dshare-option"></span><h4 class="subheading">single-key-share option</h4>

<p>This is the &ldquo;send a single key share under tls1.3&rdquo; option.
This option switches the default mode of sending multiple
key shares, to send a single one (the top one).
<span id="gnutls_002dcli-post_002dhandshake_002dauth"></span></p><span id="post_002dhandshake_002dauth-option"></span><h4 class="subheading">post-handshake-auth option</h4>

<p>This is the &ldquo;enable post-handshake authentication under tls1.3&rdquo; option.
This option enables post-handshake authentication when under TLS1.3.
<span id="gnutls_002dcli-inline_002dcommands"></span></p><span id="inline_002dcommands-option"></span><h4 class="subheading">inline-commands option</h4>

<p>This is the &ldquo;inline commands of the form ^&lt;cmd&gt;^&rdquo; option.
Enable inline commands of the form ^&lt;cmd&gt;^. The inline commands are expected to be in a line by themselves. The available commands are: resume, rekey1 (local rekey), rekey (rekey on both peers) and renegotiate.
<span id="gnutls_002dcli-inline_002dcommands_002dprefix"></span></p><span id="inline_002dcommands_002dprefix-option"></span><h4 class="subheading">inline-commands-prefix option</h4>

<p>This is the &ldquo;change the default delimiter for inline commands.&rdquo; option.
This option takes a string argument.
Change the default delimiter (^) used for inline commands. The delimiter is expected to be a single US-ASCII character (octets 0 - 127). This option is only relevant if inline commands are enabled via the inline-commands option
<span id="gnutls_002dcli-provider"></span></p><span id="provider-option"></span><h4 class="subheading">provider option</h4>

<p>This is the &ldquo;specify the pkcs #11 provider library&rdquo; option.
This option takes a file argument.
This will override the default options in /etc/gnutls/pkcs11.conf
<span id="gnutls_002dcli-exit-status"></span></p><span id="gnutls_002dcli-exit-status-1"></span><h4 class="subheading">gnutls-cli exit status</h4>

<p>One of the following exit values will be returned:
</p><dl compact="compact">
<dt>&lsquo;<samp>0 (EXIT_SUCCESS)</samp>&rsquo;</dt>
<dd><p>Successful program execution.
</p></dd>
<dt>&lsquo;<samp>1 (EXIT_FAILURE)</samp>&rsquo;</dt>
<dd><p>The operation failed or the command syntax was not valid.
</p></dd>
</dl>
<span id="gnutls_002dcli-See-Also"></span><span id="gnutls_002dcli-See-Also-1"></span><h4 class="subheading">gnutls-cli See Also</h4>
<p>gnutls-cli-debug(1), gnutls-serv(1)
<span id="gnutls_002dcli-Examples"></span></p><span id="gnutls_002dcli-Examples-1"></span><h4 class="subheading">gnutls-cli Examples</h4>
<span id="Connecting-using-PSK-authentication"></span><h4 class="subheading">Connecting using PSK authentication</h4>
<p>To connect to a server using PSK authentication, you need to enable the choice of PSK by using a cipher priority parameter such as in the example below. 
</p><div class="example">
<pre class="example">$ ./gnutls-cli -p 5556 localhost --pskusername psk_identity \
    --pskkey 88f3824b3e5659f52d00e959bacab954b6540344 \
    --priority NORMAL:-KX-ALL:+ECDHE-PSK:+DHE-PSK:+PSK
Resolving 'localhost'...
Connecting to '127.0.0.1:5556'...
- PSK authentication.
- Version: TLS1.1
- Key Exchange: PSK
- Cipher: AES-128-CBC
- MAC: SHA1
- Compression: NULL
- Handshake was completed
    
- Simple Client Mode:
</pre></div>
<p>By keeping the &ndash;pskusername parameter and removing the &ndash;pskkey parameter, it will query only for the password during the handshake. 
</p>
<span id="Connecting-to-STARTTLS-services"></span><h4 class="subheading">Connecting to STARTTLS services</h4>

<p>You could also use the client to connect to services with starttls capability.
</p><div class="example">
<pre class="example">$ gnutls-cli --starttls-proto smtp --port 25 localhost
</pre></div>

<span id="Listing-ciphersuites-in-a-priority-string"></span><h4 class="subheading">Listing ciphersuites in a priority string</h4>
<p>To list the ciphersuites in a priority string:
</p><div class="example">
<pre class="example">$ ./gnutls-cli --priority SECURE192 -l
Cipher suites for SECURE192
TLS_ECDHE_ECDSA_AES_256_CBC_SHA384         0xc0, 0x24	TLS1.2
TLS_ECDHE_ECDSA_AES_256_GCM_SHA384         0xc0, 0x2e	TLS1.2
TLS_ECDHE_RSA_AES_256_GCM_SHA384           0xc0, 0x30	TLS1.2
TLS_DHE_RSA_AES_256_CBC_SHA256             0x00, 0x6b	TLS1.2
TLS_DHE_DSS_AES_256_CBC_SHA256             0x00, 0x6a	TLS1.2
TLS_RSA_AES_256_CBC_SHA256                 0x00, 0x3d	TLS1.2

Certificate types: CTYPE-X.509
Protocols: VERS-TLS1.2, VERS-TLS1.1, VERS-TLS1.0, VERS-SSL3.0, VERS-DTLS1.0
Compression: COMP-NULL
Elliptic curves: CURVE-SECP384R1, CURVE-SECP521R1
PK-signatures: SIGN-RSA-SHA384, SIGN-ECDSA-SHA384, SIGN-RSA-SHA512, SIGN-ECDSA-SHA512
</pre></div>

<span id="Connecting-using-a-PKCS-_002311-token"></span><h4 class="subheading">Connecting using a PKCS #11 token</h4>
<p>To connect to a server using a certificate and a private key present in a PKCS #11 token you 
need to substitute the PKCS 11 URLs in the x509certfile and x509keyfile parameters.
</p>
<p>Those can be found using &quot;p11tool &ndash;list-tokens&quot; and then listing all the objects in the
needed token, and using the appropriate.
</p><div class="example">
<pre class="example">$ p11tool --list-tokens

Token 0:
URL: pkcs11:model=PKCS15;manufacturer=MyMan;serial=1234;token=Test
Label: Test
Manufacturer: EnterSafe
Model: PKCS15
Serial: 1234

$ p11tool --login --list-certs &quot;pkcs11:model=PKCS15;manufacturer=MyMan;serial=1234;token=Test&quot;

Object 0:
URL: pkcs11:model=PKCS15;manufacturer=MyMan;serial=1234;token=Test;object=client;type=cert
Type: X.509 Certificate
Label: client
ID: 2a:97:0d:58:d1:51:3c:23:07:ae:4e:0d:72:26:03:7d:99:06:02:6a

$ MYCERT=&quot;pkcs11:model=PKCS15;manufacturer=MyMan;serial=1234;token=Test;object=client;type=cert&quot;
$ MYKEY=&quot;pkcs11:model=PKCS15;manufacturer=MyMan;serial=1234;token=Test;object=client;type=private&quot;
$ export MYCERT MYKEY

$ gnutls-cli www.example.com --x509keyfile $MYKEY --x509certfile $MYCERT
</pre></div>
<p>Notice that the private key only differs from the certificate in the type.
</p><hr>
<span id="gnutls_002dserv-Invocation"></span><div class="header">
<p>
Next: <a href="#gnutls_002dcli_002ddebug-Invocation" accesskey="n" rel="next">gnutls-cli-debug Invocation</a>, Previous: <a href="#gnutls_002dcli-Invocation" accesskey="p" rel="prev">gnutls-cli Invocation</a>, Up: <a href="#Other-included-programs" accesskey="u" rel="up">Other included programs</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Invoking-gnutls_002dserv"></span><h3 class="section">10.2 Invoking gnutls-serv</h3>
<span id="index-gnutls_002dserv"></span>


<p>Server program that listens to incoming TLS connections.
</p>
<p>This section was generated by <strong>AutoGen</strong>,
using the <code>agtexi-cmd</code> template and the option descriptions for the <code>gnutls-serv</code> program.
This software is released under the GNU General Public License, version 3 or later.
</p>

<span id="gnutls_002dserv-usage"></span><span id="gnutls_002dserv-help_002fusage-_0028_002d_002dhelp_0029"></span><h4 class="subheading">gnutls-serv help/usage (<samp>--help</samp>)</h4>
<span id="index-gnutls_002dserv-help"></span>

<p>This is the automatically generated usage text for gnutls-serv.
</p>
<p>The text printed is the same whether selected with the <code>help</code> option
(<samp>--help</samp>) or the <code>more-help</code> option (<samp>--more-help</samp>).  <code>more-help</code> will print
the usage text by passing it through a pager program.
<code>more-help</code> is disabled on platforms without a working
<code>fork(2)</code> function.  The <code>PAGER</code> environment variable is
used to select the program, defaulting to <samp>more</samp>.  Both will exit
with a status code of 0.
</p>
<div class="example">
<pre class="example">gnutls-serv - GnuTLS server
Usage:  gnutls-serv [ -&lt;flag&gt; [&lt;val&gt;] | --&lt;name&gt;[{=| }&lt;val&gt;] ]...

   -d, --debug=num            Enable debugging
                                - it must be in the range:
                                  0 to 9999
       --sni-hostname=str     Server's hostname for server name extension
       --sni-hostname-fatal   Send fatal alert on sni-hostname mismatch
       --alpn=str             Specify ALPN protocol to be enabled by the server
                                - may appear multiple times
       --alpn-fatal           Send fatal alert on non-matching ALPN name
       --noticket             Don't accept session tickets
       --earlydata            Accept early data
       --maxearlydata=num     The maximum early data size to accept
                                - it must be in the range:
                                  1 to 4294967295
       --nocookie             Don't require cookie on DTLS sessions
   -g, --generate             Generate Diffie-Hellman parameters
   -q, --quiet                Suppress some messages
       --nodb                 Do not use a resumption database
       --http                 Act as an HTTP server
       --echo                 Act as an Echo server
   -u, --udp                  Use DTLS (datagram TLS) over UDP
       --mtu=num              Set MTU for datagram TLS
                                - it must be in the range:
                                  0 to 17000
       --srtp-profiles=str    Offer SRTP profiles
   -a, --disable-client-cert  Do not request a client certificate
                                - prohibits the option 'require-client-cert'
   -r, --require-client-cert  Require a client certificate
       --verify-client-cert   If a client certificate is sent then verify it.
   -b, --heartbeat            Activate heartbeat support
       --x509fmtder           Use DER format for certificates to read from
       --priority=str         Priorities string
       --dhparams=file        DH params file to use
                                - file must pre-exist
       --x509cafile=str       Certificate file or PKCS #11 URL to use
       --x509crlfile=file     CRL file to use
                                - file must pre-exist
       --x509keyfile=str      X.509 key file or PKCS #11 URL to use
                                - may appear multiple times
       --x509certfile=str     X.509 Certificate file or PKCS #11 URL to use
                                - may appear multiple times
       --srppasswd=file       SRP password file to use
                                - file must pre-exist
       --srppasswdconf=file   SRP password configuration file to use
                                - file must pre-exist
       --pskpasswd=file       PSK password file to use
                                - file must pre-exist
       --pskhint=str          PSK identity hint to use
       --ocsp-response=str    The OCSP response to send to client
                                - may appear multiple times
       --ignore-ocsp-response-errors  Ignore any errors when setting the OCSP response
   -p, --port=num             The port to connect to
   -l, --list                 Print a list of the supported algorithms and modes
       --provider=file        Specify the PKCS #11 provider library
                                - file must pre-exist
       --keymatexport=str     Label used for exporting keying material
       --keymatexportsize=num Size of the exported keying material
       --recordsize=num       The maximum record size to advertise
                                - it must be in the range:
                                  0 to 16384
       --httpdata=file        The data used as HTTP response
                                - file must pre-exist
   -v, --version[=arg]        output version information and exit
   -h, --help                 display extended usage information and exit
   -!, --more-help            extended usage information passed thru pager

Options are specified by doubled hyphens and their name or by a single
hyphen and the flag character.

Server program that listens to incoming TLS connections.

</pre></div>

<span id="gnutls_002dserv-debug"></span><span id="debug-option-_0028_002dd_0029-6"></span><h4 class="subheading">debug option (-d)</h4>

<p>This is the &ldquo;enable debugging&rdquo; option.
This option takes a number argument.
Specifies the debug level.
<span id="gnutls_002dserv-sni_002dhostname"></span></p><span id="sni_002dhostname-option-1"></span><h4 class="subheading">sni-hostname option</h4>

<p>This is the &ldquo;server&rsquo;s hostname for server name extension&rdquo; option.
This option takes a string argument.
Server name of type host_name that the server will recognise as its own. If the server receives client hello with different name, it will send a warning-level unrecognized_name alert.
<span id="gnutls_002dserv-alpn"></span></p><span id="alpn-option-1"></span><h4 class="subheading">alpn option</h4>

<p>This is the &ldquo;specify alpn protocol to be enabled by the server&rdquo; option.
This option takes a string argument.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> may appear an unlimited number of times.
</li></ul>

<p>Specify the (textual) ALPN protocol for the server to use.
<span id="gnutls_002dserv-require_002dclient_002dcert"></span></p><span id="require_002dclient_002dcert-option-_0028_002dr_0029"></span><h4 class="subheading">require-client-cert option (-r)</h4>

<p>This is the &ldquo;require a client certificate&rdquo; option.
This option before 3.6.0 used to imply &ndash;verify-client-cert.
Since 3.6.0 it will no longer verify the certificate by default.
<span id="gnutls_002dserv-verify_002dclient_002dcert"></span></p><span id="verify_002dclient_002dcert-option"></span><h4 class="subheading">verify-client-cert option</h4>

<p>This is the &ldquo;if a client certificate is sent then verify it.&rdquo; option.
Do not require, but if a client certificate is sent then verify it and close the connection if invalid.
<span id="gnutls_002dserv-heartbeat"></span></p><span id="heartbeat-option-_0028_002db_0029"></span><h4 class="subheading">heartbeat option (-b)</h4>

<p>This is the &ldquo;activate heartbeat support&rdquo; option.
Regularly ping client via heartbeat extension messages
<span id="gnutls_002dserv-priority"></span></p><span id="priority-option-1"></span><h4 class="subheading">priority option</h4>

<p>This is the &ldquo;priorities string&rdquo; option.
This option takes a string argument.
TLS algorithms and protocols to enable. You can
use predefined sets of ciphersuites such as PERFORMANCE,
NORMAL, SECURE128, SECURE256. The default is NORMAL.
</p>
<p>Check  the  GnuTLS  manual  on  section  &ldquo;Priority strings&rdquo; for more
information on allowed keywords
<span id="gnutls_002dserv-x509keyfile"></span></p><span id="x509keyfile-option"></span><h4 class="subheading">x509keyfile option</h4>

<p>This is the &ldquo;x.509 key file or pkcs #11 url to use&rdquo; option.
This option takes a string argument.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> may appear an unlimited number of times.
</li></ul>

<p>Specify the private key file or URI to use; it must correspond to
the certificate specified in &ndash;x509certfile. Multiple keys and certificates
can be specified with this option and in that case each occurrence of keyfile
must be followed by the corresponding x509certfile or vice-versa.
<span id="gnutls_002dserv-x509certfile"></span></p><span id="x509certfile-option"></span><h4 class="subheading">x509certfile option</h4>

<p>This is the &ldquo;x.509 certificate file or pkcs #11 url to use&rdquo; option.
This option takes a string argument.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> may appear an unlimited number of times.
</li></ul>

<p>Specify the certificate file or URI to use; it must correspond to
the key specified in &ndash;x509keyfile. Multiple keys and certificates
can be specified with this option and in that case each occurrence of keyfile
must be followed by the corresponding x509certfile or vice-versa.
<span id="gnutls_002dserv-x509dsakeyfile"></span></p><span id="x509dsakeyfile-option"></span><h4 class="subheading">x509dsakeyfile option</h4>

<p>This is an alias for the <code>x509keyfile</code> option,
see <a href="#gnutls_002dserv-x509keyfile">the x509keyfile option documentation</a>.
</p>
<span id="gnutls_002dserv-x509dsacertfile"></span><span id="x509dsacertfile-option"></span><h4 class="subheading">x509dsacertfile option</h4>

<p>This is an alias for the <code>x509certfile</code> option,
see <a href="#gnutls_002dserv-x509certfile">the x509certfile option documentation</a>.
</p>
<span id="gnutls_002dserv-x509ecckeyfile"></span><span id="x509ecckeyfile-option"></span><h4 class="subheading">x509ecckeyfile option</h4>

<p>This is an alias for the <code>x509keyfile</code> option,
see <a href="#gnutls_002dserv-x509keyfile">the x509keyfile option documentation</a>.
</p>
<span id="gnutls_002dserv-x509ecccertfile"></span><span id="x509ecccertfile-option"></span><h4 class="subheading">x509ecccertfile option</h4>

<p>This is an alias for the <code>x509certfile</code> option,
see <a href="#gnutls_002dserv-x509certfile">the x509certfile option documentation</a>.
</p>
<span id="gnutls_002dserv-ocsp_002dresponse"></span><span id="ocsp_002dresponse-option"></span><h4 class="subheading">ocsp-response option</h4>

<p>This is the &ldquo;the ocsp response to send to client&rdquo; option.
This option takes a string argument.
</p>
<p>This option has some usage constraints.  It:
</p><ul>
<li> may appear an unlimited number of times.
</li></ul>

<p>If the client requested an OCSP response, return data from this file to the client.
<span id="gnutls_002dserv-ignore_002docsp_002dresponse_002derrors"></span></p><span id="ignore_002docsp_002dresponse_002derrors-option"></span><h4 class="subheading">ignore-ocsp-response-errors option</h4>

<p>This is the &ldquo;ignore any errors when setting the ocsp response&rdquo; option.
That option instructs gnutls to not attempt to match the provided OCSP responses with the certificates.
<span id="gnutls_002dserv-list"></span></p><span id="list-option-_0028_002dl_0029-1"></span><h4 class="subheading">list option (-l)</h4>

<p>This is the &ldquo;print a list of the supported algorithms and modes&rdquo; option.
Print a list of the supported algorithms and modes. If a priority string is given then only the enabled ciphersuites are shown.
<span id="gnutls_002dserv-provider"></span></p><span id="provider-option-1"></span><h4 class="subheading">provider option</h4>

<p>This is the &ldquo;specify the pkcs #11 provider library&rdquo; option.
This option takes a file argument.
This will override the default options in /etc/gnutls/pkcs11.conf
<span id="gnutls_002dserv-exit-status"></span></p><span id="gnutls_002dserv-exit-status-1"></span><h4 class="subheading">gnutls-serv exit status</h4>

<p>One of the following exit values will be returned:
</p><dl compact="compact">
<dt>&lsquo;<samp>0 (EXIT_SUCCESS)</samp>&rsquo;</dt>
<dd><p>Successful program execution.
</p></dd>
<dt>&lsquo;<samp>1 (EXIT_FAILURE)</samp>&rsquo;</dt>
<dd><p>The operation failed or the command syntax was not valid.
</p></dd>
</dl>
<span id="gnutls_002dserv-See-Also"></span><span id="gnutls_002dserv-See-Also-1"></span><h4 class="subheading">gnutls-serv See Also</h4>
<p>gnutls-cli-debug(1), gnutls-cli(1)
<span id="gnutls_002dserv-Examples"></span></p><span id="gnutls_002dserv-Examples-1"></span><h4 class="subheading">gnutls-serv Examples</h4>
<p>Running your own TLS server based on GnuTLS can be useful when
debugging clients and/or GnuTLS itself.  This section describes how to
use <code>gnutls-serv</code> as a simple HTTPS server.
</p>
<p>The most basic server can be started as:
</p>
<div class="example">
<pre class="example">gnutls-serv --http --priority &quot;NORMAL:+ANON-ECDH:+ANON-DH&quot;
</pre></div>

<p>It will only support anonymous ciphersuites, which many TLS clients
refuse to use.
</p>
<p>The next step is to add support for X.509.  First we generate a CA:
</p>
<div class="example">
<pre class="example">$ certtool --generate-privkey &gt; x509-ca-key.pem
$ echo 'cn = GnuTLS test CA' &gt; ca.tmpl
$ echo 'ca' &gt;&gt; ca.tmpl
$ echo 'cert_signing_key' &gt;&gt; ca.tmpl
$ certtool --generate-self-signed --load-privkey x509-ca-key.pem \
  --template ca.tmpl --outfile x509-ca.pem
</pre></div>

<p>Then generate a server certificate.  Remember to change the dns_name
value to the name of your server host, or skip that command to avoid
the field.
</p>
<div class="example">
<pre class="example">$ certtool --generate-privkey &gt; x509-server-key.pem
$ echo 'organization = GnuTLS test server' &gt; server.tmpl
$ echo 'cn = test.gnutls.org' &gt;&gt; server.tmpl
$ echo 'tls_www_server' &gt;&gt; server.tmpl
$ echo 'encryption_key' &gt;&gt; server.tmpl
$ echo 'signing_key' &gt;&gt; server.tmpl
$ echo 'dns_name = test.gnutls.org' &gt;&gt; server.tmpl
$ certtool --generate-certificate --load-privkey x509-server-key.pem \
  --load-ca-certificate x509-ca.pem --load-ca-privkey x509-ca-key.pem \
  --template server.tmpl --outfile x509-server.pem
</pre></div>

<p>For use in the client, you may want to generate a client certificate
as well.
</p>
<div class="example">
<pre class="example">$ certtool --generate-privkey &gt; x509-client-key.pem
$ echo 'cn = GnuTLS test client' &gt; client.tmpl
$ echo 'tls_www_client' &gt;&gt; client.tmpl
$ echo 'encryption_key' &gt;&gt; client.tmpl
$ echo 'signing_key' &gt;&gt; client.tmpl
$ certtool --generate-certificate --load-privkey x509-client-key.pem \
  --load-ca-certificate x509-ca.pem --load-ca-privkey x509-ca-key.pem \
  --template client.tmpl --outfile x509-client.pem
</pre></div>

<p>To be able to import the client key/certificate into some
applications, you will need to convert them into a PKCS#12 structure.
This also encrypts the security sensitive key with a password.
</p>
<div class="example">
<pre class="example">$ certtool --to-p12 --load-ca-certificate x509-ca.pem \
  --load-privkey x509-client-key.pem --load-certificate x509-client.pem \
  --outder --outfile x509-client.p12
</pre></div>

<p>For icing, we&rsquo;ll create a proxy certificate for the client too.
</p>
<div class="example">
<pre class="example">$ certtool --generate-privkey &gt; x509-proxy-key.pem
$ echo 'cn = GnuTLS test client proxy' &gt; proxy.tmpl
$ certtool --generate-proxy --load-privkey x509-proxy-key.pem \
  --load-ca-certificate x509-client.pem --load-ca-privkey x509-client-key.pem \
  --load-certificate x509-client.pem --template proxy.tmpl \
  --outfile x509-proxy.pem
</pre></div>

<p>Then start the server again:
</p>
<div class="example">
<pre class="example">$ gnutls-serv --http \
            --x509cafile x509-ca.pem \
            --x509keyfile x509-server-key.pem \
            --x509certfile x509-server.pem
</pre></div>

<p>Try connecting to the server using your web browser.  Note that the
server listens to port 5556 by default.
</p>
<p>While you are at it, to allow connections using ECDSA, you can also
create a ECDSA key and certificate for the server.  These credentials
will be used in the final example below.
</p>
<div class="example">
<pre class="example">$ certtool --generate-privkey --ecdsa &gt; x509-server-key-ecc.pem
$ certtool --generate-certificate --load-privkey x509-server-key-ecc.pem \
  --load-ca-certificate x509-ca.pem --load-ca-privkey x509-ca-key.pem \
  --template server.tmpl --outfile x509-server-ecc.pem
</pre></div>


<p>The next step is to add support for SRP authentication. This requires
an SRP password file created with <code>srptool</code>.
To start the server with SRP support:
</p>
<div class="example">
<pre class="example">gnutls-serv --http --priority NORMAL:+SRP-RSA:+SRP \
            --srppasswdconf srp-tpasswd.conf \
            --srppasswd srp-passwd.txt
</pre></div>

<p>Let&rsquo;s also start a server with support for PSK. This would require
a password file created with <code>psktool</code>.
</p>
<div class="example">
<pre class="example">gnutls-serv --http --priority NORMAL:+ECDHE-PSK:+PSK \
            --pskpasswd psk-passwd.txt
</pre></div>

<p>Finally, we start the server with all the earlier parameters and you
get this command:
</p>
<div class="example">
<pre class="example">gnutls-serv --http --priority NORMAL:+PSK:+SRP \
            --x509cafile x509-ca.pem \
            --x509keyfile x509-server-key.pem \
            --x509certfile x509-server.pem \
            --x509keyfile x509-server-key-ecc.pem \
            --x509certfile x509-server-ecc.pem \
            --srppasswdconf srp-tpasswd.conf \
            --srppasswd srp-passwd.txt \
            --pskpasswd psk-passwd.txt
</pre></div>
<hr>
<span id="gnutls_002dcli_002ddebug-Invocation"></span><div class="header">
<p>
Previous: <a href="#gnutls_002dserv-Invocation" accesskey="p" rel="prev">gnutls-serv Invocation</a>, Up: <a href="#Other-included-programs" accesskey="u" rel="up">Other included programs</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Invoking-gnutls_002dcli_002ddebug"></span><h3 class="section">10.3 Invoking gnutls-cli-debug</h3>
<span id="index-gnutls_002dcli_002ddebug"></span>


<p>TLS debug client. It sets up multiple TLS connections to 
a server and queries its capabilities. It was created to assist in debugging 
GnuTLS, but it might be useful to extract a TLS server&rsquo;s capabilities.
It connects to a TLS server, performs tests and print the server&rsquo;s 
capabilities. If called with the &lsquo;-V&rsquo; parameter more checks will be performed.
Can be used to check for servers with special needs or bugs.
</p>
<p>This section was generated by <strong>AutoGen</strong>,
using the <code>agtexi-cmd</code> template and the option descriptions for the <code>gnutls-cli-debug</code> program.
This software is released under the GNU General Public License, version 3 or later.
</p>

<span id="gnutls_002dcli_002ddebug-usage"></span><span id="gnutls_002dcli_002ddebug-help_002fusage-_0028_002d_002dhelp_0029"></span><h4 class="subheading">gnutls-cli-debug help/usage (<samp>--help</samp>)</h4>
<span id="index-gnutls_002dcli_002ddebug-help"></span>

<p>This is the automatically generated usage text for gnutls-cli-debug.
</p>
<p>The text printed is the same whether selected with the <code>help</code> option
(<samp>--help</samp>) or the <code>more-help</code> option (<samp>--more-help</samp>).  <code>more-help</code> will print
the usage text by passing it through a pager program.
<code>more-help</code> is disabled on platforms without a working
<code>fork(2)</code> function.  The <code>PAGER</code> environment variable is
used to select the program, defaulting to <samp>more</samp>.  Both will exit
with a status code of 0.
</p>
<div class="example">
<pre class="example">gnutls-cli-debug - GnuTLS debug client
Usage:  gnutls-cli-debug [ -&lt;flag&gt; [&lt;val&gt;] | --&lt;name&gt;[{=| }&lt;val&gt;] ]... 

   -d, --debug=num            Enable debugging
                                - it must be in the range:
                                  0 to 9999
   -V, --verbose              More verbose output
                                - may appear multiple times
   -p, --port=num             The port to connect to
                                - it must be in the range:
                                  0 to 65536
       --app-proto=str        an alias for the 'starttls-proto' option
       --starttls-proto=str   The application protocol to be used to obtain the server's certificate
(https, ftp, smtp, imap, ldap, xmpp, lmtp, pop3, nntp, sieve, postgres)
   -v, --version[=arg]        output version information and exit
   -h, --help                 display extended usage information and exit
   -!, --more-help            extended usage information passed thru pager

Options are specified by doubled hyphens and their name or by a single
hyphen and the flag character.
Operands and options may be intermixed.  They will be reordered.

TLS debug client.  It sets up multiple TLS connections to a server and
queries its capabilities.  It was created to assist in debugging GnuTLS,
but it might be useful to extract a TLS server's capabilities.  It connects
to a TLS server, performs tests and print the server's capabilities.  If
called with the `-V' parameter more checks will be performed.  Can be used
to check for servers with special needs or bugs.

</pre></div>

<span id="gnutls_002dcli_002ddebug-debug"></span><span id="debug-option-_0028_002dd_0029-7"></span><h4 class="subheading">debug option (-d)</h4>

<p>This is the &ldquo;enable debugging&rdquo; option.
This option takes a number argument.
Specifies the debug level.
<span id="gnutls_002dcli_002ddebug-app_002dproto"></span></p><span id="app_002dproto-option-2"></span><h4 class="subheading">app-proto option</h4>

<p>This is an alias for the <code>starttls-proto</code> option,
see <a href="#gnutls_002dcli_002ddebug-starttls_002dproto">the starttls-proto option documentation</a>.
</p>
<span id="gnutls_002dcli_002ddebug-starttls_002dproto"></span><span id="starttls_002dproto-option-2"></span><h4 class="subheading">starttls-proto option</h4>

<p>This is the &ldquo;the application protocol to be used to obtain the server&rsquo;s certificate (https, ftp, smtp, imap, ldap, xmpp, lmtp, pop3, nntp, sieve, postgres)&rdquo; option.
This option takes a string argument.
Specify the application layer protocol for STARTTLS. If the protocol is supported, gnutls-cli will proceed to the TLS negotiation.
<span id="gnutls_002dcli_002ddebug-exit-status"></span></p><span id="gnutls_002dcli_002ddebug-exit-status-1"></span><h4 class="subheading">gnutls-cli-debug exit status</h4>

<p>One of the following exit values will be returned:
</p><dl compact="compact">
<dt>&lsquo;<samp>0 (EXIT_SUCCESS)</samp>&rsquo;</dt>
<dd><p>Successful program execution.
</p></dd>
<dt>&lsquo;<samp>1 (EXIT_FAILURE)</samp>&rsquo;</dt>
<dd><p>The operation failed or the command syntax was not valid.
</p></dd>
</dl>
<span id="gnutls_002dcli_002ddebug-See-Also"></span><span id="gnutls_002dcli_002ddebug-See-Also-1"></span><h4 class="subheading">gnutls-cli-debug See Also</h4>
<p>gnutls-cli(1), gnutls-serv(1)
<span id="gnutls_002dcli_002ddebug-Examples"></span></p><span id="gnutls_002dcli_002ddebug-Examples-1"></span><h4 class="subheading">gnutls-cli-debug Examples</h4>
<div class="example">
<pre class="example">$ gnutls-cli-debug localhost
GnuTLS debug client 3.5.0
Checking localhost:443
                             for SSL 3.0 (RFC6101) support... yes
                        whether we need to disable TLS 1.2... no
                        whether we need to disable TLS 1.1... no
                        whether we need to disable TLS 1.0... no
                        whether %NO_EXTENSIONS is required... no
                               whether %COMPAT is required... no
                             for TLS 1.0 (RFC2246) support... yes
                             for TLS 1.1 (RFC4346) support... yes
                             for TLS 1.2 (RFC5246) support... yes
                                  fallback from TLS 1.6 to... TLS1.2
                        for RFC7507 inappropriate fallback... yes
                                     for HTTPS server name... Local
                               for certificate chain order... sorted
                  for safe renegotiation (RFC5746) support... yes
                     for Safe renegotiation support (SCSV)... no
                    for encrypt-then-MAC (RFC7366) support... no
                   for ext master secret (RFC7627) support... no
                           for heartbeat (RFC6520) support... no
                       for version rollback bug in RSA PMS... dunno
                  for version rollback bug in Client Hello... no
            whether the server ignores the RSA PMS version... yes
whether small records (512 bytes) are tolerated on handshake... yes
    whether cipher suites not in SSL 3.0 spec are accepted... yes
whether a bogus TLS record version in the client hello is accepted... yes
         whether the server understands TLS closure alerts... partially
            whether the server supports session resumption... yes
                      for anonymous authentication support... no
                      for ephemeral Diffie-Hellman support... no
                   for ephemeral EC Diffie-Hellman support... yes
                    ephemeral EC Diffie-Hellman group info... SECP256R1
                  for AES-128-GCM cipher (RFC5288) support... yes
                  for AES-128-CCM cipher (RFC6655) support... no
                for AES-128-CCM-8 cipher (RFC6655) support... no
                  for AES-128-CBC cipher (RFC3268) support... yes
             for CAMELLIA-128-GCM cipher (RFC6367) support... no
             for CAMELLIA-128-CBC cipher (RFC5932) support... no
                     for 3DES-CBC cipher (RFC2246) support... yes
                  for ARCFOUR 128 cipher (RFC2246) support... yes
                                       for MD5 MAC support... yes
                                      for SHA1 MAC support... yes
                                    for SHA256 MAC support... yes
                              for ZLIB compression support... no
                     for max record size (RFC6066) support... no
                for OCSP status response (RFC6066) support... no
              for OpenPGP authentication (RFC6091) support... no
</pre></div>

<p>You could also use the client to debug services with starttls capability.
</p><div class="example">
<pre class="example">$ gnutls-cli-debug --starttls-proto smtp --port 25 localhost
</pre></div>

<hr>
<span id="Internal-architecture-of-GnuTLS"></span><div class="header">
<p>
Next: <a href="#Upgrading-from-previous-versions" accesskey="n" rel="next">Upgrading from previous versions</a>, Previous: <a href="#Other-included-programs" accesskey="p" rel="prev">Other included programs</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Internal-Architecture-of-GnuTLS"></span><h2 class="chapter">11 Internal Architecture of GnuTLS</h2>
<span id="index-internal-architecture"></span>

<p>This chapter is to give a brief description of the
way <acronym>GnuTLS</acronym> works. The focus is to give an idea
to potential developers and those who want to know what
happens inside the black box.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#The-TLS-Protocol" accesskey="1">The TLS Protocol</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#TLS-Handshake-Protocol" accesskey="2">TLS Handshake Protocol</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#TLS-Authentication-Methods" accesskey="3">TLS Authentication Methods</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#TLS-Hello-Extension-Handling" accesskey="4">TLS Hello Extension Handling</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Cryptographic-Backend" accesskey="5">Cryptographic Backend</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Random-Number-Generators_002dinternals" accesskey="6">Random Number Generators-internals</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#FIPS140_002d2-mode" accesskey="7">FIPS140-2 mode</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="The-TLS-Protocol"></span><div class="header">
<p>
Next: <a href="#TLS-Handshake-Protocol" accesskey="n" rel="next">TLS Handshake Protocol</a>, Up: <a href="#Internal-architecture-of-GnuTLS" accesskey="u" rel="up">Internal architecture of GnuTLS</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="The-TLS-Protocol-1"></span><h3 class="section">11.1 The TLS Protocol</h3>
<p>The main use case for the TLS protocol is shown in <a href="#fig_002dclient_002dserver">Figure 11.1</a>.
A user of a library implementing the protocol expects no less than this functionality,
i.e., to be able to set parameters such as the accepted security level, perform a
negotiation with the peer and be able to exchange data.
</p>
<div class="float"><span id="fig_002dclient_002dserver"></span>
<img src="gnutls-client-server-use-case.png" alt="gnutls-client-server-use-case">

<div class="float-caption"><p><strong>Figure 11.1: </strong>TLS protocol use case.</p></div></div>
<hr>
<span id="TLS-Handshake-Protocol"></span><div class="header">
<p>
Next: <a href="#TLS-Authentication-Methods" accesskey="n" rel="next">TLS Authentication Methods</a>, Previous: <a href="#The-TLS-Protocol" accesskey="p" rel="prev">The TLS Protocol</a>, Up: <a href="#Internal-architecture-of-GnuTLS" accesskey="u" rel="up">Internal architecture of GnuTLS</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="TLS-Handshake-Protocol-1"></span><h3 class="section">11.2 TLS Handshake Protocol</h3>
<p>The <acronym>GnuTLS</acronym> handshake protocol is implemented as a state
machine that waits for input or returns immediately when the non-blocking
transport layer functions are used. The main idea is shown in <a href="#fig_002dgnutls_002dhandshake">Figure 11.2</a>.
</p>
<div class="float"><span id="fig_002dgnutls_002dhandshake"></span>
<img src="gnutls-handshake-state.png" alt="gnutls-handshake-state">

<div class="float-caption"><p><strong>Figure 11.2: </strong>GnuTLS handshake state machine.</p></div></div>
<p>Also the way the input is processed varies per ciphersuite. Several
implementations of the internal handlers are available and
<a href="#gnutls_005fhandshake">gnutls_handshake</a> only multiplexes the input to the appropriate
handler. For example a <acronym>PSK</acronym> ciphersuite has a different
implementation of the <code>process_client_key_exchange</code> than a
certificate ciphersuite. We illustrate the idea in <a href="#fig_002dgnutls_002dhandshake_002dsequence">Figure 11.3</a>.
</p>
<div class="float"><span id="fig_002dgnutls_002dhandshake_002dsequence"></span>
<img src="gnutls-handshake-sequence.png" alt="gnutls-handshake-sequence">

<div class="float-caption"><p><strong>Figure 11.3: </strong>GnuTLS handshake process sequence.</p></div></div>
<hr>
<span id="TLS-Authentication-Methods"></span><div class="header">
<p>
Next: <a href="#TLS-Hello-Extension-Handling" accesskey="n" rel="next">TLS Hello Extension Handling</a>, Previous: <a href="#TLS-Handshake-Protocol" accesskey="p" rel="prev">TLS Handshake Protocol</a>, Up: <a href="#Internal-architecture-of-GnuTLS" accesskey="u" rel="up">Internal architecture of GnuTLS</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="TLS-Authentication-Methods-1"></span><h3 class="section">11.3 TLS Authentication Methods</h3>
<p>In <acronym>GnuTLS</acronym> authentication methods can be implemented quite
easily.  Since the required changes to add a new authentication method
affect only the handshake protocol, a simple interface is used. An
authentication method needs to implement the functions shown below.
</p>
<pre class="verbatim">typedef struct
{
  const char *name;
  int (*gnutls_generate_server_certificate) (gnutls_session_t, gnutls_buffer_st*);
  int (*gnutls_generate_client_certificate) (gnutls_session_t, gnutls_buffer_st*);
  int (*gnutls_generate_server_kx) (gnutls_session_t, gnutls_buffer_st*);
  int (*gnutls_generate_client_kx) (gnutls_session_t, gnutls_buffer_st*);
  int (*gnutls_generate_client_cert_vrfy) (gnutls_session_t, gnutls_buffer_st *);
  int (*gnutls_generate_server_certificate_request) (gnutls_session_t,
                                                     gnutls_buffer_st *);

  int (*gnutls_process_server_certificate) (gnutls_session_t, opaque *,
                                            size_t);
  int (*gnutls_process_client_certificate) (gnutls_session_t, opaque *,
                                            size_t);
  int (*gnutls_process_server_kx) (gnutls_session_t, opaque *, size_t);
  int (*gnutls_process_client_kx) (gnutls_session_t, opaque *, size_t);
  int (*gnutls_process_client_cert_vrfy) (gnutls_session_t, opaque *, size_t);
  int (*gnutls_process_server_certificate_request) (gnutls_session_t,
                                                    opaque *, size_t);
} mod_auth_st;
</pre>
<p>Those functions are responsible for the
interpretation of the handshake protocol messages. It is common for such
functions to read data from one or more <code>credentials_t</code>
structures<a id="DOCF23" href="#FOOT23"><sup>23</sup></a> and write data,
such as certificates, usernames etc. to <code>auth_info_t</code> structures.
</p>

<p>Simple examples of existing authentication methods can be seen in
<code>auth/psk.c</code> for PSK ciphersuites and <code>auth/srp.c</code> for SRP
ciphersuites. After implementing these functions the structure holding
its pointers has to be registered in <code>gnutls_algorithms.c</code> in the
<code>_gnutls_kx_algorithms</code> structure.
</p>
<hr>
<span id="TLS-Hello-Extension-Handling"></span><div class="header">
<p>
Next: <a href="#Cryptographic-Backend" accesskey="n" rel="next">Cryptographic Backend</a>, Previous: <a href="#TLS-Authentication-Methods" accesskey="p" rel="prev">TLS Authentication Methods</a>, Up: <a href="#Internal-architecture-of-GnuTLS" accesskey="u" rel="up">Internal architecture of GnuTLS</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="TLS-Extension-Handling"></span><h3 class="section">11.4 TLS Extension Handling</h3>
<p>As with authentication methods, adding TLS hello extensions can be done
quite easily by implementing the interface shown below.
</p>
<pre class="verbatim">typedef int (*gnutls_ext_recv_func) (gnutls_session_t session,
                                     const unsigned char *data, size_t len);
typedef int (*gnutls_ext_send_func) (gnutls_session_t session,
                                     gnutls_buffer_st *extdata);
</pre>
<p>Here there are two main functions, one for parsing the received extension data
and one for formatting the extension data that must be send. These functions
have to check internally whether they operate within a client or a server session.
</p>
<p>A simple example of an extension handler can be seen in
<code>lib/ext/srp.c</code> in GnuTLS&rsquo; source code. After implementing these functions,
the extension has to be registered. Registering an extension can be done in two
ways. You can create a GnuTLS internal extension and register it in
<code>hello_ext.c</code> or write an external extension (not inside GnuTLS but
inside an application using GnuTLS) and register it via the exported functions
<a href="#gnutls_005fsession_005fext_005fregister">gnutls_session_ext_register</a> or <a href="#gnutls_005fext_005fregister">gnutls_ext_register</a>.
</p>
<span id="Adding-a-new-TLS-hello-extension"></span><h4 class="subheading">Adding a new TLS hello extension</h4>

<p>Adding support for a new TLS hello extension is done from time to time, and
the process to do so is not difficult. Here are the steps you need to
follow if you wish to do this yourself. For the sake of discussion, let&rsquo;s
consider adding support for the hypothetical TLS extension <code>foobar</code>.
The following section is about adding an hello extension to GnuTLS itself.
For custom application extensions you should check the exported functions
<a href="#gnutls_005fsession_005fext_005fregister">gnutls_session_ext_register</a> or <a href="#gnutls_005fext_005fregister">gnutls_ext_register</a>.
</p>
<span id="Add-configure-option-like-_002d_002denable_002dfoobar-or-_002d_002ddisable_002dfoobar_002e"></span><h4 class="subsubheading">Add <code>configure</code> option like <code>--enable-foobar</code> or <code>--disable-foobar</code>.</h4>

<p>This step is useful when the extension code is large and it might be desirable
under some circumstances to be able to leave out the extension during compilation of GnuTLS.
If you don&rsquo;t need this kind of feature this step can be safely skipped.
</p>
<p>Whether to choose enable or disable depends on whether you intend to make the extension be
enabled by default. Look at existing checks (i.e., SRP, authz) for
how to model the code. For example:
</p>
<div class="example">
<pre class="example">AC_MSG_CHECKING([whether to disable foobar support])
AC_ARG_ENABLE(foobar,
	AS_HELP_STRING([--disable-foobar],
		[disable foobar support]),
	ac_enable_foobar=no)
if test x$ac_enable_foobar != xno; then
 AC_MSG_RESULT(no)
 AC_DEFINE(ENABLE_FOOBAR, 1, [enable foobar])
else
 ac_full=0
 AC_MSG_RESULT(yes)
fi
AM_CONDITIONAL(ENABLE_FOOBAR, test &quot;$ac_enable_foobar&quot; != &quot;no&quot;)
</pre></div>

<p>These lines should go in <code>lib/m4/hooks.m4</code>.
</p>
<span id="Add-an-extension-identifier-to-extensions_005ft-in-gnutls_005fint_002eh_002e"></span><h4 class="subsubheading">Add an extension identifier to <code>extensions_t</code> in <code>gnutls_int.h</code>.</h4>

<p>A good name for the identifier would be GNUTLS_EXTENSION_FOOBAR. If the
extension that you are implementing is an extension that is officially
registered by IANA then it is recommended to use its official name such
that the extension can be correctly identified by other developers. Check
with <a href="https://www.iana.org/assignments/tls-extensiontype-values">https://www.iana.org/assignments/tls-extensiontype-values</a>
for registered extensions.
</p>
<span id="Register-the-extension-in-lib_002fhello_005fext_002ec_002e"></span><h4 class="subsubheading">Register the extension in <code>lib/hello_ext.c</code>.</h4>

<p>In order for the extension to be executed you need to register it in the
<code>static hello_ext_entry_st const *extfunc[]</code> list in <code>lib/hello_ext.c</code>.
</p>
<p>A typical entry would be:
</p>
<div class="example">
<pre class="example">#ifdef ENABLE_FOOBAR
	[GNUTLS_EXTENSION_FOOBAR] = &amp;ext_mod_foobar,
#endif
</pre></div>

<p>Also for every extension you need to create an <code>hello_ext_entry_st</code>
that describes the extension. This structure is placed in the designated
c file for your extension and its name is used in the registration entry
as depicted above.
</p>
<p>The structure of <code>hello_ext_entry_st</code> is as follows:
</p><div class="example">
<pre class="example">  const hello_ext_entry_st ext_mod_foobar = {
    .name = &quot;FOOBAR&quot;,
    .tls_id = 255,
    .gid = GNUTLS_EXTENSION_FOOBAR,
    .parse_type = GNUTLS_EXT_TLS,
    .validity = GNUTLS_EXT_FLAG_CLIENT_HELLO |
	GNUTLS_EXT_FLAG_TLS12_SERVER_HELLO |
	GNUTLS_EXT_FLAG_TLS13_SERVER_HELLO |
	GNUTLS_EXT_FLAG_TLS,
    .recv_func = _gnutls_foobar_recv_params,
    .send_func = _gnutls_foobar_send_params,
    .pack_func = _gnutls_foobar_pack,
    .unpack_func = _gnutls_foobar_unpack,
    .deinit_func = _gnutls_foobar_deinit,
    .cannot_be_overriden = 1
  };
</pre></div>

<p>The GNUTLS_EXTENSION_FOOBAR is the identifier that you&rsquo;ve added to
<code>gnutls_int.h</code> earlier. The <code>.tls_id</code> should contain the number
that IANA has assigned to this extension, or an unassigned number of your
choice if this is an unregistered extension. In the rest of this structure
you specify the functions to handle the extension data. The <code>receive</code> function
will be called upon reception of the data and will be used to parse or
interpret the extension data. The <code>send</code> function will be called prior to
sending the extension data on the wire and will be used to format the data
such that it can be send over the wire. The <code>pack</code> and <code>unpack</code>
functions will be used to prepare the data for storage in case of session resumption
(and vice versa). The <code>deinit</code> function will be called to deinitialize
the extension&rsquo;s private parameters, if any.
</p>
<p>Look at <code>gnutls_ext_parse_type_t</code> and <code>gnutls_ext_flags_t</code> for a complete
list of available flags.
</p>
<p>Note that the conditional <code>ENABLE_FOOBAR</code> definition should only be
used if step 1 with the <code>configure</code> options has taken place.
</p>
<span id="Add-new-files-that-implement-the-hello-extension_002e"></span><h4 class="subsubheading">Add new files that implement the hello extension.</h4>

<p>To keep things structured every extension should have its own files. The
functions that you should (at least) add are those referenced in the struct
from the previous step. Use descriptive file names such as <code>lib/ext/foobar.c</code>
and for the corresponding header <code>lib/ext/foobar.h</code>.
As a starter, you could add this:
</p>
<div class="example">
<pre class="example">int
_gnutls_foobar_recv_params (gnutls_session_t session, const uint8_t * data,
                     size_t data_size)
{
  return 0;
}

int
_gnutls_foobar_send_params (gnutls_session_t session, gnutls_buffer_st* data)
{
  return 0;
}

int
_gnutls_foobar_pack (extension_priv_data_t epriv, gnutls_buffer_st * ps)
{
   /* Append the extension's internal state to buffer */
   return 0;
}

int
_gnutls_foobar_unpack (gnutls_buffer_st * ps, extension_priv_data_t * epriv)
{
   /* Read the internal state from buffer */
   return 0;
}
</pre></div>

<p>The <code>_gnutls_foobar_recv_params</code> function is responsible for
parsing incoming extension data (both in the client and server).
</p>
<p>The <code>_gnutls_foobar_send_params</code> function is responsible for
formatting extension data such that it can be send over the wire (both in
the client and server). It should append data to provided buffer and
return a positive (or zero) number on success or a negative error code.
Previous to 3.6.0 versions of GnuTLS required that function to return the
number of bytes that were written. If zero is returned and no bytes are
appended the extension will not be sent. If a zero byte extension is to
be sent this function must return <code>GNUTLS_E_INT_RET_0</code>.
</p>
<p>If you receive length fields that don&rsquo;t match, return
<code>GNUTLS_E_UNEXPECTED_PACKET_LENGTH</code>.  If you receive invalid
data, return <code>GNUTLS_E_RECEIVED_ILLEGAL_PARAMETER</code>.  You can use
other error codes from the list in <a href="#Error-codes">Error codes</a>. Return 0 on success.
</p>
<p>An extension typically stores private information in the <code>session</code>
data for later usage. That can be done using the functions
<code>_gnutls_hello_ext_set_datum</code> and
<code>_gnutls_hello_ext_get_datum</code>. You can check simple examples
at <code>lib/ext/max_record.c</code> and <code>lib/ext/server_name.c</code> extensions.
That private information can be saved and restored across session
resumption if the following functions are set:
</p>
<p>The <code>_gnutls_foobar_pack</code> function is responsible for packing
internal extension data to save them in the session resumption storage.
</p>
<p>The <code>_gnutls_foobar_unpack</code> function is responsible for
restoring session data from the session resumption storage.
</p>
<p>When the internal data is stored using the <code>_gnutls_hello_ext_set_datum</code>,
then you can rely on the default pack and unpack functions:
<code>_gnutls_hello_ext_default_pack</code> and
<code>_gnutls_hello_ext_default_unpack</code>.
</p>
<p>Recall that both for the client and server, the send and receive
functions most likely will need to do different things
depending on which mode they are in. It may be useful to make this
distinction explicit in the code. Thus, for example, a better
template than above would be:
</p>
<div class="example">
<pre class="example">int
_gnutls_foobar_recv_params (gnutls_session_t session,
                            const uint8_t * data,
                            size_t data_size)
{
  if (session-&gt;security_parameters.entity == GNUTLS_CLIENT)
    return foobar_recv_client (session, data, data_size);
  else
    return foobar_recv_server (session, data, data_size);
}

int
_gnutls_foobar_send_params (gnutls_session_t session,
                            gnutls_buffer_st * data)
{
  if (session-&gt;security_parameters.entity == GNUTLS_CLIENT)
    return foobar_send_client (session, data);
  else
    return foobar_send_server (session, data);
}
</pre></div>

<p>The functions used would be declared as <code>static</code> functions, of
the appropriate prototype, in the same file.
</p>
<p>When adding the new extension files, you&rsquo;ll need to add them to <code>lib/ext/Makefile.am</code>
as well, for example:
</p>
<div class="example">
<pre class="example">if ENABLE_FOOBAR
libgnutls_ext_la_SOURCES += ext/foobar.c ext/foobar.h
endif
</pre></div>

<span id="Add-API-functions-to-use-the-extension_002e"></span><h4 class="subsubheading">Add API functions to use the extension.</h4>

<p>It might be desirable to allow users of the extension to
request the use of the extension, or set extension specific data.
This can be implemented by adding extension specific function calls
that can be added to <code>includes/gnutls/gnutls.h</code>,
as long as the LGPLv2.1+ applies.
The implementation of these functions should lie in the <code>lib/ext/foobar.c</code> file.
</p>
<p>To make the API available in the shared library you need to add the added
symbols in <code>lib/libgnutls.map</code>, so that the symbols are exported properly.
</p>
<p>When writing GTK-DOC style documentation for your new APIs, don&rsquo;t
forget to add <code>Since:</code> tags to indicate the GnuTLS version the
API was introduced in.
</p>
<span id="Adding-a-new-Supplemental-Data-Handshake-Message"></span><h4 class="subheading">Adding a new Supplemental Data Handshake Message</h4>

<p>TLS handshake extensions allow to send so called supplemental data
handshake messages [<a href="#RFC4680">RFC4680</a>]. This short section explains how to
implement a supplemental data handshake message for a given TLS extension.
</p>
<p>First of all, modify your extension <code>foobar</code> in the way, to instruct
the handshake process to send and receive supplemental data, as shown below.
</p>
<div class="example">
<pre class="example">int
_gnutls_foobar_recv_params (gnutls_session_t session, const opaque * data,
                                 size_t _data_size)
{
   ...
   gnutls_supplemental_recv(session, 1);
   ...
}

int
_gnutls_foobar_send_params (gnutls_session_t session, gnutls_buffer_st *extdata)
{
   ...
   gnutls_supplemental_send(session, 1);
   ...
}
</pre></div>

<p>Furthermore you&rsquo;ll need two new functions <code>_foobar_supp_recv_params</code>
and <code>_foobar_supp_send_params</code>, which must conform to the following
prototypes.
</p>
<div class="example">
<pre class="example">typedef int (*gnutls_supp_recv_func)(gnutls_session_t session,
                                     const unsigned char *data,
                                     size_t data_size);
typedef int (*gnutls_supp_send_func)(gnutls_session_t session,
                                     gnutls_buffer_t buf);
</pre></div>

<p>The following example code shows how to send a
&ldquo;Hello World&rdquo; string in the supplemental data handshake message.
</p>
<div class="example">
<pre class="example">int
_foobar_supp_recv_params(gnutls_session_t session, const opaque *data, size_t _data_size)
{
   uint8_t len = _data_size;
   unsigned char *msg;

   msg = gnutls_malloc(len);
   if (msg == NULL) return GNUTLS_E_MEMORY_ERROR;

   memcpy(msg, data, len);
   msg[len]='\0';

   /* do something with msg */
   gnutls_free(msg);

   return len;
}

int
_foobar_supp_send_params(gnutls_session_t session, gnutls_buffer_t buf)
{
   unsigned char *msg = &quot;hello world&quot;;
   int len = strlen(msg);

   if (gnutls_buffer_append_data(buf, msg, len) &lt; 0)
       abort();

   return len;
}
</pre></div>

<p>Afterwards, register the new supplemental data using <a href="#gnutls_005fsession_005fsupplemental_005fregister">gnutls_session_supplemental_register</a>,
or <a href="#gnutls_005fsupplemental_005fregister">gnutls_supplemental_register</a> at some point in your program.
</p>
<hr>
<span id="Cryptographic-Backend"></span><div class="header">
<p>
Next: <a href="#Random-Number-Generators_002dinternals" accesskey="n" rel="next">Random Number Generators-internals</a>, Previous: <a href="#TLS-Hello-Extension-Handling" accesskey="p" rel="prev">TLS Hello Extension Handling</a>, Up: <a href="#Internal-architecture-of-GnuTLS" accesskey="u" rel="up">Internal architecture of GnuTLS</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Cryptographic-Backend-1"></span><h3 class="section">11.5 Cryptographic Backend</h3>

<p>Today most new processors, either for embedded or desktop systems
include either instructions  intended to speed up cryptographic operations,
or a co-processor with cryptographic capabilities. Taking advantage of
those is a challenging task for every cryptographic  application or
library. GnuTLS handles the cryptographic provider in a modular
way, following a layered approach to access
cryptographic operations as in <a href="#fig_002dcrypto_002dlayers">Figure 11.4</a>.
</p>
<div class="float"><span id="fig_002dcrypto_002dlayers"></span>
<img src="gnutls-crypto-layers.png" alt="gnutls-crypto-layers">

<div class="float-caption"><p><strong>Figure 11.4: </strong>GnuTLS cryptographic back-end design.</p></div></div>
<p>The TLS layer uses a cryptographic provider layer, that will in turn either
use the default crypto provider &ndash; a software crypto library, or use an external
crypto provider, if available in the local system. The reason of handling
the external cryptographic provider in GnuTLS and not delegating it to
the cryptographic libraries, is that none of the supported cryptographic
libraries support <code>/dev/crypto</code> or CPU-optimized cryptography in
an efficient way.
</p>
<span id="Cryptographic-library-layer"></span><h4 class="subheading">Cryptographic library layer</h4>
<p>The Cryptographic library layer, currently supports only
libnettle. Older versions of GnuTLS used to support libgcrypt,
but it was switched with nettle mainly for performance reasons<a id="DOCF24" href="#FOOT24"><sup>24</sup></a>
and secondary because it is a simpler library to use.
In the future other cryptographic libraries might be supported as well.
</p>
<span id="External-cryptography-provider"></span><h4 class="subheading">External cryptography provider</h4>
<p>Systems that include a cryptographic co-processor, typically come with
kernel drivers to utilize the operations from software. For this reason
GnuTLS provides a layer where each individual algorithm used can be replaced
by another implementation, i.e., the one provided by the driver. The
FreeBSD, OpenBSD and Linux kernels<a id="DOCF25" href="#FOOT25"><sup>25</sup></a> include already
a number of hardware assisted implementations, and also provide an interface
to access them, called <code>/dev/crypto</code>.
GnuTLS will take advantage of this interface if compiled with special
options. That is because in most systems where hardware-assisted
cryptographic operations are not available, using this interface might
actually harm performance.
</p>
<p>In systems that include cryptographic instructions with the CPU&rsquo;s
instructions set, using the kernel interface will introduce an
unneeded layer. For this reason GnuTLS includes such optimizations
found in popular processors such as the AES-NI or VIA PADLOCK instruction sets.
This is achieved using a mechanism that detects CPU capabilities and
overrides parts of crypto back-end at runtime.
The next section discusses the registration of a detected algorithm
optimization. For more information please consult the <acronym>GnuTLS</acronym>
source code in <code>lib/accelerated/</code>.
</p>
<span id="Overriding-specific-algorithms"></span><h4 class="subsubheading">Overriding specific algorithms</h4>
<p>When an optimized implementation of a single algorithm is available,
say a hardware assisted version of <acronym>AES-CBC</acronym> then the
following functions, from <code>crypto.h</code>, can
be used to register those algorithms.
</p>
<ul>
<li> <a href="#gnutls_005fcrypto_005fregister_005fcipher">gnutls_crypto_register_cipher</a>:
To register a cipher algorithm.

</li><li> <a href="#gnutls_005fcrypto_005fregister_005faead_005fcipher">gnutls_crypto_register_aead_cipher</a>:
To register an AEAD cipher algorithm.

</li><li> <a href="#gnutls_005fcrypto_005fregister_005fmac">gnutls_crypto_register_mac</a>:
To register a MAC algorithm.

</li><li> <a href="#gnutls_005fcrypto_005fregister_005fdigest">gnutls_crypto_register_digest</a>:
To register a hash algorithm.

</li></ul>

<p>Those registration functions will only replace the specified algorithm
and leave the rest of subsystem intact.
</p>

<span id="Protecting-keys-through-isolation"></span><h4 class="subheading">Protecting keys through isolation</h4>

<p>For asymmetric or public keys, GnuTLS supports PKCS #11 which allows
operation without access to long term keys, in addition to CPU offloading.
For more information see <a href="#Hardware-security-modules-and-abstract-key-types">Hardware security modules and abstract key types</a>.
</p>

<hr>
<span id="Random-Number-Generators_002dinternals"></span><div class="header">
<p>
Next: <a href="#FIPS140_002d2-mode" accesskey="n" rel="next">FIPS140-2 mode</a>, Previous: <a href="#Cryptographic-Backend" accesskey="p" rel="prev">Cryptographic Backend</a>, Up: <a href="#Internal-architecture-of-GnuTLS" accesskey="u" rel="up">Internal architecture of GnuTLS</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Random-Number-Generators"></span><h3 class="section">11.6 Random Number Generators</h3>

<span id="About-the-generators"></span><h4 class="subheading">About the generators</h4>

<p>GnuTLS provides two random generators. The default, and the AES-DRBG random
generator which is only used when the library is compiled with support for
FIPS140-2 and the system is in FIPS140-2 mode.
</p>
<span id="The-default-generator-_002d-inner-workings"></span><h4 class="subheading">The default generator - inner workings</h4>

<p>The random number generator levels in <code>gnutls_rnd_level_t</code> map to two CHACHA-based random generators which
are initially seeded using the OS random device, e.g., <code>/dev/urandom</code>
or <code>getrandom()</code>. These random generators are unique per thread, and
are automatically re-seeded when a fork is detected.
</p>
<p>The reason the CHACHA cipher was selected for the GnuTLS&rsquo; PRNG is the fact
that CHACHA is considered a secure and fast stream cipher, and is already
defined for use in TLS protocol. As such, the utilization of it would
not stress the CPU caches, and would allow for better performance on busy
servers, irrespective of their architecture (e.g., even if AES is not
available with an optimized instruction set).
</p>
<p>The generators are unique per thread to allow lock-free operation. That
induces a cost of around 140-bytes for the state of the generators per
thread, on threads that would utilize <a href="#gnutls_005frnd">gnutls_rnd</a>. At the same time
it allows fast and lock-free access to the generators. The lock-free access
benefits servers which utilize more than 4 threads, while imposes no cost on
single threaded processes.
</p>
<p>On the first call to <a href="#gnutls_005frnd">gnutls_rnd</a> the generators are seeded with two independent
keys obtained from the OS random device. Their seed is used to output a fixed amount
of bytes before re-seeding; the number of bytes output varies per generator.
</p>
<p>One generator is dedicated for the <code>GNUTLS_RND_NONCE</code> level, and the
second is shared for the <code>GNUTLS_RND_KEY</code> and <code>GNUTLS_RND_RANDOM</code>
levels. For the rest of this section we refer to the first as the nonce
generator and the second as the key generator.
</p>
<p>The nonce generator will reseed after outputting a fixed amount of bytes
(typically few megabytes), or after few hours of operation without reaching
the limit has passed. It is being re-seed using
the key generator to obtain a new key for the CHACHA cipher, which is mixed
with its old one.
</p>
<p>Similarly, the key generator, will also re-seed after a fixed amount
of bytes is generated (typically less than the nonce), and will also re-seed
based on time, i.e., after few hours of operation without reaching the limit
for a re-seed. For its re-seed it mixes mixes data obtained from the OS random
device with the previous key.
</p>
<p>Although the key generator used to provide data for the <code>GNUTLS_RND_RANDOM</code>
and <code>GNUTLS_RND_KEY</code> levels is identical, when used with the <code>GNUTLS_RND_KEY</code> level
a re-key of the PRNG using its own output, is additionally performed. That ensures that
the recovery of the PRNG state will not be sufficient to recover previously generated values.
</p>

<span id="The-AES_002dDRBG-generator-_002d-inner-workings"></span><h4 class="subheading">The AES-DRBG generator - inner workings</h4>

<p>Similar with the default generator, the random number generator levels in <code>gnutls_rnd_level_t</code> map to two
AES-DRBG random generators which are initially seeded using the OS random device,
e.g., <code>/dev/urandom</code> or <code>getrandom()</code>. These random generators are
unique per thread, and are automatically re-seeded when a fork is detected.
</p>
<p>The AES-DRBG generator is based on the AES cipher in counter mode and is
re-seeded after a fixed amount of bytes are generated.
</p>

<span id="Defense-against-PRNG-attacks"></span><h4 class="subheading">Defense against PRNG attacks</h4>

<p>This section describes the counter-measures available in the Pseudo-random number generator (PRNG)
of GnuTLS for known attacks as described in [<a href="#PRNGATTACKS">PRNGATTACKS</a>]. Note that, the attacks on a PRNG such as
state-compromise, assume a quite powerful adversary which has in practice
access to the PRNG state.
</p>
<span id="Cryptanalytic"></span><h4 class="subsubheading">Cryptanalytic</h4>

<p>To defend against cryptanalytic attacks GnuTLS&rsquo; PRNG is a stream cipher
designed to defend against the same attacks. As such, GnuTLS&rsquo; PRNG strength
with regards to this attack relies on the underlying crypto block,
which at the time of writing is CHACHA. That is easily replaceable in
the future if attacks are found to be possible in that cipher.
</p>
<span id="Input_002dbased-attacks"></span><h4 class="subsubheading">Input-based attacks</h4>

<p>These attacks assume that the attacker can influence the input that is used
to form the state of the PRNG. To counter these attacks GnuTLS does not
gather input from the system environment but rather relies on the OS
provided random generator. That is the <code>/dev/urandom</code> or
<code>getentropy</code>/<code>getrandom</code> system calls. As such, GnuTLS&rsquo; PRNG
is as strong as the system random generator can assure with regards to
input-based attacks.
</p>
<span id="State_002dcompromise_003a-Backtracking"></span><h4 class="subsubheading">State-compromise: Backtracking</h4>

<p>A backtracking attack, assumes that an adversary obtains at some point of time
access to the generator state, and wants to recover past bytes. As the
GnuTLS generator is fine-tuned to provide multiple levels, such an attack
mainly concerns levels <code>GNUTLS_RND_RANDOM</code> and <code>GNUTLS_RND_KEY</code>,
since <code>GNUTLS_RND_NONCE</code> is intended to output non-secret data.
The <code>GNUTLS_RND_RANDOM</code> generator at the time of writing can output
2MB prior to being re-seeded thus this is its upper bound for previously
generated data recovered using this attack. That assumes that the state
of the operating system random generator is unknown to the attacker, and we carry that
assumption on the next paragraphs. The usage of <code>GNUTLS_RND_KEY</code> level
ensures that no backtracking is possible for all output data, by re-keying
the PRNG using its own output.
</p>
<p>Such an attack reflects the real world scenario where application&rsquo;s memory is
temporarily compromised, while the kernel&rsquo;s memory is inaccessible.
</p>
<span id="State_002dcompromise_003a-Permanent-Compromise-Attack"></span><h4 class="subsubheading">State-compromise: Permanent Compromise Attack</h4>

<p>A permanent compromise attack implies that once an attacker compromises the
state of GnuTLS&rsquo; random generator at a specific time, future and past
outputs from the generator are compromised. For past outputs the
previous paragraph applies. For future outputs, both the <code>GNUTLS_RND_RANDOM</code>
and the <code>GNUTLS_RND_KEY</code> will recover after 2MB of data have been generated
or few hours have passed (two at the time of writing). Similarly the <code>GNUTLS_RND_NONCE</code>
level generator will recover after several megabytes of output is generated,
or its re-key time is reached.
</p>
<span id="State_002dcompromise_003a-Iterative-guessing"></span><h4 class="subsubheading">State-compromise: Iterative guessing</h4>

<p>This attack assumes that after an attacker obtained the PRNG state
at some point, is able to recover the state at a later time by observing
outputs of the PRNG. That is countered by switching the key to generators
using a combination of a fresh key and the old one (using XOR), at
re-seed time. All levels are immune to such attack after a re-seed.
</p>
<span id="State_002dcompromise_003a-Meet_002din_002dthe_002dMiddle"></span><h4 class="subsubheading">State-compromise: Meet-in-the-Middle</h4>

<p>This attack assumes that the attacker obtained the PRNG state at
two distinct times, and being able to recover the state at the third time
after observing the output of the PRNG. Given the approach described
on the above paragraph, all levels are immune to such attack.
</p>
<hr>
<span id="FIPS140_002d2-mode"></span><div class="header">
<p>
Previous: <a href="#Random-Number-Generators_002dinternals" accesskey="p" rel="prev">Random Number Generators-internals</a>, Up: <a href="#Internal-architecture-of-GnuTLS" accesskey="u" rel="up">Internal architecture of GnuTLS</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="FIPS140_002d2-mode-1"></span><h3 class="section">11.7 FIPS140-2 mode</h3>

<p>GnuTLS can operate in a special mode for FIPS140-2. That mode of operation
is for the conformance to NIST&rsquo;s FIPS140-2 publication, which consists of policies
for cryptographic modules (such as software libraries). Its implementation in
GnuTLS is designed for Red Hat Enterprise Linux, and can only be enabled
when the library is explicitly compiled with the &rsquo;&ndash;enable-fips140-mode&rsquo;
configure option. The operation of the library is then modified, as follows.
</p>
<ul>
<li> FIPS140-2 mode is enabled when <code>/proc/sys/crypto/fips_enabled</code> contains &rsquo;1&rsquo; and <code>/etc/system-fips</code> is present.
</li><li> Only approved by FIPS140-2 algorithms are enabled
</li><li> Only approved by FIPS140-2 key lengths are allowed for key generation
</li><li> The random generator used switches to DRBG-AES
</li><li> The integrity of the GnuTLS and dependent libraries is checked on startup
</li><li> Algorithm self-tests are run on library load
</li><li> Any cryptographic operation will be refused if any of the self-tests failed
</li></ul>


<p>There are also few environment variables which modify that operation. The
environment variable <code>GNUTLS_SKIP_FIPS_INTEGRITY_CHECKS</code> will disable
the library integrity tests on startup, and the variable
<code>GNUTLS_FORCE_FIPS_MODE</code> can be set to force a value from
<a href="#gnutls_005ffips_005fmode_005ft">Figure 11.5</a>, i.e., &rsquo;1&rsquo; will enable the FIPS140-2
mode, while &rsquo;0&rsquo; will disable it.
</p>
<p>The integrity checks for the dependent libraries and GnuTLS are performed
using &rsquo;.hmac&rsquo; files which are present at the same path as the library. The
key for the operations can be provided on compile-time with the configure
option &rsquo;&ndash;with-fips140-key&rsquo;. The MAC algorithm used is HMAC-SHA256.
</p>
<p>On runtime an application can verify whether the library is in FIPS140-2
mode using the <a href="#gnutls_005ffips140_005fmode_005fenabled">gnutls_fips140_mode_enabled</a> function.
</p>
<span id="Relaxing-FIPS140_002d2-requirements"></span><h4 class="subheading">Relaxing FIPS140-2 requirements</h4>

<p>The library by default operates in a strict enforcing mode, ensuring that
all constraints imposed by the FIPS140-2 specification are enforced. However
the application can relax these requirements via <a href="#gnutls_005ffips140_005fset_005fmode">gnutls_fips140_set_mode</a>
which can switch to alternative modes as in <a href="#gnutls_005ffips_005fmode_005ft">Figure 11.5</a>.
</p>
<div class="float"><span id="gnutls_005ffips_005fmode_005ft"></span>


<dl compact="compact">
<dt><code>GNUTLS_FIPS140_DISABLED</code></dt>
<dd><p>The FIPS140-2 mode is disabled.
</p></dd>
<dt><code>GNUTLS_FIPS140_STRICT</code></dt>
<dd><p>The default mode; all forbidden operations will cause an
operation failure via error code.
</p></dd>
<dt><code>GNUTLS_FIPS140_SELFTESTS</code></dt>
<dd><p>A transient state during library initialization. That state
cannot be set or seen by applications.
</p></dd>
<dt><code>GNUTLS_FIPS140_LAX</code></dt>
<dd><p>The library still uses the FIPS140-2 relevant algorithms but all
forbidden by FIPS140-2 operations are allowed; this is useful when the
application is aware of the followed security policy, and needs
to utilize disallowed operations for other reasons (e.g., compatibility).
</p></dd>
<dt><code>GNUTLS_FIPS140_LOG</code></dt>
<dd><p>Similarly to <code>GNUTLS_FIPS140_LAX</code> , it allows forbidden operations; any use of them results
to a message to the audit callback functions.
</p></dd>
</dl>

<div class="float-caption"><p><strong>Figure 11.5: </strong>The <code>gnutls_fips_mode_t</code> enumeration.</p></div></div>
<p>The intention of this API is to be used by applications which may run in
FIPS140-2 mode, while they utilize few algorithms not in the allowed set,
e.g., for non-security related purposes. In these cases applications should
wrap the non-compliant code within blocks like the following.
</p>
<div class="example">
<pre class="example">GNUTLS_FIPS140_SET_LAX_MODE();

_gnutls_hash_fast(GNUTLS_DIG_MD5, buffer, sizeof(buffer), output);

GNUTLS_FIPS140_SET_STRICT_MODE();
</pre></div>

<p>The <code>GNUTLS_FIPS140_SET_LAX_MODE</code> and
<code>GNUTLS_FIPS140_SET_STRICT_MODE</code> are macros to simplify the following
sequence of calls.
</p>
<div class="example">
<pre class="example">if (gnutls_fips140_mode_enabled())
  gnutls_fips140_set_mode(GNUTLS_FIPS140_LAX, GNUTLS_FIPS140_SET_MODE_THREAD);

_gnutls_hash_fast(GNUTLS_DIG_MD5, buffer, sizeof(buffer), output);

if (gnutls_fips140_mode_enabled())
  gnutls_fips140_set_mode(GNUTLS_FIPS140_STRICT, GNUTLS_FIPS140_SET_MODE_THREAD);
</pre></div>

<p>The reason of the <code>GNUTLS_FIPS140_SET_MODE_THREAD</code> flag in the
previous calls is to localize the change in the mode. Note also, that
such a block has no effect when the library is not operating
under FIPS140-2 mode, and thus it can be considered a no-op.
</p>
<p>Applications could also switch FIPS140-2 mode explicitly off, by calling
</p><div class="example">
<pre class="example">gnutls_fips140_set_mode(GNUTLS_FIPS140_LAX, 0);
</pre></div>


<hr>
<span id="Upgrading-from-previous-versions"></span><div class="header">
<p>
Next: <a href="#Support" accesskey="n" rel="next">Support</a>, Previous: <a href="#Internal-architecture-of-GnuTLS" accesskey="p" rel="prev">Internal architecture of GnuTLS</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Upgrading-from-previous-versions-1"></span><h2 class="appendix">Appendix A Upgrading from previous versions</h2>
<span id="index-upgrading"></span>

<p>The GnuTLS library typically maintains binary and source code compatibility
across versions. The releases that have the major version increased
break binary compatibility but source compatibility is provided.
This section lists exceptional cases where changes to existing code are
required due to library changes.
</p>
<span id="Upgrading-to-2_002e12_002ex-from-previous-versions"></span><h3 class="heading">Upgrading to 2.12.x from previous versions</h3>

<p>GnuTLS 2.12.x is binary compatible with previous versions but changes the
semantics of <code>gnutls_transport_set_lowat</code>, which might cause breakage
in applications that relied on its default value be 1. Two fixes
are proposed:
</p><ul>
<li> Quick fix. Explicitly call <code>gnutls_transport_set_lowat (session, 1);</code>
after <a href="#gnutls_005finit">gnutls_init</a>.
</li><li> Long term fix. Because later versions of gnutls abolish the functionality 
of using the system call <code>select</code> to check for gnutls pending data, the 
function <a href="#gnutls_005frecord_005fcheck_005fpending">gnutls_record_check_pending</a> has to be used to achieve the same 
functionality as described in <a href="#Asynchronous-operation">Asynchronous operation</a>.
</li></ul>

<span id="Upgrading-to-3_002e0_002ex-from-2_002e12_002ex"></span><h3 class="heading">Upgrading to 3.0.x from 2.12.x</h3>

<p>GnuTLS 3.0.x is source compatible with previous versions except for the functions
listed below.
</p>
<table>
<thead><tr><th width="30%">Old function</th><th width="60%">Replacement</th></tr></thead>
<tr><td width="30%"><code>gnutls_transport_set_lowat</code></td><td width="60%">To replace its functionality the function <a href="#gnutls_005frecord_005fcheck_005fpending">gnutls_record_check_pending</a> has to be used,
as described in <a href="#Asynchronous-operation">Asynchronous operation</a></td></tr>
<tr><td width="30%"><code>gnutls_session_get_server_random</code>,
<code>gnutls_session_get_client_random</code></td><td width="60%">They are replaced by the safer function <a href="#gnutls_005fsession_005fget_005frandom">gnutls_session_get_random</a></td></tr>
<tr><td width="30%"><code>gnutls_session_get_master_secret</code></td><td width="60%">Replaced by the keying material exporters discussed in <a href="#Deriving-keys-for-other-applications_002fprotocols">Deriving keys for other applications/protocols</a></td></tr>
<tr><td width="30%"><code>gnutls_transport_set_global_errno</code></td><td width="60%">Replaced by using the system&rsquo;s errno facility or <a href="#gnutls_005ftransport_005fset_005ferrno">gnutls_transport_set_errno</a>.</td></tr>
<tr><td width="30%"><code>gnutls_x509_privkey_verify_data</code></td><td width="60%">Replaced by <a href="#gnutls_005fpubkey_005fverify_005fdata2">gnutls_pubkey_verify_data2</a>.</td></tr>
<tr><td width="30%"><code>gnutls_certificate_verify_peers</code></td><td width="60%">Replaced by <a href="#gnutls_005fcertificate_005fverify_005fpeers2">gnutls_certificate_verify_peers2</a>.</td></tr>
<tr><td width="30%"><code>gnutls_psk_netconf_derive_key</code></td><td width="60%">Removed. The key derivation function was never standardized.</td></tr>
<tr><td width="30%"><code>gnutls_session_set_finished_function</code></td><td width="60%">Removed.</td></tr>
<tr><td width="30%"><code>gnutls_ext_register</code></td><td width="60%">Removed. Extension registration API is now internal to allow easier changes in the API.</td></tr>
<tr><td width="30%"><code>gnutls_certificate_get_x509_crls</code>, <code>gnutls_certificate_get_x509_cas</code></td><td width="60%">Removed to allow updating the internal structures. Replaced by <a href="#gnutls_005fcertificate_005fget_005fissuer">gnutls_certificate_get_issuer</a>.</td></tr>
<tr><td width="30%"><code>gnutls_certificate_get_openpgp_keyring</code></td><td width="60%">Removed.</td></tr>
<tr><td width="30%"><code>gnutls_ia_</code></td><td width="60%">Removed. The inner application extensions were completely removed (they failed to be standardized).</td></tr>
</table>

<span id="Upgrading-to-3_002e1_002ex-from-3_002e0_002ex"></span><h3 class="heading">Upgrading to 3.1.x from 3.0.x</h3>

<p>GnuTLS 3.1.x is source and binary compatible with GnuTLS 3.0.x releases. Few
functions have been deprecated and are listed below.
</p>
<table>
<thead><tr><th width="30%">Old function</th><th width="60%">Replacement</th></tr></thead>
<tr><td width="30%"><code>gnutls_pubkey_verify_hash</code></td><td width="60%">The function <a href="#gnutls_005fpubkey_005fverify_005fhash2">gnutls_pubkey_verify_hash2</a> is provided and
is functionally equivalent and safer to use.</td></tr>
<tr><td width="30%"><code>gnutls_pubkey_verify_data</code></td><td width="60%">The function <a href="#gnutls_005fpubkey_005fverify_005fdata2">gnutls_pubkey_verify_data2</a> is provided and
is functionally equivalent and safer to use.</td></tr>
</table>

<span id="Upgrading-to-3_002e2_002ex-from-3_002e1_002ex"></span><h3 class="heading">Upgrading to 3.2.x from 3.1.x</h3>

<p>GnuTLS 3.2.x is source and binary compatible with GnuTLS 3.1.x releases. Few
functions have been deprecated and are listed below.
</p>
<table>
<thead><tr><th width="30%">Old function</th><th width="60%">Replacement</th></tr></thead>
<tr><td width="30%"><code>gnutls_privkey_sign_raw_data</code></td><td width="60%">The function <a href="#gnutls_005fprivkey_005fsign_005fhash">gnutls_privkey_sign_hash</a> is equivalent
when the flag <code>GNUTLS_PRIVKEY_SIGN_FLAG_TLS1_RSA</code> is specified.</td></tr>
</table>

<span id="Upgrading-to-3_002e3_002ex-from-3_002e2_002ex"></span><h3 class="heading">Upgrading to 3.3.x from 3.2.x</h3>

<p>GnuTLS 3.3.x is source and binary compatible with GnuTLS 3.2.x releases;
however there few changes in semantics which are listed below.
</p>
<table>
<thead><tr><th width="30%">Old function</th><th width="60%">Replacement</th></tr></thead>
<tr><td width="30%"><code>gnutls_global_init</code></td><td width="60%">No longer required. The library is initialized using a constructor.</td></tr>
<tr><td width="30%"><code>gnutls_global_deinit</code></td><td width="60%">No longer required. The library is deinitialized using a destructor.</td></tr>
</table>

<span id="Upgrading-to-3_002e4_002ex-from-3_002e3_002ex"></span><h3 class="heading">Upgrading to 3.4.x from 3.3.x</h3>

<p>GnuTLS 3.4.x is source compatible with GnuTLS 3.3.x releases;
however, several deprecated functions were removed, and are listed below.
</p>
<table>
<thead><tr><th width="30%">Old function</th><th width="60%">Replacement</th></tr></thead>
<tr><td width="30%">Priority string &quot;NORMAL&quot; has been modified</td><td width="60%">The following string emulates the 3.3.x behavior &quot;NORMAL:+VERS-SSL3.0:+ARCFOUR-128:+DHE-DSS:+SIGN-DSA-SHA512:+SIGN-DSA-SHA256:+SIGN-DSA-SHA1&quot;</td></tr>
<tr><td width="30%"><code>gnutls_certificate_client_set_retrieve_function</code>,
<code>gnutls_certificate_server_set_retrieve_function</code></td><td width="60%"><a href="#gnutls_005fcertificate_005fset_005fretrieve_005ffunction">gnutls_certificate_set_retrieve_function</a></td></tr>
<tr><td width="30%"><code>gnutls_certificate_set_rsa_export_params</code>,
<code>gnutls_rsa_export_get_modulus_bits</code>,
<code>gnutls_rsa_export_get_pubkey</code>,
<code>gnutls_rsa_params_cpy</code>,
<code>gnutls_rsa_params_deinit</code>,
<code>gnutls_rsa_params_export_pkcs1</code>,
<code>gnutls_rsa_params_export_raw</code>,
<code>gnutls_rsa_params_generate2</code>,
<code>gnutls_rsa_params_import_pkcs1</code>,
<code>gnutls_rsa_params_import_raw</code>,
<code>gnutls_rsa_params_init</code></td><td width="60%">No replacement; the library does not support the RSA-EXPORT ciphersuites.</td></tr>
<tr><td width="30%"><code>gnutls_pubkey_verify_hash</code>,</td><td width="60%"><a href="#gnutls_005fpubkey_005fverify_005fhash2">gnutls_pubkey_verify_hash2</a>.</td></tr>
<tr><td width="30%"><code>gnutls_pubkey_verify_data</code>,</td><td width="60%"><a href="#gnutls_005fpubkey_005fverify_005fdata2">gnutls_pubkey_verify_data2</a>.</td></tr>
<tr><td width="30%"><code>gnutls_x509_crt_get_verify_algorithm</code>,</td><td width="60%">No replacement; a similar function is <a href="#gnutls_005fx509_005fcrt_005fget_005fsignature_005falgorithm">gnutls_x509_crt_get_signature_algorithm</a>.</td></tr>
<tr><td width="30%"><code>gnutls_pubkey_get_verify_algorithm</code>,</td><td width="60%">No replacement; a similar function is <a href="#gnutls_005fpubkey_005fget_005fpreferred_005fhash_005falgorithm">gnutls_pubkey_get_preferred_hash_algorithm</a>.</td></tr>
<tr><td width="30%"><code>gnutls_certificate_type_set_priority</code>,
<code>gnutls_cipher_set_priority</code>,
<code>gnutls_compression_set_priority</code>,
<code>gnutls_kx_set_priority</code>,
<code>gnutls_mac_set_priority</code>,
<code>gnutls_protocol_set_priority</code></td><td width="60%"><a href="#gnutls_005fpriority_005fset_005fdirect">gnutls_priority_set_direct</a>.</td></tr>
<tr><td width="30%"><code>gnutls_sign_callback_get</code>,
<code>gnutls_sign_callback_set</code></td><td width="60%"><a href="#gnutls_005fprivkey_005fimport_005fext3">gnutls_privkey_import_ext3</a></td></tr>
<tr><td width="30%"><code>gnutls_x509_crt_verify_hash</code></td><td width="60%"><a href="#gnutls_005fpubkey_005fverify_005fhash2">gnutls_pubkey_verify_hash2</a></td></tr>
<tr><td width="30%"><code>gnutls_x509_crt_verify_data</code></td><td width="60%"><a href="#gnutls_005fpubkey_005fverify_005fdata2">gnutls_pubkey_verify_data2</a></td></tr>
<tr><td width="30%"><code>gnutls_privkey_sign_raw_data</code></td><td width="60%"><a href="#gnutls_005fprivkey_005fsign_005fhash">gnutls_privkey_sign_hash</a> with the flag GNUTLS_PRIVKEY_SIGN_FLAG_TLS1_RSA</td></tr>
</table>

<span id="Upgrading-to-3_002e6_002ex-from-3_002e5_002ex"></span><h3 class="heading">Upgrading to 3.6.x from 3.5.x</h3>

<p>GnuTLS 3.6.x is source and binary compatible with GnuTLS 3.5.x releases;
however, there are minor differences, listed below.
</p>
<table>
<thead><tr><th width="30%">Old functionality</th><th width="60%">Replacement</th></tr></thead>
<tr><td width="30%">The priority strings &quot;+COMP&quot; are a no-op</td><td width="60%">TLS compression is no longer available.</td></tr>
<tr><td width="30%">The SSL 3.0 protocol is a no-op</td><td width="60%">SSL 3.0 is no longer compiled in by default. It is a legacy protocol
which is completely eliminated from public internet. As such it was removed
to reduce the attack vector for applications using the library.</td></tr>
<tr><td width="30%">The hash function SHA2-224 is a no-op for TLS1.2</td><td width="60%">TLS 1.3 no longer uses SHA2-224, and it was never a widespread hash
algorithm. As such it was removed for simplicity.</td></tr>
<tr><td width="30%">The SRP key exchange accepted parameters outside the [<a href="#TLSSRP">TLSSRP</a>] spec</td><td width="60%">The SRP key exchange is restricted to [<a href="#TLSSRP">TLSSRP</a>] spec parameters
to protect clients from MitM attacks.</td></tr>
<tr><td width="30%">The compression-related functions are deprecated</td><td width="60%">No longer use <code>gnutls_compression_get</code>,
<code>gnutls_compression_get_name</code>, <code>gnutls_compression_list</code>,
and <code>gnutls_compression_get_id</code>.</td></tr>
<tr><td width="30%"><a href="#gnutls_005fx509_005fcrt_005fsign">gnutls_x509_crt_sign</a>, <a href="#gnutls_005fx509_005fcrl_005fsign">gnutls_x509_crl_sign</a>, <a href="#gnutls_005fx509_005fcrq_005fsign">gnutls_x509_crq_sign</a></td><td width="60%">These signing functions will no longer sign using SHA1, but with a secure hash algorithm.</td></tr>
<tr><td width="30%"><a href="#gnutls_005fcertificate_005fset_005focsp_005fstatus_005frequest_005ffile">gnutls_certificate_set_ocsp_status_request_file</a></td><td width="60%">This function will return an error if the loaded response doesn&rsquo;t match
any of the present certificates. To revert to previous semantics set the <code>GNUTLS_CERTIFICATE_SKIP_OCSP_RESPONSE_CHECK</code>
flag using <a href="#gnutls_005fcertificate_005fset_005fflags">gnutls_certificate_set_flags</a>.</td></tr>
<tr><td width="30%">The callback <a href="#gnutls_005fprivkey_005fimport_005fext3">gnutls_privkey_import_ext3</a> is not flexible enough for new signature algorithms such as RSA-PSS</td><td width="60%">It is replaced with <a href="#gnutls_005fprivkey_005fimport_005fext4">gnutls_privkey_import_ext4</a></td></tr>
<tr><td width="30%">Re-handshake functionality is not applicable under TLS 1.3.</td><td width="60%">It is replaced by separate key update and re-authentication functionality
which can be accessed directly via <a href="#gnutls_005fsession_005fkey_005fupdate">gnutls_session_key_update</a> and <a href="#gnutls_005freauth">gnutls_reauth</a>.</td></tr>
<tr><td width="30%">TLS session identifiers are not shared with the server under TLS 1.3.</td><td width="60%">The TLS session identifiers are persistent across resumption only on
server side and can be obtained as before via <a href="#gnutls_005fsession_005fget_005fid2">gnutls_session_get_id2</a>.</td></tr>
<tr><td width="30%"><a href="#gnutls_005fpkcs11_005fprivkey_005fgenerate3">gnutls_pkcs11_privkey_generate3</a>, <a href="#gnutls_005fpkcs11_005fcopy_005fsecret_005fkey">gnutls_pkcs11_copy_secret_key</a>, <a href="#gnutls_005fpkcs11_005fcopy_005fx509_005fprivkey2">gnutls_pkcs11_copy_x509_privkey2</a></td><td width="60%">These functions no longer create an exportable key by default; they require the flag <code>GNUTLS_PKCS11_OBJ_FLAG_MARK_NOT_SENSITIVE</code> to do so.</td></tr>
<tr><td width="30%"><a href="#gnutls_005fdb_005fset_005fretrieve_005ffunction">gnutls_db_set_retrieve_function</a>, <a href="#gnutls_005fdb_005fset_005fstore_005ffunction">gnutls_db_set_store_function</a>, <a href="#gnutls_005fdb_005fset_005fremove_005ffunction">gnutls_db_set_remove_function</a></td><td width="60%">These functions are no longer relevant under TLS 1.3; resumption under
TLS 1.3 is done via session tickets, c.f. <a href="#gnutls_005fsession_005fticket_005fenable_005fserver">gnutls_session_ticket_enable_server</a>.</td></tr>
<tr><td width="30%"><a href="#gnutls_005fsession_005fget_005fdata2">gnutls_session_get_data2</a>, <a href="#gnutls_005fsession_005fget_005fdata">gnutls_session_get_data</a></td><td width="60%">These functions may introduce a slight delay under TLS 1.3 for few
milliseconds. Check output of <a href="#gnutls_005fsession_005fget_005fflags">gnutls_session_get_flags</a> for GNUTLS_SFLAGS_SESSION_TICKET
before calling this function to avoid delays. To work efficiently under
TLS 1.3 this function requires the application setting
<a href="#gnutls_005ftransport_005fset_005fpull_005ftimeout_005ffunction">gnutls_transport_set_pull_timeout_function</a>.</td></tr>
<tr><td width="30%">SRP and RSA-PSK key exchanges are not supported under TLS 1.3</td><td width="60%">SRP and RSA-PSK key exchanges are not supported in TLS 1.3, so when these key exchanges are present in a priority string, TLS 1.3 is disabled.</td></tr>
<tr><td width="30%">Anonymous key exchange is not supported under TLS 1.3</td><td width="60%">There is no anonymous key exchange supported under TLS 1.3, so if an anonymous key exchange method is set in a priority string, and no certificate credentials are set in the client or server, TLS 1.3 will not be negotiated.</td></tr>
<tr><td width="30%">ECDHE-PSK and DHE-PSK keywords have the same meaning under TLS 1.3</td><td width="60%">In the priority strings, both <code>ECDHEPSK</code> and <code>DHEPSK</code> indicate the intent to support an ephemeral key exchange with the pre-shared key.  The parameters of the key exchange are negotiated with the supported groups specified in the priority string.</td></tr>
<tr><td width="30%">Authentication-only ciphersuites are not supported under TLS 1.3</td><td width="60%">Ciphersuites with the <code>NULL</code> cipher (i.e., authentication-only) are not supported in TLS 1.3, so when they are specified in a priority string, TLS 1.3 is disabled.</td></tr>
<tr><td width="30%">Supplemental data is not supported under TLS 1.3</td><td width="60%">The TLS supplemental data handshake message (RFC 4680) is not supported under TLS 1.3, so if the application calls <a href="#gnutls_005fsupplemental_005fregister">gnutls_supplemental_register</a> or <a href="#gnutls_005fsession_005fsupplemental_005fregister">gnutls_session_supplemental_register</a>, TLS 1.3 is disabled.</td></tr>
<tr><td width="30%">The GNUTLS_X509_NO_WELL_DEFINED_EXPIRATION macro is a no-op</td><td width="60%">The macro was non-functional and because of the nature of the
definition of the no-well-defined date for certificates (a real date),
it will not be fixed or re-introduced.</td></tr>
</table>

<hr>
<span id="Support"></span><div class="header">
<p>
Next: <a href="#Error-codes" accesskey="n" rel="next">Error codes</a>, Previous: <a href="#Upgrading-from-previous-versions" accesskey="p" rel="prev">Upgrading from previous versions</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Support-1"></span><h2 class="appendix">Appendix B Support</h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Getting-help" accesskey="1">Getting help</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Commercial-Support" accesskey="2">Commercial Support</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Bug-Reports" accesskey="3">Bug Reports</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Contributing" accesskey="4">Contributing</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Certification" accesskey="5">Certification</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Getting-help"></span><div class="header">
<p>
Next: <a href="#Commercial-Support" accesskey="n" rel="next">Commercial Support</a>, Up: <a href="#Support" accesskey="u" rel="up">Support</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Getting-Help"></span><h3 class="section">B.1 Getting Help</h3>

<p>A mailing list where users may help each other exists, and you can
reach it by sending e-mail to <a href="mailto:gnutls-help@gnutls.org">gnutls-help@gnutls.org</a>.  Archives
of the mailing list discussions, and an interface to manage
subscriptions, is available through the World Wide Web at
<a href="https://lists.gnutls.org/pipermail/gnutls-help/">https://lists.gnutls.org/pipermail/gnutls-help/</a>.
</p>
<p>A mailing list for developers are also available, see
<a href="https://www.gnutls.org/lists.html">https://www.gnutls.org/lists.html</a>.
Bug reports should be sent to <a href="mailto:bugs@gnutls.org">bugs@gnutls.org</a>, see
<a href="#Bug-Reports">Bug Reports</a>.
</p>
<hr>
<span id="Commercial-Support"></span><div class="header">
<p>
Next: <a href="#Bug-Reports" accesskey="n" rel="next">Bug Reports</a>, Previous: <a href="#Getting-help" accesskey="p" rel="prev">Getting help</a>, Up: <a href="#Support" accesskey="u" rel="up">Support</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Commercial-Support-1"></span><h3 class="section">B.2 Commercial Support</h3>

<p>Commercial support is available for users of GnuTLS. See
<a href="https://www.gnutls.org/commercial.html">https://www.gnutls.org/commercial.html</a> for more information.
</p>

<hr>
<span id="Bug-Reports"></span><div class="header">
<p>
Next: <a href="#Contributing" accesskey="n" rel="next">Contributing</a>, Previous: <a href="#Commercial-Support" accesskey="p" rel="prev">Commercial Support</a>, Up: <a href="#Support" accesskey="u" rel="up">Support</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Bug-Reports-1"></span><h3 class="section">B.3 Bug Reports</h3>
<span id="index-reporting-bugs"></span>

<p>If you think you have found a bug in GnuTLS, please investigate it and
report it.
</p>
<ul>
<li> Please make sure that the bug is really in GnuTLS, and
preferably also check that it hasn&rsquo;t already been fixed in the latest
version.

</li><li> You have to send us a test case that makes it possible for us to
reproduce the bug.

</li><li> You also have to explain what is wrong; if you get a crash, or
if the results printed are not good and in that case, in what way.
Make sure that the bug report includes all information you would need
to fix this kind of bug for someone else.

</li></ul>

<p>Please make an effort to produce a self-contained report, with
something definite that can be tested or debugged.  Vague queries or
piecemeal messages are difficult to act on and don&rsquo;t help the
development effort.
</p>
<p>If your bug report is good, we will do our best to help you to get a
corrected version of the software; if the bug report is poor, we won&rsquo;t
do anything about it (apart from asking you to send better bug
reports).
</p>
<p>If you think something in this manual is unclear, or downright
incorrect, or if the language needs to be improved, please also send a
note.
</p>
<p>Send your bug report to:
</p>
<div align="center">&lsquo;<samp>bugs@gnutls.org</samp>&rsquo;
</div>
<hr>
<span id="Contributing"></span><div class="header">
<p>
Next: <a href="#Certification" accesskey="n" rel="next">Certification</a>, Previous: <a href="#Bug-Reports" accesskey="p" rel="prev">Bug Reports</a>, Up: <a href="#Support" accesskey="u" rel="up">Support</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Contributing-1"></span><h3 class="section">B.4 Contributing</h3>
<span id="index-contributing"></span>
<span id="index-hacking"></span>

<p>If you want to submit a patch for inclusion &ndash; from solving a typo you
discovered, up to adding support for a new feature &ndash; you should
submit it as a bug report, using the process in <a href="#Bug-Reports">Bug Reports</a>.  There are some
things that you can do to increase the chances for it to be included
in the official package.
</p>
<p>Unless your patch is very small (say, under 10 lines) we require that
you assign the copyright of your work to the Free Software Foundation.
This is to protect the freedom of the project.  If you have not
already signed papers, we will send you the necessary information when
you submit your contribution.
</p>
<p>For contributions that doesn&rsquo;t consist of actual programming code, the
only guidelines are common sense.  
For code contributions, a number of style guides will help you:
</p>
<ul>
<li> Coding Style.
Follow the GNU Standards document.

<p>If you normally code using another coding standard, there is no
problem, but you should use &lsquo;<samp>indent</samp>&rsquo; to reformat the code
before submitting your work.
</p>
</li><li> Use the unified diff format &lsquo;<samp>diff -u</samp>&rsquo;.

</li><li> Return errors.
No reason whatsoever should abort the execution of the library.  Even
memory allocation errors, e.g. when malloc return NULL, should work
although result in an error code.

</li><li> Design with thread safety in mind.
Don&rsquo;t use global variables.  Don&rsquo;t even write to per-handle global
variables unless the documented behaviour of the function you write is
to write to the per-handle global variable.

</li><li> Avoid using the C math library.
It causes problems for embedded implementations, and in most
situations it is very easy to avoid using it.

</li><li> Document your functions.
Use comments before each function headers, that, if properly
formatted, are extracted into Texinfo manuals and GTK-DOC web pages.

</li><li> Supply a ChangeLog and NEWS entries, where appropriate.

</li></ul>

<hr>
<span id="Certification"></span><div class="header">
<p>
Previous: <a href="#Contributing" accesskey="p" rel="prev">Contributing</a>, Up: <a href="#Support" accesskey="u" rel="up">Support</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Certification-1"></span><h3 class="section">B.5 Certification</h3>
<span id="index-certification"></span>

<p>There are certifications from national or international bodies which &quot;prove&quot;
to an auditor that the crypto component follows some best practices, such
as unit testing and reliance on well known crypto primitives.
</p>
<p>GnuTLS has support for the FIPS 140-2 certification under Red Hat Enterprise Linux.
See <a href="#FIPS140_002d2-mode">FIPS140-2 mode</a> for more information.
</p>
<hr>
<span id="Error-codes"></span><div class="header">
<p>
Next: <a href="#Supported-ciphersuites" accesskey="n" rel="next">Supported ciphersuites</a>, Previous: <a href="#Support" accesskey="p" rel="prev">Support</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Error-Codes-and-Descriptions"></span><h2 class="appendix">Appendix C Error Codes and Descriptions</h2>
<span id="index-error-codes"></span>

<p>The error codes used throughout the library are described below.  The
return code <code>GNUTLS_E_SUCCESS</code> indicates a successful operation, and
is guaranteed to have the value 0, so you can use it in logical
expressions.
</p>
<table>
<tr><td width="15%">0</td><td width="40%">GNUTLS_E_SUCCESS</td><td width="37%">Success.</td></tr>
<tr><td width="15%">-3</td><td width="40%">GNUTLS_E_UNKNOWN_COMPRESSION_ALGORITHM</td><td width="37%">Could not negotiate a supported compression method.</td></tr>
<tr><td width="15%">-6</td><td width="40%">GNUTLS_E_UNKNOWN_CIPHER_TYPE</td><td width="37%">The cipher type is unsupported.</td></tr>
<tr><td width="15%">-7</td><td width="40%">GNUTLS_E_LARGE_PACKET</td><td width="37%">The transmitted packet is too large (EMSGSIZE).</td></tr>
<tr><td width="15%">-8</td><td width="40%">GNUTLS_E_UNSUPPORTED_VERSION_PACKET</td><td width="37%">A packet with illegal or unsupported version was received.</td></tr>
<tr><td width="15%">-9</td><td width="40%">GNUTLS_E_UNEXPECTED_PACKET_LENGTH</td><td width="37%">Error decoding the received TLS packet.</td></tr>
<tr><td width="15%">-10</td><td width="40%">GNUTLS_E_INVALID_SESSION</td><td width="37%">The specified session has been invalidated for some reason.</td></tr>
<tr><td width="15%">-12</td><td width="40%">GNUTLS_E_FATAL_ALERT_RECEIVED</td><td width="37%">A TLS fatal alert has been received.</td></tr>
<tr><td width="15%">-15</td><td width="40%">GNUTLS_E_UNEXPECTED_PACKET</td><td width="37%">An unexpected TLS packet was received.</td></tr>
<tr><td width="15%">-16</td><td width="40%">GNUTLS_E_WARNING_ALERT_RECEIVED</td><td width="37%">A TLS warning alert has been received.</td></tr>
<tr><td width="15%">-18</td><td width="40%">GNUTLS_E_ERROR_IN_FINISHED_PACKET</td><td width="37%">An error was encountered at the TLS Finished packet calculation.</td></tr>
<tr><td width="15%">-19</td><td width="40%">GNUTLS_E_UNEXPECTED_HANDSHAKE_PACKET</td><td width="37%">An unexpected TLS handshake packet was received.</td></tr>
<tr><td width="15%">-21</td><td width="40%">GNUTLS_E_UNKNOWN_CIPHER_SUITE</td><td width="37%">Could not negotiate a supported cipher suite.</td></tr>
<tr><td width="15%">-22</td><td width="40%">GNUTLS_E_UNWANTED_ALGORITHM</td><td width="37%">An algorithm that is not enabled was negotiated.</td></tr>
<tr><td width="15%">-23</td><td width="40%">GNUTLS_E_MPI_SCAN_FAILED</td><td width="37%">The scanning of a large integer has failed.</td></tr>
<tr><td width="15%">-24</td><td width="40%">GNUTLS_E_DECRYPTION_FAILED</td><td width="37%">Decryption has failed.</td></tr>
<tr><td width="15%">-25</td><td width="40%">GNUTLS_E_MEMORY_ERROR</td><td width="37%">Internal error in memory allocation.</td></tr>
<tr><td width="15%">-26</td><td width="40%">GNUTLS_E_DECOMPRESSION_FAILED</td><td width="37%">Decompression of the TLS record packet has failed.</td></tr>
<tr><td width="15%">-27</td><td width="40%">GNUTLS_E_COMPRESSION_FAILED</td><td width="37%">Compression of the TLS record packet has failed.</td></tr>
<tr><td width="15%">-28</td><td width="40%">GNUTLS_E_AGAIN</td><td width="37%">Resource temporarily unavailable, try again.</td></tr>
<tr><td width="15%">-29</td><td width="40%">GNUTLS_E_EXPIRED</td><td width="37%">The session or certificate has expired.</td></tr>
<tr><td width="15%">-30</td><td width="40%">GNUTLS_E_DB_ERROR</td><td width="37%">Error in Database backend.</td></tr>
<tr><td width="15%">-31</td><td width="40%">GNUTLS_E_SRP_PWD_ERROR</td><td width="37%">Error in password/key file.</td></tr>
<tr><td width="15%">-32</td><td width="40%">GNUTLS_E_INSUFFICIENT_CREDENTIALS</td><td width="37%">Insufficient credentials for that request.</td></tr>
<tr><td width="15%">-33</td><td width="40%">GNUTLS_E_HASH_FAILED</td><td width="37%">Hashing has failed.</td></tr>
<tr><td width="15%">-34</td><td width="40%">GNUTLS_E_BASE64_DECODING_ERROR</td><td width="37%">Base64 decoding error.</td></tr>
<tr><td width="15%">-35</td><td width="40%">GNUTLS_E_MPI_PRINT_FAILED</td><td width="37%">Could not export a large integer.</td></tr>
<tr><td width="15%">-37</td><td width="40%">GNUTLS_E_REHANDSHAKE</td><td width="37%">Rehandshake was requested by the peer.</td></tr>
<tr><td width="15%">-38</td><td width="40%">GNUTLS_E_GOT_APPLICATION_DATA</td><td width="37%">TLS Application data were received, while expecting handshake data.</td></tr>
<tr><td width="15%">-39</td><td width="40%">GNUTLS_E_RECORD_LIMIT_REACHED</td><td width="37%">The upper limit of record packet sequence numbers has been reached. Wow!</td></tr>
<tr><td width="15%">-40</td><td width="40%">GNUTLS_E_ENCRYPTION_FAILED</td><td width="37%">Encryption has failed.</td></tr>
<tr><td width="15%">-43</td><td width="40%">GNUTLS_E_CERTIFICATE_ERROR</td><td width="37%">Error in the certificate.</td></tr>
<tr><td width="15%">-44</td><td width="40%">GNUTLS_E_PK_ENCRYPTION_FAILED</td><td width="37%">Public key encryption has failed.</td></tr>
<tr><td width="15%">-45</td><td width="40%">GNUTLS_E_PK_DECRYPTION_FAILED</td><td width="37%">Public key decryption has failed.</td></tr>
<tr><td width="15%">-46</td><td width="40%">GNUTLS_E_PK_SIGN_FAILED</td><td width="37%">Public key signing has failed.</td></tr>
<tr><td width="15%">-47</td><td width="40%">GNUTLS_E_X509_UNSUPPORTED_CRITICAL_EXTENSION</td><td width="37%">Unsupported critical extension in X.509 certificate.</td></tr>
<tr><td width="15%">-48</td><td width="40%">GNUTLS_E_KEY_USAGE_VIOLATION</td><td width="37%">Key usage violation in certificate has been detected.</td></tr>
<tr><td width="15%">-49</td><td width="40%">GNUTLS_E_NO_CERTIFICATE_FOUND</td><td width="37%">No certificate was found.</td></tr>
<tr><td width="15%">-50</td><td width="40%">GNUTLS_E_INVALID_REQUEST</td><td width="37%">The request is invalid.</td></tr>
<tr><td width="15%">-51</td><td width="40%">GNUTLS_E_SHORT_MEMORY_BUFFER</td><td width="37%">The given memory buffer is too short to hold parameters.</td></tr>
<tr><td width="15%">-52</td><td width="40%">GNUTLS_E_INTERRUPTED</td><td width="37%">Function was interrupted.</td></tr>
<tr><td width="15%">-53</td><td width="40%">GNUTLS_E_PUSH_ERROR</td><td width="37%">Error in the push function.</td></tr>
<tr><td width="15%">-54</td><td width="40%">GNUTLS_E_PULL_ERROR</td><td width="37%">Error in the pull function.</td></tr>
<tr><td width="15%">-55</td><td width="40%">GNUTLS_E_RECEIVED_ILLEGAL_PARAMETER</td><td width="37%">An illegal parameter has been received.</td></tr>
<tr><td width="15%">-56</td><td width="40%">GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</td><td width="37%">The requested data were not available.</td></tr>
<tr><td width="15%">-57</td><td width="40%">GNUTLS_E_PKCS1_WRONG_PAD</td><td width="37%">Wrong padding in PKCS1 packet.</td></tr>
<tr><td width="15%">-58</td><td width="40%">GNUTLS_E_RECEIVED_ILLEGAL_EXTENSION</td><td width="37%">An illegal TLS extension was received.</td></tr>
<tr><td width="15%">-59</td><td width="40%">GNUTLS_E_INTERNAL_ERROR</td><td width="37%">GnuTLS internal error.</td></tr>
<tr><td width="15%">-60</td><td width="40%">GNUTLS_E_CERTIFICATE_KEY_MISMATCH</td><td width="37%">The certificate and the given key do not match.</td></tr>
<tr><td width="15%">-61</td><td width="40%">GNUTLS_E_UNSUPPORTED_CERTIFICATE_TYPE</td><td width="37%">The certificate type is not supported.</td></tr>
<tr><td width="15%">-62</td><td width="40%">GNUTLS_E_X509_UNKNOWN_SAN</td><td width="37%">Unknown Subject Alternative name in X.509 certificate.</td></tr>
<tr><td width="15%">-63</td><td width="40%">GNUTLS_E_DH_PRIME_UNACCEPTABLE</td><td width="37%">The Diffie-Hellman prime sent by the server is not acceptable (not long enough).</td></tr>
<tr><td width="15%">-64</td><td width="40%">GNUTLS_E_FILE_ERROR</td><td width="37%">Error while reading file.</td></tr>
<tr><td width="15%">-67</td><td width="40%">GNUTLS_E_ASN1_ELEMENT_NOT_FOUND</td><td width="37%">ASN1 parser: Element was not found.</td></tr>
<tr><td width="15%">-68</td><td width="40%">GNUTLS_E_ASN1_IDENTIFIER_NOT_FOUND</td><td width="37%">ASN1 parser: Identifier was not found</td></tr>
<tr><td width="15%">-69</td><td width="40%">GNUTLS_E_ASN1_DER_ERROR</td><td width="37%">ASN1 parser: Error in DER parsing.</td></tr>
<tr><td width="15%">-70</td><td width="40%">GNUTLS_E_ASN1_VALUE_NOT_FOUND</td><td width="37%">ASN1 parser: Value was not found.</td></tr>
<tr><td width="15%">-71</td><td width="40%">GNUTLS_E_ASN1_GENERIC_ERROR</td><td width="37%">ASN1 parser: Generic parsing error.</td></tr>
<tr><td width="15%">-72</td><td width="40%">GNUTLS_E_ASN1_VALUE_NOT_VALID</td><td width="37%">ASN1 parser: Value is not valid.</td></tr>
<tr><td width="15%">-73</td><td width="40%">GNUTLS_E_ASN1_TAG_ERROR</td><td width="37%">ASN1 parser: Error in TAG.</td></tr>
<tr><td width="15%">-74</td><td width="40%">GNUTLS_E_ASN1_TAG_IMPLICIT</td><td width="37%">ASN1 parser: error in implicit tag</td></tr>
<tr><td width="15%">-75</td><td width="40%">GNUTLS_E_ASN1_TYPE_ANY_ERROR</td><td width="37%">ASN1 parser: Error in type &rsquo;ANY&rsquo;.</td></tr>
<tr><td width="15%">-76</td><td width="40%">GNUTLS_E_ASN1_SYNTAX_ERROR</td><td width="37%">ASN1 parser: Syntax error.</td></tr>
<tr><td width="15%">-77</td><td width="40%">GNUTLS_E_ASN1_DER_OVERFLOW</td><td width="37%">ASN1 parser: Overflow in DER parsing.</td></tr>
<tr><td width="15%">-78</td><td width="40%">GNUTLS_E_TOO_MANY_EMPTY_PACKETS</td><td width="37%">Too many empty record packets have been received.</td></tr>
<tr><td width="15%">-79</td><td width="40%">GNUTLS_E_OPENPGP_UID_REVOKED</td><td width="37%">The OpenPGP User ID is revoked.</td></tr>
<tr><td width="15%">-80</td><td width="40%">GNUTLS_E_UNKNOWN_PK_ALGORITHM</td><td width="37%">An unknown public key algorithm was encountered.</td></tr>
<tr><td width="15%">-81</td><td width="40%">GNUTLS_E_TOO_MANY_HANDSHAKE_PACKETS</td><td width="37%">Too many handshake packets have been received.</td></tr>
<tr><td width="15%">-82</td><td width="40%">GNUTLS_E_RECEIVED_DISALLOWED_NAME</td><td width="37%">A disallowed SNI server name has been received.</td></tr>
<tr><td width="15%">-84</td><td width="40%">GNUTLS_E_NO_TEMPORARY_RSA_PARAMS</td><td width="37%">No temporary RSA parameters were found.</td></tr>
<tr><td width="15%">-86</td><td width="40%">GNUTLS_E_NO_COMPRESSION_ALGORITHMS</td><td width="37%">No supported compression algorithms have been found.</td></tr>
<tr><td width="15%">-87</td><td width="40%">GNUTLS_E_NO_CIPHER_SUITES</td><td width="37%">No supported cipher suites have been found.</td></tr>
<tr><td width="15%">-88</td><td width="40%">GNUTLS_E_OPENPGP_GETKEY_FAILED</td><td width="37%">Could not get OpenPGP key.</td></tr>
<tr><td width="15%">-89</td><td width="40%">GNUTLS_E_PK_SIG_VERIFY_FAILED</td><td width="37%">Public key signature verification has failed.</td></tr>
<tr><td width="15%">-90</td><td width="40%">GNUTLS_E_ILLEGAL_SRP_USERNAME</td><td width="37%">The SRP username supplied is illegal.</td></tr>
<tr><td width="15%">-91</td><td width="40%">GNUTLS_E_SRP_PWD_PARSING_ERROR</td><td width="37%">Parsing error in password/key file.</td></tr>
<tr><td width="15%">-93</td><td width="40%">GNUTLS_E_NO_TEMPORARY_DH_PARAMS</td><td width="37%">No temporary DH parameters were found.</td></tr>
<tr><td width="15%">-94</td><td width="40%">GNUTLS_E_OPENPGP_FINGERPRINT_UNSUPPORTED</td><td width="37%">The OpenPGP fingerprint is not supported.</td></tr>
<tr><td width="15%">-95</td><td width="40%">GNUTLS_E_X509_UNSUPPORTED_ATTRIBUTE</td><td width="37%">The certificate has unsupported attributes.</td></tr>
<tr><td width="15%">-96</td><td width="40%">GNUTLS_E_UNKNOWN_HASH_ALGORITHM</td><td width="37%">The hash algorithm is unknown.</td></tr>
<tr><td width="15%">-97</td><td width="40%">GNUTLS_E_UNKNOWN_PKCS_CONTENT_TYPE</td><td width="37%">The PKCS structure&rsquo;s content type is unknown.</td></tr>
<tr><td width="15%">-98</td><td width="40%">GNUTLS_E_UNKNOWN_PKCS_BAG_TYPE</td><td width="37%">The PKCS structure&rsquo;s bag type is unknown.</td></tr>
<tr><td width="15%">-99</td><td width="40%">GNUTLS_E_INVALID_PASSWORD</td><td width="37%">The given password contains invalid characters.</td></tr>
<tr><td width="15%">-100</td><td width="40%">GNUTLS_E_MAC_VERIFY_FAILED</td><td width="37%">The Message Authentication Code verification failed.</td></tr>
<tr><td width="15%">-101</td><td width="40%">GNUTLS_E_CONSTRAINT_ERROR</td><td width="37%">Some constraint limits were reached.</td></tr>
<tr><td width="15%">-104</td><td width="40%">GNUTLS_E_IA_VERIFY_FAILED</td><td width="37%">Verifying TLS/IA phase checksum failed</td></tr>
<tr><td width="15%">-105</td><td width="40%">GNUTLS_E_UNKNOWN_ALGORITHM</td><td width="37%">The specified algorithm or protocol is unknown.</td></tr>
<tr><td width="15%">-106</td><td width="40%">GNUTLS_E_UNSUPPORTED_SIGNATURE_ALGORITHM</td><td width="37%">The signature algorithm is not supported.</td></tr>
<tr><td width="15%">-107</td><td width="40%">GNUTLS_E_SAFE_RENEGOTIATION_FAILED</td><td width="37%">Safe renegotiation failed.</td></tr>
<tr><td width="15%">-108</td><td width="40%">GNUTLS_E_UNSAFE_RENEGOTIATION_DENIED</td><td width="37%">Unsafe renegotiation denied.</td></tr>
<tr><td width="15%">-109</td><td width="40%">GNUTLS_E_UNKNOWN_SRP_USERNAME</td><td width="37%">The username supplied is unknown.</td></tr>
<tr><td width="15%">-110</td><td width="40%">GNUTLS_E_PREMATURE_TERMINATION</td><td width="37%">The TLS connection was non-properly terminated.</td></tr>
<tr><td width="15%">-111</td><td width="40%">GNUTLS_E_MALFORMED_CIDR</td><td width="37%">CIDR name constraint is malformed in size or structure.</td></tr>
<tr><td width="15%">-112</td><td width="40%">GNUTLS_E_CERTIFICATE_REQUIRED</td><td width="37%">Certificate is required.</td></tr>
<tr><td width="15%">-201</td><td width="40%">GNUTLS_E_BASE64_ENCODING_ERROR</td><td width="37%">Base64 encoding error.</td></tr>
<tr><td width="15%">-202</td><td width="40%">GNUTLS_E_INCOMPATIBLE_GCRYPT_LIBRARY</td><td width="37%">The crypto library version is too old.</td></tr>
<tr><td width="15%">-203</td><td width="40%">GNUTLS_E_INCOMPATIBLE_LIBTASN1_LIBRARY</td><td width="37%">The tasn1 library version is too old.</td></tr>
<tr><td width="15%">-204</td><td width="40%">GNUTLS_E_OPENPGP_KEYRING_ERROR</td><td width="37%">Error loading the keyring.</td></tr>
<tr><td width="15%">-205</td><td width="40%">GNUTLS_E_X509_UNSUPPORTED_OID</td><td width="37%">The OID is not supported.</td></tr>
<tr><td width="15%">-206</td><td width="40%">GNUTLS_E_RANDOM_FAILED</td><td width="37%">Failed to acquire random data.</td></tr>
<tr><td width="15%">-207</td><td width="40%">GNUTLS_E_BASE64_UNEXPECTED_HEADER_ERROR</td><td width="37%">Base64 unexpected header error.</td></tr>
<tr><td width="15%">-208</td><td width="40%">GNUTLS_E_OPENPGP_SUBKEY_ERROR</td><td width="37%">Could not find OpenPGP subkey.</td></tr>
<tr><td width="15%">-209</td><td width="40%">GNUTLS_E_CRYPTO_ALREADY_REGISTERED</td><td width="37%">There is already a crypto algorithm with lower priority.</td></tr>
<tr><td width="15%">-210</td><td width="40%">GNUTLS_E_HANDSHAKE_TOO_LARGE</td><td width="37%">The handshake data size is too large.</td></tr>
<tr><td width="15%">-211</td><td width="40%">GNUTLS_E_CRYPTODEV_IOCTL_ERROR</td><td width="37%">Error interfacing with /dev/crypto</td></tr>
<tr><td width="15%">-212</td><td width="40%">GNUTLS_E_CRYPTODEV_DEVICE_ERROR</td><td width="37%">Error opening /dev/crypto</td></tr>
<tr><td width="15%">-213</td><td width="40%">GNUTLS_E_CHANNEL_BINDING_NOT_AVAILABLE</td><td width="37%">Channel binding data not available</td></tr>
<tr><td width="15%">-214</td><td width="40%">GNUTLS_E_BAD_COOKIE</td><td width="37%">The cookie was bad.</td></tr>
<tr><td width="15%">-215</td><td width="40%">GNUTLS_E_OPENPGP_PREFERRED_KEY_ERROR</td><td width="37%">The OpenPGP key has not a preferred key set.</td></tr>
<tr><td width="15%">-216</td><td width="40%">GNUTLS_E_INCOMPAT_DSA_KEY_WITH_TLS_PROTOCOL</td><td width="37%">The given DSA key is incompatible with the selected TLS protocol.</td></tr>
<tr><td width="15%">-217</td><td width="40%">GNUTLS_E_INSUFFICIENT_SECURITY</td><td width="37%">One of the involved algorithms has insufficient security level.</td></tr>
<tr><td width="15%">-292</td><td width="40%">GNUTLS_E_HEARTBEAT_PONG_RECEIVED</td><td width="37%">A heartbeat pong message was received.</td></tr>
<tr><td width="15%">-293</td><td width="40%">GNUTLS_E_HEARTBEAT_PING_RECEIVED</td><td width="37%">A heartbeat ping message was received.</td></tr>
<tr><td width="15%">-294</td><td width="40%">GNUTLS_E_UNRECOGNIZED_NAME</td><td width="37%">The SNI host name not recognised.</td></tr>
<tr><td width="15%">-300</td><td width="40%">GNUTLS_E_PKCS11_ERROR</td><td width="37%">PKCS #11 error.</td></tr>
<tr><td width="15%">-301</td><td width="40%">GNUTLS_E_PKCS11_LOAD_ERROR</td><td width="37%">PKCS #11 initialization error.</td></tr>
<tr><td width="15%">-302</td><td width="40%">GNUTLS_E_PARSING_ERROR</td><td width="37%">Error in parsing.</td></tr>
<tr><td width="15%">-303</td><td width="40%">GNUTLS_E_PKCS11_PIN_ERROR</td><td width="37%">Error in provided PIN.</td></tr>
<tr><td width="15%">-305</td><td width="40%">GNUTLS_E_PKCS11_SLOT_ERROR</td><td width="37%">PKCS #11 error in slot</td></tr>
<tr><td width="15%">-306</td><td width="40%">GNUTLS_E_LOCKING_ERROR</td><td width="37%">Thread locking error</td></tr>
<tr><td width="15%">-307</td><td width="40%">GNUTLS_E_PKCS11_ATTRIBUTE_ERROR</td><td width="37%">PKCS #11 error in attribute</td></tr>
<tr><td width="15%">-308</td><td width="40%">GNUTLS_E_PKCS11_DEVICE_ERROR</td><td width="37%">PKCS #11 error in device</td></tr>
<tr><td width="15%">-309</td><td width="40%">GNUTLS_E_PKCS11_DATA_ERROR</td><td width="37%">PKCS #11 error in data</td></tr>
<tr><td width="15%">-310</td><td width="40%">GNUTLS_E_PKCS11_UNSUPPORTED_FEATURE_ERROR</td><td width="37%">PKCS #11 unsupported feature</td></tr>
<tr><td width="15%">-311</td><td width="40%">GNUTLS_E_PKCS11_KEY_ERROR</td><td width="37%">PKCS #11 error in key</td></tr>
<tr><td width="15%">-312</td><td width="40%">GNUTLS_E_PKCS11_PIN_EXPIRED</td><td width="37%">PKCS #11 PIN expired</td></tr>
<tr><td width="15%">-313</td><td width="40%">GNUTLS_E_PKCS11_PIN_LOCKED</td><td width="37%">PKCS #11 PIN locked</td></tr>
<tr><td width="15%">-314</td><td width="40%">GNUTLS_E_PKCS11_SESSION_ERROR</td><td width="37%">PKCS #11 error in session</td></tr>
<tr><td width="15%">-315</td><td width="40%">GNUTLS_E_PKCS11_SIGNATURE_ERROR</td><td width="37%">PKCS #11 error in signature</td></tr>
<tr><td width="15%">-316</td><td width="40%">GNUTLS_E_PKCS11_TOKEN_ERROR</td><td width="37%">PKCS #11 error in token</td></tr>
<tr><td width="15%">-317</td><td width="40%">GNUTLS_E_PKCS11_USER_ERROR</td><td width="37%">PKCS #11 user error</td></tr>
<tr><td width="15%">-318</td><td width="40%">GNUTLS_E_CRYPTO_INIT_FAILED</td><td width="37%">The initialization of crypto backend has failed.</td></tr>
<tr><td width="15%">-319</td><td width="40%">GNUTLS_E_TIMEDOUT</td><td width="37%">The operation timed out</td></tr>
<tr><td width="15%">-320</td><td width="40%">GNUTLS_E_USER_ERROR</td><td width="37%">The operation was cancelled due to user error</td></tr>
<tr><td width="15%">-321</td><td width="40%">GNUTLS_E_ECC_NO_SUPPORTED_CURVES</td><td width="37%">No supported ECC curves were found</td></tr>
<tr><td width="15%">-322</td><td width="40%">GNUTLS_E_ECC_UNSUPPORTED_CURVE</td><td width="37%">The curve is unsupported</td></tr>
<tr><td width="15%">-323</td><td width="40%">GNUTLS_E_PKCS11_REQUESTED_OBJECT_NOT_AVAILBLE</td><td width="37%">The requested PKCS #11 object is not available</td></tr>
<tr><td width="15%">-324</td><td width="40%">GNUTLS_E_CERTIFICATE_LIST_UNSORTED</td><td width="37%">The provided X.509 certificate list is not sorted (in subject to issuer order)</td></tr>
<tr><td width="15%">-325</td><td width="40%">GNUTLS_E_ILLEGAL_PARAMETER</td><td width="37%">An illegal parameter was found.</td></tr>
<tr><td width="15%">-326</td><td width="40%">GNUTLS_E_NO_PRIORITIES_WERE_SET</td><td width="37%">No or insufficient priorities were set.</td></tr>
<tr><td width="15%">-327</td><td width="40%">GNUTLS_E_X509_UNSUPPORTED_EXTENSION</td><td width="37%">Unsupported extension in X.509 certificate.</td></tr>
<tr><td width="15%">-328</td><td width="40%">GNUTLS_E_SESSION_EOF</td><td width="37%">Peer has terminated the connection</td></tr>
<tr><td width="15%">-329</td><td width="40%">GNUTLS_E_TPM_ERROR</td><td width="37%">TPM error.</td></tr>
<tr><td width="15%">-330</td><td width="40%">GNUTLS_E_TPM_KEY_PASSWORD_ERROR</td><td width="37%">Error in provided password for key to be loaded in TPM.</td></tr>
<tr><td width="15%">-331</td><td width="40%">GNUTLS_E_TPM_SRK_PASSWORD_ERROR</td><td width="37%">Error in provided SRK password for TPM.</td></tr>
<tr><td width="15%">-332</td><td width="40%">GNUTLS_E_TPM_SESSION_ERROR</td><td width="37%">Cannot initialize a session with the TPM.</td></tr>
<tr><td width="15%">-333</td><td width="40%">GNUTLS_E_TPM_KEY_NOT_FOUND</td><td width="37%">TPM key was not found in persistent storage.</td></tr>
<tr><td width="15%">-334</td><td width="40%">GNUTLS_E_TPM_UNINITIALIZED</td><td width="37%">TPM is not initialized.</td></tr>
<tr><td width="15%">-335</td><td width="40%">GNUTLS_E_TPM_NO_LIB</td><td width="37%">The TPM library (trousers) cannot be found.</td></tr>
<tr><td width="15%">-340</td><td width="40%">GNUTLS_E_NO_CERTIFICATE_STATUS</td><td width="37%">There is no certificate status (OCSP).</td></tr>
<tr><td width="15%">-341</td><td width="40%">GNUTLS_E_OCSP_RESPONSE_ERROR</td><td width="37%">The OCSP response is invalid</td></tr>
<tr><td width="15%">-342</td><td width="40%">GNUTLS_E_RANDOM_DEVICE_ERROR</td><td width="37%">Error in the system&rsquo;s randomness device.</td></tr>
<tr><td width="15%">-343</td><td width="40%">GNUTLS_E_AUTH_ERROR</td><td width="37%">Could not authenticate peer.</td></tr>
<tr><td width="15%">-344</td><td width="40%">GNUTLS_E_NO_APPLICATION_PROTOCOL</td><td width="37%">No common application protocol could be negotiated.</td></tr>
<tr><td width="15%">-345</td><td width="40%">GNUTLS_E_SOCKETS_INIT_ERROR</td><td width="37%">Error in sockets initialization.</td></tr>
<tr><td width="15%">-346</td><td width="40%">GNUTLS_E_KEY_IMPORT_FAILED</td><td width="37%">Failed to import the key into store.</td></tr>
<tr><td width="15%">-347</td><td width="40%">GNUTLS_E_INAPPROPRIATE_FALLBACK</td><td width="37%">A connection with inappropriate fallback was attempted.</td></tr>
<tr><td width="15%">-348</td><td width="40%">GNUTLS_E_CERTIFICATE_VERIFICATION_ERROR</td><td width="37%">Error in the certificate verification.</td></tr>
<tr><td width="15%">-349</td><td width="40%">GNUTLS_E_PRIVKEY_VERIFICATION_ERROR</td><td width="37%">Error in the private key verification; seed doesn&rsquo;t match.</td></tr>
<tr><td width="15%">-350</td><td width="40%">GNUTLS_E_UNEXPECTED_EXTENSIONS_LENGTH</td><td width="37%">Invalid TLS extensions length field.</td></tr>
<tr><td width="15%">-351</td><td width="40%">GNUTLS_E_ASN1_EMBEDDED_NULL_IN_STRING</td><td width="37%">The provided string has an embedded null.</td></tr>
<tr><td width="15%">-400</td><td width="40%">GNUTLS_E_SELF_TEST_ERROR</td><td width="37%">Error while performing self checks.</td></tr>
<tr><td width="15%">-401</td><td width="40%">GNUTLS_E_NO_SELF_TEST</td><td width="37%">There is no self test for this algorithm.</td></tr>
<tr><td width="15%">-402</td><td width="40%">GNUTLS_E_LIB_IN_ERROR_STATE</td><td width="37%">An error has been detected in the library and cannot continue operations.</td></tr>
<tr><td width="15%">-403</td><td width="40%">GNUTLS_E_PK_GENERATION_ERROR</td><td width="37%">Error in public key generation.</td></tr>
<tr><td width="15%">-404</td><td width="40%">GNUTLS_E_IDNA_ERROR</td><td width="37%">There was an issue converting to or from UTF8.</td></tr>
<tr><td width="15%">-406</td><td width="40%">GNUTLS_E_SESSION_USER_ID_CHANGED</td><td width="37%">Peer&rsquo;s certificate or username has changed during a rehandshake.</td></tr>
<tr><td width="15%">-407</td><td width="40%">GNUTLS_E_HANDSHAKE_DURING_FALSE_START</td><td width="37%">Attempted handshake during false start.</td></tr>
<tr><td width="15%">-408</td><td width="40%">GNUTLS_E_UNAVAILABLE_DURING_HANDSHAKE</td><td width="37%">Cannot perform this action while handshake is in progress.</td></tr>
<tr><td width="15%">-409</td><td width="40%">GNUTLS_E_PK_INVALID_PUBKEY</td><td width="37%">The public key is invalid.</td></tr>
<tr><td width="15%">-410</td><td width="40%">GNUTLS_E_PK_INVALID_PRIVKEY</td><td width="37%">The private key is invalid.</td></tr>
<tr><td width="15%">-411</td><td width="40%">GNUTLS_E_NOT_YET_ACTIVATED</td><td width="37%">The certificate is not yet activated.</td></tr>
<tr><td width="15%">-412</td><td width="40%">GNUTLS_E_INVALID_UTF8_STRING</td><td width="37%">The given string contains invalid UTF-8 characters.</td></tr>
<tr><td width="15%">-413</td><td width="40%">GNUTLS_E_NO_EMBEDDED_DATA</td><td width="37%">There are no embedded data in the structure.</td></tr>
<tr><td width="15%">-414</td><td width="40%">GNUTLS_E_INVALID_UTF8_EMAIL</td><td width="37%">The given email string contains non-ASCII characters before &rsquo;.'</td></tr>
<tr><td width="15%">-415</td><td width="40%">GNUTLS_E_INVALID_PASSWORD_STRING</td><td width="37%">The given password contains invalid characters.</td></tr>
<tr><td width="15%">-416</td><td width="40%">GNUTLS_E_CERTIFICATE_TIME_ERROR</td><td width="37%">Error in the time fields of certificate.</td></tr>
<tr><td width="15%">-417</td><td width="40%">GNUTLS_E_RECORD_OVERFLOW</td><td width="37%">A TLS record packet with invalid length was received.</td></tr>
<tr><td width="15%">-418</td><td width="40%">GNUTLS_E_ASN1_TIME_ERROR</td><td width="37%">The DER time encoding is invalid.</td></tr>
<tr><td width="15%">-419</td><td width="40%">GNUTLS_E_INCOMPATIBLE_SIG_WITH_KEY</td><td width="37%">The signature is incompatible with the public key.</td></tr>
<tr><td width="15%">-420</td><td width="40%">GNUTLS_E_PK_INVALID_PUBKEY_PARAMS</td><td width="37%">The public key parameters are invalid.</td></tr>
<tr><td width="15%">-421</td><td width="40%">GNUTLS_E_PK_NO_VALIDATION_PARAMS</td><td width="37%">There are no validation parameters present.</td></tr>
<tr><td width="15%">-422</td><td width="40%">GNUTLS_E_OCSP_MISMATCH_WITH_CERTS</td><td width="37%">The OCSP response provided doesn&rsquo;t match the available certificates</td></tr>
<tr><td width="15%">-423</td><td width="40%">GNUTLS_E_NO_COMMON_KEY_SHARE</td><td width="37%">No common key share with peer.</td></tr>
<tr><td width="15%">-424</td><td width="40%">GNUTLS_E_REAUTH_REQUEST</td><td width="37%">Re-authentication was requested by the peer.</td></tr>
<tr><td width="15%">-425</td><td width="40%">GNUTLS_E_TOO_MANY_MATCHES</td><td width="37%">More than a single object matches the criteria.</td></tr>
<tr><td width="15%">-426</td><td width="40%">GNUTLS_E_CRL_VERIFICATION_ERROR</td><td width="37%">Error in the CRL verification.</td></tr>
<tr><td width="15%">-427</td><td width="40%">GNUTLS_E_MISSING_EXTENSION</td><td width="37%">An required TLS extension was received.</td></tr>
<tr><td width="15%">-428</td><td width="40%">GNUTLS_E_DB_ENTRY_EXISTS</td><td width="37%">The Database entry already exists.</td></tr>
<tr><td width="15%">-429</td><td width="40%">GNUTLS_E_EARLY_DATA_REJECTED</td><td width="37%">The early data were rejected.</td></tr>
</table>


<hr>
<span id="Supported-ciphersuites"></span><div class="header">
<p>
Next: <a href="#API-reference" accesskey="n" rel="next">API reference</a>, Previous: <a href="#Error-codes" accesskey="p" rel="prev">Error codes</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Supported-Ciphersuites"></span><h2 class="appendix">Appendix D Supported Ciphersuites</h2>
<span id="ciphersuites"></span><span id="index-ciphersuites"></span>

<span id="Ciphersuites"></span><h3 class="heading">Ciphersuites</h3>
<table>
<thead><tr><th width="60%">Ciphersuite name</th><th width="20%">TLS ID</th><th width="20%">Since</th></tr></thead>
<tr><td width="60%">TLS_AES_128_GCM_SHA256</td><td width="20%">0x13 0x01</td><td width="20%">TLS1.3</td></tr>
<tr><td width="60%">TLS_AES_256_GCM_SHA384</td><td width="20%">0x13 0x02</td><td width="20%">TLS1.3</td></tr>
<tr><td width="60%">TLS_CHACHA20_POLY1305_SHA256</td><td width="20%">0x13 0x03</td><td width="20%">TLS1.3</td></tr>
<tr><td width="60%">TLS_AES_128_CCM_SHA256</td><td width="20%">0x13 0x04</td><td width="20%">TLS1.3</td></tr>
<tr><td width="60%">TLS_AES_128_CCM_8_SHA256</td><td width="20%">0x13 0x05</td><td width="20%">TLS1.3</td></tr>
<tr><td width="60%">TLS_RSA_NULL_MD5</td><td width="20%">0x00 0x01</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_RSA_NULL_SHA1</td><td width="20%">0x00 0x02</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_RSA_NULL_SHA256</td><td width="20%">0x00 0x3B</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_RSA_ARCFOUR_128_SHA1</td><td width="20%">0x00 0x05</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_RSA_ARCFOUR_128_MD5</td><td width="20%">0x00 0x04</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_RSA_3DES_EDE_CBC_SHA1</td><td width="20%">0x00 0x0A</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_RSA_AES_128_CBC_SHA1</td><td width="20%">0x00 0x2F</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_RSA_AES_256_CBC_SHA1</td><td width="20%">0x00 0x35</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_RSA_CAMELLIA_128_CBC_SHA256</td><td width="20%">0x00 0xBA</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_RSA_CAMELLIA_256_CBC_SHA256</td><td width="20%">0x00 0xC0</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_RSA_CAMELLIA_128_CBC_SHA1</td><td width="20%">0x00 0x41</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_RSA_CAMELLIA_256_CBC_SHA1</td><td width="20%">0x00 0x84</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_RSA_AES_128_CBC_SHA256</td><td width="20%">0x00 0x3C</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_RSA_AES_256_CBC_SHA256</td><td width="20%">0x00 0x3D</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_RSA_AES_128_GCM_SHA256</td><td width="20%">0x00 0x9C</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_RSA_AES_256_GCM_SHA384</td><td width="20%">0x00 0x9D</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_RSA_CAMELLIA_128_GCM_SHA256</td><td width="20%">0xC0 0x7A</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_RSA_CAMELLIA_256_GCM_SHA384</td><td width="20%">0xC0 0x7B</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_RSA_AES_128_CCM</td><td width="20%">0xC0 0x9C</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_RSA_AES_256_CCM</td><td width="20%">0xC0 0x9D</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_RSA_AES_128_CCM_8</td><td width="20%">0xC0 0xA0</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_RSA_AES_256_CCM_8</td><td width="20%">0xC0 0xA1</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_DHE_DSS_ARCFOUR_128_SHA1</td><td width="20%">0x00 0x66</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_DHE_DSS_3DES_EDE_CBC_SHA1</td><td width="20%">0x00 0x13</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_DHE_DSS_AES_128_CBC_SHA1</td><td width="20%">0x00 0x32</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_DHE_DSS_AES_256_CBC_SHA1</td><td width="20%">0x00 0x38</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_DHE_DSS_CAMELLIA_128_CBC_SHA256</td><td width="20%">0x00 0xBD</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_DHE_DSS_CAMELLIA_256_CBC_SHA256</td><td width="20%">0x00 0xC3</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_DHE_DSS_CAMELLIA_128_CBC_SHA1</td><td width="20%">0x00 0x44</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_DHE_DSS_CAMELLIA_256_CBC_SHA1</td><td width="20%">0x00 0x87</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_DHE_DSS_AES_128_CBC_SHA256</td><td width="20%">0x00 0x40</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_DHE_DSS_AES_256_CBC_SHA256</td><td width="20%">0x00 0x6A</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_DHE_DSS_AES_128_GCM_SHA256</td><td width="20%">0x00 0xA2</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_DHE_DSS_AES_256_GCM_SHA384</td><td width="20%">0x00 0xA3</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_DHE_DSS_CAMELLIA_128_GCM_SHA256</td><td width="20%">0xC0 0x80</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_DHE_DSS_CAMELLIA_256_GCM_SHA384</td><td width="20%">0xC0 0x81</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_DHE_RSA_3DES_EDE_CBC_SHA1</td><td width="20%">0x00 0x16</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_DHE_RSA_AES_128_CBC_SHA1</td><td width="20%">0x00 0x33</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_DHE_RSA_AES_256_CBC_SHA1</td><td width="20%">0x00 0x39</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_DHE_RSA_CAMELLIA_128_CBC_SHA256</td><td width="20%">0x00 0xBE</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_DHE_RSA_CAMELLIA_256_CBC_SHA256</td><td width="20%">0x00 0xC4</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_DHE_RSA_CAMELLIA_128_CBC_SHA1</td><td width="20%">0x00 0x45</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_DHE_RSA_CAMELLIA_256_CBC_SHA1</td><td width="20%">0x00 0x88</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_DHE_RSA_AES_128_CBC_SHA256</td><td width="20%">0x00 0x67</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_DHE_RSA_AES_256_CBC_SHA256</td><td width="20%">0x00 0x6B</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_DHE_RSA_AES_128_GCM_SHA256</td><td width="20%">0x00 0x9E</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_DHE_RSA_AES_256_GCM_SHA384</td><td width="20%">0x00 0x9F</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_DHE_RSA_CAMELLIA_128_GCM_SHA256</td><td width="20%">0xC0 0x7C</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_DHE_RSA_CAMELLIA_256_GCM_SHA384</td><td width="20%">0xC0 0x7D</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_DHE_RSA_CHACHA20_POLY1305</td><td width="20%">0xCC 0xAA</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_DHE_RSA_AES_128_CCM</td><td width="20%">0xC0 0x9E</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_DHE_RSA_AES_256_CCM</td><td width="20%">0xC0 0x9F</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_DHE_RSA_AES_128_CCM_8</td><td width="20%">0xC0 0xA2</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_DHE_RSA_AES_256_CCM_8</td><td width="20%">0xC0 0xA3</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_ECDHE_RSA_NULL_SHA1</td><td width="20%">0xC0 0x10</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_ECDHE_RSA_3DES_EDE_CBC_SHA1</td><td width="20%">0xC0 0x12</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_ECDHE_RSA_AES_128_CBC_SHA1</td><td width="20%">0xC0 0x13</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_ECDHE_RSA_AES_256_CBC_SHA1</td><td width="20%">0xC0 0x14</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_ECDHE_RSA_AES_256_CBC_SHA384</td><td width="20%">0xC0 0x28</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_ECDHE_RSA_ARCFOUR_128_SHA1</td><td width="20%">0xC0 0x11</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_ECDHE_RSA_CAMELLIA_128_CBC_SHA256</td><td width="20%">0xC0 0x76</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_ECDHE_RSA_CAMELLIA_256_CBC_SHA384</td><td width="20%">0xC0 0x77</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_ECDHE_ECDSA_NULL_SHA1</td><td width="20%">0xC0 0x06</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_ECDHE_ECDSA_3DES_EDE_CBC_SHA1</td><td width="20%">0xC0 0x08</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_ECDHE_ECDSA_AES_128_CBC_SHA1</td><td width="20%">0xC0 0x09</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_ECDHE_ECDSA_AES_256_CBC_SHA1</td><td width="20%">0xC0 0x0A</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_ECDHE_ECDSA_ARCFOUR_128_SHA1</td><td width="20%">0xC0 0x07</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_ECDHE_ECDSA_CAMELLIA_128_CBC_SHA256</td><td width="20%">0xC0 0x72</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_ECDHE_ECDSA_CAMELLIA_256_CBC_SHA384</td><td width="20%">0xC0 0x73</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_ECDHE_ECDSA_AES_128_CBC_SHA256</td><td width="20%">0xC0 0x23</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_ECDHE_RSA_AES_128_CBC_SHA256</td><td width="20%">0xC0 0x27</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_ECDHE_ECDSA_CAMELLIA_128_GCM_SHA256</td><td width="20%">0xC0 0x86</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_ECDHE_ECDSA_CAMELLIA_256_GCM_SHA384</td><td width="20%">0xC0 0x87</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_ECDHE_ECDSA_AES_128_GCM_SHA256</td><td width="20%">0xC0 0x2B</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_ECDHE_ECDSA_AES_256_GCM_SHA384</td><td width="20%">0xC0 0x2C</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_ECDHE_RSA_AES_128_GCM_SHA256</td><td width="20%">0xC0 0x2F</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_ECDHE_RSA_AES_256_GCM_SHA384</td><td width="20%">0xC0 0x30</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_ECDHE_ECDSA_AES_256_CBC_SHA384</td><td width="20%">0xC0 0x24</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_ECDHE_RSA_CAMELLIA_128_GCM_SHA256</td><td width="20%">0xC0 0x8A</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_ECDHE_RSA_CAMELLIA_256_GCM_SHA384</td><td width="20%">0xC0 0x8B</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_ECDHE_RSA_CHACHA20_POLY1305</td><td width="20%">0xCC 0xA8</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_ECDHE_ECDSA_CHACHA20_POLY1305</td><td width="20%">0xCC 0xA9</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_ECDHE_ECDSA_AES_128_CCM</td><td width="20%">0xC0 0xAC</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_ECDHE_ECDSA_AES_256_CCM</td><td width="20%">0xC0 0xAD</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_ECDHE_ECDSA_AES_128_CCM_8</td><td width="20%">0xC0 0xAE</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_ECDHE_ECDSA_AES_256_CCM_8</td><td width="20%">0xC0 0xAF</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_ECDHE_PSK_3DES_EDE_CBC_SHA1</td><td width="20%">0xC0 0x34</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_ECDHE_PSK_AES_128_CBC_SHA1</td><td width="20%">0xC0 0x35</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_ECDHE_PSK_AES_256_CBC_SHA1</td><td width="20%">0xC0 0x36</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_ECDHE_PSK_AES_128_CBC_SHA256</td><td width="20%">0xC0 0x37</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_ECDHE_PSK_AES_256_CBC_SHA384</td><td width="20%">0xC0 0x38</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_ECDHE_PSK_ARCFOUR_128_SHA1</td><td width="20%">0xC0 0x33</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_ECDHE_PSK_NULL_SHA1</td><td width="20%">0xC0 0x39</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_ECDHE_PSK_NULL_SHA256</td><td width="20%">0xC0 0x3A</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_ECDHE_PSK_NULL_SHA384</td><td width="20%">0xC0 0x3B</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_ECDHE_PSK_CAMELLIA_128_CBC_SHA256</td><td width="20%">0xC0 0x9A</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_ECDHE_PSK_CAMELLIA_256_CBC_SHA384</td><td width="20%">0xC0 0x9B</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_PSK_ARCFOUR_128_SHA1</td><td width="20%">0x00 0x8A</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_PSK_3DES_EDE_CBC_SHA1</td><td width="20%">0x00 0x8B</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_PSK_AES_128_CBC_SHA1</td><td width="20%">0x00 0x8C</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_PSK_AES_256_CBC_SHA1</td><td width="20%">0x00 0x8D</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_PSK_AES_128_CBC_SHA256</td><td width="20%">0x00 0xAE</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_PSK_AES_256_GCM_SHA384</td><td width="20%">0x00 0xA9</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_PSK_CAMELLIA_128_GCM_SHA256</td><td width="20%">0xC0 0x8E</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_PSK_CAMELLIA_256_GCM_SHA384</td><td width="20%">0xC0 0x8F</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_PSK_AES_128_GCM_SHA256</td><td width="20%">0x00 0xA8</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_PSK_NULL_SHA1</td><td width="20%">0x00 0x2C</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_PSK_NULL_SHA256</td><td width="20%">0x00 0xB0</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_PSK_CAMELLIA_128_CBC_SHA256</td><td width="20%">0xC0 0x94</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_PSK_CAMELLIA_256_CBC_SHA384</td><td width="20%">0xC0 0x95</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_PSK_AES_256_CBC_SHA384</td><td width="20%">0x00 0xAF</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_PSK_NULL_SHA384</td><td width="20%">0x00 0xB1</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_RSA_PSK_ARCFOUR_128_SHA1</td><td width="20%">0x00 0x92</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_RSA_PSK_3DES_EDE_CBC_SHA1</td><td width="20%">0x00 0x93</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_RSA_PSK_AES_128_CBC_SHA1</td><td width="20%">0x00 0x94</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_RSA_PSK_AES_256_CBC_SHA1</td><td width="20%">0x00 0x95</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_RSA_PSK_CAMELLIA_128_GCM_SHA256</td><td width="20%">0xC0 0x92</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_RSA_PSK_CAMELLIA_256_GCM_SHA384</td><td width="20%">0xC0 0x93</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_RSA_PSK_AES_128_GCM_SHA256</td><td width="20%">0x00 0xAC</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_RSA_PSK_AES_128_CBC_SHA256</td><td width="20%">0x00 0xB6</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_RSA_PSK_NULL_SHA1</td><td width="20%">0x00 0x2E</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_RSA_PSK_NULL_SHA256</td><td width="20%">0x00 0xB8</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_RSA_PSK_AES_256_GCM_SHA384</td><td width="20%">0x00 0xAD</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_RSA_PSK_AES_256_CBC_SHA384</td><td width="20%">0x00 0xB7</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_RSA_PSK_NULL_SHA384</td><td width="20%">0x00 0xB9</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_RSA_PSK_CAMELLIA_128_CBC_SHA256</td><td width="20%">0xC0 0x98</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_RSA_PSK_CAMELLIA_256_CBC_SHA384</td><td width="20%">0xC0 0x99</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_DHE_PSK_ARCFOUR_128_SHA1</td><td width="20%">0x00 0x8E</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_DHE_PSK_3DES_EDE_CBC_SHA1</td><td width="20%">0x00 0x8F</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_DHE_PSK_AES_128_CBC_SHA1</td><td width="20%">0x00 0x90</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_DHE_PSK_AES_256_CBC_SHA1</td><td width="20%">0x00 0x91</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_DHE_PSK_AES_128_CBC_SHA256</td><td width="20%">0x00 0xB2</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_DHE_PSK_AES_128_GCM_SHA256</td><td width="20%">0x00 0xAA</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_DHE_PSK_NULL_SHA1</td><td width="20%">0x00 0x2D</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_DHE_PSK_NULL_SHA256</td><td width="20%">0x00 0xB4</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_DHE_PSK_NULL_SHA384</td><td width="20%">0x00 0xB5</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_DHE_PSK_AES_256_CBC_SHA384</td><td width="20%">0x00 0xB3</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_DHE_PSK_AES_256_GCM_SHA384</td><td width="20%">0x00 0xAB</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_DHE_PSK_CAMELLIA_128_CBC_SHA256</td><td width="20%">0xC0 0x96</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_DHE_PSK_CAMELLIA_256_CBC_SHA384</td><td width="20%">0xC0 0x97</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_DHE_PSK_CAMELLIA_128_GCM_SHA256</td><td width="20%">0xC0 0x90</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_DHE_PSK_CAMELLIA_256_GCM_SHA384</td><td width="20%">0xC0 0x91</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_PSK_AES_128_CCM</td><td width="20%">0xC0 0xA4</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_PSK_AES_256_CCM</td><td width="20%">0xC0 0xA5</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_DHE_PSK_AES_128_CCM</td><td width="20%">0xC0 0xA6</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_DHE_PSK_AES_256_CCM</td><td width="20%">0xC0 0xA7</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_PSK_AES_128_CCM_8</td><td width="20%">0xC0 0xA8</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_PSK_AES_256_CCM_8</td><td width="20%">0xC0 0xA9</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_DHE_PSK_AES_128_CCM_8</td><td width="20%">0xC0 0xAA</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_DHE_PSK_AES_256_CCM_8</td><td width="20%">0xC0 0xAB</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_DHE_PSK_CHACHA20_POLY1305</td><td width="20%">0xCC 0xAD</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_ECDHE_PSK_CHACHA20_POLY1305</td><td width="20%">0xCC 0xAC</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_RSA_PSK_CHACHA20_POLY1305</td><td width="20%">0xCC 0xAE</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_PSK_CHACHA20_POLY1305</td><td width="20%">0xCC 0xAB</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_DH_ANON_ARCFOUR_128_MD5</td><td width="20%">0x00 0x18</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_DH_ANON_3DES_EDE_CBC_SHA1</td><td width="20%">0x00 0x1B</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_DH_ANON_AES_128_CBC_SHA1</td><td width="20%">0x00 0x34</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_DH_ANON_AES_256_CBC_SHA1</td><td width="20%">0x00 0x3A</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_DH_ANON_CAMELLIA_128_CBC_SHA256</td><td width="20%">0x00 0xBF</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_DH_ANON_CAMELLIA_256_CBC_SHA256</td><td width="20%">0x00 0xC5</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_DH_ANON_CAMELLIA_128_CBC_SHA1</td><td width="20%">0x00 0x46</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_DH_ANON_CAMELLIA_256_CBC_SHA1</td><td width="20%">0x00 0x89</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_DH_ANON_AES_128_CBC_SHA256</td><td width="20%">0x00 0x6C</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_DH_ANON_AES_256_CBC_SHA256</td><td width="20%">0x00 0x6D</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_DH_ANON_AES_128_GCM_SHA256</td><td width="20%">0x00 0xA6</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_DH_ANON_AES_256_GCM_SHA384</td><td width="20%">0x00 0xA7</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_DH_ANON_CAMELLIA_128_GCM_SHA256</td><td width="20%">0xC0 0x84</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_DH_ANON_CAMELLIA_256_GCM_SHA384</td><td width="20%">0xC0 0x85</td><td width="20%">TLS1.2</td></tr>
<tr><td width="60%">TLS_ECDH_ANON_NULL_SHA1</td><td width="20%">0xC0 0x15</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_ECDH_ANON_3DES_EDE_CBC_SHA1</td><td width="20%">0xC0 0x17</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_ECDH_ANON_AES_128_CBC_SHA1</td><td width="20%">0xC0 0x18</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_ECDH_ANON_AES_256_CBC_SHA1</td><td width="20%">0xC0 0x19</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_ECDH_ANON_ARCFOUR_128_SHA1</td><td width="20%">0xC0 0x16</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_SRP_SHA_3DES_EDE_CBC_SHA1</td><td width="20%">0xC0 0x1A</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_SRP_SHA_AES_128_CBC_SHA1</td><td width="20%">0xC0 0x1D</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_SRP_SHA_AES_256_CBC_SHA1</td><td width="20%">0xC0 0x20</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_SRP_SHA_DSS_3DES_EDE_CBC_SHA1</td><td width="20%">0xC0 0x1C</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_SRP_SHA_RSA_3DES_EDE_CBC_SHA1</td><td width="20%">0xC0 0x1B</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_SRP_SHA_DSS_AES_128_CBC_SHA1</td><td width="20%">0xC0 0x1F</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_SRP_SHA_RSA_AES_128_CBC_SHA1</td><td width="20%">0xC0 0x1E</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_SRP_SHA_DSS_AES_256_CBC_SHA1</td><td width="20%">0xC0 0x22</td><td width="20%">TLS1.0</td></tr>
<tr><td width="60%">TLS_SRP_SHA_RSA_AES_256_CBC_SHA1</td><td width="20%">0xC0 0x21</td><td width="20%">TLS1.0</td></tr>
</table>


<span id="Certificate-types"></span><h3 class="heading">Certificate types</h3>
<dl compact="compact">
<dt><code>X.509</code></dt>
<dt><code>Raw Public Key</code></dt>
</dl>

<span id="Protocols"></span><h3 class="heading">Protocols</h3>
<dl compact="compact">
<dt><code>TLS1.0</code></dt>
<dt><code>TLS1.1</code></dt>
<dt><code>TLS1.2</code></dt>
<dt><code>TLS1.3</code></dt>
<dt><code>DTLS0.9</code></dt>
<dt><code>DTLS1.0</code></dt>
<dt><code>DTLS1.2</code></dt>
</dl>

<span id="Ciphers"></span><h3 class="heading">Ciphers</h3>
<dl compact="compact">
<dt><code>AES-256-CBC</code></dt>
<dt><code>AES-192-CBC</code></dt>
<dt><code>AES-128-CBC</code></dt>
<dt><code>AES-128-GCM</code></dt>
<dt><code>AES-256-GCM</code></dt>
<dt><code>AES-128-CCM</code></dt>
<dt><code>AES-256-CCM</code></dt>
<dt><code>AES-128-CCM-8</code></dt>
<dt><code>AES-256-CCM-8</code></dt>
<dt><code>ARCFOUR-128</code></dt>
<dt><code>ESTREAM-SALSA20-256</code></dt>
<dt><code>SALSA20-256</code></dt>
<dt><code>CAMELLIA-256-CBC</code></dt>
<dt><code>CAMELLIA-192-CBC</code></dt>
<dt><code>CAMELLIA-128-CBC</code></dt>
<dt><code>CHACHA20-POLY1305</code></dt>
<dt><code>CAMELLIA-128-GCM</code></dt>
<dt><code>CAMELLIA-256-GCM</code></dt>
<dt><code>GOST28147-TC26Z-CFB</code></dt>
<dt><code>GOST28147-CPA-CFB</code></dt>
<dt><code>GOST28147-CPB-CFB</code></dt>
<dt><code>GOST28147-CPC-CFB</code></dt>
<dt><code>GOST28147-CPD-CFB</code></dt>
<dt><code>AES-128-CFB8</code></dt>
<dt><code>AES-192-CFB8</code></dt>
<dt><code>AES-256-CFB8</code></dt>
<dt><code>AES-128-XTS</code></dt>
<dt><code>AES-256-XTS</code></dt>
<dt><code>GOST28147-TC26Z-CNT</code></dt>
<dt><code>3DES-CBC</code></dt>
<dt><code>DES-CBC</code></dt>
<dt><code>RC2-40</code></dt>
<dt><code>NULL</code></dt>
</dl>

<span id="MAC-algorithms"></span><h3 class="heading">MAC algorithms</h3>
<dl compact="compact">
<dt><code>SHA1</code></dt>
<dt><code>SHA256</code></dt>
<dt><code>SHA384</code></dt>
<dt><code>SHA512</code></dt>
<dt><code>SHA224</code></dt>
<dt><code>UMAC-96</code></dt>
<dt><code>UMAC-128</code></dt>
<dt><code>AEAD</code></dt>
<dt><code>MD5</code></dt>
<dt><code>GOSTR341194</code></dt>
<dt><code>STREEBOG-256</code></dt>
<dt><code>STREEBOG-512</code></dt>
<dt><code>AES-CMAC-128</code></dt>
<dt><code>AES-CMAC-256</code></dt>
<dt><code>AES-GMAC-128</code></dt>
<dt><code>AES-GMAC-192</code></dt>
<dt><code>AES-GMAC-256</code></dt>
<dt><code>GOST28147-TC26Z-IMIT</code></dt>
</dl>

<span id="Key-exchange-methods"></span><h3 class="heading">Key exchange methods</h3>
<dl compact="compact">
<dt><code>ECDHE-RSA</code></dt>
<dt><code>ECDHE-ECDSA</code></dt>
<dt><code>RSA</code></dt>
<dt><code>DHE-RSA</code></dt>
<dt><code>DHE-DSS</code></dt>
<dt><code>PSK</code></dt>
<dt><code>RSA-PSK</code></dt>
<dt><code>DHE-PSK</code></dt>
<dt><code>ECDHE-PSK</code></dt>
<dt><code>SRP-DSS</code></dt>
<dt><code>SRP-RSA</code></dt>
<dt><code>SRP</code></dt>
<dt><code>ANON-DH</code></dt>
<dt><code>ANON-ECDH</code></dt>
<dt><code>RSA-EXPORT</code></dt>
</dl>

<span id="Public-key-algorithms-2"></span><h3 class="heading">Public key algorithms</h3>
<dl compact="compact">
<dt><code>RSA</code></dt>
<dt><code>RSA-PSS</code></dt>
<dt><code>RSA</code></dt>
<dt><code>DSA</code></dt>
<dt><code>GOST R 34.10-2012-512</code></dt>
<dt><code>GOST R 34.10-2012-256</code></dt>
<dt><code>GOST R 34.10-2001</code></dt>
<dt><code>EC/ECDSA</code></dt>
<dt><code>EdDSA (Ed25519)</code></dt>
<dt><code>DH</code></dt>
<dt><code>ECDH (X25519)</code></dt>
</dl>

<span id="Public-key-signature-algorithms"></span><h3 class="heading">Public key signature algorithms</h3>
<dl compact="compact">
<dt><code>RSA-SHA256</code></dt>
<dt><code>RSA-SHA384</code></dt>
<dt><code>RSA-SHA512</code></dt>
<dt><code>RSA-PSS-SHA256</code></dt>
<dt><code>RSA-PSS-RSAE-SHA256</code></dt>
<dt><code>RSA-PSS-SHA384</code></dt>
<dt><code>RSA-PSS-RSAE-SHA384</code></dt>
<dt><code>RSA-PSS-SHA512</code></dt>
<dt><code>RSA-PSS-RSAE-SHA512</code></dt>
<dt><code>EdDSA-Ed25519</code></dt>
<dt><code>ECDSA-SHA256</code></dt>
<dt><code>ECDSA-SHA384</code></dt>
<dt><code>ECDSA-SHA512</code></dt>
<dt><code>ECDSA-SECP256R1-SHA256</code></dt>
<dt><code>ECDSA-SECP384R1-SHA384</code></dt>
<dt><code>ECDSA-SECP521R1-SHA512</code></dt>
<dt><code>ECDSA-SHA3-224</code></dt>
<dt><code>ECDSA-SHA3-256</code></dt>
<dt><code>ECDSA-SHA3-384</code></dt>
<dt><code>ECDSA-SHA3-512</code></dt>
<dt><code>RSA-SHA3-224</code></dt>
<dt><code>RSA-SHA3-256</code></dt>
<dt><code>RSA-SHA3-384</code></dt>
<dt><code>RSA-SHA3-512</code></dt>
<dt><code>DSA-SHA3-224</code></dt>
<dt><code>DSA-SHA3-256</code></dt>
<dt><code>DSA-SHA3-384</code></dt>
<dt><code>DSA-SHA3-512</code></dt>
<dt><code>RSA-RAW</code></dt>
<dt><code>RSA-SHA1</code></dt>
<dt><code>RSA-SHA1</code></dt>
<dt><code>RSA-SHA224</code></dt>
<dt><code>RSA-RMD160</code></dt>
<dt><code>DSA-SHA1</code></dt>
<dt><code>DSA-SHA1</code></dt>
<dt><code>DSA-SHA224</code></dt>
<dt><code>DSA-SHA256</code></dt>
<dt><code>RSA-MD5</code></dt>
<dt><code>RSA-MD5</code></dt>
<dt><code>RSA-MD2</code></dt>
<dt><code>ECDSA-SHA1</code></dt>
<dt><code>ECDSA-SHA224</code></dt>
<dt><code>GOSTR341012-512</code></dt>
<dt><code>GOSTR341012-256</code></dt>
<dt><code>GOSTR341001</code></dt>
<dt><code>DSA-SHA384</code></dt>
<dt><code>DSA-SHA512</code></dt>
</dl>

<span id="Groups"></span><h3 class="heading">Groups</h3>
<dl compact="compact">
<dt><code>SECP192R1</code></dt>
<dt><code>SECP224R1</code></dt>
<dt><code>SECP256R1</code></dt>
<dt><code>SECP384R1</code></dt>
<dt><code>SECP521R1</code></dt>
<dt><code>X25519</code></dt>
<dt><code>FFDHE2048</code></dt>
<dt><code>FFDHE3072</code></dt>
<dt><code>FFDHE4096</code></dt>
<dt><code>FFDHE6144</code></dt>
<dt><code>FFDHE8192</code></dt>
</dl>


<hr>
<span id="API-reference"></span><div class="header">
<p>
Next: <a href="#Copying-Information" accesskey="n" rel="next">Copying Information</a>, Previous: <a href="#Supported-ciphersuites" accesskey="p" rel="prev">Supported ciphersuites</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="API-reference-1"></span><h2 class="appendix">Appendix E API reference</h2>
<span id="index-API-reference"></span>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Core-TLS-API" accesskey="1">Core TLS API</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Datagram-TLS-API" accesskey="2">Datagram TLS API</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#X509-certificate-API" accesskey="3">X509 certificate API</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#PKCS-7-API" accesskey="4">PKCS 7 API</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#OCSP-API" accesskey="5">OCSP API</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#PKCS-12-API" accesskey="6">PKCS 12 API</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#PKCS-11-API" accesskey="7">PKCS 11 API</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#TPM-API" accesskey="8">TPM API</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Abstract-key-API" accesskey="9">Abstract key API</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Socket-specific-API">Socket specific API</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#DANE-API">DANE API</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Cryptographic-API">Cryptographic API</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Compatibility-API">Compatibility API</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Core-TLS-API"></span><div class="header">
<p>
Next: <a href="#Datagram-TLS-API" accesskey="n" rel="next">Datagram TLS API</a>, Up: <a href="#API-reference" accesskey="u" rel="up">API reference</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Core-TLS-API-1"></span><h3 class="section">E.1 Core TLS API</h3>

<p>The prototypes for the following functions lie in
<samp>gnutls/gnutls.h</samp>.
</p>

<span id="gnutls_005falert_005fget-1"></span><h4 class="subheading">gnutls_alert_get</h4>
<span id="gnutls_005falert_005fget"></span><dl>
<dt id="index-gnutls_005falert_005fget-1">Function: <em>gnutls_alert_description_t</em> <strong>gnutls_alert_get</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>This function will return the last alert number received.  This
function should be called when <code>GNUTLS_E_WARNING_ALERT_RECEIVED</code>  or
<code>GNUTLS_E_FATAL_ALERT_RECEIVED</code>  errors are returned by a gnutls
function.  The peer may send alerts if he encounters an error.
If no alert has been received the returned value is undefined.
</p>
<p><strong>Returns:</strong> the last alert received, a
<code>gnutls_alert_description_t</code>  value.
</p></dd></dl>

<span id="gnutls_005falert_005fget_005fname-1"></span><h4 class="subheading">gnutls_alert_get_name</h4>
<span id="gnutls_005falert_005fget_005fname"></span><dl>
<dt id="index-gnutls_005falert_005fget_005fname-1">Function: <em>const char *</em> <strong>gnutls_alert_get_name</strong> <em>(gnutls_alert_description_t <var>alert</var>)</em></dt>
<dd><p><var>alert</var>: is an alert number.
</p>
<p>This function will return a string that describes the given alert
number, or <code>NULL</code> .  See <code>gnutls_alert_get()</code> .
</p>
<p><strong>Returns:</strong> string corresponding to <code>gnutls_alert_description_t</code>  value.
</p></dd></dl>

<span id="gnutls_005falert_005fget_005fstrname-1"></span><h4 class="subheading">gnutls_alert_get_strname</h4>
<span id="gnutls_005falert_005fget_005fstrname"></span><dl>
<dt id="index-gnutls_005falert_005fget_005fstrname">Function: <em>const char *</em> <strong>gnutls_alert_get_strname</strong> <em>(gnutls_alert_description_t <var>alert</var>)</em></dt>
<dd><p><var>alert</var>: is an alert number.
</p>
<p>This function will return a string of the name of the alert.
</p>
<p><strong>Returns:</strong> string corresponding to <code>gnutls_alert_description_t</code>  value.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005falert_005fsend-1"></span><h4 class="subheading">gnutls_alert_send</h4>
<span id="gnutls_005falert_005fsend"></span><dl>
<dt id="index-gnutls_005falert_005fsend-1">Function: <em>int</em> <strong>gnutls_alert_send</strong> <em>(gnutls_session_t <var>session</var>, gnutls_alert_level_t <var>level</var>, gnutls_alert_description_t <var>desc</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>level</var>: is the level of the alert
</p>
<p><var>desc</var>: is the alert description
</p>
<p>This function will send an alert to the peer in order to inform
him of something important (eg. his Certificate could not be verified).
If the alert level is Fatal then the peer is expected to close the
connection, otherwise he may ignore the alert and continue.
</p>
<p>The error code of the underlying record send function will be
returned, so you may also receive <code>GNUTLS_E_INTERRUPTED</code>  or
<code>GNUTLS_E_AGAIN</code>  as well.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p></dd></dl>

<span id="gnutls_005falert_005fsend_005fappropriate-1"></span><h4 class="subheading">gnutls_alert_send_appropriate</h4>
<span id="gnutls_005falert_005fsend_005fappropriate"></span><dl>
<dt id="index-gnutls_005falert_005fsend_005fappropriate">Function: <em>int</em> <strong>gnutls_alert_send_appropriate</strong> <em>(gnutls_session_t <var>session</var>, int <var>err</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>err</var>: is an error code returned by another GnuTLS function
</p>
<p>Sends an alert to the peer depending on the error code returned by
a gnutls function. This function will call <code>gnutls_error_to_alert()</code> 
to determine the appropriate alert to send.
</p>
<p>This function may also return <code>GNUTLS_E_AGAIN</code> , or
<code>GNUTLS_E_INTERRUPTED</code> .
</p>
<p>This function historically was always sending an alert to the
peer, even if  <code>err</code> was inappropriate to respond with an alert
(e.g., <code>GNUTLS_E_SUCCESS</code> ). Since 3.6.6 this function returns
success without transmitting any data on error codes that
should not result to an alert.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p></dd></dl>

<span id="gnutls_005falpn_005fget_005fselected_005fprotocol-1"></span><h4 class="subheading">gnutls_alpn_get_selected_protocol</h4>
<span id="gnutls_005falpn_005fget_005fselected_005fprotocol"></span><dl>
<dt id="index-gnutls_005falpn_005fget_005fselected_005fprotocol">Function: <em>int</em> <strong>gnutls_alpn_get_selected_protocol</strong> <em>(gnutls_session_t <var>session</var>, gnutls_datum_t * <var>protocol</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>protocol</var>: will hold the protocol name
</p>
<p>This function allows you to get the negotiated protocol name. The
returned protocol should be treated as opaque, constant value and
only valid during the session life.
</p>
<p>The selected protocol is the first supported by the list sent
by the client.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p>
<p>Since 3.2.0
</p></dd></dl>

<span id="gnutls_005falpn_005fset_005fprotocols-1"></span><h4 class="subheading">gnutls_alpn_set_protocols</h4>
<span id="gnutls_005falpn_005fset_005fprotocols"></span><dl>
<dt id="index-gnutls_005falpn_005fset_005fprotocols">Function: <em>int</em> <strong>gnutls_alpn_set_protocols</strong> <em>(gnutls_session_t <var>session</var>, const gnutls_datum_t * <var>protocols</var>, unsigned <var>protocols_size</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>protocols</var>: is the protocol names to add.
</p>
<p><var>protocols_size</var>: the number of protocols to add.
</p>
<p><var>flags</var>: zero or a sequence of <code>gnutls_alpn_flags_t</code> 
</p>
<p>This function is to be used by both clients and servers, to declare
the supported ALPN protocols, which are used during negotiation with peer.
</p>
<p>See <code>gnutls_alpn_flags_t</code>  description for the documentation of available
flags.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p>
<p>Since 3.2.0
</p></dd></dl>

<span id="gnutls_005fanon_005fallocate_005fclient_005fcredentials-1"></span><h4 class="subheading">gnutls_anon_allocate_client_credentials</h4>
<span id="gnutls_005fanon_005fallocate_005fclient_005fcredentials"></span><dl>
<dt id="index-gnutls_005fanon_005fallocate_005fclient_005fcredentials">Function: <em>int</em> <strong>gnutls_anon_allocate_client_credentials</strong> <em>(gnutls_anon_client_credentials_t *      <var>sc</var>)</em></dt>
<dd><p><var>sc</var>: is a pointer to a <code>gnutls_anon_client_credentials_t</code>  type.
</p>
<p>Allocate a gnutls_anon_client_credentials_t structure.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, or an error code.
</p></dd></dl>

<span id="gnutls_005fanon_005fallocate_005fserver_005fcredentials-1"></span><h4 class="subheading">gnutls_anon_allocate_server_credentials</h4>
<span id="gnutls_005fanon_005fallocate_005fserver_005fcredentials"></span><dl>
<dt id="index-gnutls_005fanon_005fallocate_005fserver_005fcredentials">Function: <em>int</em> <strong>gnutls_anon_allocate_server_credentials</strong> <em>(gnutls_anon_server_credentials_t *      <var>sc</var>)</em></dt>
<dd><p><var>sc</var>: is a pointer to a <code>gnutls_anon_server_credentials_t</code>  type.
</p>
<p>Allocate a gnutls_anon_server_credentials_t structure.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, or an error code.
</p></dd></dl>

<span id="gnutls_005fanon_005ffree_005fclient_005fcredentials-1"></span><h4 class="subheading">gnutls_anon_free_client_credentials</h4>
<span id="gnutls_005fanon_005ffree_005fclient_005fcredentials"></span><dl>
<dt id="index-gnutls_005fanon_005ffree_005fclient_005fcredentials">Function: <em>void</em> <strong>gnutls_anon_free_client_credentials</strong> <em>(gnutls_anon_client_credentials_t <var>sc</var>)</em></dt>
<dd><p><var>sc</var>: is a <code>gnutls_anon_client_credentials_t</code>  type.
</p>
<p>Free a gnutls_anon_client_credentials_t structure.
</p></dd></dl>

<span id="gnutls_005fanon_005ffree_005fserver_005fcredentials-1"></span><h4 class="subheading">gnutls_anon_free_server_credentials</h4>
<span id="gnutls_005fanon_005ffree_005fserver_005fcredentials"></span><dl>
<dt id="index-gnutls_005fanon_005ffree_005fserver_005fcredentials">Function: <em>void</em> <strong>gnutls_anon_free_server_credentials</strong> <em>(gnutls_anon_server_credentials_t <var>sc</var>)</em></dt>
<dd><p><var>sc</var>: is a <code>gnutls_anon_server_credentials_t</code>  type.
</p>
<p>Free a gnutls_anon_server_credentials_t structure.
</p></dd></dl>

<span id="gnutls_005fanon_005fset_005fparams_005ffunction-1"></span><h4 class="subheading">gnutls_anon_set_params_function</h4>
<span id="gnutls_005fanon_005fset_005fparams_005ffunction"></span><dl>
<dt id="index-gnutls_005fanon_005fset_005fparams_005ffunction">Function: <em>void</em> <strong>gnutls_anon_set_params_function</strong> <em>(gnutls_anon_server_credentials_t <var>res</var>, gnutls_params_function * <var>func</var>)</em></dt>
<dd><p><var>res</var>: is a gnutls_anon_server_credentials_t type
</p>
<p><var>func</var>: is the function to be called
</p>
<p>This function will set a callback in order for the server to get
the Diffie-Hellman or RSA parameters for anonymous authentication.
The callback should return <code>GNUTLS_E_SUCCESS</code>  (0) on success.
</p>
<p><strong>Deprecated:</strong> This function is unnecessary and discouraged on GnuTLS 3.6.0
or later. Since 3.6.0, DH parameters are negotiated
following RFC7919.
</p></dd></dl>

<span id="gnutls_005fanon_005fset_005fserver_005fdh_005fparams-1"></span><h4 class="subheading">gnutls_anon_set_server_dh_params</h4>
<span id="gnutls_005fanon_005fset_005fserver_005fdh_005fparams"></span><dl>
<dt id="index-gnutls_005fanon_005fset_005fserver_005fdh_005fparams">Function: <em>void</em> <strong>gnutls_anon_set_server_dh_params</strong> <em>(gnutls_anon_server_credentials_t <var>res</var>, gnutls_dh_params_t <var>dh_params</var>)</em></dt>
<dd><p><var>res</var>: is a gnutls_anon_server_credentials_t type
</p>
<p><var>dh_params</var>: The Diffie-Hellman parameters.
</p>
<p>This function will set the Diffie-Hellman parameters for an
anonymous server to use.  These parameters will be used in
Anonymous Diffie-Hellman cipher suites.
</p>
<p><strong>Deprecated:</strong> This function is unnecessary and discouraged on GnuTLS 3.6.0
or later. Since 3.6.0, DH parameters are negotiated
following RFC7919.
</p></dd></dl>

<span id="gnutls_005fanon_005fset_005fserver_005fknown_005fdh_005fparams-1"></span><h4 class="subheading">gnutls_anon_set_server_known_dh_params</h4>
<span id="gnutls_005fanon_005fset_005fserver_005fknown_005fdh_005fparams"></span><dl>
<dt id="index-gnutls_005fanon_005fset_005fserver_005fknown_005fdh_005fparams">Function: <em>int</em> <strong>gnutls_anon_set_server_known_dh_params</strong> <em>(gnutls_anon_server_credentials_t <var>res</var>, gnutls_sec_param_t <var>sec_param</var>)</em></dt>
<dd><p><var>res</var>: is a gnutls_anon_server_credentials_t type
</p>
<p><var>sec_param</var>: is an option of the <code>gnutls_sec_param_t</code>  enumeration
</p>
<p>This function will set the Diffie-Hellman parameters for an
anonymous server to use.  These parameters will be used in
Anonymous Diffie-Hellman cipher suites and will be selected from
the FFDHE set of RFC7919 according to the security level provided.
</p>
<p><strong>Deprecated:</strong> This function is unnecessary and discouraged on GnuTLS 3.6.0
or later. Since 3.6.0, DH parameters are negotiated
following RFC7919.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.5.6
</p></dd></dl>

<span id="gnutls_005fanon_005fset_005fserver_005fparams_005ffunction-1"></span><h4 class="subheading">gnutls_anon_set_server_params_function</h4>
<span id="gnutls_005fanon_005fset_005fserver_005fparams_005ffunction"></span><dl>
<dt id="index-gnutls_005fanon_005fset_005fserver_005fparams_005ffunction">Function: <em>void</em> <strong>gnutls_anon_set_server_params_function</strong> <em>(gnutls_anon_server_credentials_t            <var>res</var>, gnutls_params_function * <var>func</var>)</em></dt>
<dd><p><var>res</var>: is a gnutls_certificate_credentials_t type
</p>
<p><var>func</var>: is the function to be called
</p>
<p>This function will set a callback in order for the server to get
the Diffie-Hellman parameters for anonymous authentication.  The
callback should return <code>GNUTLS_E_SUCCESS</code>  (0) on success.
</p>
<p><strong>Deprecated:</strong> This function is unnecessary and discouraged on GnuTLS 3.6.0
or later. Since 3.6.0, DH parameters are negotiated
following RFC7919.
</p></dd></dl>

<span id="gnutls_005fanti_005freplay_005fdeinit-1"></span><h4 class="subheading">gnutls_anti_replay_deinit</h4>
<span id="gnutls_005fanti_005freplay_005fdeinit"></span><dl>
<dt id="index-gnutls_005fanti_005freplay_005fdeinit">Function: <em>void</em> <strong>gnutls_anti_replay_deinit</strong> <em>(gnutls_anti_replay_t <var>anti_replay</var>)</em></dt>
<dd><p><var>anti_replay</var>: is a <code>gnutls_anti_replay</code>  type
</p>
<p>This function will deinitialize all resources occupied by the given
anti-replay context.
</p>
<p><strong>Since:</strong> 3.6.5
</p></dd></dl>

<span id="gnutls_005fanti_005freplay_005fenable-1"></span><h4 class="subheading">gnutls_anti_replay_enable</h4>
<span id="gnutls_005fanti_005freplay_005fenable"></span><dl>
<dt id="index-gnutls_005fanti_005freplay_005fenable">Function: <em>void</em> <strong>gnutls_anti_replay_enable</strong> <em>(gnutls_session_t <var>session</var>, gnutls_anti_replay_t <var>anti_replay</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>anti_replay</var>: is a <code>gnutls_anti_replay_t</code>  type.
</p>
<p>Request that the server should use anti-replay mechanism.
</p>
<p><strong>Since:</strong> 3.6.5
</p></dd></dl>

<span id="gnutls_005fanti_005freplay_005finit-1"></span><h4 class="subheading">gnutls_anti_replay_init</h4>
<span id="gnutls_005fanti_005freplay_005finit"></span><dl>
<dt id="index-gnutls_005fanti_005freplay_005finit">Function: <em>int</em> <strong>gnutls_anti_replay_init</strong> <em>(gnutls_anti_replay_t * <var>anti_replay</var>)</em></dt>
<dd><p><var>anti_replay</var>: is a pointer to <code>gnutls_anti_replay_t</code>  type
</p>
<p>This function will allocate and initialize the  <code>anti_replay</code> context
to be usable for detect replay attacks. The context can then be
attached to a  <code>gnutls_session_t</code> with
<code>gnutls_anti_replay_enable()</code> .
</p>
<p><strong>Returns:</strong> Zero or a negative error code on error.
</p>
<p><strong>Since:</strong> 3.6.5
</p></dd></dl>

<span id="gnutls_005fanti_005freplay_005fset_005fadd_005ffunction-1"></span><h4 class="subheading">gnutls_anti_replay_set_add_function</h4>
<span id="gnutls_005fanti_005freplay_005fset_005fadd_005ffunction"></span><dl>
<dt id="index-gnutls_005fanti_005freplay_005fset_005fadd_005ffunction">Function: <em>void</em> <strong>gnutls_anti_replay_set_add_function</strong> <em>(gnutls_anti_replay_t <var>anti_replay</var>, gnutls_db_add_func <var>add_func</var>)</em></dt>
<dd><p><var>anti_replay</var>: is a <code>gnutls_anti_replay_t</code>  type.
</p>
<p><var>add_func</var>: is the function.
</p>
<p>Sets the function that will be used to store an entry if it is not
already present in the resumed sessions database.  This function returns 0
if the entry is successfully stored, and a negative error code
otherwise.  In particular, if the entry is found in the database,
it returns <code>GNUTLS_E_DB_ENTRY_EXISTS</code> .
</p>
<p>The arguments to the  <code>add_func</code> are:
- <code>ptr</code> : the pointer set with <code>gnutls_anti_replay_set_ptr()</code> 
- <code>exp_time</code> : the expiration time of the entry
- <code>key</code> : a pointer to the key
- <code>data</code> : a pointer to data to store
</p>
<p>The data set by this function can be examined using
<code>gnutls_db_check_entry_expire_time()</code>  and <code>gnutls_db_check_entry_time()</code> .
</p>
<p><strong>Since:</strong> 3.6.5
</p></dd></dl>

<span id="gnutls_005fanti_005freplay_005fset_005fptr-1"></span><h4 class="subheading">gnutls_anti_replay_set_ptr</h4>
<span id="gnutls_005fanti_005freplay_005fset_005fptr"></span><dl>
<dt id="index-gnutls_005fanti_005freplay_005fset_005fptr">Function: <em>void</em> <strong>gnutls_anti_replay_set_ptr</strong> <em>(gnutls_anti_replay_t <var>anti_replay</var>, void * <var>ptr</var>)</em></dt>
<dd><p><var>anti_replay</var>: is a <code>gnutls_anti_replay_t</code>  type.
</p>
<p><var>ptr</var>: is the pointer
</p>
<p>Sets the pointer that will be provided to db add function
as the first argument.
</p></dd></dl>

<span id="gnutls_005fanti_005freplay_005fset_005fwindow-1"></span><h4 class="subheading">gnutls_anti_replay_set_window</h4>
<span id="gnutls_005fanti_005freplay_005fset_005fwindow"></span><dl>
<dt id="index-gnutls_005fanti_005freplay_005fset_005fwindow">Function: <em>void</em> <strong>gnutls_anti_replay_set_window</strong> <em>(gnutls_anti_replay_t <var>anti_replay</var>, unsigned int <var>window</var>)</em></dt>
<dd><p><var>anti_replay</var>: is a <code>gnutls_anti_replay_t</code>  type.
</p>
<p><var>window</var>: is the time window recording ClientHello, in milliseconds
</p>
<p>Sets the time window used for ClientHello recording.  In order to
protect against replay attacks, the server records ClientHello
messages within this time period from the last update, and
considers it a replay when a ClientHello outside of the period; if
a ClientHello arrives within this period, the server checks the
database and detects duplicates.
</p>
<p>For the details of the algorithm, see RFC 8446, section 8.2.
</p>
<p><strong>Since:</strong> 3.6.5
</p></dd></dl>

<span id="gnutls_005fauth_005fclient_005fget_005ftype-1"></span><h4 class="subheading">gnutls_auth_client_get_type</h4>
<span id="gnutls_005fauth_005fclient_005fget_005ftype"></span><dl>
<dt id="index-gnutls_005fauth_005fclient_005fget_005ftype">Function: <em>gnutls_credentials_type_t</em> <strong>gnutls_auth_client_get_type</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Returns the type of credentials that were used for client authentication.
The returned information is to be used to distinguish the function used
to access authentication data.
</p>
<p>Note that on resumed sessions, this function returns the schema
used in the original session authentication.
</p>
<p><strong>Returns:</strong> The type of credentials for the client authentication
schema, a <code>gnutls_credentials_type_t</code>  type.
</p></dd></dl>

<span id="gnutls_005fauth_005fget_005ftype-1"></span><h4 class="subheading">gnutls_auth_get_type</h4>
<span id="gnutls_005fauth_005fget_005ftype"></span><dl>
<dt id="index-gnutls_005fauth_005fget_005ftype">Function: <em>gnutls_credentials_type_t</em> <strong>gnutls_auth_get_type</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Returns type of credentials for the current authentication schema.
The returned information is to be used to distinguish the function used
to access authentication data.
</p>
<p>Eg. for CERTIFICATE ciphersuites (key exchange algorithms:
<code>GNUTLS_KX_RSA</code> , <code>GNUTLS_KX_DHE_RSA</code> ), the same function are to be
used to access the authentication data.
</p>
<p>Note that on resumed sessions, this function returns the schema
used in the original session authentication.
</p>
<p><strong>Returns:</strong> The type of credentials for the current authentication
schema, a <code>gnutls_credentials_type_t</code>  type.
</p></dd></dl>

<span id="gnutls_005fauth_005fserver_005fget_005ftype-1"></span><h4 class="subheading">gnutls_auth_server_get_type</h4>
<span id="gnutls_005fauth_005fserver_005fget_005ftype"></span><dl>
<dt id="index-gnutls_005fauth_005fserver_005fget_005ftype">Function: <em>gnutls_credentials_type_t</em> <strong>gnutls_auth_server_get_type</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Returns the type of credentials that were used for server authentication.
The returned information is to be used to distinguish the function used
to access authentication data.
</p>
<p>Note that on resumed sessions, this function returns the schema
used in the original session authentication.
</p>
<p><strong>Returns:</strong> The type of credentials for the server authentication
schema, a <code>gnutls_credentials_type_t</code>  type.
</p></dd></dl>

<span id="gnutls_005fbase64_005fdecode2-1"></span><h4 class="subheading">gnutls_base64_decode2</h4>
<span id="gnutls_005fbase64_005fdecode2"></span><dl>
<dt id="index-gnutls_005fbase64_005fdecode2">Function: <em>int</em> <strong>gnutls_base64_decode2</strong> <em>(const gnutls_datum_t * <var>base64</var>, gnutls_datum_t * <var>result</var>)</em></dt>
<dd><p><var>base64</var>: contains the encoded data
</p>
<p><var>result</var>: the location of decoded data
</p>
<p>This function will decode the given base64 encoded data. The decoded data
will be allocated, and stored into result.
</p>
<p>You should use <code>gnutls_free()</code>  to free the returned data.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p>
<p><strong>Since:</strong> 3.6.0
</p></dd></dl>

<span id="gnutls_005fbase64_005fencode2-1"></span><h4 class="subheading">gnutls_base64_encode2</h4>
<span id="gnutls_005fbase64_005fencode2"></span><dl>
<dt id="index-gnutls_005fbase64_005fencode2">Function: <em>int</em> <strong>gnutls_base64_encode2</strong> <em>(const gnutls_datum_t * <var>data</var>, gnutls_datum_t * <var>result</var>)</em></dt>
<dd><p><var>data</var>: contains the raw data
</p>
<p><var>result</var>: will hold the newly allocated encoded data
</p>
<p>This function will convert the given data to printable data, using
the base64 encoding. This function will allocate the required
memory to hold the encoded data.
</p>
<p>You should use <code>gnutls_free()</code>  to free the returned data.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p>
<p><strong>Since:</strong> 3.6.0
</p></dd></dl>

<span id="gnutls_005fbuffer_005fappend_005fdata-1"></span><h4 class="subheading">gnutls_buffer_append_data</h4>
<span id="gnutls_005fbuffer_005fappend_005fdata"></span><dl>
<dt id="index-gnutls_005fbuffer_005fappend_005fdata">Function: <em>int</em> <strong>gnutls_buffer_append_data</strong> <em>(gnutls_buffer_t <var>dest</var>, const void * <var>data</var>, size_t <var>data_size</var>)</em></dt>
<dd><p><var>dest</var>: the buffer to append to
</p>
<p><var>data</var>: the data
</p>
<p><var>data_size</var>: the size of  <code>data</code> 
</p>
<p>Appends the provided  <code>data</code> to the destination buffer.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fbye-1"></span><h4 class="subheading">gnutls_bye</h4>
<span id="gnutls_005fbye"></span><dl>
<dt id="index-gnutls_005fbye-1">Function: <em>int</em> <strong>gnutls_bye</strong> <em>(gnutls_session_t <var>session</var>, gnutls_close_request_t <var>how</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>how</var>: is an integer
</p>
<p>Terminates the current TLS/SSL connection. The connection should
have been initiated using <code>gnutls_handshake()</code> .   <code>how</code> should be one
of <code>GNUTLS_SHUT_RDWR</code> , <code>GNUTLS_SHUT_WR</code> .
</p>
<p>In case of <code>GNUTLS_SHUT_RDWR</code>  the TLS session gets
terminated and further receives and sends will be disallowed.  If
the return value is zero you may continue using the underlying
transport layer. <code>GNUTLS_SHUT_RDWR</code>  sends an alert containing a close
request and waits for the peer to reply with the same message.
</p>
<p>In case of <code>GNUTLS_SHUT_WR</code>  the TLS session gets terminated
and further sends will be disallowed. In order to reuse the
connection you should wait for an EOF from the peer.
<code>GNUTLS_SHUT_WR</code>  sends an alert containing a close request.
</p>
<p>Note that not all implementations will properly terminate a TLS
connection.  Some of them, usually for performance reasons, will
terminate only the underlying transport layer, and thus not
distinguishing between a malicious party prematurely terminating 
the connection and normal termination. 
</p>
<p>This function may also return <code>GNUTLS_E_AGAIN</code>  or
<code>GNUTLS_E_INTERRUPTED</code> ; cf.  <code>gnutls_record_get_direction()</code> .
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, or an error code, see
function documentation for entire semantics.
</p></dd></dl>

<span id="gnutls_005fcertificate_005factivation_005ftime_005fpeers-1"></span><h4 class="subheading">gnutls_certificate_activation_time_peers</h4>
<span id="gnutls_005fcertificate_005factivation_005ftime_005fpeers"></span><dl>
<dt id="index-gnutls_005fcertificate_005factivation_005ftime_005fpeers">Function: <em>time_t</em> <strong>gnutls_certificate_activation_time_peers</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a gnutls session
</p>
<p>This function will return the peer&rsquo;s certificate activation time.
</p>
<p><strong>Returns:</strong> (time_t)-1 on error.
</p>
<p><strong>Deprecated:</strong> <code>gnutls_certificate_verify_peers2()</code>  now verifies activation times.
</p></dd></dl>

<span id="gnutls_005fcertificate_005fallocate_005fcredentials-1"></span><h4 class="subheading">gnutls_certificate_allocate_credentials</h4>
<span id="gnutls_005fcertificate_005fallocate_005fcredentials"></span><dl>
<dt id="index-gnutls_005fcertificate_005fallocate_005fcredentials">Function: <em>int</em> <strong>gnutls_certificate_allocate_credentials</strong> <em>(gnutls_certificate_credentials_t *      <var>res</var>)</em></dt>
<dd><p><var>res</var>: is a pointer to a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p>Allocate a gnutls_certificate_credentials_t structure.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, or an error code.
</p></dd></dl>

<span id="gnutls_005fcertificate_005fclient_005fget_005frequest_005fstatus-1"></span><h4 class="subheading">gnutls_certificate_client_get_request_status</h4>
<span id="gnutls_005fcertificate_005fclient_005fget_005frequest_005fstatus"></span><dl>
<dt id="index-gnutls_005fcertificate_005fclient_005fget_005frequest_005fstatus">Function: <em>unsigned</em> <strong>gnutls_certificate_client_get_request_status</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a gnutls session
</p>
<p>Get whether client certificate was requested on the last
handshake or not.
</p>
<p><strong>Returns:</strong> 0 if the peer (server) did not request client
authentication or 1 otherwise.
</p></dd></dl>

<span id="gnutls_005fcertificate_005fexpiration_005ftime_005fpeers-1"></span><h4 class="subheading">gnutls_certificate_expiration_time_peers</h4>
<span id="gnutls_005fcertificate_005fexpiration_005ftime_005fpeers"></span><dl>
<dt id="index-gnutls_005fcertificate_005fexpiration_005ftime_005fpeers">Function: <em>time_t</em> <strong>gnutls_certificate_expiration_time_peers</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a gnutls session
</p>
<p>This function will return the peer&rsquo;s certificate expiration time.
</p>
<p><strong>Returns:</strong> (time_t)-1 on error.
</p>
<p><strong>Deprecated:</strong> <code>gnutls_certificate_verify_peers2()</code>  now verifies expiration times.
</p></dd></dl>

<span id="gnutls_005fcertificate_005ffree_005fca_005fnames-1"></span><h4 class="subheading">gnutls_certificate_free_ca_names</h4>
<span id="gnutls_005fcertificate_005ffree_005fca_005fnames"></span><dl>
<dt id="index-gnutls_005fcertificate_005ffree_005fca_005fnames">Function: <em>void</em> <strong>gnutls_certificate_free_ca_names</strong> <em>(gnutls_certificate_credentials_t <var>sc</var>)</em></dt>
<dd><p><var>sc</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p>This function will delete all the CA name in the given
credentials. Clients may call this to save some memory since in
client side the CA names are not used. Servers might want to use
this function if a large list of trusted CAs is present and
sending the names of it would just consume bandwidth without providing
information to client.
</p>
<p>CA names are used by servers to advertise the CAs they support to
clients.
</p></dd></dl>

<span id="gnutls_005fcertificate_005ffree_005fcas-1"></span><h4 class="subheading">gnutls_certificate_free_cas</h4>
<span id="gnutls_005fcertificate_005ffree_005fcas"></span><dl>
<dt id="index-gnutls_005fcertificate_005ffree_005fcas">Function: <em>void</em> <strong>gnutls_certificate_free_cas</strong> <em>(gnutls_certificate_credentials_t <var>sc</var>)</em></dt>
<dd><p><var>sc</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p>This function was operational on very early versions of gnutls.
Due to internal refactorings and the fact that this was hardly ever
used, it is currently a no-op.
</p></dd></dl>

<span id="gnutls_005fcertificate_005ffree_005fcredentials-1"></span><h4 class="subheading">gnutls_certificate_free_credentials</h4>
<span id="gnutls_005fcertificate_005ffree_005fcredentials"></span><dl>
<dt id="index-gnutls_005fcertificate_005ffree_005fcredentials">Function: <em>void</em> <strong>gnutls_certificate_free_credentials</strong> <em>(gnutls_certificate_credentials_t <var>sc</var>)</em></dt>
<dd><p><var>sc</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p>Free a gnutls_certificate_credentials_t structure.
</p>
<p>This function does not free any temporary parameters associated
with this structure (ie RSA and DH parameters are not freed by this
function).
</p></dd></dl>

<span id="gnutls_005fcertificate_005ffree_005fcrls-1"></span><h4 class="subheading">gnutls_certificate_free_crls</h4>
<span id="gnutls_005fcertificate_005ffree_005fcrls"></span><dl>
<dt id="index-gnutls_005fcertificate_005ffree_005fcrls">Function: <em>void</em> <strong>gnutls_certificate_free_crls</strong> <em>(gnutls_certificate_credentials_t <var>sc</var>)</em></dt>
<dd><p><var>sc</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p>This function will delete all the CRLs associated
with the given credentials.
</p></dd></dl>

<span id="gnutls_005fcertificate_005ffree_005fkeys-1"></span><h4 class="subheading">gnutls_certificate_free_keys</h4>
<span id="gnutls_005fcertificate_005ffree_005fkeys"></span><dl>
<dt id="index-gnutls_005fcertificate_005ffree_005fkeys">Function: <em>void</em> <strong>gnutls_certificate_free_keys</strong> <em>(gnutls_certificate_credentials_t <var>sc</var>)</em></dt>
<dd><p><var>sc</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p>This function will delete all the keys and the certificates associated
with the given credentials. This function must not be called when a
TLS negotiation that uses the credentials is in progress.
</p></dd></dl>

<span id="gnutls_005fcertificate_005fget_005fcrt_005fraw-1"></span><h4 class="subheading">gnutls_certificate_get_crt_raw</h4>
<span id="gnutls_005fcertificate_005fget_005fcrt_005fraw"></span><dl>
<dt id="index-gnutls_005fcertificate_005fget_005fcrt_005fraw">Function: <em>int</em> <strong>gnutls_certificate_get_crt_raw</strong> <em>(gnutls_certificate_credentials_t <var>sc</var>, unsigned <var>idx1</var>, unsigned <var>idx2</var>, gnutls_datum_t * <var>cert</var>)</em></dt>
<dd><p><var>sc</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>idx1</var>: the index of the certificate chain if multiple are present
</p>
<p><var>idx2</var>: the index of the certificate in the chain. Zero gives the server&rsquo;s certificate.
</p>
<p><var>cert</var>: Will hold the DER encoded certificate.
</p>
<p>This function will return the DER encoded certificate of the
server or any other certificate on its certificate chain (based on  <code>idx2</code> ).
The returned data should be treated as constant and only accessible during the lifetime
of  <code>sc</code> . The  <code>idx1</code> matches the value <code>gnutls_certificate_set_x509_key()</code>  and friends
functions.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value. In case the indexes are out of bounds <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
is returned.
</p>
<p><strong>Since:</strong> 3.2.5
</p></dd></dl>

<span id="gnutls_005fcertificate_005fget_005fissuer-1"></span><h4 class="subheading">gnutls_certificate_get_issuer</h4>
<span id="gnutls_005fcertificate_005fget_005fissuer"></span><dl>
<dt id="index-gnutls_005fcertificate_005fget_005fissuer">Function: <em>int</em> <strong>gnutls_certificate_get_issuer</strong> <em>(gnutls_certificate_credentials_t <var>sc</var>, gnutls_x509_crt_t <var>cert</var>, gnutls_x509_crt_t * <var>issuer</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>sc</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>cert</var>: is the certificate to find issuer for
</p>
<p><var>issuer</var>: Will hold the issuer if any. Should be treated as constant.
</p>
<p><var>flags</var>: Use zero or <code>GNUTLS_TL_GET_COPY</code> 
</p>
<p>This function will return the issuer of a given certificate.
If the flag <code>GNUTLS_TL_GET_COPY</code>  is specified a copy of the issuer
will be returned which must be freed using <code>gnutls_x509_crt_deinit()</code> .
In that case the provided  <code>issuer</code> must not be initialized.
</p>
<p>As with <code>gnutls_x509_trust_list_get_issuer()</code>  this function requires
the <code>GNUTLS_TL_GET_COPY</code>  flag in order to operate with PKCS<code>11</code>  trust
lists in a thread-safe way.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fcertificate_005fget_005focsp_005fexpiration-1"></span><h4 class="subheading">gnutls_certificate_get_ocsp_expiration</h4>
<span id="gnutls_005fcertificate_005fget_005focsp_005fexpiration"></span><dl>
<dt id="index-gnutls_005fcertificate_005fget_005focsp_005fexpiration-1">Function: <em>time_t</em> <strong>gnutls_certificate_get_ocsp_expiration</strong> <em>(gnutls_certificate_credentials_t <var>sc</var>, unsigned <var>idx</var>, int <var>oidx</var>, unsigned <var>flags</var>)</em></dt>
<dd><p><var>sc</var>: is a credentials structure.
</p>
<p><var>idx</var>: is a certificate chain index as returned by <code>gnutls_certificate_set_key()</code>  and friends
</p>
<p><var>oidx</var>: is an OCSP response index
</p>
<p><var>flags</var>: should be zero
</p>
<p>This function returns the validity of the loaded OCSP responses,
to provide information on when to reload/refresh them.
</p>
<p>Note that the credentials structure should be read-only when in
use, thus when reloading, either the credentials structure must not
be in use by any sessions, or a new credentials structure should be
allocated for new sessions.
</p>
<p>When  <code>oidx</code> is (-1) then the minimum refresh time for all responses
is returned. Otherwise the index specifies the response corresponding
to the  <code>odix</code> certificate in the certificate chain.
</p>
<p><strong>Returns:</strong> On success, the expiration time of the OCSP response. Otherwise
(time_t)(-1) on error, or (time_t)-2 on out of bounds.
</p>
<p><strong>Since:</strong> 3.6.3
</p></dd></dl>

<span id="gnutls_005fcertificate_005fget_005fours-1"></span><h4 class="subheading">gnutls_certificate_get_ours</h4>
<span id="gnutls_005fcertificate_005fget_005fours"></span><dl>
<dt id="index-gnutls_005fcertificate_005fget_005fours">Function: <em>const gnutls_datum_t *</em> <strong>gnutls_certificate_get_ours</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a gnutls session
</p>
<p>Gets the certificate as sent to the peer in the last handshake.
The certificate is in raw (DER) format.  No certificate
list is being returned. Only the first certificate.
</p>
<p>This function returns the certificate that was sent in the current
handshake. In subsequent resumed sessions this function will return
<code>NULL</code> . That differs from <code>gnutls_certificate_get_peers()</code>  which always
returns the peer&rsquo;s certificate used in the original session.
</p>
<p><strong>Returns:</strong> a pointer to a <code>gnutls_datum_t</code>  containing our
certificate, or <code>NULL</code>  in case of an error or if no certificate
was used.
</p></dd></dl>

<span id="gnutls_005fcertificate_005fget_005fpeers-1"></span><h4 class="subheading">gnutls_certificate_get_peers</h4>
<span id="gnutls_005fcertificate_005fget_005fpeers"></span><dl>
<dt id="index-gnutls_005fcertificate_005fget_005fpeers">Function: <em>const gnutls_datum_t *</em> <strong>gnutls_certificate_get_peers</strong> <em>(gnutls_session_t          <var>session</var>, unsigned int * <var>list_size</var>)</em></dt>
<dd><p><var>session</var>: is a gnutls session
</p>
<p><var>list_size</var>: is the length of the certificate list (may be <code>NULL</code> )
</p>
<p>Get the peer&rsquo;s raw certificate (chain) as sent by the peer.  These
certificates are in raw format (DER encoded for X.509).  In case of
a X.509 then a certificate list may be present.  The list
is provided as sent by the server; the server must send as first
certificate in the list its own certificate, following the
issuer&rsquo;s certificate, then the issuer&rsquo;s issuer etc. However, there
are servers which violate this principle and thus on certain
occasions this may be an unsorted list.
</p>
<p>In resumed sessions, this function will return the peer&rsquo;s certificate
list as used in the first/original session.
</p>
<p><strong>Returns:</strong> a pointer to a <code>gnutls_datum_t</code>  containing the peer&rsquo;s
certificates, or <code>NULL</code>  in case of an error or if no certificate
was used.
</p></dd></dl>

<span id="gnutls_005fcertificate_005fget_005fpeers_005fsubkey_005fid-1"></span><h4 class="subheading">gnutls_certificate_get_peers_subkey_id</h4>
<span id="gnutls_005fcertificate_005fget_005fpeers_005fsubkey_005fid"></span><dl>
<dt id="index-gnutls_005fcertificate_005fget_005fpeers_005fsubkey_005fid">Function: <em>int</em> <strong>gnutls_certificate_get_peers_subkey_id</strong> <em>(gnutls_session_t <var>session</var>, gnutls_datum_t * <var>id</var>)</em></dt>
<dd><p><var>session</var>: is a gnutls session
</p>
<p><var>id</var>: will contain the ID
</p>
<p>This function is no-op.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_UNIMPLEMENTED_FEATURE</code> .
</p>
<p><strong>Since:</strong> 3.1.3
</p></dd></dl>

<span id="gnutls_005fcertificate_005fget_005fverify_005fflags-1"></span><h4 class="subheading">gnutls_certificate_get_verify_flags</h4>
<span id="gnutls_005fcertificate_005fget_005fverify_005fflags"></span><dl>
<dt id="index-gnutls_005fcertificate_005fget_005fverify_005fflags">Function: <em>unsigned int</em> <strong>gnutls_certificate_get_verify_flags</strong> <em>(gnutls_certificate_credentials_t <var>res</var>)</em></dt>
<dd><p><var>res</var>: is a gnutls_certificate_credentials_t type
</p>
<p>Returns the verification flags set with
<code>gnutls_certificate_set_verify_flags()</code> .
</p>
<p><strong>Returns:</strong> The certificate verification flags used by  <code>res</code> .
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fcertificate_005fget_005fx509_005fcrt-1"></span><h4 class="subheading">gnutls_certificate_get_x509_crt</h4>
<span id="gnutls_005fcertificate_005fget_005fx509_005fcrt"></span><dl>
<dt id="index-gnutls_005fcertificate_005fget_005fx509_005fcrt">Function: <em>int</em> <strong>gnutls_certificate_get_x509_crt</strong> <em>(gnutls_certificate_credentials_t <var>res</var>, unsigned <var>index</var>, gnutls_x509_crt_t ** <var>crt_list</var>, unsigned * <var>crt_list_size</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>index</var>: The index of the certificate list to obtain.
</p>
<p><var>crt_list</var>: Where to store the certificate list.
</p>
<p><var>crt_list_size</var>: Will hold the number of certificates.
</p>
<p>Obtains a X.509 certificate list that has been stored in  <code>res</code> with one of
<code>gnutls_certificate_set_x509_key()</code> , <code>gnutls_certificate_set_key()</code> ,
<code>gnutls_certificate_set_x509_key_file()</code> ,
<code>gnutls_certificate_set_x509_key_file2()</code> ,
<code>gnutls_certificate_set_x509_key_mem()</code> , or
<code>gnutls_certificate_set_x509_key_mem2()</code> . Each certificate in the returned
certificate list must be deallocated with <code>gnutls_x509_crt_deinit()</code> , and the
list itself must be freed with <code>gnutls_free()</code> .
</p>
<p>The  <code>index</code> matches the return value of <code>gnutls_certificate_set_x509_key()</code>  and friends
functions, when the <code>GNUTLS_CERTIFICATE_API_V2</code>  flag is set.
</p>
<p>If there is no certificate with the given index,
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  is returned. If the certificate
with the given index is not a X.509 certificate, <code>GNUTLS_E_INVALID_REQUEST</code> 
is returned. The returned certificates must be deinitialized after
use, and the  <code>crt_list</code> pointer must be freed using <code>gnutls_free()</code> .
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  (0) on success, or a negative error code.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fcertificate_005fget_005fx509_005fkey-1"></span><h4 class="subheading">gnutls_certificate_get_x509_key</h4>
<span id="gnutls_005fcertificate_005fget_005fx509_005fkey"></span><dl>
<dt id="index-gnutls_005fcertificate_005fget_005fx509_005fkey">Function: <em>int</em> <strong>gnutls_certificate_get_x509_key</strong> <em>(gnutls_certificate_credentials_t <var>res</var>, unsigned <var>index</var>, gnutls_x509_privkey_t * <var>key</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>index</var>: The index of the key to obtain.
</p>
<p><var>key</var>: Location to store the key.
</p>
<p>Obtains a X.509 private key that has been stored in  <code>res</code> with one of
<code>gnutls_certificate_set_x509_key()</code> , <code>gnutls_certificate_set_key()</code> ,
<code>gnutls_certificate_set_x509_key_file()</code> ,
<code>gnutls_certificate_set_x509_key_file2()</code> ,
<code>gnutls_certificate_set_x509_key_mem()</code> , or
<code>gnutls_certificate_set_x509_key_mem2()</code> . The returned key must be deallocated
with <code>gnutls_x509_privkey_deinit()</code>  when no longer needed.
</p>
<p>The  <code>index</code> matches the return value of <code>gnutls_certificate_set_x509_key()</code>  and friends
functions, when the <code>GNUTLS_CERTIFICATE_API_V2</code>  flag is set.
</p>
<p>If there is no key with the given index,
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  is returned. If the key with the
given index is not a X.509 key, <code>GNUTLS_E_INVALID_REQUEST</code>  is returned.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  (0) on success, or a negative error code.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fcertificate_005fsend_005fx509_005frdn_005fsequence-1"></span><h4 class="subheading">gnutls_certificate_send_x509_rdn_sequence</h4>
<span id="gnutls_005fcertificate_005fsend_005fx509_005frdn_005fsequence"></span><dl>
<dt id="index-gnutls_005fcertificate_005fsend_005fx509_005frdn_005fsequence-1">Function: <em>void</em> <strong>gnutls_certificate_send_x509_rdn_sequence</strong> <em>(gnutls_session_t <var>session</var>, int <var>status</var>)</em></dt>
<dd><p><var>session</var>: a <code>gnutls_session_t</code>  type.
</p>
<p><var>status</var>: is 0 or 1
</p>
<p>If status is non zero, this function will order gnutls not to send
the rdnSequence in the certificate request message. That is the
server will not advertise its trusted CAs to the peer. If status
is zero then the default behaviour will take effect, which is to
advertise the server&rsquo;s trusted CAs.
</p>
<p>This function has no effect in clients, and in authentication
methods other than certificate with X.509 certificates.
</p></dd></dl>

<span id="gnutls_005fcertificate_005fserver_005fset_005frequest-1"></span><h4 class="subheading">gnutls_certificate_server_set_request</h4>
<span id="gnutls_005fcertificate_005fserver_005fset_005frequest"></span><dl>
<dt id="index-gnutls_005fcertificate_005fserver_005fset_005frequest-1">Function: <em>void</em> <strong>gnutls_certificate_server_set_request</strong> <em>(gnutls_session_t <var>session</var>, gnutls_certificate_request_t <var>req</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>req</var>: is one of GNUTLS_CERT_REQUEST, GNUTLS_CERT_REQUIRE, GNUTLS_CERT_IGNORE
</p>
<p>This function specifies if we (in case of a server) are going to
send a certificate request message to the client. If  <code>req</code> is
GNUTLS_CERT_REQUIRE then the server will return the <code>GNUTLS_E_NO_CERTIFICATE_FOUND</code> 
error if the peer does not provide a certificate. If you do not call this
function then the client will not be asked to send a certificate. Invoking
the function with  <code>req</code> GNUTLS_CERT_IGNORE has the same effect.
</p></dd></dl>

<span id="gnutls_005fcertificate_005fset_005fdh_005fparams-1"></span><h4 class="subheading">gnutls_certificate_set_dh_params</h4>
<span id="gnutls_005fcertificate_005fset_005fdh_005fparams"></span><dl>
<dt id="index-gnutls_005fcertificate_005fset_005fdh_005fparams">Function: <em>void</em> <strong>gnutls_certificate_set_dh_params</strong> <em>(gnutls_certificate_credentials_t <var>res</var>, gnutls_dh_params_t <var>dh_params</var>)</em></dt>
<dd><p><var>res</var>: is a gnutls_certificate_credentials_t type
</p>
<p><var>dh_params</var>: the Diffie-Hellman parameters.
</p>
<p>This function will set the Diffie-Hellman parameters for a
certificate server to use. These parameters will be used in
Ephemeral Diffie-Hellman cipher suites.  Note that only a pointer
to the parameters are stored in the certificate handle, so you
must not deallocate the parameters before the certificate is deallocated.
</p>
<p><strong>Deprecated:</strong> This function is unnecessary and discouraged on GnuTLS 3.6.0
or later. Since 3.6.0, DH parameters are negotiated
following RFC7919.
</p></dd></dl>

<span id="gnutls_005fcertificate_005fset_005fflags-1"></span><h4 class="subheading">gnutls_certificate_set_flags</h4>
<span id="gnutls_005fcertificate_005fset_005fflags"></span><dl>
<dt id="index-gnutls_005fcertificate_005fset_005fflags">Function: <em>void</em> <strong>gnutls_certificate_set_flags</strong> <em>(gnutls_certificate_credentials_t <var>res</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>res</var>: is a gnutls_certificate_credentials_t type
</p>
<p><var>flags</var>: are the flags of <code>gnutls_certificate_flags</code>  type
</p>
<p>This function will set flags to tweak the operation of
the credentials structure. See the <code>gnutls_certificate_flags</code>  enumerations
for more information on the available flags. 
</p>
<p><strong>Since:</strong> 3.4.7
</p></dd></dl>

<span id="gnutls_005fcertificate_005fset_005fknown_005fdh_005fparams-1"></span><h4 class="subheading">gnutls_certificate_set_known_dh_params</h4>
<span id="gnutls_005fcertificate_005fset_005fknown_005fdh_005fparams"></span><dl>
<dt id="index-gnutls_005fcertificate_005fset_005fknown_005fdh_005fparams">Function: <em>int</em> <strong>gnutls_certificate_set_known_dh_params</strong> <em>(gnutls_certificate_credentials_t <var>res</var>, gnutls_sec_param_t <var>sec_param</var>)</em></dt>
<dd><p><var>res</var>: is a gnutls_certificate_credentials_t type
</p>
<p><var>sec_param</var>: is an option of the <code>gnutls_sec_param_t</code>  enumeration
</p>
<p>This function will set the Diffie-Hellman parameters for a
certificate server to use. These parameters will be used in
Ephemeral Diffie-Hellman cipher suites and will be selected from
the FFDHE set of RFC7919 according to the security level provided.
</p>
<p><strong>Deprecated:</strong> This function is unnecessary and discouraged on GnuTLS 3.6.0
or later. Since 3.6.0, DH parameters are negotiated
following RFC7919.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.5.6
</p></dd></dl>

<span id="gnutls_005fcertificate_005fset_005focsp_005fstatus_005frequest_005ffile-1"></span><h4 class="subheading">gnutls_certificate_set_ocsp_status_request_file</h4>
<span id="gnutls_005fcertificate_005fset_005focsp_005fstatus_005frequest_005ffile"></span><dl>
<dt id="index-gnutls_005fcertificate_005fset_005focsp_005fstatus_005frequest_005ffile">Function: <em>int</em> <strong>gnutls_certificate_set_ocsp_status_request_file</strong> <em>(gnutls_certificate_credentials_t <var>sc</var>, const char * <var>response_file</var>, unsigned <var>idx</var>)</em></dt>
<dd><p><var>sc</var>: is a credentials structure.
</p>
<p><var>response_file</var>: a filename of the OCSP response
</p>
<p><var>idx</var>: is a certificate index as returned by <code>gnutls_certificate_set_key()</code>  and friends
</p>
<p>This function loads the provided OCSP response. It will be
sent to the client if requests an OCSP certificate status for
the certificate chain specified by  <code>idx</code> .
</p>
<p><strong>Note:</strong> the ability to set multiple OCSP responses per credential
structure via the index  <code>idx</code> was added in version 3.5.6. To keep
backwards compatibility, it requires using <code>gnutls_certificate_set_flags()</code> 
with the <code>GNUTLS_CERTIFICATE_API_V2</code>  flag to make the set certificate
functions return an index usable by this function.
</p>
<p>This function can be called multiple times since GnuTLS 3.6.3
when multiple responses which apply to the chain are available.
If the response provided does not match any certificates present
in the chain, the code <code>GNUTLS_E_OCSP_MISMATCH_WITH_CERTS</code>  is returned.
To revert to the previous behavior set the flag <code>GNUTLS_CERTIFICATE_SKIP_OCSP_RESPONSE_CHECK</code> 
in the certificate credentials structure. In that case, only the
end-certificate&rsquo;s OCSP response can be set.
If the response is already expired at the time of loading the code
<code>GNUTLS_E_EXPIRED</code>  is returned.
</p>
<p>To revert to the previous behavior of this function which does not return
any errors, set the flag <code>GNUTLS_CERTIFICATE_SKIP_OCSP_RESPONSE_CHECK</code> 
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p>
<p><strong>Since:</strong> 3.1.3
</p></dd></dl>

<span id="gnutls_005fcertificate_005fset_005focsp_005fstatus_005frequest_005ffile2-1"></span><h4 class="subheading">gnutls_certificate_set_ocsp_status_request_file2</h4>
<span id="gnutls_005fcertificate_005fset_005focsp_005fstatus_005frequest_005ffile2"></span><dl>
<dt id="index-gnutls_005fcertificate_005fset_005focsp_005fstatus_005frequest_005ffile2">Function: <em>int</em> <strong>gnutls_certificate_set_ocsp_status_request_file2</strong> <em>(gnutls_certificate_credentials_t <var>sc</var>, const char * <var>response_file</var>, unsigned <var>idx</var>, gnutls_x509_crt_fmt_t <var>fmt</var>)</em></dt>
<dd><p><var>sc</var>: is a credentials structure.
</p>
<p><var>response_file</var>: a filename of the OCSP response
</p>
<p><var>idx</var>: is a certificate index as returned by <code>gnutls_certificate_set_key()</code>  and friends
</p>
<p><var>fmt</var>: is PEM or DER
</p>
<p>This function loads the OCSP responses to be sent to the
peer for the certificate chain specified by  <code>idx</code> . When  <code>fmt</code> is
set to PEM, multiple responses can be loaded.
</p>
<p>This function must be called after setting any certificates, and
cannot be used for certificates that are provided via a callback &ndash;
that is when <code>gnutls_certificate_set_retrieve_function()</code>  is used. In
that case consider using <code>gnutls_certificate_set_retrieve_function3()</code> .
</p>
<p>This function can be called multiple times when multiple responses
applicable to the certificate chain are available.
If the response provided does not match any certificates present
in the chain, the code <code>GNUTLS_E_OCSP_MISMATCH_WITH_CERTS</code>  is returned.
If the response is already expired at the time of loading the code
<code>GNUTLS_E_EXPIRED</code>  is returned.
</p>
<p><strong>Returns:</strong> On success, the number of loaded responses is returned,
otherwise a negative error code.
</p>
<p><strong>Since:</strong> 3.1.3
</p></dd></dl>

<span id="gnutls_005fcertificate_005fset_005focsp_005fstatus_005frequest_005ffunction-1"></span><h4 class="subheading">gnutls_certificate_set_ocsp_status_request_function</h4>
<span id="gnutls_005fcertificate_005fset_005focsp_005fstatus_005frequest_005ffunction"></span><dl>
<dt id="index-gnutls_005fcertificate_005fset_005focsp_005fstatus_005frequest_005ffunction">Function: <em>void</em> <strong>gnutls_certificate_set_ocsp_status_request_function</strong> <em>(gnutls_certificate_credentials_t <var>sc</var>, gnutls_status_request_ocsp_func <var>ocsp_func</var>, void * <var>ptr</var>)</em></dt>
<dd><p><var>sc</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>ocsp_func</var>: function pointer to OCSP status request callback.
</p>
<p><var>ptr</var>: opaque pointer passed to callback function
</p>
<p>This function is to be used by server to register a callback to
handle OCSP status requests from the client.  The callback will be
invoked if the client supplied a status-request OCSP extension.
The callback function prototype is:
</p>
<p>typedef int (*gnutls_status_request_ocsp_func)
(gnutls_session_t session, void *ptr, gnutls_datum_t *ocsp_response);
</p>
<p>The callback will be invoked if the client requests an OCSP certificate
status.  The callback may return <code>GNUTLS_E_NO_CERTIFICATE_STATUS</code> , if
there is no recent OCSP response. If the callback returns <code>GNUTLS_E_SUCCESS</code> ,
it is expected to have the  <code>ocsp_response</code> field set with a valid (DER-encoded)
OCSP response. The response must be a value allocated using <code>gnutls_malloc()</code> ,
and will be deinitialized by the caller.
</p>
<p>It is possible to set a specific callback for each provided certificate
using <code>gnutls_certificate_set_ocsp_status_request_function2()</code> .
</p>
<p><strong>Since:</strong> 3.1.3
</p></dd></dl>

<span id="gnutls_005fcertificate_005fset_005focsp_005fstatus_005frequest_005ffunction2-1"></span><h4 class="subheading">gnutls_certificate_set_ocsp_status_request_function2</h4>
<span id="gnutls_005fcertificate_005fset_005focsp_005fstatus_005frequest_005ffunction2"></span><dl>
<dt id="index-gnutls_005fcertificate_005fset_005focsp_005fstatus_005frequest_005ffunction2">Function: <em>int</em> <strong>gnutls_certificate_set_ocsp_status_request_function2</strong> <em>(gnutls_certificate_credentials_t <var>sc</var>, unsigned <var>idx</var>, gnutls_status_request_ocsp_func <var>ocsp_func</var>, void * <var>ptr</var>)</em></dt>
<dd><p><var>sc</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>idx</var>: is a certificate index as returned by <code>gnutls_certificate_set_key()</code>  and friends
</p>
<p><var>ocsp_func</var>: function pointer to OCSP status request callback.
</p>
<p><var>ptr</var>: opaque pointer passed to callback function
</p>
<p>This function is to be used by server to register a callback to
provide OCSP status requests that correspond to the indexed certificate chain
from the client.  The callback will be invoked if the client supplied a
status-request OCSP extension.
</p>
<p>The callback function prototype is:
</p>
<p>typedef int (*gnutls_status_request_ocsp_func)
(gnutls_session_t session, void *ptr, gnutls_datum_t *ocsp_response);
</p>
<p>The callback will be invoked if the client requests an OCSP certificate
status.  The callback may return <code>GNUTLS_E_NO_CERTIFICATE_STATUS</code> , if
there is no recent OCSP response. If the callback returns <code>GNUTLS_E_SUCCESS</code> ,
it is expected to have the  <code>ocsp_response</code> field set with a valid (DER-encoded)
OCSP response. The response must be a value allocated using <code>gnutls_malloc()</code> ,
and will be deinitialized by the caller.
</p>
<p><strong>Note:</strong> the ability to set multiple OCSP responses per credential
structure via the index  <code>idx</code> was added in version 3.5.6. To keep
backwards compatibility, it requires using <code>gnutls_certificate_set_flags()</code> 
with the <code>GNUTLS_CERTIFICATE_API_V2</code>  flag to make the set certificate
functions return an index usable by this function.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p>
<p><strong>Since:</strong> 3.5.5
</p></dd></dl>

<span id="gnutls_005fcertificate_005fset_005focsp_005fstatus_005frequest_005fmem-1"></span><h4 class="subheading">gnutls_certificate_set_ocsp_status_request_mem</h4>
<span id="gnutls_005fcertificate_005fset_005focsp_005fstatus_005frequest_005fmem"></span><dl>
<dt id="index-gnutls_005fcertificate_005fset_005focsp_005fstatus_005frequest_005fmem">Function: <em>int</em> <strong>gnutls_certificate_set_ocsp_status_request_mem</strong> <em>(gnutls_certificate_credentials_t <var>sc</var>, const gnutls_datum_t * <var>resp_data</var>, unsigned <var>idx</var>, gnutls_x509_crt_fmt_t <var>fmt</var>)</em></dt>
<dd><p><var>sc</var>: is a credentials structure.
</p>
<p><var>resp_data</var>: a memory buffer holding an OCSP response
</p>
<p><var>idx</var>: is a certificate index as returned by <code>gnutls_certificate_set_key()</code>  and friends
</p>
<p><var>fmt</var>: is PEM or DER
</p>
<p>This function sets the OCSP responses to be sent to the
peer for the certificate chain specified by  <code>idx</code> . When  <code>fmt</code> is set
to PEM, multiple responses can be loaded.
</p>
<p><strong>Note:</strong> the ability to set multiple OCSP responses per credential
structure via the index  <code>idx</code> was added in version 3.5.6. To keep
backwards compatibility, it requires using <code>gnutls_certificate_set_flags()</code> 
with the <code>GNUTLS_CERTIFICATE_API_V2</code>  flag to make the set certificate
functions return an index usable by this function.
</p>
<p>This function must be called after setting any certificates, and
cannot be used for certificates that are provided via a callback &ndash;
that is when <code>gnutls_certificate_set_retrieve_function()</code>  is used.
</p>
<p>This function can be called multiple times when multiple responses which
apply to the certificate chain are available.
If the response provided does not match any certificates present
in the chain, the code <code>GNUTLS_E_OCSP_MISMATCH_WITH_CERTS</code>  is returned.
If the response is already expired at the time of loading the code
<code>GNUTLS_E_EXPIRED</code>  is returned.
</p>
<p><strong>Returns:</strong> On success, the number of loaded responses is returned,
otherwise a negative error code.
</p>
<p><strong>Since:</strong> 3.6.3
</p></dd></dl>

<span id="gnutls_005fcertificate_005fset_005fparams_005ffunction-1"></span><h4 class="subheading">gnutls_certificate_set_params_function</h4>
<span id="gnutls_005fcertificate_005fset_005fparams_005ffunction"></span><dl>
<dt id="index-gnutls_005fcertificate_005fset_005fparams_005ffunction">Function: <em>void</em> <strong>gnutls_certificate_set_params_function</strong> <em>(gnutls_certificate_credentials_t            <var>res</var>, gnutls_params_function * <var>func</var>)</em></dt>
<dd><p><var>res</var>: is a gnutls_certificate_credentials_t type
</p>
<p><var>func</var>: is the function to be called
</p>
<p>This function will set a callback in order for the server to get
the Diffie-Hellman or RSA parameters for certificate
authentication.  The callback should return <code>GNUTLS_E_SUCCESS</code>  (0) on success.
</p>
<p><strong>Deprecated:</strong> This function is unnecessary and discouraged on GnuTLS 3.6.0
or later. Since 3.6.0, DH parameters are negotiated
following RFC7919.
</p></dd></dl>

<span id="gnutls_005fcertificate_005fset_005fpin_005ffunction-1"></span><h4 class="subheading">gnutls_certificate_set_pin_function</h4>
<span id="gnutls_005fcertificate_005fset_005fpin_005ffunction"></span><dl>
<dt id="index-gnutls_005fcertificate_005fset_005fpin_005ffunction-1">Function: <em>void</em> <strong>gnutls_certificate_set_pin_function</strong> <em>(gnutls_certificate_credentials_t       <var>cred</var>, gnutls_pin_callback_t <var>fn</var>, void * <var>userdata</var>)</em></dt>
<dd><p><var>cred</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>fn</var>: A PIN callback
</p>
<p><var>userdata</var>: Data to be passed in the callback
</p>
<p>This function will set a callback function to be used when
required to access a protected object. This function overrides any other
global PIN functions.
</p>
<p>Note that this function must be called right after initialization
to have effect.
</p>
<p><strong>Since:</strong> 3.1.0
</p></dd></dl>

<span id="gnutls_005fcertificate_005fset_005frawpk_005fkey_005ffile-1"></span><h4 class="subheading">gnutls_certificate_set_rawpk_key_file</h4>
<span id="gnutls_005fcertificate_005fset_005frawpk_005fkey_005ffile"></span><dl>
<dt id="index-gnutls_005fcertificate_005fset_005frawpk_005fkey_005ffile">Function: <em>int</em> <strong>gnutls_certificate_set_rawpk_key_file</strong> <em>(gnutls_certificate_credentials_t <var>cred</var>, const char* <var>rawpkfile</var>, const char* <var>privkeyfile</var>, gnutls_x509_crt_fmt_t <var>format</var>, const char * <var>pass</var>, unsigned int <var>key_usage</var>, const char ** <var>names</var>, unsigned int <var>names_length</var>, unsigned int <var>privkey_flags</var>, unsigned int <var>pkcs11_flags</var>)</em></dt>
<dd><p><var>cred</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>rawpkfile</var>: contains a raw public key in
PKIX.SubjectPublicKeyInfo format.
</p>
<p><var>privkeyfile</var>: contains a file path to a private key.
</p>
<p><var>format</var>: encoding of the keys. DER or PEM.
</p>
<p><var>pass</var>: an optional password to unlock the private key privkeyfile.
</p>
<p><var>key_usage</var>: an ORed sequence of <code>GNUTLS_KEY_</code> * flags.
</p>
<p><var>names</var>: is an array of DNS names belonging to the public-key (NULL if none).
</p>
<p><var>names_length</var>: holds the length of the names list.
</p>
<p><var>privkey_flags</var>: an ORed sequence of <code>gnutls_pkcs_encrypt_flags_t</code> .
These apply to the private key pkey.
</p>
<p><var>pkcs11_flags</var>: one of gnutls_pkcs11_obj_flags. These apply to URLs.
</p>
<p>This function sets a public/private keypair read from file in the
<code>gnutls_certificate_credentials_t</code>  type to be used for authentication
and/or encryption.  <code>spki</code> and  <code>privkey</code> should match otherwise set
signatures cannot be validated. In case of no match this function
returns <code>GNUTLS_E_CERTIFICATE_KEY_MISMATCH</code> . This function should
be called once for the client because there is currently no mechanism
to determine which raw public-key to select for the peer when there
are multiple present. Multiple raw public keys for the server can be
distinghuished by setting the  <code>names</code> .
</p>
<p>Note here that  <code>spki</code> is a raw public-key as defined
in RFC7250. It means that there is no surrounding certificate that
holds the public key and that there is therefore no direct mechanism
to prove the authenticity of this key. The keypair can be used during
a TLS handshake but its authenticity should be established via a
different mechanism (e.g. TOFU or known fingerprint).
</p>
<p>The supported formats are basic unencrypted key, PKCS8, PKCS12,
and the openssl format and will be autodetected.
</p>
<p>If the raw public-key and the private key are given in PEM encoding
then the strings that hold their values must be null terminated.
</p>
<p>Key usage (as defined by X.509 extension (2.5.29.15)) can be explicitly
set because there is no certificate structure around the key to define
this value. See for more info <code>gnutls_x509_crt_get_key_usage()</code> .
</p>
<p>Note that, this function by default returns zero on success and a
negative value on error. Since 3.5.6, when the flag <code>GNUTLS_CERTIFICATE_API_V2</code> 
is set using <code>gnutls_certificate_set_flags()</code>  it returns an index
(greater or equal to zero). That index can be used in other functions
to refer to the added key-pair.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, in case the
key pair does not match <code>GNUTLS_E_CERTIFICATE_KEY_MISMATCH</code>  is returned,
in other erroneous cases a different negative error code is returned.
</p>
<p><strong>Since:</strong> 3.6.6
</p></dd></dl>

<span id="gnutls_005fcertificate_005fset_005frawpk_005fkey_005fmem-1"></span><h4 class="subheading">gnutls_certificate_set_rawpk_key_mem</h4>
<span id="gnutls_005fcertificate_005fset_005frawpk_005fkey_005fmem"></span><dl>
<dt id="index-gnutls_005fcertificate_005fset_005frawpk_005fkey_005fmem">Function: <em>int</em> <strong>gnutls_certificate_set_rawpk_key_mem</strong> <em>(gnutls_certificate_credentials_t <var>cred</var>, const gnutls_datum_t* <var>spki</var>, const gnutls_datum_t* <var>pkey</var>, gnutls_x509_crt_fmt_t <var>format</var>, const char* <var>pass</var>, unsigned int <var>key_usage</var>, const char ** <var>names</var>, unsigned int <var>names_length</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>cred</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>spki</var>: contains a raw public key in
PKIX.SubjectPublicKeyInfo format.
</p>
<p><var>pkey</var>: contains a raw private key.
</p>
<p><var>format</var>: encoding of the keys. DER or PEM.
</p>
<p><var>pass</var>: an optional password to unlock the private key pkey.
</p>
<p><var>key_usage</var>: An ORed sequence of <code>GNUTLS_KEY_</code> * flags.
</p>
<p><var>names</var>: is an array of DNS names belonging to the public-key (NULL if none).
</p>
<p><var>names_length</var>: holds the length of the names list.
</p>
<p><var>flags</var>: an ORed sequence of <code>gnutls_pkcs_encrypt_flags_t</code> .
These apply to the private key pkey.
</p>
<p>This function sets a public/private keypair in the
<code>gnutls_certificate_credentials_t</code>  type to be used for authentication
and/or encryption.  <code>spki</code> and  <code>privkey</code> should match otherwise set
signatures cannot be validated. In case of no match this function
returns <code>GNUTLS_E_CERTIFICATE_KEY_MISMATCH</code> . This function should
be called once for the client because there is currently no mechanism
to determine which raw public-key to select for the peer when there
are multiple present. Multiple raw public keys for the server can be
distinghuished by setting the  <code>names</code> .
</p>
<p>Note here that  <code>spki</code> is a raw public-key as defined
in RFC7250. It means that there is no surrounding certificate that
holds the public key and that there is therefore no direct mechanism
to prove the authenticity of this key. The keypair can be used during
a TLS handshake but its authenticity should be established via a
different mechanism (e.g. TOFU or known fingerprint).
</p>
<p>The supported formats are basic unencrypted key, PKCS8, PKCS12,
and the openssl format and will be autodetected.
</p>
<p>If the raw public-key and the private key are given in PEM encoding
then the strings that hold their values must be null terminated.
</p>
<p>Key usage (as defined by X.509 extension (2.5.29.15)) can be explicitly
set because there is no certificate structure around the key to define
this value. See for more info <code>gnutls_x509_crt_get_key_usage()</code> .
</p>
<p>Note that, this function by default returns zero on success and a
negative value on error. Since 3.5.6, when the flag <code>GNUTLS_CERTIFICATE_API_V2</code> 
is set using <code>gnutls_certificate_set_flags()</code>  it returns an index
(greater or equal to zero). That index can be used in other functions
to refer to the added key-pair.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, in case the
key pair does not match <code>GNUTLS_E_CERTIFICATE_KEY_MISMATCH</code>  is returned,
in other erroneous cases a different negative error code is returned.
</p>
<p><strong>Since:</strong> 3.6.6
</p></dd></dl>

<span id="gnutls_005fcertificate_005fset_005fretrieve_005ffunction-1"></span><h4 class="subheading">gnutls_certificate_set_retrieve_function</h4>
<span id="gnutls_005fcertificate_005fset_005fretrieve_005ffunction"></span><dl>
<dt id="index-gnutls_005fcertificate_005fset_005fretrieve_005ffunction">Function: <em>void</em> <strong>gnutls_certificate_set_retrieve_function</strong> <em>(gnutls_certificate_credentials_t <var>cred</var>, gnutls_certificate_retrieve_function * <var>func</var>)</em></dt>
<dd><p><var>cred</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>func</var>: is the callback function
</p>
<p>This function sets a callback to be called in order to retrieve the
certificate to be used in the handshake. The callback will take control
only if a certificate is requested by the peer. You are advised
to use <code>gnutls_certificate_set_retrieve_function2()</code>  because it
is much more efficient in the processing it requires from gnutls.
</p>
<p>The callback&rsquo;s function prototype is:
int (*callback)(gnutls_session_t, const gnutls_datum_t* req_ca_dn, int nreqs,
const gnutls_pk_algorithm_t* pk_algos, int pk_algos_length, gnutls_retr2_st* st);
</p>
<p><code>req_ca_dn</code> is only used in X.509 certificates.
Contains a list with the CA names that the server considers trusted.
This is a hint and typically the client should send a certificate that is signed
by one of these CAs. These names, when available, are DER encoded. To get a more
meaningful value use the function <code>gnutls_x509_rdn_get()</code> .
</p>
<p><code>pk_algos</code> contains a list with server&rsquo;s acceptable public key algorithms.
The certificate returned should support the server&rsquo;s given algorithms.
</p>
<p><code>st</code> should contain the certificates and private keys.
</p>
<p>If the callback function is provided then gnutls will call it, in the
handshake, after the certificate request message has been received.
</p>
<p>In server side pk_algos and req_ca_dn are NULL.
</p>
<p>The callback function should set the certificate list to be sent,
and return 0 on success. If no certificate was selected then the
number of certificates should be set to zero. The value (-1)
indicates error and the handshake will be terminated. If both certificates
are set in the credentials and a callback is available, the callback
takes predence.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fcertificate_005fset_005fverify_005fflags-1"></span><h4 class="subheading">gnutls_certificate_set_verify_flags</h4>
<span id="gnutls_005fcertificate_005fset_005fverify_005fflags"></span><dl>
<dt id="index-gnutls_005fcertificate_005fset_005fverify_005fflags">Function: <em>void</em> <strong>gnutls_certificate_set_verify_flags</strong> <em>(gnutls_certificate_credentials_t         <var>res</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>res</var>: is a gnutls_certificate_credentials_t type
</p>
<p><var>flags</var>: are the flags
</p>
<p>This function will set the flags to be used for verification 
of certificates and override any defaults.  The provided flags must be an OR of the
<code>gnutls_certificate_verify_flags</code>  enumerations. 
</p></dd></dl>

<span id="gnutls_005fcertificate_005fset_005fverify_005ffunction-1"></span><h4 class="subheading">gnutls_certificate_set_verify_function</h4>
<span id="gnutls_005fcertificate_005fset_005fverify_005ffunction"></span><dl>
<dt id="index-gnutls_005fcertificate_005fset_005fverify_005ffunction">Function: <em>void</em> <strong>gnutls_certificate_set_verify_function</strong> <em>(gnutls_certificate_credentials_t <var>cred</var>, gnutls_certificate_verify_function * <var>func</var>)</em></dt>
<dd><p><var>cred</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>func</var>: is the callback function
</p>
<p>This function sets a callback to be called when peer&rsquo;s certificate
has been received in order to verify it on receipt rather than
doing after the handshake is completed.
</p>
<p>The callback&rsquo;s function prototype is:
int (*callback)(gnutls_session_t);
</p>
<p>If the callback function is provided then gnutls will call it, in the
handshake, just after the certificate message has been received.
To verify or obtain the certificate the <code>gnutls_certificate_verify_peers2()</code> ,
<code>gnutls_certificate_type_get()</code> , <code>gnutls_certificate_get_peers()</code>  functions
can be used.
</p>
<p>The callback function should return 0 for the handshake to continue
or non-zero to terminate.
</p>
<p><strong>Since:</strong> 2.10.0
</p></dd></dl>

<span id="gnutls_005fcertificate_005fset_005fverify_005flimits-1"></span><h4 class="subheading">gnutls_certificate_set_verify_limits</h4>
<span id="gnutls_005fcertificate_005fset_005fverify_005flimits"></span><dl>
<dt id="index-gnutls_005fcertificate_005fset_005fverify_005flimits">Function: <em>void</em> <strong>gnutls_certificate_set_verify_limits</strong> <em>(gnutls_certificate_credentials_t <var>res</var>, unsigned int <var>max_bits</var>, unsigned int <var>max_depth</var>)</em></dt>
<dd><p><var>res</var>: is a gnutls_certificate_credentials type
</p>
<p><var>max_bits</var>: is the number of bits of an acceptable certificate (default 8200)
</p>
<p><var>max_depth</var>: is maximum depth of the verification of a certificate chain (default 5)
</p>
<p>This function will set some upper limits for the default
verification function, <code>gnutls_certificate_verify_peers2()</code> , to avoid
denial of service attacks.  You can set them to zero to disable
limits.
</p></dd></dl>

<span id="gnutls_005fcertificate_005fset_005fx509_005fcrl-1"></span><h4 class="subheading">gnutls_certificate_set_x509_crl</h4>
<span id="gnutls_005fcertificate_005fset_005fx509_005fcrl"></span><dl>
<dt id="index-gnutls_005fcertificate_005fset_005fx509_005fcrl">Function: <em>int</em> <strong>gnutls_certificate_set_x509_crl</strong> <em>(gnutls_certificate_credentials_t <var>res</var>, gnutls_x509_crl_t * <var>crl_list</var>, int <var>crl_list_size</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>crl_list</var>: is a list of trusted CRLs. They should have been verified before.
</p>
<p><var>crl_list_size</var>: holds the size of the crl_list
</p>
<p>This function adds the trusted CRLs in order to verify client or
server certificates.  In case of a client this is not required to
be called if the certificates are not verified using
<code>gnutls_certificate_verify_peers2()</code> .  This function may be called
multiple times.
</p>
<p><strong>Returns:</strong> number of CRLs processed, or a negative error code on error.
</p>
<p><strong>Since:</strong> 2.4.0
</p></dd></dl>

<span id="gnutls_005fcertificate_005fset_005fx509_005fcrl_005ffile-1"></span><h4 class="subheading">gnutls_certificate_set_x509_crl_file</h4>
<span id="gnutls_005fcertificate_005fset_005fx509_005fcrl_005ffile"></span><dl>
<dt id="index-gnutls_005fcertificate_005fset_005fx509_005fcrl_005ffile">Function: <em>int</em> <strong>gnutls_certificate_set_x509_crl_file</strong> <em>(gnutls_certificate_credentials_t <var>res</var>, const char * <var>crlfile</var>, gnutls_x509_crt_fmt_t <var>type</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>crlfile</var>: is a file containing the list of verified CRLs (DER or PEM list)
</p>
<p><var>type</var>: is PEM or DER
</p>
<p>This function adds the trusted CRLs in order to verify client or server
certificates.  In case of a client this is not required
to be called if the certificates are not verified using
<code>gnutls_certificate_verify_peers2()</code> .
This function may be called multiple times.
</p>
<p><strong>Returns:</strong> number of CRLs processed or a negative error code on error.
</p></dd></dl>

<span id="gnutls_005fcertificate_005fset_005fx509_005fcrl_005fmem-1"></span><h4 class="subheading">gnutls_certificate_set_x509_crl_mem</h4>
<span id="gnutls_005fcertificate_005fset_005fx509_005fcrl_005fmem"></span><dl>
<dt id="index-gnutls_005fcertificate_005fset_005fx509_005fcrl_005fmem">Function: <em>int</em> <strong>gnutls_certificate_set_x509_crl_mem</strong> <em>(gnutls_certificate_credentials_t <var>res</var>, const gnutls_datum_t * <var>CRL</var>, gnutls_x509_crt_fmt_t <var>type</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>CRL</var>: is a list of trusted CRLs. They should have been verified before.
</p>
<p><var>type</var>: is DER or PEM
</p>
<p>This function adds the trusted CRLs in order to verify client or
server certificates.  In case of a client this is not required to
be called if the certificates are not verified using
<code>gnutls_certificate_verify_peers2()</code> .  This function may be called
multiple times.
</p>
<p><strong>Returns:</strong> number of CRLs processed, or a negative error code on error.
</p></dd></dl>

<span id="gnutls_005fcertificate_005fset_005fx509_005fkey-1"></span><h4 class="subheading">gnutls_certificate_set_x509_key</h4>
<span id="gnutls_005fcertificate_005fset_005fx509_005fkey"></span><dl>
<dt id="index-gnutls_005fcertificate_005fset_005fx509_005fkey">Function: <em>int</em> <strong>gnutls_certificate_set_x509_key</strong> <em>(gnutls_certificate_credentials_t <var>res</var>, gnutls_x509_crt_t * <var>cert_list</var>, int <var>cert_list_size</var>, gnutls_x509_privkey_t <var>key</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>cert_list</var>: contains a certificate list (path) for the specified private key
</p>
<p><var>cert_list_size</var>: holds the size of the certificate list
</p>
<p><var>key</var>: is a <code>gnutls_x509_privkey_t</code>  key
</p>
<p>This function sets a certificate/private key pair in the
gnutls_certificate_credentials_t type.  This function may be
called more than once, in case multiple keys/certificates exist for
the server.  For clients that wants to send more than their own end
entity certificate (e.g., also an intermediate CA cert) then put
the certificate chain in  <code>cert_list</code> .
</p>
<p>Note that the certificates and keys provided, can be safely deinitialized
after this function is called.
</p>
<p>If that function fails to load the  <code>res</code> type is at an undefined state, it must
not be reused to load other keys or certificates.
</p>
<p>Note that, this function by default returns zero on success and a negative value on error.
Since 3.5.6, when the flag <code>GNUTLS_CERTIFICATE_API_V2</code>  is set using <code>gnutls_certificate_set_flags()</code> 
it returns an index (greater or equal to zero). That index can be used to other functions to refer to the added key-pair.
</p>
<p><strong>Returns:</strong> On success this functions returns zero, and otherwise a negative value on error (see above for modifying that behavior).
</p>
<p><strong>Since:</strong> 2.4.0
</p></dd></dl>

<span id="gnutls_005fcertificate_005fset_005fx509_005fkey_005ffile-1"></span><h4 class="subheading">gnutls_certificate_set_x509_key_file</h4>
<span id="gnutls_005fcertificate_005fset_005fx509_005fkey_005ffile"></span><dl>
<dt id="index-gnutls_005fcertificate_005fset_005fx509_005fkey_005ffile">Function: <em>int</em> <strong>gnutls_certificate_set_x509_key_file</strong> <em>(gnutls_certificate_credentials_t <var>res</var>, const char * <var>certfile</var>, const char * <var>keyfile</var>, gnutls_x509_crt_fmt_t <var>type</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>certfile</var>: is a file that containing the certificate list (path) for
the specified private key, in PKCS7 format, or a list of certificates
</p>
<p><var>keyfile</var>: is a file that contains the private key
</p>
<p><var>type</var>: is PEM or DER
</p>
<p>This function sets a certificate/private key pair in the
gnutls_certificate_credentials_t type.  This function may be
called more than once, in case multiple keys/certificates exist for
the server.  For clients that need to send more than its own end
entity certificate, e.g., also an intermediate CA cert, then the
 <code>certfile</code> must contain the ordered certificate chain.
</p>
<p>Note that the names in the certificate provided will be considered
when selecting the appropriate certificate to use (in case of multiple
certificate/key pairs).
</p>
<p>This function can also accept URLs at  <code>keyfile</code> and  <code>certfile</code> . In that case it
will use the private key and certificate indicated by the URLs. Note
that the supported URLs are the ones indicated by <code>gnutls_url_is_supported()</code> .
</p>
<p>In case the  <code>certfile</code> is provided as a PKCS <code>11</code>  URL, then the certificate, and its
present issuers in the token are imported (i.e., forming the required trust chain).
</p>
<p>If that function fails to load the  <code>res</code> structure is at an undefined state, it must
not be reused to load other keys or certificates.
</p>
<p>Note that, this function by default returns zero on success and a negative value on error.
Since 3.5.6, when the flag <code>GNUTLS_CERTIFICATE_API_V2</code>  is set using <code>gnutls_certificate_set_flags()</code> 
it returns an index (greater or equal to zero). That index can be used to other functions to refer to the added key-pair.
</p>
<p><strong>Returns:</strong> On success this functions returns zero, and otherwise a negative value on error (see above for modifying that behavior).
</p>
<p><strong>Since:</strong> 3.1.11
</p></dd></dl>

<span id="gnutls_005fcertificate_005fset_005fx509_005fkey_005ffile2-1"></span><h4 class="subheading">gnutls_certificate_set_x509_key_file2</h4>
<span id="gnutls_005fcertificate_005fset_005fx509_005fkey_005ffile2"></span><dl>
<dt id="index-gnutls_005fcertificate_005fset_005fx509_005fkey_005ffile2">Function: <em>int</em> <strong>gnutls_certificate_set_x509_key_file2</strong> <em>(gnutls_certificate_credentials_t <var>res</var>, const char * <var>certfile</var>, const char * <var>keyfile</var>, gnutls_x509_crt_fmt_t <var>type</var>, const char * <var>pass</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>certfile</var>: is a file that containing the certificate list (path) for
the specified private key, in PKCS7 format, or a list of certificates
</p>
<p><var>keyfile</var>: is a file that contains the private key
</p>
<p><var>type</var>: is PEM or DER
</p>
<p><var>pass</var>: is the password of the key
</p>
<p><var>flags</var>: an ORed sequence of gnutls_pkcs_encrypt_flags_t
</p>
<p>This function sets a certificate/private key pair in the
gnutls_certificate_credentials_t type.  This function may be
called more than once, in case multiple keys/certificates exist for
the server.  For clients that need to send more than its own end
entity certificate, e.g., also an intermediate CA cert, then the
 <code>certfile</code> must contain the ordered certificate chain.
</p>
<p>Note that the names in the certificate provided will be considered
when selecting the appropriate certificate to use (in case of multiple
certificate/key pairs).
</p>
<p>This function can also accept URLs at  <code>keyfile</code> and  <code>certfile</code> . In that case it
will use the private key and certificate indicated by the URLs. Note
that the supported URLs are the ones indicated by <code>gnutls_url_is_supported()</code> .
Before GnuTLS 3.4.0 when a URL was specified, the  <code>pass</code> part was ignored and a
PIN callback had to be registered, this is no longer the case in current releases.
</p>
<p>In case the  <code>certfile</code> is provided as a PKCS <code>11</code>  URL, then the certificate, and its
present issuers in the token are imported (i.e., forming the required trust chain).
</p>
<p>If that function fails to load the  <code>res</code> structure is at an undefined state, it must
not be reused to load other keys or certificates.
</p>
<p>Note that, this function by default returns zero on success and a negative value on error.
Since 3.5.6, when the flag <code>GNUTLS_CERTIFICATE_API_V2</code>  is set using <code>gnutls_certificate_set_flags()</code> 
it returns an index (greater or equal to zero). That index can be used to other functions to refer to the added key-pair.
</p>
<p><strong>Returns:</strong> On success this functions returns zero, and otherwise a negative value on error (see above for modifying that behavior).
</p></dd></dl>

<span id="gnutls_005fcertificate_005fset_005fx509_005fkey_005fmem-1"></span><h4 class="subheading">gnutls_certificate_set_x509_key_mem</h4>
<span id="gnutls_005fcertificate_005fset_005fx509_005fkey_005fmem"></span><dl>
<dt id="index-gnutls_005fcertificate_005fset_005fx509_005fkey_005fmem">Function: <em>int</em> <strong>gnutls_certificate_set_x509_key_mem</strong> <em>(gnutls_certificate_credentials_t <var>res</var>, const gnutls_datum_t * <var>cert</var>, const gnutls_datum_t * <var>key</var>, gnutls_x509_crt_fmt_t <var>type</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>cert</var>: contains a certificate list (path) for the specified private key
</p>
<p><var>key</var>: is the private key, or <code>NULL</code> 
</p>
<p><var>type</var>: is PEM or DER
</p>
<p>This function sets a certificate/private key pair in the
gnutls_certificate_credentials_t type. This function may be called
more than once, in case multiple keys/certificates exist for the
server.
</p>
<p>Note that the keyUsage (2.5.29.15) PKIX extension in X.509 certificates
is supported. This means that certificates intended for signing cannot
be used for ciphersuites that require encryption.
</p>
<p>If the certificate and the private key are given in PEM encoding
then the strings that hold their values must be null terminated.
</p>
<p>The  <code>key</code> may be <code>NULL</code>  if you are using a sign callback, see
<code>gnutls_sign_callback_set()</code> .
</p>
<p>Note that, this function by default returns zero on success and a negative value on error.
Since 3.5.6, when the flag <code>GNUTLS_CERTIFICATE_API_V2</code>  is set using <code>gnutls_certificate_set_flags()</code> 
it returns an index (greater or equal to zero). That index can be used to other functions to refer to the added key-pair.
</p>
<p><strong>Returns:</strong> On success this functions returns zero, and otherwise a negative value on error (see above for modifying that behavior).
</p></dd></dl>

<span id="gnutls_005fcertificate_005fset_005fx509_005fkey_005fmem2-1"></span><h4 class="subheading">gnutls_certificate_set_x509_key_mem2</h4>
<span id="gnutls_005fcertificate_005fset_005fx509_005fkey_005fmem2"></span><dl>
<dt id="index-gnutls_005fcertificate_005fset_005fx509_005fkey_005fmem2">Function: <em>int</em> <strong>gnutls_certificate_set_x509_key_mem2</strong> <em>(gnutls_certificate_credentials_t <var>res</var>, const gnutls_datum_t * <var>cert</var>, const gnutls_datum_t * <var>key</var>, gnutls_x509_crt_fmt_t <var>type</var>, const char * <var>pass</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>cert</var>: contains a certificate list (path) for the specified private key
</p>
<p><var>key</var>: is the private key, or <code>NULL</code> 
</p>
<p><var>type</var>: is PEM or DER
</p>
<p><var>pass</var>: is the key&rsquo;s password
</p>
<p><var>flags</var>: an ORed sequence of gnutls_pkcs_encrypt_flags_t
</p>
<p>This function sets a certificate/private key pair in the
gnutls_certificate_credentials_t type. This function may be called
more than once, in case multiple keys/certificates exist for the
server.
</p>
<p>Note that the keyUsage (2.5.29.15) PKIX extension in X.509 certificates
is supported. This means that certificates intended for signing cannot
be used for ciphersuites that require encryption.
</p>
<p>If the certificate and the private key are given in PEM encoding
then the strings that hold their values must be null terminated.
</p>
<p>The  <code>key</code> may be <code>NULL</code>  if you are using a sign callback, see
<code>gnutls_sign_callback_set()</code> .
</p>
<p>Note that, this function by default returns zero on success and a negative value on error.
Since 3.5.6, when the flag <code>GNUTLS_CERTIFICATE_API_V2</code>  is set using <code>gnutls_certificate_set_flags()</code> 
it returns an index (greater or equal to zero). That index can be used to other functions to refer to the added key-pair.
</p>
<p><strong>Returns:</strong> On success this functions returns zero, and otherwise a negative value on error (see above for modifying that behavior).
</p></dd></dl>

<span id="gnutls_005fcertificate_005fset_005fx509_005fsimple_005fpkcs12_005ffile-1"></span><h4 class="subheading">gnutls_certificate_set_x509_simple_pkcs12_file</h4>
<span id="gnutls_005fcertificate_005fset_005fx509_005fsimple_005fpkcs12_005ffile"></span><dl>
<dt id="index-gnutls_005fcertificate_005fset_005fx509_005fsimple_005fpkcs12_005ffile">Function: <em>int</em> <strong>gnutls_certificate_set_x509_simple_pkcs12_file</strong> <em>(gnutls_certificate_credentials_t <var>res</var>, const char * <var>pkcs12file</var>, gnutls_x509_crt_fmt_t <var>type</var>, const char * <var>password</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>pkcs12file</var>: filename of file containing PKCS<code>12</code>  blob.
</p>
<p><var>type</var>: is PEM or DER of the  <code>pkcs12file</code> .
</p>
<p><var>password</var>: optional password used to decrypt PKCS<code>12</code>  file, bags and keys.
</p>
<p>This function sets a certificate/private key pair and/or a CRL in
the gnutls_certificate_credentials_t type.  This function may
be called more than once (in case multiple keys/certificates exist
for the server).
</p>
<p>PKCS<code>12</code>  files with a MAC, encrypted bags and PKCS <code>8</code> 
private keys are supported. However,
only password based security, and the same password for all
operations, are supported.
</p>
<p>PKCS<code>12</code>  file may contain many keys and/or certificates, and this
function will try to auto-detect based on the key ID the certificate
and key pair to use. If the PKCS<code>12</code>  file contain the issuer of
the selected certificate, it will be appended to the certificate
to form a chain.
</p>
<p>If more than one private keys are stored in the PKCS<code>12</code>  file,
then only one key will be read (and it is undefined which one).
</p>
<p>It is believed that the limitations of this function is acceptable
for most usage, and that any more flexibility would introduce
complexity that would make it harder to use this functionality at
all.
</p>
<p>Note that, this function by default returns zero on success and a negative value on error.
Since 3.5.6, when the flag <code>GNUTLS_CERTIFICATE_API_V2</code>  is set using <code>gnutls_certificate_set_flags()</code> 
it returns an index (greater or equal to zero). That index can be used to other functions to refer to the added key-pair.
</p>
<p><strong>Returns:</strong> On success this functions returns zero, and otherwise a negative value on error (see above for modifying that behavior).
</p></dd></dl>

<span id="gnutls_005fcertificate_005fset_005fx509_005fsimple_005fpkcs12_005fmem-1"></span><h4 class="subheading">gnutls_certificate_set_x509_simple_pkcs12_mem</h4>
<span id="gnutls_005fcertificate_005fset_005fx509_005fsimple_005fpkcs12_005fmem"></span><dl>
<dt id="index-gnutls_005fcertificate_005fset_005fx509_005fsimple_005fpkcs12_005fmem">Function: <em>int</em> <strong>gnutls_certificate_set_x509_simple_pkcs12_mem</strong> <em>(gnutls_certificate_credentials_t <var>res</var>, const gnutls_datum_t * <var>p12blob</var>, gnutls_x509_crt_fmt_t <var>type</var>, const char * <var>password</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>p12blob</var>: the PKCS<code>12</code>  blob.
</p>
<p><var>type</var>: is PEM or DER of the  <code>pkcs12file</code> .
</p>
<p><var>password</var>: optional password used to decrypt PKCS<code>12</code>  file, bags and keys.
</p>
<p>This function sets a certificate/private key pair and/or a CRL in
the gnutls_certificate_credentials_t type.  This function may
be called more than once (in case multiple keys/certificates exist
for the server).
</p>
<p>Encrypted PKCS<code>12</code>  bags and PKCS<code>8</code>  private keys are supported.  However,
only password based security, and the same password for all
operations, are supported.
</p>
<p>PKCS<code>12</code>  file may contain many keys and/or certificates, and this
function will try to auto-detect based on the key ID the certificate
and key pair to use. If the PKCS<code>12</code>  file contain the issuer of
the selected certificate, it will be appended to the certificate
to form a chain.
</p>
<p>If more than one private keys are stored in the PKCS<code>12</code>  file,
then only one key will be read (and it is undefined which one).
</p>
<p>It is believed that the limitations of this function is acceptable
for most usage, and that any more flexibility would introduce
complexity that would make it harder to use this functionality at
all.
</p>
<p>Note that, this function by default returns zero on success and a negative value on error.
Since 3.5.6, when the flag <code>GNUTLS_CERTIFICATE_API_V2</code>  is set using <code>gnutls_certificate_set_flags()</code> 
it returns an index (greater or equal to zero). That index can be used to other functions to refer to the added key-pair.
</p>
<p><strong>Returns:</strong> On success this functions returns zero, and otherwise a negative value on error (see above for modifying that behavior).
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<span id="gnutls_005fcertificate_005fset_005fx509_005fsystem_005ftrust-1"></span><h4 class="subheading">gnutls_certificate_set_x509_system_trust</h4>
<span id="gnutls_005fcertificate_005fset_005fx509_005fsystem_005ftrust"></span><dl>
<dt id="index-gnutls_005fcertificate_005fset_005fx509_005fsystem_005ftrust-1">Function: <em>int</em> <strong>gnutls_certificate_set_x509_system_trust</strong> <em>(gnutls_certificate_credentials_t       <var>cred</var>)</em></dt>
<dd><p><var>cred</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p>This function adds the system&rsquo;s default trusted CAs in order to
verify client or server certificates.
</p>
<p>In the case the system is currently unsupported <code>GNUTLS_E_UNIMPLEMENTED_FEATURE</code> 
is returned.
</p>
<p><strong>Returns:</strong> the number of certificates processed or a negative error code
on error.
</p>
<p><strong>Since:</strong> 3.0.20
</p></dd></dl>

<span id="gnutls_005fcertificate_005fset_005fx509_005ftrust-1"></span><h4 class="subheading">gnutls_certificate_set_x509_trust</h4>
<span id="gnutls_005fcertificate_005fset_005fx509_005ftrust"></span><dl>
<dt id="index-gnutls_005fcertificate_005fset_005fx509_005ftrust">Function: <em>int</em> <strong>gnutls_certificate_set_x509_trust</strong> <em>(gnutls_certificate_credentials_t <var>res</var>, gnutls_x509_crt_t * <var>ca_list</var>, int <var>ca_list_size</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>ca_list</var>: is a list of trusted CAs
</p>
<p><var>ca_list_size</var>: holds the size of the CA list
</p>
<p>This function adds the trusted CAs in order to verify client
or server certificates. In case of a client this is not required
to be called if the certificates are not verified using
<code>gnutls_certificate_verify_peers2()</code> .
This function may be called multiple times.
</p>
<p>In case of a server the CAs set here will be sent to the client if
a certificate request is sent. This can be disabled using
<code>gnutls_certificate_send_x509_rdn_sequence()</code> .
</p>
<p><strong>Returns:</strong> the number of certificates processed or a negative error code
on error.
</p>
<p><strong>Since:</strong> 2.4.0
</p></dd></dl>

<span id="gnutls_005fcertificate_005fset_005fx509_005ftrust_005fdir-1"></span><h4 class="subheading">gnutls_certificate_set_x509_trust_dir</h4>
<span id="gnutls_005fcertificate_005fset_005fx509_005ftrust_005fdir"></span><dl>
<dt id="index-gnutls_005fcertificate_005fset_005fx509_005ftrust_005fdir">Function: <em>int</em> <strong>gnutls_certificate_set_x509_trust_dir</strong> <em>(gnutls_certificate_credentials_t <var>cred</var>, const char * <var>ca_dir</var>, gnutls_x509_crt_fmt_t <var>type</var>)</em></dt>
<dd><p><var>cred</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>ca_dir</var>: is a directory containing the list of trusted CAs (DER or PEM list)
</p>
<p><var>type</var>: is PEM or DER
</p>
<p>This function adds the trusted CAs present in the directory in order to
verify client or server certificates. This function is identical
to <code>gnutls_certificate_set_x509_trust_file()</code>  but loads all certificates
in a directory.
</p>
<p><strong>Returns:</strong> the number of certificates processed
</p>
<p><strong>Since:</strong> 3.3.6
</p></dd></dl>

<span id="gnutls_005fcertificate_005fset_005fx509_005ftrust_005ffile-1"></span><h4 class="subheading">gnutls_certificate_set_x509_trust_file</h4>
<span id="gnutls_005fcertificate_005fset_005fx509_005ftrust_005ffile"></span><dl>
<dt id="index-gnutls_005fcertificate_005fset_005fx509_005ftrust_005ffile">Function: <em>int</em> <strong>gnutls_certificate_set_x509_trust_file</strong> <em>(gnutls_certificate_credentials_t            <var>cred</var>, const char * <var>cafile</var>, gnutls_x509_crt_fmt_t <var>type</var>)</em></dt>
<dd><p><var>cred</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>cafile</var>: is a file containing the list of trusted CAs (DER or PEM list)
</p>
<p><var>type</var>: is PEM or DER
</p>
<p>This function adds the trusted CAs in order to verify client or
server certificates. In case of a client this is not required to
be called if the certificates are not verified using
<code>gnutls_certificate_verify_peers2()</code> .  This function may be called
multiple times.
</p>
<p>In case of a server the names of the CAs set here will be sent to
the client if a certificate request is sent. This can be disabled
using <code>gnutls_certificate_send_x509_rdn_sequence()</code> .
</p>
<p>This function can also accept URLs. In that case it
will import all certificates that are marked as trusted. Note
that the supported URLs are the ones indicated by <code>gnutls_url_is_supported()</code> .
</p>
<p><strong>Returns:</strong> the number of certificates processed
</p></dd></dl>

<span id="gnutls_005fcertificate_005fset_005fx509_005ftrust_005fmem-1"></span><h4 class="subheading">gnutls_certificate_set_x509_trust_mem</h4>
<span id="gnutls_005fcertificate_005fset_005fx509_005ftrust_005fmem"></span><dl>
<dt id="index-gnutls_005fcertificate_005fset_005fx509_005ftrust_005fmem">Function: <em>int</em> <strong>gnutls_certificate_set_x509_trust_mem</strong> <em>(gnutls_certificate_credentials_t <var>res</var>, const gnutls_datum_t * <var>ca</var>, gnutls_x509_crt_fmt_t <var>type</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>ca</var>: is a list of trusted CAs or a DER certificate
</p>
<p><var>type</var>: is DER or PEM
</p>
<p>This function adds the trusted CAs in order to verify client or
server certificates. In case of a client this is not required to be
called if the certificates are not verified using
<code>gnutls_certificate_verify_peers2()</code> .  This function may be called
multiple times.
</p>
<p>In case of a server the CAs set here will be sent to the client if
a certificate request is sent. This can be disabled using
<code>gnutls_certificate_send_x509_rdn_sequence()</code> .
</p>
<p><strong>Returns:</strong> the number of certificates processed or a negative error code
on error.
</p></dd></dl>

<span id="gnutls_005fcertificate_005ftype_005fget-1"></span><h4 class="subheading">gnutls_certificate_type_get</h4>
<span id="gnutls_005fcertificate_005ftype_005fget"></span><dl>
<dt id="index-gnutls_005fcertificate_005ftype_005fget">Function: <em>gnutls_certificate_type_t</em> <strong>gnutls_certificate_type_get</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>This function returns the type of the certificate that is negotiated
for this side to send to the peer. The certificate type is by default
X.509, unless an alternative certificate type is enabled by
<code>gnutls_init()</code>  and negotiated during the session.
</p>
<p>Resumed sessions will return the certificate type that was negotiated
and used in the original session.
</p>
<p>As of version 3.6.4 it is recommended to use
<code>gnutls_certificate_type_get2()</code>  which is more fine-grained.
</p>
<p><strong>Returns:</strong> the currently used <code>gnutls_certificate_type_t</code>  certificate
type as negotiated for &rsquo;our&rsquo; side of the connection.
</p></dd></dl>

<span id="gnutls_005fcertificate_005ftype_005fget2-1"></span><h4 class="subheading">gnutls_certificate_type_get2</h4>
<span id="gnutls_005fcertificate_005ftype_005fget2"></span><dl>
<dt id="index-gnutls_005fcertificate_005ftype_005fget2">Function: <em>gnutls_certificate_type_t</em> <strong>gnutls_certificate_type_get2</strong> <em>(gnutls_session_t <var>session</var>, gnutls_ctype_target_t <var>target</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>target</var>: is a <code>gnutls_ctype_target_t</code>  type.
</p>
<p>This function returns the type of the certificate that a side
is negotiated to use.  The certificate type is by default X.509,
unless an alternative certificate type is enabled by <code>gnutls_init()</code>  and
negotiated during the session.
</p>
<p>The  <code>target</code> parameter specifies whether to request the negotiated
certificate type for the client (<code>GNUTLS_CTYPE_CLIENT</code> ),
or for the server (<code>GNUTLS_CTYPE_SERVER</code> ). Additionally, in P2P mode
connection set up where you don&rsquo;t know in advance who will be client
and who will be server you can use the flag (<code>GNUTLS_CTYPE_OURS</code> ) and
(<code>GNUTLS_CTYPE_PEERS</code> ) to retrieve the corresponding certificate types.
</p>
<p>Resumed sessions will return the certificate type that was negotiated
and used in the original session. That is, this function can be used
to reliably determine the type of the certificate returned by
<code>gnutls_certificate_get_peers()</code> .
</p>
<p><strong>Returns:</strong> the currently used <code>gnutls_certificate_type_t</code>  certificate
type for the client or the server.
</p>
<p><strong>Since:</strong> 3.6.4
</p></dd></dl>

<span id="gnutls_005fcertificate_005ftype_005fget_005fid-1"></span><h4 class="subheading">gnutls_certificate_type_get_id</h4>
<span id="gnutls_005fcertificate_005ftype_005fget_005fid"></span><dl>
<dt id="index-gnutls_005fcertificate_005ftype_005fget_005fid">Function: <em>gnutls_certificate_type_t</em> <strong>gnutls_certificate_type_get_id</strong> <em>(const char * <var>name</var>)</em></dt>
<dd><p><var>name</var>: is a certificate type name
</p>
<p>The names are compared in a case insensitive way.
</p>
<p><strong>Returns:</strong> a <code>gnutls_certificate_type_t</code>  for the specified in a
string certificate type, or <code>GNUTLS_CRT_UNKNOWN</code>  on error.
</p></dd></dl>

<span id="gnutls_005fcertificate_005ftype_005fget_005fname-1"></span><h4 class="subheading">gnutls_certificate_type_get_name</h4>
<span id="gnutls_005fcertificate_005ftype_005fget_005fname"></span><dl>
<dt id="index-gnutls_005fcertificate_005ftype_005fget_005fname">Function: <em>const char *</em> <strong>gnutls_certificate_type_get_name</strong> <em>(gnutls_certificate_type_t           <var>type</var>)</em></dt>
<dd><p><var>type</var>: is a certificate type
</p>
<p>Convert a <code>gnutls_certificate_type_t</code>  type to a string.
</p>
<p><strong>Returns:</strong> a string that contains the name of the specified
certificate type, or <code>NULL</code>  in case of unknown types.
</p></dd></dl>

<span id="gnutls_005fcertificate_005ftype_005flist-1"></span><h4 class="subheading">gnutls_certificate_type_list</h4>
<span id="gnutls_005fcertificate_005ftype_005flist"></span><dl>
<dt id="index-gnutls_005fcertificate_005ftype_005flist">Function: <em>const gnutls_certificate_type_t *</em> <strong>gnutls_certificate_type_list</strong> <em>( <var>void</var>)</em></dt>
<dd>
<p>Get a list of certificate types.
</p>
<p><strong>Returns:</strong> a (0)-terminated list of <code>gnutls_certificate_type_t</code> 
integers indicating the available certificate types.
</p></dd></dl>

<span id="gnutls_005fcertificate_005fverification_005fstatus_005fprint-1"></span><h4 class="subheading">gnutls_certificate_verification_status_print</h4>
<span id="gnutls_005fcertificate_005fverification_005fstatus_005fprint"></span><dl>
<dt id="index-gnutls_005fcertificate_005fverification_005fstatus_005fprint">Function: <em>int</em> <strong>gnutls_certificate_verification_status_print</strong> <em>(unsigned int <var>status</var>, gnutls_certificate_type_t           <var>type</var>, gnutls_datum_t * <var>out</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>status</var>: The status flags to be printed
</p>
<p><var>type</var>: The certificate type
</p>
<p><var>out</var>: Newly allocated datum with (0) terminated string.
</p>
<p><var>flags</var>: should be zero
</p>
<p>This function will pretty print the status of a verification
process &ndash; eg. the one obtained by <code>gnutls_certificate_verify_peers3()</code> .
</p>
<p>The output  <code>out</code> needs to be deallocated using <code>gnutls_free()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.1.4
</p></dd></dl>

<span id="gnutls_005fcertificate_005fverify_005fpeers-1"></span><h4 class="subheading">gnutls_certificate_verify_peers</h4>
<span id="gnutls_005fcertificate_005fverify_005fpeers"></span><dl>
<dt id="index-gnutls_005fcertificate_005fverify_005fpeers">Function: <em>int</em> <strong>gnutls_certificate_verify_peers</strong> <em>(gnutls_session_t <var>session</var>, gnutls_typed_vdata_st * <var>data</var>, unsigned int <var>elements</var>, unsigned int * <var>status</var>)</em></dt>
<dd><p><var>session</var>: is a gnutls session
</p>
<p><var>data</var>: an array of typed data
</p>
<p><var>elements</var>: the number of data elements
</p>
<p><var>status</var>: is the output of the verification
</p>
<p>This function will verify the peer&rsquo;s certificate and store the
the status in the  <code>status</code> variable as a bitwise OR of gnutls_certificate_status_t
values or zero if the certificate is trusted. Note that value in  <code>status</code> is set only when the return value of this function is success (i.e, failure 
to trust a certificate does not imply a negative return value).
The default verification flags used by this function can be overridden
using <code>gnutls_certificate_set_verify_flags()</code> . See the documentation
of <code>gnutls_certificate_verify_peers2()</code>  for details in the verification process.
</p>
<p>This function will take into account the stapled OCSP responses sent by the server,
as well as the following X.509 certificate extensions: Name Constraints,
Key Usage, and Basic Constraints (pathlen).
</p>
<p>The acceptable  <code>data</code> types are <code>GNUTLS_DT_DNS_HOSTNAME</code> , <code>GNUTLS_DT_RFC822NAME</code>  and <code>GNUTLS_DT_KEY_PURPOSE_OID</code> .
The former two accept as data a null-terminated hostname or email address, and the latter a null-terminated
object identifier (e.g., <code>GNUTLS_KP_TLS_WWW_SERVER</code> ).
</p>
<p>If a DNS hostname is provided then this function will compare
the hostname in the certificate against the given. If names do not match the 
<code>GNUTLS_CERT_UNEXPECTED_OWNER</code>  status flag will be set.
If a key purpose OID is provided and the end-certificate contains the extended key
usage PKIX extension, it will be required to be have the provided key purpose 
or be marked for any purpose, otherwise verification status will have the
<code>GNUTLS_CERT_SIGNER_CONSTRAINTS_FAILURE</code>  flag set.
</p>
<p>To avoid denial of service attacks some
default upper limits regarding the certificate key size and chain
size are set. To override them use <code>gnutls_certificate_set_verify_limits()</code> .
</p>
<p>Note that when using raw public-keys verification will not work because there is
no corresponding certificate body belonging to the raw key that can be verified. In that
case this function will return <code>GNUTLS_E_INVALID_REQUEST</code> .
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  (0) when the validation is performed, or a negative error code otherwise.
A successful error code means that the  <code>status</code> parameter must be checked to obtain the validation status.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fcertificate_005fverify_005fpeers2-1"></span><h4 class="subheading">gnutls_certificate_verify_peers2</h4>
<span id="gnutls_005fcertificate_005fverify_005fpeers2"></span><dl>
<dt id="index-gnutls_005fcertificate_005fverify_005fpeers2">Function: <em>int</em> <strong>gnutls_certificate_verify_peers2</strong> <em>(gnutls_session_t <var>session</var>, unsigned int * <var>status</var>)</em></dt>
<dd><p><var>session</var>: is a gnutls session
</p>
<p><var>status</var>: is the output of the verification
</p>
<p>This function will verify the peer&rsquo;s certificate and store
the status in the  <code>status</code> variable as a bitwise OR of gnutls_certificate_status_t
values or zero if the certificate is trusted. Note that value in  <code>status</code> is set only when the return value of this function is success (i.e, failure 
to trust a certificate does not imply a negative return value).
The default verification flags used by this function can be overridden
using <code>gnutls_certificate_set_verify_flags()</code> .
</p>
<p>This function will take into account the stapled OCSP responses sent by the server,
as well as the following X.509 certificate extensions: Name Constraints,
Key Usage, and Basic Constraints (pathlen).
</p>
<p>Note that you must also check the peer&rsquo;s name in order to check if
the verified certificate belongs to the actual peer, see <code>gnutls_x509_crt_check_hostname()</code> ,
or use <code>gnutls_certificate_verify_peers3()</code> .
</p>
<p>To avoid denial of service attacks some
default upper limits regarding the certificate key size and chain
size are set. To override them use <code>gnutls_certificate_set_verify_limits()</code> .
</p>
<p>Note that when using raw public-keys verification will not work because there is
no corresponding certificate body belonging to the raw key that can be verified. In that
case this function will return <code>GNUTLS_E_INVALID_REQUEST</code> .
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  (0) when the validation is performed, or a negative error code otherwise.
A successful error code means that the  <code>status</code> parameter must be checked to obtain the validation status.
</p></dd></dl>

<span id="gnutls_005fcertificate_005fverify_005fpeers3-1"></span><h4 class="subheading">gnutls_certificate_verify_peers3</h4>
<span id="gnutls_005fcertificate_005fverify_005fpeers3"></span><dl>
<dt id="index-gnutls_005fcertificate_005fverify_005fpeers3">Function: <em>int</em> <strong>gnutls_certificate_verify_peers3</strong> <em>(gnutls_session_t <var>session</var>, const char * <var>hostname</var>, unsigned int * <var>status</var>)</em></dt>
<dd><p><var>session</var>: is a gnutls session
</p>
<p><var>hostname</var>: is the expected name of the peer; may be <code>NULL</code> 
</p>
<p><var>status</var>: is the output of the verification
</p>
<p>This function will verify the peer&rsquo;s certificate and store the
the status in the  <code>status</code> variable as a bitwise OR of gnutls_certificate_status_t
values or zero if the certificate is trusted. Note that value in  <code>status</code> is set only when the return value of this function is success (i.e, failure 
to trust a certificate does not imply a negative return value).
The default verification flags used by this function can be overridden
using <code>gnutls_certificate_set_verify_flags()</code> . See the documentation
of <code>gnutls_certificate_verify_peers2()</code>  for details in the verification process.
</p>
<p>This function will take into account the stapled OCSP responses sent by the server,
as well as the following X.509 certificate extensions: Name Constraints,
Key Usage, and Basic Constraints (pathlen).
</p>
<p>If the  <code>hostname</code> provided is non-NULL then this function will compare
the hostname in the certificate against it. The comparison will follow
the RFC6125 recommendations. If names do not match the
<code>GNUTLS_CERT_UNEXPECTED_OWNER</code>  status flag will be set.
</p>
<p>In order to verify the purpose of the end-certificate (by checking the extended
key usage), use <code>gnutls_certificate_verify_peers()</code> .
</p>
<p>To avoid denial of service attacks some
default upper limits regarding the certificate key size and chain
size are set. To override them use <code>gnutls_certificate_set_verify_limits()</code> .
</p>
<p>Note that when using raw public-keys verification will not work because there is
no corresponding certificate body belonging to the raw key that can be verified. In that
case this function will return <code>GNUTLS_E_INVALID_REQUEST</code> .
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  (0) when the validation is performed, or a negative error code otherwise.
A successful error code means that the  <code>status</code> parameter must be checked to obtain the validation status.
</p>
<p><strong>Since:</strong> 3.1.4
</p></dd></dl>

<span id="gnutls_005fcheck_005fversion-1"></span><h4 class="subheading">gnutls_check_version</h4>
<span id="gnutls_005fcheck_005fversion"></span><dl>
<dt id="index-gnutls_005fcheck_005fversion">Function: <em>const char *</em> <strong>gnutls_check_version</strong> <em>(const char * <var>req_version</var>)</em></dt>
<dd><p><var>req_version</var>: version string to compare with, or <code>NULL</code> .
</p>
<p>Check the GnuTLS Library version against the provided string.
See <code>GNUTLS_VERSION</code>  for a suitable  <code>req_version</code> string.
</p>
<p>See also <code>gnutls_check_version_numeric()</code> , which provides this
functionality as a macro.
</p>
<p><strong>Returns:</strong> Check that the version of the library is at
minimum the one given as a string in  <code>req_version</code> and return the
actual version string of the library; return <code>NULL</code>  if the
condition is not met.  If <code>NULL</code>  is passed to this function no
check is done and only the version string is returned.
</p></dd></dl>

<span id="gnutls_005fcipher_005fget-1"></span><h4 class="subheading">gnutls_cipher_get</h4>
<span id="gnutls_005fcipher_005fget"></span><dl>
<dt id="index-gnutls_005fcipher_005fget">Function: <em>gnutls_cipher_algorithm_t</em> <strong>gnutls_cipher_get</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Get the currently used cipher.
</p>
<p><strong>Returns:</strong> the currently used cipher, a <code>gnutls_cipher_algorithm_t</code> 
type.
</p></dd></dl>

<span id="gnutls_005fcipher_005fget_005fid-1"></span><h4 class="subheading">gnutls_cipher_get_id</h4>
<span id="gnutls_005fcipher_005fget_005fid"></span><dl>
<dt id="index-gnutls_005fcipher_005fget_005fid">Function: <em>gnutls_cipher_algorithm_t</em> <strong>gnutls_cipher_get_id</strong> <em>(const char * <var>name</var>)</em></dt>
<dd><p><var>name</var>: is a cipher algorithm name
</p>
<p>The names are compared in a case insensitive way.
</p>
<p><strong>Returns:</strong> return a <code>gnutls_cipher_algorithm_t</code>  value corresponding to
the specified cipher, or <code>GNUTLS_CIPHER_UNKNOWN</code>  on error.
</p></dd></dl>

<span id="gnutls_005fcipher_005fget_005fkey_005fsize-1"></span><h4 class="subheading">gnutls_cipher_get_key_size</h4>
<span id="gnutls_005fcipher_005fget_005fkey_005fsize"></span><dl>
<dt id="index-gnutls_005fcipher_005fget_005fkey_005fsize">Function: <em>size_t</em> <strong>gnutls_cipher_get_key_size</strong> <em>(gnutls_cipher_algorithm_t <var>algorithm</var>)</em></dt>
<dd><p><var>algorithm</var>: is an encryption algorithm
</p>
<p>This function returns the key size of the provided algorithm.
</p>
<p><strong>Returns:</strong> length (in bytes) of the given cipher&rsquo;s key size, or 0 if
the given cipher is invalid.
</p></dd></dl>

<span id="gnutls_005fcipher_005fget_005fname-1"></span><h4 class="subheading">gnutls_cipher_get_name</h4>
<span id="gnutls_005fcipher_005fget_005fname"></span><dl>
<dt id="index-gnutls_005fcipher_005fget_005fname">Function: <em>const char *</em> <strong>gnutls_cipher_get_name</strong> <em>(gnutls_cipher_algorithm_t <var>algorithm</var>)</em></dt>
<dd><p><var>algorithm</var>: is an encryption algorithm
</p>
<p>Convert a <code>gnutls_cipher_algorithm_t</code>  type to a string.
</p>
<p><strong>Returns:</strong> a pointer to a string that contains the name of the
specified cipher, or <code>NULL</code> .
</p></dd></dl>

<span id="gnutls_005fcipher_005flist-1"></span><h4 class="subheading">gnutls_cipher_list</h4>
<span id="gnutls_005fcipher_005flist"></span><dl>
<dt id="index-gnutls_005fcipher_005flist">Function: <em>const gnutls_cipher_algorithm_t *</em> <strong>gnutls_cipher_list</strong> <em>( <var>void</var>)</em></dt>
<dd>
<p>Get a list of supported cipher algorithms.  Note that not
necessarily all ciphers are supported as TLS cipher suites.  For
example, DES is not supported as a cipher suite, but is supported
for other purposes (e.g., PKCS<code>8</code>  or similar).
</p>
<p>This function is not thread safe.
</p>
<p><strong>Returns:</strong> a (0)-terminated list of <code>gnutls_cipher_algorithm_t</code> 
integers indicating the available ciphers.
</p></dd></dl>

<span id="gnutls_005fcipher_005fsuite_005fget_005fname-1"></span><h4 class="subheading">gnutls_cipher_suite_get_name</h4>
<span id="gnutls_005fcipher_005fsuite_005fget_005fname"></span><dl>
<dt id="index-gnutls_005fcipher_005fsuite_005fget_005fname">Function: <em>const char *</em> <strong>gnutls_cipher_suite_get_name</strong> <em>(gnutls_kx_algorithm_t       <var>kx_algorithm</var>, gnutls_cipher_algorithm_t       <var>cipher_algorithm</var>, gnutls_mac_algorithm_t       <var>mac_algorithm</var>)</em></dt>
<dd><p><var>kx_algorithm</var>: is a Key exchange algorithm
</p>
<p><var>cipher_algorithm</var>: is a cipher algorithm
</p>
<p><var>mac_algorithm</var>: is a MAC algorithm
</p>
<p>This function returns the ciphersuite name under TLS1.2 or earlier
versions when provided with individual algorithms. The full cipher suite
name must be prepended by TLS or SSL depending of the protocol in use.
</p>
<p>To get a description of the current ciphersuite across versions, it
is recommended to use <code>gnutls_session_get_desc()</code> .
</p>
<p><strong>Returns:</strong> a string that contains the name of a TLS cipher suite,
specified by the given algorithms, or <code>NULL</code> .
</p></dd></dl>

<span id="gnutls_005fcipher_005fsuite_005finfo-1"></span><h4 class="subheading">gnutls_cipher_suite_info</h4>
<span id="gnutls_005fcipher_005fsuite_005finfo"></span><dl>
<dt id="index-gnutls_005fcipher_005fsuite_005finfo">Function: <em>const char *</em> <strong>gnutls_cipher_suite_info</strong> <em>(size_t <var>idx</var>, unsigned char * <var>cs_id</var>, gnutls_kx_algorithm_t * <var>kx</var>, gnutls_cipher_algorithm_t * <var>cipher</var>, gnutls_mac_algorithm_t * <var>mac</var>, gnutls_protocol_t * <var>min_version</var>)</em></dt>
<dd><p><var>idx</var>: index of cipher suite to get information about, starts on 0.
</p>
<p><var>cs_id</var>: output buffer with room for 2 bytes, indicating cipher suite value
</p>
<p><var>kx</var>: output variable indicating key exchange algorithm, or <code>NULL</code> .
</p>
<p><var>cipher</var>: output variable indicating cipher, or <code>NULL</code> .
</p>
<p><var>mac</var>: output variable indicating MAC algorithm, or <code>NULL</code> .
</p>
<p><var>min_version</var>: output variable indicating TLS protocol version, or <code>NULL</code> .
</p>
<p>Get information about supported cipher suites.  Use the function
iteratively to get information about all supported cipher suites.
Call with idx=0 to get information about first cipher suite, then
idx=1 and so on until the function returns NULL.
</p>
<p><strong>Returns:</strong> the name of  <code>idx</code> cipher suite, and set the information
about the cipher suite in the output variables.  If  <code>idx</code> is out of
bounds, <code>NULL</code>  is returned.
</p></dd></dl>

<span id="gnutls_005fcredentials_005fclear-1"></span><h4 class="subheading">gnutls_credentials_clear</h4>
<span id="gnutls_005fcredentials_005fclear"></span><dl>
<dt id="index-gnutls_005fcredentials_005fclear">Function: <em>void</em> <strong>gnutls_credentials_clear</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Clears all the credentials previously set in this session.
</p></dd></dl>

<span id="gnutls_005fcredentials_005fget-1"></span><h4 class="subheading">gnutls_credentials_get</h4>
<span id="gnutls_005fcredentials_005fget"></span><dl>
<dt id="index-gnutls_005fcredentials_005fget">Function: <em>int</em> <strong>gnutls_credentials_get</strong> <em>(gnutls_session_t <var>session</var>, gnutls_credentials_type_t <var>type</var>, void ** <var>cred</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>type</var>: is the type of the credentials to return
</p>
<p><var>cred</var>: will contain the credentials.
</p>
<p>Returns the previously provided credentials structures.
</p>
<p>For <code>GNUTLS_CRD_ANON</code> ,  <code>cred</code> will be
<code>gnutls_anon_client_credentials_t</code>  in case of a client.  In case of
a server it should be <code>gnutls_anon_server_credentials_t</code> .
</p>
<p>For <code>GNUTLS_CRD_SRP</code> ,  <code>cred</code> will be <code>gnutls_srp_client_credentials_t</code> 
in case of a client, and <code>gnutls_srp_server_credentials_t</code> , in case
of a server.
</p>
<p>For <code>GNUTLS_CRD_CERTIFICATE</code> ,  <code>cred</code> will be
<code>gnutls_certificate_credentials_t</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p>
<p><strong>Since:</strong> 3.3.3
</p></dd></dl>

<span id="gnutls_005fcredentials_005fset-1"></span><h4 class="subheading">gnutls_credentials_set</h4>
<span id="gnutls_005fcredentials_005fset"></span><dl>
<dt id="index-gnutls_005fcredentials_005fset-1">Function: <em>int</em> <strong>gnutls_credentials_set</strong> <em>(gnutls_session_t <var>session</var>, gnutls_credentials_type_t <var>type</var>, void * <var>cred</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>type</var>: is the type of the credentials
</p>
<p><var>cred</var>: the credentials to set
</p>
<p>Sets the needed credentials for the specified type.  E.g. username,
password - or public and private keys etc.  The  <code>cred</code> parameter is
a structure that depends on the specified type and on the current
session (client or server).
</p>
<p>In order to minimize memory usage, and share credentials between
several threads gnutls keeps a pointer to cred, and not the whole
cred structure.  Thus you will have to keep the structure allocated
until you call <code>gnutls_deinit()</code> .
</p>
<p>For <code>GNUTLS_CRD_ANON</code> ,  <code>cred</code> should be
<code>gnutls_anon_client_credentials_t</code>  in case of a client.  In case of
a server it should be <code>gnutls_anon_server_credentials_t</code> .
</p>
<p>For <code>GNUTLS_CRD_SRP</code> ,  <code>cred</code> should be <code>gnutls_srp_client_credentials_t</code> 
in case of a client, and <code>gnutls_srp_server_credentials_t</code> , in case
of a server.
</p>
<p>For <code>GNUTLS_CRD_CERTIFICATE</code> ,  <code>cred</code> should be
<code>gnutls_certificate_credentials_t</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p></dd></dl>

<span id="gnutls_005fdb_005fcheck_005fentry-1"></span><h4 class="subheading">gnutls_db_check_entry</h4>
<span id="gnutls_005fdb_005fcheck_005fentry"></span><dl>
<dt id="index-gnutls_005fdb_005fcheck_005fentry">Function: <em>int</em> <strong>gnutls_db_check_entry</strong> <em>(gnutls_session_t <var>session</var>, gnutls_datum_t <var>session_entry</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>session_entry</var>: is the session data (not key)
</p>
<p>This function has no effect. 
</p>
<p><strong>Returns:</strong> Returns <code>GNUTLS_E_EXPIRED</code> , if the database entry has
expired or 0 otherwise.
</p>
<p><strong>Deprecated:</strong> This function is deprecated.
</p></dd></dl>

<span id="gnutls_005fdb_005fcheck_005fentry_005fexpire_005ftime-1"></span><h4 class="subheading">gnutls_db_check_entry_expire_time</h4>
<span id="gnutls_005fdb_005fcheck_005fentry_005fexpire_005ftime"></span><dl>
<dt id="index-gnutls_005fdb_005fcheck_005fentry_005fexpire_005ftime">Function: <em>time_t</em> <strong>gnutls_db_check_entry_expire_time</strong> <em>(gnutls_datum_t * <var>entry</var>)</em></dt>
<dd><p><var>entry</var>: is a pointer to a <code>gnutls_datum_t</code>  type.
</p>
<p>This function returns the time that this entry will expire.
It can be used for database entry expiration.
</p>
<p><strong>Returns:</strong> The time this entry will expire, or zero on error.
</p>
<p><strong>Since:</strong> 3.6.5
</p></dd></dl>

<span id="gnutls_005fdb_005fcheck_005fentry_005ftime-1"></span><h4 class="subheading">gnutls_db_check_entry_time</h4>
<span id="gnutls_005fdb_005fcheck_005fentry_005ftime"></span><dl>
<dt id="index-gnutls_005fdb_005fcheck_005fentry_005ftime">Function: <em>time_t</em> <strong>gnutls_db_check_entry_time</strong> <em>(gnutls_datum_t * <var>entry</var>)</em></dt>
<dd><p><var>entry</var>: is a pointer to a <code>gnutls_datum_t</code>  type.
</p>
<p>This function returns the time that this entry was active.
It can be used for database entry expiration.
</p>
<p><strong>Returns:</strong> The time this entry was created, or zero on error.
</p></dd></dl>

<span id="gnutls_005fdb_005fget_005fdefault_005fcache_005fexpiration-1"></span><h4 class="subheading">gnutls_db_get_default_cache_expiration</h4>
<span id="gnutls_005fdb_005fget_005fdefault_005fcache_005fexpiration"></span><dl>
<dt id="index-gnutls_005fdb_005fget_005fdefault_005fcache_005fexpiration">Function: <em>unsigned</em> <strong>gnutls_db_get_default_cache_expiration</strong> <em>( <var>void</var>)</em></dt>
<dd>
<p>Returns the expiration time (in seconds) of stored sessions for resumption. 
</p></dd></dl>

<span id="gnutls_005fdb_005fget_005fptr-1"></span><h4 class="subheading">gnutls_db_get_ptr</h4>
<span id="gnutls_005fdb_005fget_005fptr"></span><dl>
<dt id="index-gnutls_005fdb_005fget_005fptr">Function: <em>void *</em> <strong>gnutls_db_get_ptr</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Get db function pointer.
</p>
<p><strong>Returns:</strong> the pointer that will be sent to db store, retrieve and
delete functions, as the first argument.
</p></dd></dl>

<span id="gnutls_005fdb_005fremove_005fsession-1"></span><h4 class="subheading">gnutls_db_remove_session</h4>
<span id="gnutls_005fdb_005fremove_005fsession"></span><dl>
<dt id="index-gnutls_005fdb_005fremove_005fsession">Function: <em>void</em> <strong>gnutls_db_remove_session</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>This function will remove the current session data from the
session database.  This will prevent future handshakes reusing
these session data.  This function should be called if a session
was terminated abnormally, and before <code>gnutls_deinit()</code>  is called.
</p>
<p>Normally <code>gnutls_deinit()</code>  will remove abnormally terminated
sessions.
</p></dd></dl>

<span id="gnutls_005fdb_005fset_005fcache_005fexpiration-1"></span><h4 class="subheading">gnutls_db_set_cache_expiration</h4>
<span id="gnutls_005fdb_005fset_005fcache_005fexpiration"></span><dl>
<dt id="index-gnutls_005fdb_005fset_005fcache_005fexpiration">Function: <em>void</em> <strong>gnutls_db_set_cache_expiration</strong> <em>(gnutls_session_t <var>session</var>, int <var>seconds</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>seconds</var>: is the number of seconds.
</p>
<p>Set the expiration time for resumed sessions. The default is 21600
(6 hours) at the time of writing.
</p>
<p>The maximum value that can be set using this function is 604800
(7 days).
</p></dd></dl>

<span id="gnutls_005fdb_005fset_005fptr-1"></span><h4 class="subheading">gnutls_db_set_ptr</h4>
<span id="gnutls_005fdb_005fset_005fptr"></span><dl>
<dt id="index-gnutls_005fdb_005fset_005fptr">Function: <em>void</em> <strong>gnutls_db_set_ptr</strong> <em>(gnutls_session_t <var>session</var>, void * <var>ptr</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>ptr</var>: is the pointer
</p>
<p>Sets the pointer that will be provided to db store, retrieve and
delete functions, as the first argument.
</p></dd></dl>

<span id="gnutls_005fdb_005fset_005fremove_005ffunction-1"></span><h4 class="subheading">gnutls_db_set_remove_function</h4>
<span id="gnutls_005fdb_005fset_005fremove_005ffunction"></span><dl>
<dt id="index-gnutls_005fdb_005fset_005fremove_005ffunction">Function: <em>void</em> <strong>gnutls_db_set_remove_function</strong> <em>(gnutls_session_t <var>session</var>, gnutls_db_remove_func <var>rem_func</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>rem_func</var>: is the function.
</p>
<p>Sets the function that will be used to remove data from the
resumed sessions database. This function must return 0 on success.
</p>
<p>The first argument to  <code>rem_func</code> will be null unless
<code>gnutls_db_set_ptr()</code>  has been called.
</p></dd></dl>

<span id="gnutls_005fdb_005fset_005fretrieve_005ffunction-1"></span><h4 class="subheading">gnutls_db_set_retrieve_function</h4>
<span id="gnutls_005fdb_005fset_005fretrieve_005ffunction"></span><dl>
<dt id="index-gnutls_005fdb_005fset_005fretrieve_005ffunction">Function: <em>void</em> <strong>gnutls_db_set_retrieve_function</strong> <em>(gnutls_session_t <var>session</var>, gnutls_db_retr_func <var>retr_func</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>retr_func</var>: is the function.
</p>
<p>Sets the function that will be used to retrieve data from the
resumed sessions database.  This function must return a
gnutls_datum_t containing the data on success, or a gnutls_datum_t
containing null and 0 on failure.
</p>
<p>The datum&rsquo;s data must be allocated using the function
<code>gnutls_malloc()</code> .
</p>
<p>The first argument to  <code>retr_func</code> will be null unless
<code>gnutls_db_set_ptr()</code>  has been called.
</p></dd></dl>

<span id="gnutls_005fdb_005fset_005fstore_005ffunction-1"></span><h4 class="subheading">gnutls_db_set_store_function</h4>
<span id="gnutls_005fdb_005fset_005fstore_005ffunction"></span><dl>
<dt id="index-gnutls_005fdb_005fset_005fstore_005ffunction">Function: <em>void</em> <strong>gnutls_db_set_store_function</strong> <em>(gnutls_session_t <var>session</var>, gnutls_db_store_func <var>store_func</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>store_func</var>: is the function
</p>
<p>Sets the function that will be used to store data in the resumed
sessions database. This function must return 0 on success.
</p>
<p>The first argument to  <code>store_func</code> will be null unless
<code>gnutls_db_set_ptr()</code>  has been called.
</p></dd></dl>

<span id="gnutls_005fdeinit-1"></span><h4 class="subheading">gnutls_deinit</h4>
<span id="gnutls_005fdeinit"></span><dl>
<dt id="index-gnutls_005fdeinit-1">Function: <em>void</em> <strong>gnutls_deinit</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>This function clears all buffers associated with the  <code>session</code> .
This function will also remove session data from the session
database if the session was terminated abnormally.
</p></dd></dl>

<span id="gnutls_005fdh_005fget_005fgroup-1"></span><h4 class="subheading">gnutls_dh_get_group</h4>
<span id="gnutls_005fdh_005fget_005fgroup"></span><dl>
<dt id="index-gnutls_005fdh_005fget_005fgroup">Function: <em>int</em> <strong>gnutls_dh_get_group</strong> <em>(gnutls_session_t <var>session</var>, gnutls_datum_t * <var>raw_gen</var>, gnutls_datum_t * <var>raw_prime</var>)</em></dt>
<dd><p><var>session</var>: is a gnutls session
</p>
<p><var>raw_gen</var>: will hold the generator.
</p>
<p><var>raw_prime</var>: will hold the prime.
</p>
<p>This function will return the group parameters used in the last
Diffie-Hellman key exchange with the peer.  These are the prime and
the generator used.  This function should be used for both
anonymous and ephemeral Diffie-Hellman.  The output parameters must
be freed with <code>gnutls_free()</code> .
</p>
<p>Note, that the prime and generator are exported as non-negative
integers and may include a leading zero byte.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p></dd></dl>

<span id="gnutls_005fdh_005fget_005fpeers_005fpublic_005fbits-1"></span><h4 class="subheading">gnutls_dh_get_peers_public_bits</h4>
<span id="gnutls_005fdh_005fget_005fpeers_005fpublic_005fbits"></span><dl>
<dt id="index-gnutls_005fdh_005fget_005fpeers_005fpublic_005fbits">Function: <em>int</em> <strong>gnutls_dh_get_peers_public_bits</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a gnutls session
</p>
<p>Get the Diffie-Hellman public key bit size.  Can be used for both
anonymous and ephemeral Diffie-Hellman.
</p>
<p><strong>Returns:</strong> The public key bit size used in the last Diffie-Hellman
key exchange with the peer, or a negative error code in case of error.
</p></dd></dl>

<span id="gnutls_005fdh_005fget_005fprime_005fbits-1"></span><h4 class="subheading">gnutls_dh_get_prime_bits</h4>
<span id="gnutls_005fdh_005fget_005fprime_005fbits"></span><dl>
<dt id="index-gnutls_005fdh_005fget_005fprime_005fbits">Function: <em>int</em> <strong>gnutls_dh_get_prime_bits</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a gnutls session
</p>
<p>This function will return the bits of the prime used in the last
Diffie-Hellman key exchange with the peer.  Should be used for both
anonymous and ephemeral Diffie-Hellman.  Note that some ciphers,
like RSA and DSA without DHE, do not use a Diffie-Hellman key
exchange, and then this function will return 0.
</p>
<p><strong>Returns:</strong> The Diffie-Hellman bit strength is returned, or 0 if no
Diffie-Hellman key exchange was done, or a negative error code on
failure.
</p></dd></dl>

<span id="gnutls_005fdh_005fget_005fpubkey-1"></span><h4 class="subheading">gnutls_dh_get_pubkey</h4>
<span id="gnutls_005fdh_005fget_005fpubkey"></span><dl>
<dt id="index-gnutls_005fdh_005fget_005fpubkey">Function: <em>int</em> <strong>gnutls_dh_get_pubkey</strong> <em>(gnutls_session_t <var>session</var>, gnutls_datum_t * <var>raw_key</var>)</em></dt>
<dd><p><var>session</var>: is a gnutls session
</p>
<p><var>raw_key</var>: will hold the public key.
</p>
<p>This function will return the peer&rsquo;s public key used in the last
Diffie-Hellman key exchange.  This function should be used for both
anonymous and ephemeral Diffie-Hellman.  The output parameters must
be freed with <code>gnutls_free()</code> .
</p>
<p>Note, that public key is exported as non-negative
integer and may include a leading zero byte.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p></dd></dl>

<span id="gnutls_005fdh_005fget_005fsecret_005fbits-1"></span><h4 class="subheading">gnutls_dh_get_secret_bits</h4>
<span id="gnutls_005fdh_005fget_005fsecret_005fbits"></span><dl>
<dt id="index-gnutls_005fdh_005fget_005fsecret_005fbits">Function: <em>int</em> <strong>gnutls_dh_get_secret_bits</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a gnutls session
</p>
<p>This function will return the bits used in the last Diffie-Hellman
key exchange with the peer.  Should be used for both anonymous and
ephemeral Diffie-Hellman.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p></dd></dl>

<span id="gnutls_005fdh_005fparams_005fcpy-1"></span><h4 class="subheading">gnutls_dh_params_cpy</h4>
<span id="gnutls_005fdh_005fparams_005fcpy"></span><dl>
<dt id="index-gnutls_005fdh_005fparams_005fcpy">Function: <em>int</em> <strong>gnutls_dh_params_cpy</strong> <em>(gnutls_dh_params_t <var>dst</var>, gnutls_dh_params_t <var>src</var>)</em></dt>
<dd><p><var>dst</var>: Is the destination parameters, which should be initialized.
</p>
<p><var>src</var>: Is the source parameters
</p>
<p>This function will copy the DH parameters structure from source
to destination. The destination should be already initialized.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p></dd></dl>

<span id="gnutls_005fdh_005fparams_005fdeinit-1"></span><h4 class="subheading">gnutls_dh_params_deinit</h4>
<span id="gnutls_005fdh_005fparams_005fdeinit"></span><dl>
<dt id="index-gnutls_005fdh_005fparams_005fdeinit">Function: <em>void</em> <strong>gnutls_dh_params_deinit</strong> <em>(gnutls_dh_params_t <var>dh_params</var>)</em></dt>
<dd><p><var>dh_params</var>: The parameters
</p>
<p>This function will deinitialize the DH parameters type.
</p></dd></dl>

<span id="gnutls_005fdh_005fparams_005fexport2_005fpkcs3-1"></span><h4 class="subheading">gnutls_dh_params_export2_pkcs3</h4>
<span id="gnutls_005fdh_005fparams_005fexport2_005fpkcs3"></span><dl>
<dt id="index-gnutls_005fdh_005fparams_005fexport2_005fpkcs3">Function: <em>int</em> <strong>gnutls_dh_params_export2_pkcs3</strong> <em>(gnutls_dh_params_t <var>params</var>, gnutls_x509_crt_fmt_t <var>format</var>, gnutls_datum_t * <var>out</var>)</em></dt>
<dd><p><var>params</var>: Holds the DH parameters
</p>
<p><var>format</var>: the format of output params. One of PEM or DER.
</p>
<p><var>out</var>: will contain a PKCS3 DHParams structure PEM or DER encoded
</p>
<p>This function will export the given dh parameters to a PKCS3
DHParams structure. This is the format generated by &quot;openssl dhparam&quot; tool.
The data in  <code>out</code> will be allocated using <code>gnutls_malloc()</code> .
</p>
<p>If the structure is PEM encoded, it will have a header
of &quot;BEGIN DH PARAMETERS&quot;.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p>
<p><strong>Since:</strong> 3.1.3
</p></dd></dl>

<span id="gnutls_005fdh_005fparams_005fexport_005fpkcs3-1"></span><h4 class="subheading">gnutls_dh_params_export_pkcs3</h4>
<span id="gnutls_005fdh_005fparams_005fexport_005fpkcs3"></span><dl>
<dt id="index-gnutls_005fdh_005fparams_005fexport_005fpkcs3">Function: <em>int</em> <strong>gnutls_dh_params_export_pkcs3</strong> <em>(gnutls_dh_params_t <var>params</var>, gnutls_x509_crt_fmt_t <var>format</var>, unsigned char * <var>params_data</var>, size_t * <var>params_data_size</var>)</em></dt>
<dd><p><var>params</var>: Holds the DH parameters
</p>
<p><var>format</var>: the format of output params. One of PEM or DER.
</p>
<p><var>params_data</var>: will contain a PKCS3 DHParams structure PEM or DER encoded
</p>
<p><var>params_data_size</var>: holds the size of params_data (and will be replaced by the actual size of parameters)
</p>
<p>This function will export the given dh parameters to a PKCS3
DHParams structure. This is the format generated by &quot;openssl dhparam&quot; tool.
If the buffer provided is not long enough to hold the output, then
GNUTLS_E_SHORT_MEMORY_BUFFER will be returned.
</p>
<p>If the structure is PEM encoded, it will have a header
of &quot;BEGIN DH PARAMETERS&quot;.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p></dd></dl>

<span id="gnutls_005fdh_005fparams_005fexport_005fraw-1"></span><h4 class="subheading">gnutls_dh_params_export_raw</h4>
<span id="gnutls_005fdh_005fparams_005fexport_005fraw"></span><dl>
<dt id="index-gnutls_005fdh_005fparams_005fexport_005fraw">Function: <em>int</em> <strong>gnutls_dh_params_export_raw</strong> <em>(gnutls_dh_params_t <var>params</var>, gnutls_datum_t * <var>prime</var>, gnutls_datum_t * <var>generator</var>, unsigned int * <var>bits</var>)</em></dt>
<dd><p><var>params</var>: Holds the DH parameters
</p>
<p><var>prime</var>: will hold the new prime
</p>
<p><var>generator</var>: will hold the new generator
</p>
<p><var>bits</var>: if non null will hold the secret key&rsquo;s number of bits
</p>
<p>This function will export the pair of prime and generator for use
in the Diffie-Hellman key exchange.  The new parameters will be
allocated using <code>gnutls_malloc()</code>  and will be stored in the
appropriate datum.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p></dd></dl>

<span id="gnutls_005fdh_005fparams_005fgenerate2-1"></span><h4 class="subheading">gnutls_dh_params_generate2</h4>
<span id="gnutls_005fdh_005fparams_005fgenerate2"></span><dl>
<dt id="index-gnutls_005fdh_005fparams_005fgenerate2">Function: <em>int</em> <strong>gnutls_dh_params_generate2</strong> <em>(gnutls_dh_params_t <var>dparams</var>, unsigned int <var>bits</var>)</em></dt>
<dd><p><var>dparams</var>: The parameters
</p>
<p><var>bits</var>: is the prime&rsquo;s number of bits
</p>
<p>This function will generate a new pair of prime and generator for use in
the Diffie-Hellman key exchange. This may take long time.
</p>
<p>It is recommended not to set the number of bits directly, but 
use <code>gnutls_sec_param_to_pk_bits()</code>  instead.
Also note that the DH parameters are only useful to servers.
Since clients use the parameters sent by the server, it&rsquo;s of
no use to call this in client side.
</p>
<p>The parameters generated are of the DSA form. It also is possible
to generate provable parameters (following the Shawe-Taylor
algorithm), using <code>gnutls_x509_privkey_generate2()</code>  with DSA option
and the <code>GNUTLS_PRIVKEY_FLAG_PROVABLE</code>  flag set. These can the
be imported with <code>gnutls_dh_params_import_dsa()</code> .
</p>
<p>It is no longer recommended for applications to generate parameters.
See the &quot;Parameter generation&quot; section in the manual.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p></dd></dl>

<span id="gnutls_005fdh_005fparams_005fimport_005fdsa-1"></span><h4 class="subheading">gnutls_dh_params_import_dsa</h4>
<span id="gnutls_005fdh_005fparams_005fimport_005fdsa"></span><dl>
<dt id="index-gnutls_005fdh_005fparams_005fimport_005fdsa">Function: <em>int</em> <strong>gnutls_dh_params_import_dsa</strong> <em>(gnutls_dh_params_t <var>dh_params</var>, gnutls_x509_privkey_t <var>key</var>)</em></dt>
<dd><p><var>dh_params</var>: The parameters
</p>
<p><var>key</var>: holds a DSA private key
</p>
<p>This function will import the prime and generator of the DSA key for use 
in the Diffie-Hellman key exchange.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p></dd></dl>

<span id="gnutls_005fdh_005fparams_005fimport_005fpkcs3-1"></span><h4 class="subheading">gnutls_dh_params_import_pkcs3</h4>
<span id="gnutls_005fdh_005fparams_005fimport_005fpkcs3"></span><dl>
<dt id="index-gnutls_005fdh_005fparams_005fimport_005fpkcs3">Function: <em>int</em> <strong>gnutls_dh_params_import_pkcs3</strong> <em>(gnutls_dh_params_t <var>params</var>, const gnutls_datum_t * <var>pkcs3_params</var>, gnutls_x509_crt_fmt_t <var>format</var>)</em></dt>
<dd><p><var>params</var>: The parameters
</p>
<p><var>pkcs3_params</var>: should contain a PKCS3 DHParams structure PEM or DER encoded
</p>
<p><var>format</var>: the format of params. PEM or DER.
</p>
<p>This function will extract the DHParams found in a PKCS3 formatted
structure. This is the format generated by &quot;openssl dhparam&quot; tool.
</p>
<p>If the structure is PEM encoded, it should have a header
of &quot;BEGIN DH PARAMETERS&quot;.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p></dd></dl>

<span id="gnutls_005fdh_005fparams_005fimport_005fraw-1"></span><h4 class="subheading">gnutls_dh_params_import_raw</h4>
<span id="gnutls_005fdh_005fparams_005fimport_005fraw"></span><dl>
<dt id="index-gnutls_005fdh_005fparams_005fimport_005fraw">Function: <em>int</em> <strong>gnutls_dh_params_import_raw</strong> <em>(gnutls_dh_params_t <var>dh_params</var>, const gnutls_datum_t * <var>prime</var>, const gnutls_datum_t * <var>generator</var>)</em></dt>
<dd><p><var>dh_params</var>: The parameters
</p>
<p><var>prime</var>: holds the new prime
</p>
<p><var>generator</var>: holds the new generator
</p>
<p>This function will replace the pair of prime and generator for use
in the Diffie-Hellman key exchange.  The new parameters should be
stored in the appropriate gnutls_datum.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p></dd></dl>

<span id="gnutls_005fdh_005fparams_005fimport_005fraw2-1"></span><h4 class="subheading">gnutls_dh_params_import_raw2</h4>
<span id="gnutls_005fdh_005fparams_005fimport_005fraw2"></span><dl>
<dt id="index-gnutls_005fdh_005fparams_005fimport_005fraw2">Function: <em>int</em> <strong>gnutls_dh_params_import_raw2</strong> <em>(gnutls_dh_params_t <var>dh_params</var>, const gnutls_datum_t * <var>prime</var>, const gnutls_datum_t * <var>generator</var>, unsigned <var>key_bits</var>)</em></dt>
<dd><p><var>dh_params</var>: The parameters
</p>
<p><var>prime</var>: holds the new prime
</p>
<p><var>generator</var>: holds the new generator
</p>
<p><var>key_bits</var>: the private key bits (set to zero when unknown)
</p>
<p>This function will replace the pair of prime and generator for use
in the Diffie-Hellman key exchange.  The new parameters should be
stored in the appropriate gnutls_datum.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p></dd></dl>

<span id="gnutls_005fdh_005fparams_005fimport_005fraw3-1"></span><h4 class="subheading">gnutls_dh_params_import_raw3</h4>
<span id="gnutls_005fdh_005fparams_005fimport_005fraw3"></span><dl>
<dt id="index-gnutls_005fdh_005fparams_005fimport_005fraw3">Function: <em>int</em> <strong>gnutls_dh_params_import_raw3</strong> <em>(gnutls_dh_params_t <var>dh_params</var>, const gnutls_datum_t * <var>prime</var>, const gnutls_datum_t * <var>q</var>, const gnutls_datum_t * <var>generator</var>)</em></dt>
<dd><p><var>dh_params</var>: The parameters
</p>
<p><var>prime</var>: holds the new prime
</p>
<p><var>q</var>: holds the subgroup if available, otherwise NULL
</p>
<p><var>generator</var>: holds the new generator
</p>
<p>This function will replace the pair of prime and generator for use
in the Diffie-Hellman key exchange.  The new parameters should be
stored in the appropriate gnutls_datum.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p></dd></dl>

<span id="gnutls_005fdh_005fparams_005finit-1"></span><h4 class="subheading">gnutls_dh_params_init</h4>
<span id="gnutls_005fdh_005fparams_005finit"></span><dl>
<dt id="index-gnutls_005fdh_005fparams_005finit">Function: <em>int</em> <strong>gnutls_dh_params_init</strong> <em>(gnutls_dh_params_t * <var>dh_params</var>)</em></dt>
<dd><p><var>dh_params</var>: The parameters
</p>
<p>This function will initialize the DH parameters type.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p></dd></dl>

<span id="gnutls_005fdh_005fset_005fprime_005fbits-1"></span><h4 class="subheading">gnutls_dh_set_prime_bits</h4>
<span id="gnutls_005fdh_005fset_005fprime_005fbits"></span><dl>
<dt id="index-gnutls_005fdh_005fset_005fprime_005fbits">Function: <em>void</em> <strong>gnutls_dh_set_prime_bits</strong> <em>(gnutls_session_t <var>session</var>, unsigned int <var>bits</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>bits</var>: is the number of bits
</p>
<p>This function sets the number of bits, for use in a Diffie-Hellman
key exchange.  This is used both in DH ephemeral and DH anonymous
cipher suites.  This will set the minimum size of the prime that
will be used for the handshake.
</p>
<p>In the client side it sets the minimum accepted number of bits.  If
a server sends a prime with less bits than that
<code>GNUTLS_E_DH_PRIME_UNACCEPTABLE</code>  will be returned by the handshake.
</p>
<p>Note that this function will warn via the audit log for value that
are believed to be weak.
</p>
<p>The function has no effect in server side.
</p>
<p>Note that since 3.1.7 this function is deprecated. The minimum
number of bits is set by the priority string level.
Also this function must be called after <code>gnutls_priority_set_direct()</code> 
or the set value may be overridden by the selected priority options.
</p></dd></dl>

<span id="gnutls_005fdigest_005fget_005fid-1"></span><h4 class="subheading">gnutls_digest_get_id</h4>
<span id="gnutls_005fdigest_005fget_005fid"></span><dl>
<dt id="index-gnutls_005fdigest_005fget_005fid">Function: <em>gnutls_digest_algorithm_t</em> <strong>gnutls_digest_get_id</strong> <em>(const char * <var>name</var>)</em></dt>
<dd><p><var>name</var>: is a digest algorithm name
</p>
<p>Convert a string to a <code>gnutls_digest_algorithm_t</code>  value.  The names are
compared in a case insensitive way.
</p>
<p><strong>Returns:</strong> a <code>gnutls_digest_algorithm_t</code>  id of the specified MAC
algorithm string, or <code>GNUTLS_DIG_UNKNOWN</code>  on failure.
</p></dd></dl>

<span id="gnutls_005fdigest_005fget_005fname-1"></span><h4 class="subheading">gnutls_digest_get_name</h4>
<span id="gnutls_005fdigest_005fget_005fname"></span><dl>
<dt id="index-gnutls_005fdigest_005fget_005fname">Function: <em>const char *</em> <strong>gnutls_digest_get_name</strong> <em>(gnutls_digest_algorithm_t <var>algorithm</var>)</em></dt>
<dd><p><var>algorithm</var>: is a digest algorithm
</p>
<p>Convert a <code>gnutls_digest_algorithm_t</code>  value to a string.
</p>
<p><strong>Returns:</strong> a string that contains the name of the specified digest
algorithm, or <code>NULL</code> .
</p></dd></dl>

<span id="gnutls_005fdigest_005fget_005foid-1"></span><h4 class="subheading">gnutls_digest_get_oid</h4>
<span id="gnutls_005fdigest_005fget_005foid"></span><dl>
<dt id="index-gnutls_005fdigest_005fget_005foid">Function: <em>const char *</em> <strong>gnutls_digest_get_oid</strong> <em>(gnutls_digest_algorithm_t <var>algorithm</var>)</em></dt>
<dd><p><var>algorithm</var>: is a digest algorithm
</p>
<p>Convert a <code>gnutls_digest_algorithm_t</code>  value to its object identifier.
</p>
<p><strong>Returns:</strong> a string that contains the object identifier of the specified digest
algorithm, or <code>NULL</code> .
</p>
<p><strong>Since:</strong> 3.4.3
</p></dd></dl>

<span id="gnutls_005fdigest_005flist-1"></span><h4 class="subheading">gnutls_digest_list</h4>
<span id="gnutls_005fdigest_005flist"></span><dl>
<dt id="index-gnutls_005fdigest_005flist">Function: <em>const gnutls_digest_algorithm_t *</em> <strong>gnutls_digest_list</strong> <em>( <var>void</var>)</em></dt>
<dd>
<p>Get a list of hash (digest) algorithms supported by GnuTLS.
</p>
<p>This function is not thread safe.
</p>
<p><strong>Returns:</strong> Return a (0)-terminated list of <code>gnutls_digest_algorithm_t</code> 
integers indicating the available digests.
</p></dd></dl>

<span id="gnutls_005fecc_005fcurve_005fget-1"></span><h4 class="subheading">gnutls_ecc_curve_get</h4>
<span id="gnutls_005fecc_005fcurve_005fget"></span><dl>
<dt id="index-gnutls_005fecc_005fcurve_005fget">Function: <em>gnutls_ecc_curve_t</em> <strong>gnutls_ecc_curve_get</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Returns the currently used elliptic curve for key exchange. Only valid
when using an elliptic curve ciphersuite.
</p>
<p><strong>Returns:</strong> the currently used curve, a <code>gnutls_ecc_curve_t</code> 
type.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fecc_005fcurve_005fget_005fid-1"></span><h4 class="subheading">gnutls_ecc_curve_get_id</h4>
<span id="gnutls_005fecc_005fcurve_005fget_005fid"></span><dl>
<dt id="index-gnutls_005fecc_005fcurve_005fget_005fid">Function: <em>gnutls_ecc_curve_t</em> <strong>gnutls_ecc_curve_get_id</strong> <em>(const char * <var>name</var>)</em></dt>
<dd><p><var>name</var>: is a curve name
</p>
<p>The names are compared in a case insensitive way.
</p>
<p><strong>Returns:</strong> return a <code>gnutls_ecc_curve_t</code>  value corresponding to
the specified curve, or <code>GNUTLS_ECC_CURVE_INVALID</code>  on error.
</p>
<p><strong>Since:</strong> 3.4.3
</p></dd></dl>

<span id="gnutls_005fecc_005fcurve_005fget_005fname-1"></span><h4 class="subheading">gnutls_ecc_curve_get_name</h4>
<span id="gnutls_005fecc_005fcurve_005fget_005fname"></span><dl>
<dt id="index-gnutls_005fecc_005fcurve_005fget_005fname">Function: <em>const char *</em> <strong>gnutls_ecc_curve_get_name</strong> <em>(gnutls_ecc_curve_t <var>curve</var>)</em></dt>
<dd><p><var>curve</var>: is an ECC curve
</p>
<p>Convert a <code>gnutls_ecc_curve_t</code>  value to a string.
</p>
<p><strong>Returns:</strong> a string that contains the name of the specified
curve or <code>NULL</code> .
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fecc_005fcurve_005fget_005foid-1"></span><h4 class="subheading">gnutls_ecc_curve_get_oid</h4>
<span id="gnutls_005fecc_005fcurve_005fget_005foid"></span><dl>
<dt id="index-gnutls_005fecc_005fcurve_005fget_005foid">Function: <em>const char *</em> <strong>gnutls_ecc_curve_get_oid</strong> <em>(gnutls_ecc_curve_t <var>curve</var>)</em></dt>
<dd><p><var>curve</var>: is an ECC curve
</p>
<p>Convert a <code>gnutls_ecc_curve_t</code>  value to its object identifier.
</p>
<p><strong>Returns:</strong> a string that contains the OID of the specified
curve or <code>NULL</code> .
</p>
<p><strong>Since:</strong> 3.4.3
</p></dd></dl>

<span id="gnutls_005fecc_005fcurve_005fget_005fpk-1"></span><h4 class="subheading">gnutls_ecc_curve_get_pk</h4>
<span id="gnutls_005fecc_005fcurve_005fget_005fpk"></span><dl>
<dt id="index-gnutls_005fecc_005fcurve_005fget_005fpk">Function: <em>gnutls_pk_algorithm_t</em> <strong>gnutls_ecc_curve_get_pk</strong> <em>(gnutls_ecc_curve_t <var>curve</var>)</em></dt>
<dd><p><var>curve</var>: is an ECC curve
</p>

<p><strong>Returns:</strong> the public key algorithm associated with the named curve or <code>GNUTLS_PK_UNKNOWN</code> .
</p>
<p><strong>Since:</strong> 3.5.0
</p></dd></dl>

<span id="gnutls_005fecc_005fcurve_005fget_005fsize-1"></span><h4 class="subheading">gnutls_ecc_curve_get_size</h4>
<span id="gnutls_005fecc_005fcurve_005fget_005fsize"></span><dl>
<dt id="index-gnutls_005fecc_005fcurve_005fget_005fsize">Function: <em>int</em> <strong>gnutls_ecc_curve_get_size</strong> <em>(gnutls_ecc_curve_t <var>curve</var>)</em></dt>
<dd><p><var>curve</var>: is an ECC curve
</p>

<p><strong>Returns:</strong> the size in bytes of the curve or 0 on failure.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fecc_005fcurve_005flist-1"></span><h4 class="subheading">gnutls_ecc_curve_list</h4>
<span id="gnutls_005fecc_005fcurve_005flist"></span><dl>
<dt id="index-gnutls_005fecc_005fcurve_005flist">Function: <em>const gnutls_ecc_curve_t *</em> <strong>gnutls_ecc_curve_list</strong> <em>( <var>void</var>)</em></dt>
<dd>
<p>Get the list of supported elliptic curves.
</p>
<p>This function is not thread safe.
</p>
<p><strong>Returns:</strong> Return a (0)-terminated list of <code>gnutls_ecc_curve_t</code> 
integers indicating the available curves.
</p></dd></dl>

<span id="gnutls_005ferror_005fis_005ffatal-1"></span><h4 class="subheading">gnutls_error_is_fatal</h4>
<span id="gnutls_005ferror_005fis_005ffatal"></span><dl>
<dt id="index-gnutls_005ferror_005fis_005ffatal-1">Function: <em>int</em> <strong>gnutls_error_is_fatal</strong> <em>(int <var>error</var>)</em></dt>
<dd><p><var>error</var>: is a GnuTLS error code, a negative error code
</p>
<p>If a GnuTLS function returns a negative error code you may feed that
value to this function to see if the error condition is fatal to
a TLS session (i.e., must be terminated).
</p>
<p>Note that you may also want to check the error code manually, since some
non-fatal errors to the protocol (such as a warning alert or
a rehandshake request) may be fatal for your program.
</p>
<p>This function is only useful if you are dealing with errors from
functions that relate to a TLS session (e.g., record layer or handshake
layer handling functions).
</p>
<p><strong>Returns:</strong> Non-zero value on fatal errors or zero on non-fatal.
</p></dd></dl>

<span id="gnutls_005ferror_005fto_005falert-1"></span><h4 class="subheading">gnutls_error_to_alert</h4>
<span id="gnutls_005ferror_005fto_005falert"></span><dl>
<dt id="index-gnutls_005ferror_005fto_005falert-1">Function: <em>int</em> <strong>gnutls_error_to_alert</strong> <em>(int <var>err</var>, int * <var>level</var>)</em></dt>
<dd><p><var>err</var>: is a negative integer
</p>
<p><var>level</var>: the alert level will be stored there
</p>
<p>Get an alert depending on the error code returned by a gnutls
function.  All alerts sent by this function should be considered
fatal.  The only exception is when  <code>err</code> is <code>GNUTLS_E_REHANDSHAKE</code> ,
where a warning alert should be sent to the peer indicating that no
renegotiation will be performed.
</p>
<p>If there is no mapping to a valid alert the alert to indicate
internal error (<code>GNUTLS_A_INTERNAL_ERROR</code> ) is returned.
</p>
<p><strong>Returns:</strong> the alert code to use for a particular error code.
</p></dd></dl>

<span id="gnutls_005fest_005frecord_005foverhead_005fsize-1"></span><h4 class="subheading">gnutls_est_record_overhead_size</h4>
<span id="gnutls_005fest_005frecord_005foverhead_005fsize"></span><dl>
<dt id="index-gnutls_005fest_005frecord_005foverhead_005fsize">Function: <em>size_t</em> <strong>gnutls_est_record_overhead_size</strong> <em>(gnutls_protocol_t <var>version</var>, gnutls_cipher_algorithm_t <var>cipher</var>, gnutls_mac_algorithm_t <var>mac</var>, gnutls_compression_method_t <var>comp</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>version</var>: is a <code>gnutls_protocol_t</code>  value
</p>
<p><var>cipher</var>: is a <code>gnutls_cipher_algorithm_t</code>  value
</p>
<p><var>mac</var>: is a <code>gnutls_mac_algorithm_t</code>  value
</p>
<p><var>comp</var>: is a <code>gnutls_compression_method_t</code>  value (ignored)
</p>
<p><var>flags</var>: must be zero
</p>
<p>This function will return the set size in bytes of the overhead
due to TLS (or DTLS) per record.
</p>
<p>Note that this function may provide inacurate values when TLS
extensions that modify the record format are negotiated. In these
cases a more accurate value can be obtained using <code>gnutls_record_overhead_size()</code>  
after a completed handshake.
</p>
<p><strong>Since:</strong> 3.2.2
</p></dd></dl>

<span id="gnutls_005fext_005fget_005fcurrent_005fmsg-1"></span><h4 class="subheading">gnutls_ext_get_current_msg</h4>
<span id="gnutls_005fext_005fget_005fcurrent_005fmsg"></span><dl>
<dt id="index-gnutls_005fext_005fget_005fcurrent_005fmsg">Function: <em>unsigned</em> <strong>gnutls_ext_get_current_msg</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: a <code>gnutls_session_t</code>  opaque pointer
</p>
<p>This function allows an extension handler to obtain the message
this extension is being called from. The returned value is a single
entry of the <code>gnutls_ext_flags_t</code>  enumeration. That is, if an
extension was registered with the <code>GNUTLS_EXT_FLAG_HRR</code>  and
<code>GNUTLS_EXT_FLAG_EE</code>  flags, the value when called during parsing of the
encrypted extensions message will be <code>GNUTLS_EXT_FLAG_EE</code> .
</p>
<p>If not called under an extension handler, its value is undefined.
</p>
<p><strong>Since:</strong> 3.6.3
</p></dd></dl>

<span id="gnutls_005fext_005fget_005fdata-1"></span><h4 class="subheading">gnutls_ext_get_data</h4>
<span id="gnutls_005fext_005fget_005fdata"></span><dl>
<dt id="index-gnutls_005fext_005fget_005fdata">Function: <em>int</em> <strong>gnutls_ext_get_data</strong> <em>(gnutls_session_t <var>session</var>, unsigned <var>tls_id</var>, gnutls_ext_priv_data_t * <var>data</var>)</em></dt>
<dd><p><var>session</var>: a <code>gnutls_session_t</code>  opaque pointer
</p>
<p><var>tls_id</var>: the numeric id of the extension
</p>
<p><var>data</var>: a pointer to the private data to retrieve
</p>
<p>This function retrieves any data previously stored with <code>gnutls_ext_set_data()</code> .
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fext_005fget_005fname-1"></span><h4 class="subheading">gnutls_ext_get_name</h4>
<span id="gnutls_005fext_005fget_005fname"></span><dl>
<dt id="index-gnutls_005fext_005fget_005fname">Function: <em>const char *</em> <strong>gnutls_ext_get_name</strong> <em>(unsigned int <var>ext</var>)</em></dt>
<dd><p><var>ext</var>: is a TLS extension numeric ID
</p>
<p>Convert a TLS extension numeric ID to a printable string.
</p>
<p><strong>Returns:</strong> a pointer to a string that contains the name of the
specified cipher, or <code>NULL</code> .
</p></dd></dl>

<span id="gnutls_005fext_005fraw_005fparse-1"></span><h4 class="subheading">gnutls_ext_raw_parse</h4>
<span id="gnutls_005fext_005fraw_005fparse"></span><dl>
<dt id="index-gnutls_005fext_005fraw_005fparse">Function: <em>int</em> <strong>gnutls_ext_raw_parse</strong> <em>(void * <var>ctx</var>, gnutls_ext_raw_process_func <var>cb</var>, const gnutls_datum_t * <var>data</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>ctx</var>: a pointer to pass to callback function
</p>
<p><var>cb</var>: callback function to process each extension found
</p>
<p><var>data</var>: TLS extension data
</p>
<p><var>flags</var>: should be zero or <code>GNUTLS_EXT_RAW_FLAG_TLS_CLIENT_HELLO</code>  or <code>GNUTLS_EXT_RAW_FLAG_DTLS_CLIENT_HELLO</code> 
</p>
<p>This function iterates through the TLS extensions as passed in
 <code>data</code> , passing the individual extension data to callback. The
 <code>data</code> must conform to Extension extensions&lt;0..2^16-1&gt; format.
</p>
<p>If flags is <code>GNUTLS_EXT_RAW_TLS_FLAG_CLIENT_HELLO</code>  then this function
will parse the extension data from the position, as if the packet in
 <code>data</code> is a client hello (without record or handshake headers) -
as provided by <code>gnutls_handshake_set_hook_function()</code> .
</p>
<p>The return value of the callback will be propagated.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, or an error code. On unknown
flags it returns <code>GNUTLS_E_INVALID_REQUEST</code> .
</p>
<p><strong>Since:</strong> 3.6.3
</p></dd></dl>

<span id="gnutls_005fext_005fregister-1"></span><h4 class="subheading">gnutls_ext_register</h4>
<span id="gnutls_005fext_005fregister"></span><dl>
<dt id="index-gnutls_005fext_005fregister">Function: <em>int</em> <strong>gnutls_ext_register</strong> <em>(const char * <var>name</var>, int <var>id</var>, gnutls_ext_parse_type_t <var>parse_type</var>, gnutls_ext_recv_func <var>recv_func</var>, gnutls_ext_send_func <var>send_func</var>, gnutls_ext_deinit_data_func <var>deinit_func</var>, gnutls_ext_pack_func <var>pack_func</var>, gnutls_ext_unpack_func <var>unpack_func</var>)</em></dt>
<dd><p><var>name</var>: the name of the extension to register
</p>
<p><var>id</var>: the numeric TLS id of the extension
</p>
<p><var>parse_type</var>: the parse type of the extension (see gnutls_ext_parse_type_t)
</p>
<p><var>recv_func</var>: a function to receive the data
</p>
<p><var>send_func</var>: a function to send the data
</p>
<p><var>deinit_func</var>: a function deinitialize any private data
</p>
<p><var>pack_func</var>: a function which serializes the extension&rsquo;s private data (used on session packing for resumption)
</p>
<p><var>unpack_func</var>: a function which will deserialize the extension&rsquo;s private data
</p>
<p>This function will register a new extension type. The extension will remain
registered until <code>gnutls_global_deinit()</code>  is called. If the extension type
is already registered then <code>GNUTLS_E_ALREADY_REGISTERED</code>  will be returned.
</p>
<p>Each registered extension can store temporary data into the gnutls_session_t
structure using <code>gnutls_ext_set_data()</code> , and they can be retrieved using
<code>gnutls_ext_get_data()</code> .
</p>
<p>Any extensions registered with this function are valid for the client
and TLS1.2 server hello (or encrypted extensions for TLS1.3).
</p>
<p>This function is not thread safe.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fext_005fset_005fdata-1"></span><h4 class="subheading">gnutls_ext_set_data</h4>
<span id="gnutls_005fext_005fset_005fdata"></span><dl>
<dt id="index-gnutls_005fext_005fset_005fdata">Function: <em>void</em> <strong>gnutls_ext_set_data</strong> <em>(gnutls_session_t <var>session</var>, unsigned <var>tls_id</var>, gnutls_ext_priv_data_t <var>data</var>)</em></dt>
<dd><p><var>session</var>: a <code>gnutls_session_t</code>  opaque pointer
</p>
<p><var>tls_id</var>: the numeric id of the extension
</p>
<p><var>data</var>: the private data to set
</p>
<p>This function allows an extension handler to store data in the current session
and retrieve them later on. The set data will be deallocated using
the gnutls_ext_deinit_data_func.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005ffingerprint-1"></span><h4 class="subheading">gnutls_fingerprint</h4>
<span id="gnutls_005ffingerprint"></span><dl>
<dt id="index-gnutls_005ffingerprint">Function: <em>int</em> <strong>gnutls_fingerprint</strong> <em>(gnutls_digest_algorithm_t <var>algo</var>, const gnutls_datum_t * <var>data</var>, void * <var>result</var>, size_t * <var>result_size</var>)</em></dt>
<dd><p><var>algo</var>: is a digest algorithm
</p>
<p><var>data</var>: is the data
</p>
<p><var>result</var>: is the place where the result will be copied (may be null).
</p>
<p><var>result_size</var>: should hold the size of the result. The actual size
of the returned result will also be copied there.
</p>
<p>This function will calculate a fingerprint (actually a hash), of
the given data.  The result is not printable data.  You should
convert it to hex, or to something else printable.
</p>
<p>This is the usual way to calculate a fingerprint of an X.509 DER
encoded certificate.  Note however that the fingerprint of an
OpenPGP certificate is not just a hash and cannot be calculated with this
function.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p></dd></dl>

<span id="gnutls_005ffips140_005fmode_005fenabled-1"></span><h4 class="subheading">gnutls_fips140_mode_enabled</h4>
<span id="gnutls_005ffips140_005fmode_005fenabled"></span><dl>
<dt id="index-gnutls_005ffips140_005fmode_005fenabled">Function: <em>unsigned</em> <strong>gnutls_fips140_mode_enabled</strong> <em>( <var>void</var>)</em></dt>
<dd>
<p>Checks whether this library is in FIPS140 mode. The returned
value corresponds to the library mode as set with
<code>gnutls_fips140_set_mode()</code> .
</p>
<p>If <code>gnutls_fips140_set_mode()</code>  was called with <code>GNUTLS_FIPS140_SET_MODE_THREAD</code> 
then this function will return the current thread&rsquo;s FIPS140 mode, otherwise
the global value is returned.
</p>
<p><strong>Returns:</strong> return non-zero if true or zero if false.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005ffips140_005fset_005fmode-1"></span><h4 class="subheading">gnutls_fips140_set_mode</h4>
<span id="gnutls_005ffips140_005fset_005fmode"></span><dl>
<dt id="index-gnutls_005ffips140_005fset_005fmode">Function: <em>void</em> <strong>gnutls_fips140_set_mode</strong> <em>(gnutls_fips_mode_t <var>mode</var>, unsigned <var>flags</var>)</em></dt>
<dd><p><var>mode</var>: the FIPS140-2 mode to switch to
</p>
<p><var>flags</var>: should be zero or <code>GNUTLS_FIPS140_SET_MODE_THREAD</code> 
</p>
<p>That function is not thread-safe when changing the mode with no flags
(globally), and should be called prior to creating any threads. Its
behavior with no flags after threads are created is undefined.
</p>
<p>When the flag <code>GNUTLS_FIPS140_SET_MODE_THREAD</code>  is specified
then this call will change the FIPS140-2 mode for this particular
thread and not for the whole process. That way an application
can utilize this function to set and reset mode for specific
operations.
</p>
<p>This function never fails but will be a no-op if used when
the library is not in FIPS140-2 mode. When asked to switch to unknown
values for  <code>mode</code> or to <code>GNUTLS_FIPS140_SELFTESTS</code>  mode, the library
switches to <code>GNUTLS_FIPS140_STRICT</code>  mode.
</p>
<p><strong>Since:</strong> 3.6.2
</p></dd></dl>

<span id="gnutls_005fget_005fsystem_005fconfig_005ffile-1"></span><h4 class="subheading">gnutls_get_system_config_file</h4>
<span id="gnutls_005fget_005fsystem_005fconfig_005ffile"></span><dl>
<dt id="index-gnutls_005fget_005fsystem_005fconfig_005ffile-1">Function: <em>const char *</em> <strong>gnutls_get_system_config_file</strong> <em>( <var>void</var>)</em></dt>
<dd>
<p>Returns the filename of the system wide configuration
file loaded by the library. The returned pointer is valid
until the library is unloaded.
</p>
<p><strong>Returns:</strong> a constant pointer to the config file loaded, or <code>NULL</code>  if none
</p>
<p><strong>Since:</strong> 3.6.9
</p></dd></dl>

<span id="gnutls_005fglobal_005fdeinit-1"></span><h4 class="subheading">gnutls_global_deinit</h4>
<span id="gnutls_005fglobal_005fdeinit"></span><dl>
<dt id="index-gnutls_005fglobal_005fdeinit">Function: <em>void</em> <strong>gnutls_global_deinit</strong> <em>( <var>void</var>)</em></dt>
<dd>
<p>This function deinitializes the global data, that were initialized
using <code>gnutls_global_init()</code> .
</p>
<p>Since GnuTLS 3.3.0 this function is no longer necessary to be explicitly
called. GnuTLS will automatically deinitialize on library destructor. See
<code>gnutls_global_init()</code>  for disabling the implicit initialization/deinitialization.
</p></dd></dl>

<span id="gnutls_005fglobal_005finit-1"></span><h4 class="subheading">gnutls_global_init</h4>
<span id="gnutls_005fglobal_005finit"></span><dl>
<dt id="index-gnutls_005fglobal_005finit">Function: <em>int</em> <strong>gnutls_global_init</strong> <em>( <var>void</var>)</em></dt>
<dd>
<p>Since GnuTLS 3.3.0 this function is no longer necessary to be explicitly
called. To disable the implicit call (in a library constructor) of this
function set the environment variable <code>GNUTLS_NO_EXPLICIT_INIT</code>  to 1.
</p>
<p>This function performs any required precalculations, detects
the supported CPU capabilities and initializes the underlying
cryptographic backend. In order to free any resources 
taken by this call you should <code>gnutls_global_deinit()</code>  
when gnutls usage is no longer needed.
</p>
<p>This function increments a global counter, so that
<code>gnutls_global_deinit()</code>  only releases resources when it has been
called as many times as <code>gnutls_global_init()</code> .  This is useful when
GnuTLS is used by more than one library in an application.  This
function can be called many times, but will only do something the
first time.
</p>
<p>A subsequent call of this function if the initial has failed will
return the same error code.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p></dd></dl>

<span id="gnutls_005fglobal_005fset_005faudit_005flog_005ffunction-1"></span><h4 class="subheading">gnutls_global_set_audit_log_function</h4>
<span id="gnutls_005fglobal_005fset_005faudit_005flog_005ffunction"></span><dl>
<dt id="index-gnutls_005fglobal_005fset_005faudit_005flog_005ffunction-1">Function: <em>void</em> <strong>gnutls_global_set_audit_log_function</strong> <em>(gnutls_audit_log_func <var>log_func</var>)</em></dt>
<dd><p><var>log_func</var>: it is the audit log function
</p>
<p>This is the function to set the audit logging function. This
is a function to report important issues, such as possible
attacks in the protocol. This is different from <code>gnutls_global_set_log_function()</code> 
because it will report also session-specific events. The session
parameter will be null if there is no corresponding TLS session.
</p>
<p><code>gnutls_audit_log_func</code> is of the form,
void (*gnutls_audit_log_func)( gnutls_session_t, const char*);
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fglobal_005fset_005flog_005ffunction-1"></span><h4 class="subheading">gnutls_global_set_log_function</h4>
<span id="gnutls_005fglobal_005fset_005flog_005ffunction"></span><dl>
<dt id="index-gnutls_005fglobal_005fset_005flog_005ffunction">Function: <em>void</em> <strong>gnutls_global_set_log_function</strong> <em>(gnutls_log_func <var>log_func</var>)</em></dt>
<dd><p><var>log_func</var>: it&rsquo;s a log function
</p>
<p>This is the function where you set the logging function gnutls is
going to use.  This function only accepts a character array.
Normally you may not use this function since it is only used for
debugging purposes.
</p>
<p><code>gnutls_log_func</code> is of the form,
void (*gnutls_log_func)( int level, const char*);
</p></dd></dl>

<span id="gnutls_005fglobal_005fset_005flog_005flevel-1"></span><h4 class="subheading">gnutls_global_set_log_level</h4>
<span id="gnutls_005fglobal_005fset_005flog_005flevel"></span><dl>
<dt id="index-gnutls_005fglobal_005fset_005flog_005flevel">Function: <em>void</em> <strong>gnutls_global_set_log_level</strong> <em>(int <var>level</var>)</em></dt>
<dd><p><var>level</var>: it&rsquo;s an integer from 0 to 99.
</p>
<p>This is the function that allows you to set the log level.  The
level is an integer between 0 and 9.  Higher values mean more
verbosity. The default value is 0.  Larger values should only be
used with care, since they may reveal sensitive information.
</p>
<p>Use a log level over 10 to enable all debugging options.
</p></dd></dl>

<span id="gnutls_005fglobal_005fset_005fmutex-1"></span><h4 class="subheading">gnutls_global_set_mutex</h4>
<span id="gnutls_005fglobal_005fset_005fmutex"></span><dl>
<dt id="index-gnutls_005fglobal_005fset_005fmutex">Function: <em>void</em> <strong>gnutls_global_set_mutex</strong> <em>(mutex_init_func <var>init</var>, mutex_deinit_func <var>deinit</var>, mutex_lock_func <var>lock</var>, mutex_unlock_func <var>unlock</var>)</em></dt>
<dd><p><var>init</var>: mutex initialization function
</p>
<p><var>deinit</var>: mutex deinitialization function
</p>
<p><var>lock</var>: mutex locking function
</p>
<p><var>unlock</var>: mutex unlocking function
</p>
<p>With this function you are allowed to override the default mutex
locks used in some parts of gnutls and dependent libraries. This function
should be used if you have complete control of your program and libraries.
Do not call this function from a library, or preferably from any application
unless really needed to. GnuTLS will use the appropriate locks for the running
system.
</p>
<p>Note that since the move to implicit initialization of GnuTLS on library
load, calling this function will deinitialize the library, and re-initialize
it after the new locking functions are set.
</p>
<p>This function must be called prior to any other gnutls function.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fglobal_005fset_005ftime_005ffunction-1"></span><h4 class="subheading">gnutls_global_set_time_function</h4>
<span id="gnutls_005fglobal_005fset_005ftime_005ffunction"></span><dl>
<dt id="index-gnutls_005fglobal_005fset_005ftime_005ffunction">Function: <em>void</em> <strong>gnutls_global_set_time_function</strong> <em>(gnutls_time_func <var>time_func</var>)</em></dt>
<dd><p><var>time_func</var>: it&rsquo;s the system time function, a <code>gnutls_time_func()</code>  callback.
</p>
<p>This is the function where you can override the default system time
function.  The application provided function should behave the same
as the standard function.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fgost_005fparamset_005fget_005fname-1"></span><h4 class="subheading">gnutls_gost_paramset_get_name</h4>
<span id="gnutls_005fgost_005fparamset_005fget_005fname"></span><dl>
<dt id="index-gnutls_005fgost_005fparamset_005fget_005fname">Function: <em>const char *</em> <strong>gnutls_gost_paramset_get_name</strong> <em>(gnutls_gost_paramset_t <var>param</var>)</em></dt>
<dd><p><var>param</var>: is a GOST 28147 param set
</p>
<p>Convert a <code>gnutls_gost_paramset_t</code>  value to a string.
</p>
<p><strong>Returns:</strong> a string that contains the name of the specified GOST param set,
or <code>NULL</code> .
</p>
<p><strong>Since:</strong> 3.6.3
</p></dd></dl>

<span id="gnutls_005fgost_005fparamset_005fget_005foid-1"></span><h4 class="subheading">gnutls_gost_paramset_get_oid</h4>
<span id="gnutls_005fgost_005fparamset_005fget_005foid"></span><dl>
<dt id="index-gnutls_005fgost_005fparamset_005fget_005foid">Function: <em>const char *</em> <strong>gnutls_gost_paramset_get_oid</strong> <em>(gnutls_gost_paramset_t <var>param</var>)</em></dt>
<dd><p><var>param</var>: is a GOST 28147 param set
</p>
<p>Convert a <code>gnutls_gost_paramset_t</code>  value to its object identifier.
</p>
<p><strong>Returns:</strong> a string that contains the object identifier of the specified GOST
param set, or <code>NULL</code> .
</p>
<p><strong>Since:</strong> 3.6.3
</p></dd></dl>

<span id="gnutls_005fgroup_005fget-1"></span><h4 class="subheading">gnutls_group_get</h4>
<span id="gnutls_005fgroup_005fget"></span><dl>
<dt id="index-gnutls_005fgroup_005fget">Function: <em>gnutls_group_t</em> <strong>gnutls_group_get</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Returns the currently used group for key exchange. Only valid
when using an elliptic curve or DH ciphersuite.
</p>
<p><strong>Returns:</strong> the currently used group, a <code>gnutls_group_t</code> 
type.
</p>
<p><strong>Since:</strong> 3.6.0
</p></dd></dl>

<span id="gnutls_005fgroup_005fget_005fid-1"></span><h4 class="subheading">gnutls_group_get_id</h4>
<span id="gnutls_005fgroup_005fget_005fid"></span><dl>
<dt id="index-gnutls_005fgroup_005fget_005fid">Function: <em>gnutls_group_t</em> <strong>gnutls_group_get_id</strong> <em>(const char * <var>name</var>)</em></dt>
<dd><p><var>name</var>: is a group name
</p>
<p>The names are compared in a case insensitive way.
</p>
<p><strong>Returns:</strong> return a <code>gnutls_group_t</code>  value corresponding to
the specified group, or <code>GNUTLS_GROUP_INVALID</code>  on error.
</p>
<p><strong>Since:</strong> 3.6.0
</p></dd></dl>

<span id="gnutls_005fgroup_005fget_005fname-1"></span><h4 class="subheading">gnutls_group_get_name</h4>
<span id="gnutls_005fgroup_005fget_005fname"></span><dl>
<dt id="index-gnutls_005fgroup_005fget_005fname">Function: <em>const char *</em> <strong>gnutls_group_get_name</strong> <em>(gnutls_group_t <var>group</var>)</em></dt>
<dd><p><var>group</var>: is an element from <code>gnutls_group_t</code> 
</p>
<p>Convert a <code>gnutls_group_t</code>  value to a string.
</p>
<p><strong>Returns:</strong> a string that contains the name of the specified
group or <code>NULL</code> .
</p>
<p><strong>Since:</strong> 3.6.0
</p></dd></dl>

<span id="gnutls_005fgroup_005flist-1"></span><h4 class="subheading">gnutls_group_list</h4>
<span id="gnutls_005fgroup_005flist"></span><dl>
<dt id="index-gnutls_005fgroup_005flist">Function: <em>const gnutls_group_t *</em> <strong>gnutls_group_list</strong> <em>( <var>void</var>)</em></dt>
<dd>
<p>Get the list of supported elliptic curves.
</p>
<p>This function is not thread safe.
</p>
<p><strong>Returns:</strong> Return a (0)-terminated list of <code>gnutls_group_t</code> 
integers indicating the available groups.
</p>
<p><strong>Since:</strong> 3.6.0
</p></dd></dl>

<span id="gnutls_005fhandshake-1"></span><h4 class="subheading">gnutls_handshake</h4>
<span id="gnutls_005fhandshake"></span><dl>
<dt id="index-gnutls_005fhandshake-1">Function: <em>int</em> <strong>gnutls_handshake</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>This function performs the handshake of the TLS/SSL protocol, and
initializes the TLS session parameters.
</p>
<p>The non-fatal errors expected by this function are:
<code>GNUTLS_E_INTERRUPTED</code> , <code>GNUTLS_E_AGAIN</code> , 
<code>GNUTLS_E_WARNING_ALERT_RECEIVED</code> . When this function is called
for re-handshake under TLS 1.2 or earlier, the non-fatal error code
<code>GNUTLS_E_GOT_APPLICATION_DATA</code>  may also be returned.
</p>
<p>The former two interrupt the handshake procedure due to the transport
layer being interrupted, and the latter because of a &quot;warning&quot; alert that
was sent by the peer (it is always a good idea to check any
received alerts). On these non-fatal errors call this function again,
until it returns 0; cf.  <code>gnutls_record_get_direction()</code>  and
<code>gnutls_error_is_fatal()</code> . In DTLS sessions the non-fatal error
<code>GNUTLS_E_LARGE_PACKET</code>  is also possible, and indicates that
the MTU should be adjusted.
</p>
<p>When this function is called by a server after a rehandshake request
under TLS 1.2 or earlier the <code>GNUTLS_E_GOT_APPLICATION_DATA</code>  error code indicates
that some data were pending prior to peer initiating the handshake.
Under TLS 1.3 this function when called after a successful handshake, is a no-op
and always succeeds in server side; in client side this function is
equivalent to <code>gnutls_session_key_update()</code>  with <code>GNUTLS_KU_PEER</code>  flag.
</p>
<p>This function handles both full and abbreviated TLS handshakes (resumption).
For abbreviated handshakes, in client side, the <code>gnutls_session_set_data()</code> 
should be called prior to this function to set parameters from a previous session.
In server side, resumption is handled by either setting a DB back-end, or setting
up keys for session tickets.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on a successful handshake, otherwise a negative error code.
</p></dd></dl>

<span id="gnutls_005fhandshake_005fdescription_005fget_005fname-1"></span><h4 class="subheading">gnutls_handshake_description_get_name</h4>
<span id="gnutls_005fhandshake_005fdescription_005fget_005fname"></span><dl>
<dt id="index-gnutls_005fhandshake_005fdescription_005fget_005fname">Function: <em>const char     *</em> <strong>gnutls_handshake_description_get_name</strong> <em>(gnutls_handshake_description_t         <var>type</var>)</em></dt>
<dd><p><var>type</var>: is a handshake message description
</p>
<p>Convert a <code>gnutls_handshake_description_t</code>  value to a string.
</p>
<p><strong>Returns:</strong> a string that contains the name of the specified handshake
message or <code>NULL</code> .
</p></dd></dl>

<span id="gnutls_005fhandshake_005fget_005flast_005fin-1"></span><h4 class="subheading">gnutls_handshake_get_last_in</h4>
<span id="gnutls_005fhandshake_005fget_005flast_005fin"></span><dl>
<dt id="index-gnutls_005fhandshake_005fget_005flast_005fin">Function: <em>gnutls_handshake_description_t</em> <strong>gnutls_handshake_get_last_in</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>This function is only useful to check where the last performed
handshake failed.  If the previous handshake succeed or was not
performed at all then no meaningful value will be returned.
</p>
<p>Check <code>gnutls_handshake_description_t</code>  in gnutls.h for the
available handshake descriptions.
</p>
<p><strong>Returns:</strong> the last handshake message type received, a
<code>gnutls_handshake_description_t</code> .
</p></dd></dl>

<span id="gnutls_005fhandshake_005fget_005flast_005fout-1"></span><h4 class="subheading">gnutls_handshake_get_last_out</h4>
<span id="gnutls_005fhandshake_005fget_005flast_005fout"></span><dl>
<dt id="index-gnutls_005fhandshake_005fget_005flast_005fout">Function: <em>gnutls_handshake_description_t</em> <strong>gnutls_handshake_get_last_out</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>This function is only useful to check where the last performed
handshake failed.  If the previous handshake succeed or was not
performed at all then no meaningful value will be returned.
</p>
<p>Check <code>gnutls_handshake_description_t</code>  in gnutls.h for the
available handshake descriptions.
</p>
<p><strong>Returns:</strong> the last handshake message type sent, a
<code>gnutls_handshake_description_t</code> .
</p></dd></dl>

<span id="gnutls_005fhandshake_005fset_005fhook_005ffunction-1"></span><h4 class="subheading">gnutls_handshake_set_hook_function</h4>
<span id="gnutls_005fhandshake_005fset_005fhook_005ffunction"></span><dl>
<dt id="index-gnutls_005fhandshake_005fset_005fhook_005ffunction-1">Function: <em>void</em> <strong>gnutls_handshake_set_hook_function</strong> <em>(gnutls_session_t <var>session</var>, unsigned int <var>htype</var>, int <var>when</var>, gnutls_handshake_hook_func <var>func</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type
</p>
<p><var>htype</var>: the <code>gnutls_handshake_description_t</code>  of the message to hook at
</p>
<p><var>when</var>: <code>GNUTLS_HOOK_</code> * depending on when the hook function should be called
</p>
<p><var>func</var>: is the function to be called
</p>
<p>This function will set a callback to be called after or before the specified
handshake message has been received or generated. This is a
generalization of <code>gnutls_handshake_set_post_client_hello_function()</code> .
</p>
<p>To call the hook function prior to the message being generated or processed
use <code>GNUTLS_HOOK_PRE</code>  as  <code>when</code> parameter, <code>GNUTLS_HOOK_POST</code>  to call
after, and <code>GNUTLS_HOOK_BOTH</code>  for both cases.
</p>
<p>This callback must return 0 on success or a gnutls error code to
terminate the handshake.
</p>
<p>To hook at all handshake messages use an  <code>htype</code> of <code>GNUTLS_HANDSHAKE_ANY</code> .
</p>
<p><strong>Warning:</strong> You should not use this function to terminate the
handshake based on client input unless you know what you are
doing. Before the handshake is finished there is no way to know if
there is a man-in-the-middle attack being performed.
</p></dd></dl>

<span id="gnutls_005fhandshake_005fset_005fmax_005fpacket_005flength-1"></span><h4 class="subheading">gnutls_handshake_set_max_packet_length</h4>
<span id="gnutls_005fhandshake_005fset_005fmax_005fpacket_005flength"></span><dl>
<dt id="index-gnutls_005fhandshake_005fset_005fmax_005fpacket_005flength">Function: <em>void</em> <strong>gnutls_handshake_set_max_packet_length</strong> <em>(gnutls_session_t <var>session</var>, size_t <var>max</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>max</var>: is the maximum number.
</p>
<p>This function will set the maximum size of all handshake messages.
Handshakes over this size are rejected with
<code>GNUTLS_E_HANDSHAKE_TOO_LARGE</code>  error code.  The default value is
128kb which is typically large enough.  Set this to 0 if you do not
want to set an upper limit.
</p>
<p>The reason for restricting the handshake message sizes are to
limit Denial of Service attacks.
</p>
<p>Note that the maximum handshake size was increased to 128kb
from 48kb in GnuTLS 3.5.5.
</p></dd></dl>

<span id="gnutls_005fhandshake_005fset_005fpost_005fclient_005fhello_005ffunction-1"></span><h4 class="subheading">gnutls_handshake_set_post_client_hello_function</h4>
<span id="gnutls_005fhandshake_005fset_005fpost_005fclient_005fhello_005ffunction"></span><dl>
<dt id="index-gnutls_005fhandshake_005fset_005fpost_005fclient_005fhello_005ffunction">Function: <em>void</em> <strong>gnutls_handshake_set_post_client_hello_function</strong> <em>(gnutls_session_t <var>session</var>, gnutls_handshake_simple_hook_func <var>func</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>func</var>: is the function to be called
</p>
<p>This function will set a callback to be called after the client
hello has been received (callback valid in server side only). This
allows the server to adjust settings based on received extensions.
</p>
<p>Those settings could be ciphersuites, requesting certificate, or
anything else except for version negotiation (this is done before
the hello message is parsed).
</p>
<p>This callback must return 0 on success or a gnutls error code to
terminate the handshake.
</p>
<p>Since GnuTLS 3.3.5 the callback is
allowed to return <code>GNUTLS_E_AGAIN</code>  or <code>GNUTLS_E_INTERRUPTED</code>  to
put the handshake on hold. In that case <code>gnutls_handshake()</code> 
will return <code>GNUTLS_E_INTERRUPTED</code>  and can be resumed when needed.
</p>
<p><strong>Warning:</strong> You should not use this function to terminate the
handshake based on client input unless you know what you are
doing. Before the handshake is finished there is no way to know if
there is a man-in-the-middle attack being performed.
</p></dd></dl>

<span id="gnutls_005fhandshake_005fset_005fprivate_005fextensions-1"></span><h4 class="subheading">gnutls_handshake_set_private_extensions</h4>
<span id="gnutls_005fhandshake_005fset_005fprivate_005fextensions"></span><dl>
<dt id="index-gnutls_005fhandshake_005fset_005fprivate_005fextensions">Function: <em>void</em> <strong>gnutls_handshake_set_private_extensions</strong> <em>(gnutls_session_t <var>session</var>, int <var>allow</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>allow</var>: is an integer (0 or 1)
</p>
<p>This function will enable or disable the use of private cipher
suites (the ones that start with 0xFF).  By default or if  <code>allow</code> is 0 then these cipher suites will not be advertised nor used.
</p>
<p>Currently GnuTLS does not include such cipher-suites or
compression algorithms.
</p>
<p>Enabling the private ciphersuites when talking to other than
gnutls servers and clients may cause interoperability problems.
</p></dd></dl>

<span id="gnutls_005fhandshake_005fset_005frandom-1"></span><h4 class="subheading">gnutls_handshake_set_random</h4>
<span id="gnutls_005fhandshake_005fset_005frandom"></span><dl>
<dt id="index-gnutls_005fhandshake_005fset_005frandom">Function: <em>int</em> <strong>gnutls_handshake_set_random</strong> <em>(gnutls_session_t <var>session</var>, const gnutls_datum_t * <var>random</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>random</var>: a random value of 32-bytes
</p>
<p>This function will explicitly set the server or client hello 
random value in the subsequent TLS handshake. The random value 
should be a 32-byte value.
</p>
<p>Note that this function should not normally be used as gnutls
will select automatically a random value for the handshake.
</p>
<p>This function should not be used when resuming a session.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, or an error code.
</p>
<p>Since 3.1.9
</p></dd></dl>

<span id="gnutls_005fhandshake_005fset_005ftimeout-1"></span><h4 class="subheading">gnutls_handshake_set_timeout</h4>
<span id="gnutls_005fhandshake_005fset_005ftimeout"></span><dl>
<dt id="index-gnutls_005fhandshake_005fset_005ftimeout-1">Function: <em>void</em> <strong>gnutls_handshake_set_timeout</strong> <em>(gnutls_session_t <var>session</var>, unsigned int <var>ms</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>ms</var>: is a timeout value in milliseconds
</p>
<p>This function sets the timeout for the TLS handshake process
to the provided value. Use an  <code>ms</code> value of zero to disable
timeout, or <code>GNUTLS_DEFAULT_HANDSHAKE_TIMEOUT</code>  for a reasonable
default value. For the DTLS protocol, the more detailed
<code>gnutls_dtls_set_timeouts()</code>  is provided.
</p>
<p>This function requires to set a pull timeout callback. See
<code>gnutls_transport_set_pull_timeout_function()</code> .
</p>
<p><strong>Since:</strong> 3.1.0
</p></dd></dl>

<span id="gnutls_005fheartbeat_005fallowed-1"></span><h4 class="subheading">gnutls_heartbeat_allowed</h4>
<span id="gnutls_005fheartbeat_005fallowed"></span><dl>
<dt id="index-gnutls_005fheartbeat_005fallowed">Function: <em>unsigned</em> <strong>gnutls_heartbeat_allowed</strong> <em>(gnutls_session_t <var>session</var>, unsigned int <var>type</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>type</var>: one of <code>GNUTLS_HB_LOCAL_ALLOWED_TO_SEND</code>  and <code>GNUTLS_HB_PEER_ALLOWED_TO_SEND</code> 
</p>
<p>This function will check whether heartbeats are allowed
to be sent or received in this session. 
</p>
<p><strong>Returns:</strong> Non zero if heartbeats are allowed.
</p>
<p><strong>Since:</strong> 3.1.2
</p></dd></dl>

<span id="gnutls_005fheartbeat_005fenable-1"></span><h4 class="subheading">gnutls_heartbeat_enable</h4>
<span id="gnutls_005fheartbeat_005fenable"></span><dl>
<dt id="index-gnutls_005fheartbeat_005fenable">Function: <em>void</em> <strong>gnutls_heartbeat_enable</strong> <em>(gnutls_session_t <var>session</var>, unsigned int <var>type</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>type</var>: one of the GNUTLS_HB_* flags
</p>
<p>If this function is called with the <code>GNUTLS_HB_PEER_ALLOWED_TO_SEND</code> 
 <code>type</code> , GnuTLS will allow heartbeat messages to be received. Moreover it also
request the peer to accept heartbeat messages. This function
must be called prior to TLS handshake.
</p>
<p>If the  <code>type</code> used is <code>GNUTLS_HB_LOCAL_ALLOWED_TO_SEND</code> , then the peer
will be asked to accept heartbeat messages but not send ones.
</p>
<p>The function <code>gnutls_heartbeat_allowed()</code>  can be used to test Whether
locally generated heartbeat messages can be accepted by the peer.
</p>
<p><strong>Since:</strong> 3.1.2
</p></dd></dl>

<span id="gnutls_005fheartbeat_005fget_005ftimeout-1"></span><h4 class="subheading">gnutls_heartbeat_get_timeout</h4>
<span id="gnutls_005fheartbeat_005fget_005ftimeout"></span><dl>
<dt id="index-gnutls_005fheartbeat_005fget_005ftimeout">Function: <em>unsigned int</em> <strong>gnutls_heartbeat_get_timeout</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>This function will return the milliseconds remaining
for a retransmission of the previously sent ping
message. This function is useful when ping is used in
non-blocking mode, to estimate when to call <code>gnutls_heartbeat_ping()</code> 
if no packets have been received.
</p>
<p><strong>Returns:</strong> the remaining time in milliseconds.
</p>
<p><strong>Since:</strong> 3.1.2
</p></dd></dl>

<span id="gnutls_005fheartbeat_005fping-1"></span><h4 class="subheading">gnutls_heartbeat_ping</h4>
<span id="gnutls_005fheartbeat_005fping"></span><dl>
<dt id="index-gnutls_005fheartbeat_005fping">Function: <em>int</em> <strong>gnutls_heartbeat_ping</strong> <em>(gnutls_session_t <var>session</var>, size_t <var>data_size</var>, unsigned int <var>max_tries</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>data_size</var>: is the length of the ping payload.
</p>
<p><var>max_tries</var>: if flags is <code>GNUTLS_HEARTBEAT_WAIT</code>  then this sets the number of retransmissions. Use zero for indefinite (until timeout).
</p>
<p><var>flags</var>: if <code>GNUTLS_HEARTBEAT_WAIT</code>  then wait for pong or timeout instead of returning immediately.
</p>
<p>This function sends a ping to the peer. If the  <code>flags</code> is set
to <code>GNUTLS_HEARTBEAT_WAIT</code>  then it waits for a reply from the peer.
</p>
<p>Note that it is highly recommended to use this function with the
flag <code>GNUTLS_HEARTBEAT_WAIT</code> , or you need to handle retransmissions
and timeouts manually.
</p>
<p>The total TLS data transmitted as part of the ping message are given by
the following formula: MAX(16,  <code>data_size</code> )+<code>gnutls_record_overhead_size()</code> +3.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p>
<p><strong>Since:</strong> 3.1.2
</p></dd></dl>

<span id="gnutls_005fheartbeat_005fpong-1"></span><h4 class="subheading">gnutls_heartbeat_pong</h4>
<span id="gnutls_005fheartbeat_005fpong"></span><dl>
<dt id="index-gnutls_005fheartbeat_005fpong">Function: <em>int</em> <strong>gnutls_heartbeat_pong</strong> <em>(gnutls_session_t <var>session</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>flags</var>: should be zero
</p>
<p>This function replies to a ping by sending a pong to the peer.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p>
<p><strong>Since:</strong> 3.1.2
</p></dd></dl>

<span id="gnutls_005fheartbeat_005fset_005ftimeouts-1"></span><h4 class="subheading">gnutls_heartbeat_set_timeouts</h4>
<span id="gnutls_005fheartbeat_005fset_005ftimeouts"></span><dl>
<dt id="index-gnutls_005fheartbeat_005fset_005ftimeouts">Function: <em>void</em> <strong>gnutls_heartbeat_set_timeouts</strong> <em>(gnutls_session_t <var>session</var>, unsigned int <var>retrans_timeout</var>, unsigned int <var>total_timeout</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>retrans_timeout</var>: The time at which a retransmission will occur in milliseconds
</p>
<p><var>total_timeout</var>: The time at which the connection will be aborted, in milliseconds.
</p>
<p>This function will override the timeouts for the DTLS heartbeat
protocol. The retransmission timeout is the time after which a
message from the peer is not received, the previous request will
be retransmitted. The total timeout is the time after which the
handshake will be aborted with <code>GNUTLS_E_TIMEDOUT</code> .
</p>
<p><strong>Since:</strong> 3.1.2
</p></dd></dl>

<span id="gnutls_005fhex2bin-1"></span><h4 class="subheading">gnutls_hex2bin</h4>
<span id="gnutls_005fhex2bin"></span><dl>
<dt id="index-gnutls_005fhex2bin">Function: <em>int</em> <strong>gnutls_hex2bin</strong> <em>(const char * <var>hex_data</var>, size_t <var>hex_size</var>, void * <var>bin_data</var>, size_t * <var>bin_size</var>)</em></dt>
<dd><p><var>hex_data</var>: string with data in hex format
</p>
<p><var>hex_size</var>: size of hex data
</p>
<p><var>bin_data</var>: output array with binary data
</p>
<p><var>bin_size</var>: when calling should hold maximum size of  <code>bin_data</code> ,
on return will hold actual length of  <code>bin_data</code> .
</p>
<p>Convert a buffer with hex data to binary data. This function
unlike <code>gnutls_hex_decode()</code>  can parse hex data with separators
between numbers. That is, it ignores any non-hex characters.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p>
<p><strong>Since:</strong> 2.4.0
</p></dd></dl>

<span id="gnutls_005fhex_005fdecode-1"></span><h4 class="subheading">gnutls_hex_decode</h4>
<span id="gnutls_005fhex_005fdecode"></span><dl>
<dt id="index-gnutls_005fhex_005fdecode">Function: <em>int</em> <strong>gnutls_hex_decode</strong> <em>(const gnutls_datum_t * <var>hex_data</var>, void * <var>result</var>, size_t * <var>result_size</var>)</em></dt>
<dd><p><var>hex_data</var>: contain the encoded data
</p>
<p><var>result</var>: the place where decoded data will be copied
</p>
<p><var>result_size</var>: holds the size of the result
</p>
<p>This function will decode the given encoded data, using the hex
encoding used by PSK password files.
</p>
<p>Initially  <code>result_size</code> must hold the maximum size available in
 <code>result</code> , and on return it will contain the number of bytes written.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if the buffer given is not
long enough, <code>GNUTLS_E_PARSING_ERROR</code>  on invalid hex data, or 0 on success.
</p></dd></dl>

<span id="gnutls_005fhex_005fdecode2-1"></span><h4 class="subheading">gnutls_hex_decode2</h4>
<span id="gnutls_005fhex_005fdecode2"></span><dl>
<dt id="index-gnutls_005fhex_005fdecode2">Function: <em>int</em> <strong>gnutls_hex_decode2</strong> <em>(const gnutls_datum_t * <var>hex_data</var>, gnutls_datum_t * <var>result</var>)</em></dt>
<dd><p><var>hex_data</var>: contain the encoded data
</p>
<p><var>result</var>: the result in an allocated string
</p>
<p>This function will decode the given encoded data, using the hex
encoding used by PSK password files.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_PARSING_ERROR</code>  on invalid hex data, or 0 on success.
</p></dd></dl>

<span id="gnutls_005fhex_005fencode-1"></span><h4 class="subheading">gnutls_hex_encode</h4>
<span id="gnutls_005fhex_005fencode"></span><dl>
<dt id="index-gnutls_005fhex_005fencode">Function: <em>int</em> <strong>gnutls_hex_encode</strong> <em>(const gnutls_datum_t * <var>data</var>, char * <var>result</var>, size_t * <var>result_size</var>)</em></dt>
<dd><p><var>data</var>: contain the raw data
</p>
<p><var>result</var>: the place where hex data will be copied
</p>
<p><var>result_size</var>: holds the size of the result
</p>
<p>This function will convert the given data to printable data, using
the hex encoding, as used in the PSK password files.
</p>
<p>Note that the size of the result includes the null terminator.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if the buffer given is not
long enough, or 0 on success.
</p></dd></dl>

<span id="gnutls_005fhex_005fencode2-1"></span><h4 class="subheading">gnutls_hex_encode2</h4>
<span id="gnutls_005fhex_005fencode2"></span><dl>
<dt id="index-gnutls_005fhex_005fencode2">Function: <em>int</em> <strong>gnutls_hex_encode2</strong> <em>(const gnutls_datum_t * <var>data</var>, gnutls_datum_t * <var>result</var>)</em></dt>
<dd><p><var>data</var>: contain the raw data
</p>
<p><var>result</var>: the result in an allocated string
</p>
<p>This function will convert the given data to printable data, using
the hex encoding, as used in the PSK password files.
</p>
<p>Note that the size of the result does NOT include the null terminator.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p></dd></dl>

<span id="gnutls_005fidna_005fmap-1"></span><h4 class="subheading">gnutls_idna_map</h4>
<span id="gnutls_005fidna_005fmap"></span><dl>
<dt id="index-gnutls_005fidna_005fmap">Function: <em>int</em> <strong>gnutls_idna_map</strong> <em>(const char * <var>input</var>, unsigned <var>ilen</var>, gnutls_datum_t * <var>out</var>, unsigned <var>flags</var>)</em></dt>
<dd><p><var>input</var>: contain the UTF-8 formatted domain name
</p>
<p><var>ilen</var>: the length of the provided string
</p>
<p><var>out</var>: the result in an null-terminated allocated string
</p>
<p><var>flags</var>: should be zero
</p>
<p>This function will convert the provided UTF-8 domain name, to
its IDNA mapping in an allocated variable. Note that depending on the flags the used gnutls
library was compiled with, the output of this function may vary (i.e.,
may be IDNA2008, or IDNA2003).
</p>
<p>To force IDNA2008 specify the flag <code>GNUTLS_IDNA_FORCE_2008</code> . In
the case GnuTLS is not compiled with the necessary dependencies,
<code>GNUTLS_E_UNIMPLEMENTED_FEATURE</code>  will be returned to indicate that
gnutls is unable to perform the requested conversion.
</p>
<p>Note also, that this function will return an empty string if an
empty string is provided as input.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_INVALID_UTF8_STRING</code>  on invalid UTF-8 data, or 0 on success.
</p>
<p><strong>Since:</strong> 3.5.8
</p></dd></dl>

<span id="gnutls_005fidna_005freverse_005fmap-1"></span><h4 class="subheading">gnutls_idna_reverse_map</h4>
<span id="gnutls_005fidna_005freverse_005fmap"></span><dl>
<dt id="index-gnutls_005fidna_005freverse_005fmap">Function: <em>int</em> <strong>gnutls_idna_reverse_map</strong> <em>(const char * <var>input</var>, unsigned <var>ilen</var>, gnutls_datum_t * <var>out</var>, unsigned <var>flags</var>)</em></dt>
<dd><p><var>input</var>: contain the ACE (IDNA) formatted domain name
</p>
<p><var>ilen</var>: the length of the provided string
</p>
<p><var>out</var>: the result in an null-terminated allocated UTF-8 string
</p>
<p><var>flags</var>: should be zero
</p>
<p>This function will convert an ACE (ASCII-encoded) domain name to a UTF-8 domain name.
</p>
<p>If GnuTLS is compiled without IDNA support, then this function
will return <code>GNUTLS_E_UNIMPLEMENTED_FEATURE</code> .
</p>
<p>Note also, that this function will return an empty string if an
empty string is provided as input.
</p>
<p><strong>Returns:</strong> A negative error code on error, or 0 on success.
</p>
<p><strong>Since:</strong> 3.5.8
</p></dd></dl>

<span id="gnutls_005finit-1"></span><h4 class="subheading">gnutls_init</h4>
<span id="gnutls_005finit"></span><dl>
<dt id="index-gnutls_005finit-1">Function: <em>int</em> <strong>gnutls_init</strong> <em>(gnutls_session_t * <var>session</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>session</var>: is a pointer to a <code>gnutls_session_t</code>  type.
</p>
<p><var>flags</var>: indicate if this session is to be used for server or client.
</p>
<p>This function initializes the provided session. Every
session must be initialized before use, and must be deinitialized
after used by calling <code>gnutls_deinit()</code> .
</p>
<p><code>flags</code> can be any combination of flags from <code>gnutls_init_flags_t</code> .
</p>
<p>Note that since version 3.1.2 this function enables some common
TLS extensions such as session tickets and OCSP certificate status
request in client side by default. To prevent that use the <code>GNUTLS_NO_EXTENSIONS</code> 
flag.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, or an error code.
</p></dd></dl>

<span id="gnutls_005fkey_005fgenerate-1"></span><h4 class="subheading">gnutls_key_generate</h4>
<span id="gnutls_005fkey_005fgenerate"></span><dl>
<dt id="index-gnutls_005fkey_005fgenerate">Function: <em>int</em> <strong>gnutls_key_generate</strong> <em>(gnutls_datum_t * <var>key</var>, unsigned int <var>key_size</var>)</em></dt>
<dd><p><var>key</var>: is a pointer to a <code>gnutls_datum_t</code>  which will contain a newly
created key
</p>
<p><var>key_size</var>: the number of bytes of the key
</p>
<p>Generates a random key of  <code>key_size</code> bytes.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, or an
error code.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fkx_005fget-1"></span><h4 class="subheading">gnutls_kx_get</h4>
<span id="gnutls_005fkx_005fget"></span><dl>
<dt id="index-gnutls_005fkx_005fget">Function: <em>gnutls_kx_algorithm_t</em> <strong>gnutls_kx_get</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Get the currently used key exchange algorithm.
</p>
<p>This function will return <code>GNUTLS_KX_ECDHE_RSA</code> , or <code>GNUTLS_KX_DHE_RSA</code> 
under TLS 1.3, to indicate an elliptic curve DH key exchange or
a finite field one. The precise group used is available
by calling <code>gnutls_group_get()</code>  instead.
</p>
<p><strong>Returns:</strong> the key exchange algorithm used in the last handshake, a
<code>gnutls_kx_algorithm_t</code>  value.
</p></dd></dl>

<span id="gnutls_005fkx_005fget_005fid-1"></span><h4 class="subheading">gnutls_kx_get_id</h4>
<span id="gnutls_005fkx_005fget_005fid"></span><dl>
<dt id="index-gnutls_005fkx_005fget_005fid">Function: <em>gnutls_kx_algorithm_t</em> <strong>gnutls_kx_get_id</strong> <em>(const char * <var>name</var>)</em></dt>
<dd><p><var>name</var>: is a KX name
</p>
<p>Convert a string to a <code>gnutls_kx_algorithm_t</code>  value.  The names are
compared in a case insensitive way.
</p>
<p><strong>Returns:</strong> an id of the specified KX algorithm, or <code>GNUTLS_KX_UNKNOWN</code> 
on error.
</p></dd></dl>

<span id="gnutls_005fkx_005fget_005fname-1"></span><h4 class="subheading">gnutls_kx_get_name</h4>
<span id="gnutls_005fkx_005fget_005fname"></span><dl>
<dt id="index-gnutls_005fkx_005fget_005fname">Function: <em>const char *</em> <strong>gnutls_kx_get_name</strong> <em>(gnutls_kx_algorithm_t <var>algorithm</var>)</em></dt>
<dd><p><var>algorithm</var>: is a key exchange algorithm
</p>
<p>Convert a <code>gnutls_kx_algorithm_t</code>  value to a string.
</p>
<p><strong>Returns:</strong> a pointer to a string that contains the name of the
specified key exchange algorithm, or <code>NULL</code> .
</p></dd></dl>

<span id="gnutls_005fkx_005flist-1"></span><h4 class="subheading">gnutls_kx_list</h4>
<span id="gnutls_005fkx_005flist"></span><dl>
<dt id="index-gnutls_005fkx_005flist">Function: <em>const gnutls_kx_algorithm_t *</em> <strong>gnutls_kx_list</strong> <em>( <var>void</var>)</em></dt>
<dd>
<p>Get a list of supported key exchange algorithms.
</p>
<p>This function is not thread safe.
</p>
<p><strong>Returns:</strong> a (0)-terminated list of <code>gnutls_kx_algorithm_t</code>  integers
indicating the available key exchange algorithms.
</p></dd></dl>

<span id="gnutls_005fload_005ffile-1"></span><h4 class="subheading">gnutls_load_file</h4>
<span id="gnutls_005fload_005ffile"></span><dl>
<dt id="index-gnutls_005fload_005ffile">Function: <em>int</em> <strong>gnutls_load_file</strong> <em>(const char * <var>filename</var>, gnutls_datum_t * <var>data</var>)</em></dt>
<dd><p><var>filename</var>: the name of the file to load
</p>
<p><var>data</var>: Where the file will be stored
</p>
<p>This function will load a file into a datum. The data are
zero terminated but the terminating null is not included in length.
The returned data are allocated using <code>gnutls_malloc()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p>
<p>Since 3.1.0
</p></dd></dl>

<span id="gnutls_005fmac_005fget-1"></span><h4 class="subheading">gnutls_mac_get</h4>
<span id="gnutls_005fmac_005fget"></span><dl>
<dt id="index-gnutls_005fmac_005fget">Function: <em>gnutls_mac_algorithm_t</em> <strong>gnutls_mac_get</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Get the currently used MAC algorithm.
</p>
<p><strong>Returns:</strong> the currently used mac algorithm, a
<code>gnutls_mac_algorithm_t</code>  value.
</p></dd></dl>

<span id="gnutls_005fmac_005fget_005fid-1"></span><h4 class="subheading">gnutls_mac_get_id</h4>
<span id="gnutls_005fmac_005fget_005fid"></span><dl>
<dt id="index-gnutls_005fmac_005fget_005fid">Function: <em>gnutls_mac_algorithm_t</em> <strong>gnutls_mac_get_id</strong> <em>(const char * <var>name</var>)</em></dt>
<dd><p><var>name</var>: is a MAC algorithm name
</p>
<p>Convert a string to a <code>gnutls_mac_algorithm_t</code>  value.  The names are
compared in a case insensitive way.
</p>
<p><strong>Returns:</strong> a <code>gnutls_mac_algorithm_t</code>  id of the specified MAC
algorithm string, or <code>GNUTLS_MAC_UNKNOWN</code>  on failure.
</p></dd></dl>

<span id="gnutls_005fmac_005fget_005fkey_005fsize-1"></span><h4 class="subheading">gnutls_mac_get_key_size</h4>
<span id="gnutls_005fmac_005fget_005fkey_005fsize"></span><dl>
<dt id="index-gnutls_005fmac_005fget_005fkey_005fsize">Function: <em>size_t</em> <strong>gnutls_mac_get_key_size</strong> <em>(gnutls_mac_algorithm_t <var>algorithm</var>)</em></dt>
<dd><p><var>algorithm</var>: is an encryption algorithm
</p>
<p>Returns the size of the MAC key used in TLS.
</p>
<p><strong>Returns:</strong> length (in bytes) of the given MAC key size, or 0 if the
given MAC algorithm is invalid.
</p></dd></dl>

<span id="gnutls_005fmac_005fget_005fname-1"></span><h4 class="subheading">gnutls_mac_get_name</h4>
<span id="gnutls_005fmac_005fget_005fname"></span><dl>
<dt id="index-gnutls_005fmac_005fget_005fname">Function: <em>const char *</em> <strong>gnutls_mac_get_name</strong> <em>(gnutls_mac_algorithm_t <var>algorithm</var>)</em></dt>
<dd><p><var>algorithm</var>: is a MAC algorithm
</p>
<p>Convert a <code>gnutls_mac_algorithm_t</code>  value to a string.
</p>
<p><strong>Returns:</strong> a string that contains the name of the specified MAC
algorithm, or <code>NULL</code> .
</p></dd></dl>

<span id="gnutls_005fmac_005flist-1"></span><h4 class="subheading">gnutls_mac_list</h4>
<span id="gnutls_005fmac_005flist"></span><dl>
<dt id="index-gnutls_005fmac_005flist">Function: <em>const gnutls_mac_algorithm_t *</em> <strong>gnutls_mac_list</strong> <em>( <var>void</var>)</em></dt>
<dd>
<p>Get a list of hash algorithms for use as MACs.  Note that not
necessarily all MACs are supported in TLS cipher suites.
This function is not thread safe.
</p>
<p><strong>Returns:</strong> Return a (0)-terminated list of <code>gnutls_mac_algorithm_t</code> 
integers indicating the available MACs.
</p></dd></dl>

<span id="gnutls_005fmemcmp-1"></span><h4 class="subheading">gnutls_memcmp</h4>
<span id="gnutls_005fmemcmp"></span><dl>
<dt id="index-gnutls_005fmemcmp">Function: <em>int</em> <strong>gnutls_memcmp</strong> <em>(const void * <var>s1</var>, const void * <var>s2</var>, size_t <var>n</var>)</em></dt>
<dd><p><var>s1</var>: the first address to compare
</p>
<p><var>s2</var>: the second address to compare
</p>
<p><var>n</var>: the size of memory to compare
</p>
<p>This function will operate similarly to <code>memcmp()</code> , but will operate
on time that depends only on the size of the string. That is will
not return early if the strings don&rsquo;t match on the first byte.
</p>
<p><strong>Returns:</strong> non zero on difference and zero if the buffers are identical.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fmemset-1"></span><h4 class="subheading">gnutls_memset</h4>
<span id="gnutls_005fmemset"></span><dl>
<dt id="index-gnutls_005fmemset">Function: <em>void</em> <strong>gnutls_memset</strong> <em>(void * <var>data</var>, int <var>c</var>, size_t <var>size</var>)</em></dt>
<dd><p><var>data</var>: the memory to set
</p>
<p><var>c</var>: the constant byte to fill the memory with
</p>
<p><var>size</var>: the size of memory
</p>
<p>This function will operate similarly to <code>memset()</code> , but will
not be optimized out by the compiler.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005focsp_005fstatus_005frequest_005fenable_005fclient-1"></span><h4 class="subheading">gnutls_ocsp_status_request_enable_client</h4>
<span id="gnutls_005focsp_005fstatus_005frequest_005fenable_005fclient"></span><dl>
<dt id="index-gnutls_005focsp_005fstatus_005frequest_005fenable_005fclient">Function: <em>int</em> <strong>gnutls_ocsp_status_request_enable_client</strong> <em>(gnutls_session_t <var>session</var>, gnutls_datum_t * <var>responder_id</var>, size_t <var>responder_id_size</var>, gnutls_datum_t * <var>extensions</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>responder_id</var>: ignored, must be <code>NULL</code> 
</p>
<p><var>responder_id_size</var>: ignored, must be zero
</p>
<p><var>extensions</var>: ignored, must be <code>NULL</code> 
</p>
<p>This function is to be used by clients to request OCSP response
from the server, using the &quot;status_request&quot; TLS extension.  Only
OCSP status type is supported.
</p>
<p>Previous versions of GnuTLS supported setting  <code>responder_id</code> and
 <code>extensions</code> fields, but due to the difficult semantics of the
parameter usage, and other issues, this support was removed
since 3.6.0 and these parameters must be set to <code>NULL</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p>
<p><strong>Since:</strong> 3.1.3
</p></dd></dl>

<span id="gnutls_005focsp_005fstatus_005frequest_005fget-1"></span><h4 class="subheading">gnutls_ocsp_status_request_get</h4>
<span id="gnutls_005focsp_005fstatus_005frequest_005fget"></span><dl>
<dt id="index-gnutls_005focsp_005fstatus_005frequest_005fget">Function: <em>int</em> <strong>gnutls_ocsp_status_request_get</strong> <em>(gnutls_session_t <var>session</var>, gnutls_datum_t * <var>response</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>response</var>: a <code>gnutls_datum_t</code>  with DER encoded OCSP response
</p>
<p>This function returns the OCSP status response received
from the TLS server. The  <code>response</code> should be treated as
constant. If no OCSP response is available then
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  is returned.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p>
<p><strong>Since:</strong> 3.1.3
</p></dd></dl>

<span id="gnutls_005focsp_005fstatus_005frequest_005fget2-1"></span><h4 class="subheading">gnutls_ocsp_status_request_get2</h4>
<span id="gnutls_005focsp_005fstatus_005frequest_005fget2"></span><dl>
<dt id="index-gnutls_005focsp_005fstatus_005frequest_005fget2">Function: <em>int</em> <strong>gnutls_ocsp_status_request_get2</strong> <em>(gnutls_session_t <var>session</var>, unsigned <var>idx</var>, gnutls_datum_t * <var>response</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>idx</var>: the index of peer&rsquo;s certificate
</p>
<p><var>response</var>: a <code>gnutls_datum_t</code>  with DER encoded OCSP response
</p>
<p>This function returns the OCSP status response received
from the TLS server for the certificate index provided.
The index corresponds to certificates as returned by
gnutls_certificate_get_peers. When index is zero this
function operates identically to <code>gnutls_ocsp_status_request_get()</code> .
</p>
<p>The returned  <code>response</code> should be treated as
constant. If no OCSP response is available for the
given index then <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
is returned.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p>
<p><strong>Since:</strong> 3.6.3
</p></dd></dl>

<span id="gnutls_005focsp_005fstatus_005frequest_005fis_005fchecked-1"></span><h4 class="subheading">gnutls_ocsp_status_request_is_checked</h4>
<span id="gnutls_005focsp_005fstatus_005frequest_005fis_005fchecked"></span><dl>
<dt id="index-gnutls_005focsp_005fstatus_005frequest_005fis_005fchecked">Function: <em>int</em> <strong>gnutls_ocsp_status_request_is_checked</strong> <em>(gnutls_session_t <var>session</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>session</var>: is a gnutls session
</p>
<p><var>flags</var>: should be zero or <code>GNUTLS_OCSP_SR_IS_AVAIL</code> 
</p>
<p>When flags are zero this function returns non-zero if a valid OCSP status
response was included in the TLS handshake. That is, an OCSP status response
which is not too old or superseded. It returns zero otherwise.
</p>
<p>When the flag <code>GNUTLS_OCSP_SR_IS_AVAIL</code>  is specified, the function
returns non-zero if an OCSP status response was included in the handshake
even if it was invalid. Otherwise, if no OCSP status response was included,
it returns zero. The <code>GNUTLS_OCSP_SR_IS_AVAIL</code>  flag was introduced in GnuTLS 3.4.0.
</p>
<p>This is a helper function when needing to decide whether to perform an
explicit OCSP validity check on the peer&rsquo;s certificate. Should be called after
any of gnutls_certificate_verify_peers*() are called.
</p>
<p>This function is always usable on client side, but on server side only
under TLS 1.3, which is the first version of TLS that allows cliend-side OCSP
responses.
</p>
<p><strong>Returns:</strong> non zero if the response was valid, or a zero if it wasn&rsquo;t sent,
or sent and was invalid.
</p>
<p><strong>Since:</strong> 3.1.4
</p></dd></dl>

<span id="gnutls_005foid_005fto_005fdigest-1"></span><h4 class="subheading">gnutls_oid_to_digest</h4>
<span id="gnutls_005foid_005fto_005fdigest"></span><dl>
<dt id="index-gnutls_005foid_005fto_005fdigest">Function: <em>gnutls_digest_algorithm_t</em> <strong>gnutls_oid_to_digest</strong> <em>(const char * <var>oid</var>)</em></dt>
<dd><p><var>oid</var>: is an object identifier
</p>
<p>Converts a textual object identifier to a <code>gnutls_digest_algorithm_t</code>  value.
</p>
<p><strong>Returns:</strong> a <code>gnutls_digest_algorithm_t</code>  id of the specified digest
algorithm, or <code>GNUTLS_DIG_UNKNOWN</code>  on failure.
</p>
<p><strong>Since:</strong> 3.4.3
</p></dd></dl>

<span id="gnutls_005foid_005fto_005fecc_005fcurve-1"></span><h4 class="subheading">gnutls_oid_to_ecc_curve</h4>
<span id="gnutls_005foid_005fto_005fecc_005fcurve"></span><dl>
<dt id="index-gnutls_005foid_005fto_005fecc_005fcurve">Function: <em>gnutls_ecc_curve_t</em> <strong>gnutls_oid_to_ecc_curve</strong> <em>(const char * <var>oid</var>)</em></dt>
<dd><p><var>oid</var>: is a curve&rsquo;s OID
</p>

<p><strong>Returns:</strong> return a <code>gnutls_ecc_curve_t</code>  value corresponding to
the specified OID, or <code>GNUTLS_ECC_CURVE_INVALID</code>  on error.
</p>
<p><strong>Since:</strong> 3.4.3
</p></dd></dl>

<span id="gnutls_005foid_005fto_005fgost_005fparamset-1"></span><h4 class="subheading">gnutls_oid_to_gost_paramset</h4>
<span id="gnutls_005foid_005fto_005fgost_005fparamset"></span><dl>
<dt id="index-gnutls_005foid_005fto_005fgost_005fparamset">Function: <em>gnutls_gost_paramset_t</em> <strong>gnutls_oid_to_gost_paramset</strong> <em>(const char * <var>oid</var>)</em></dt>
<dd><p><var>oid</var>: is an object identifier
</p>
<p>Converts a textual object identifier to a <code>gnutls_gost_paramset_t</code>  value.
</p>
<p><strong>Returns:</strong> a <code>gnutls_gost_paramset_get_oid</code>  of the specified GOST 28147
param st, or <code>GNUTLS_GOST_PARAMSET_UNKNOWN</code>  on failure.
</p>
<p><strong>Since:</strong> 3.6.3
</p></dd></dl>

<span id="gnutls_005foid_005fto_005fmac-1"></span><h4 class="subheading">gnutls_oid_to_mac</h4>
<span id="gnutls_005foid_005fto_005fmac"></span><dl>
<dt id="index-gnutls_005foid_005fto_005fmac">Function: <em>gnutls_mac_algorithm_t</em> <strong>gnutls_oid_to_mac</strong> <em>(const char * <var>oid</var>)</em></dt>
<dd><p><var>oid</var>: is an object identifier
</p>
<p>Converts a textual object identifier typically from PKCS<code>5</code>  values to a <code>gnutls_mac_algorithm_t</code>  value.
</p>
<p><strong>Returns:</strong> a <code>gnutls_mac_algorithm_t</code>  id of the specified digest
algorithm, or <code>GNUTLS_MAC_UNKNOWN</code>  on failure.
</p>
<p><strong>Since:</strong> 3.5.4
</p></dd></dl>

<span id="gnutls_005foid_005fto_005fpk-1"></span><h4 class="subheading">gnutls_oid_to_pk</h4>
<span id="gnutls_005foid_005fto_005fpk"></span><dl>
<dt id="index-gnutls_005foid_005fto_005fpk">Function: <em>gnutls_pk_algorithm_t</em> <strong>gnutls_oid_to_pk</strong> <em>(const char * <var>oid</var>)</em></dt>
<dd><p><var>oid</var>: is an object identifier
</p>
<p>Converts a textual object identifier to a <code>gnutls_pk_algorithm_t</code>  value.
</p>
<p><strong>Returns:</strong> a <code>gnutls_pk_algorithm_t</code>  id of the specified digest
algorithm, or <code>GNUTLS_PK_UNKNOWN</code>  on failure.
</p>
<p><strong>Since:</strong> 3.4.3
</p></dd></dl>

<span id="gnutls_005foid_005fto_005fsign-1"></span><h4 class="subheading">gnutls_oid_to_sign</h4>
<span id="gnutls_005foid_005fto_005fsign"></span><dl>
<dt id="index-gnutls_005foid_005fto_005fsign">Function: <em>gnutls_sign_algorithm_t</em> <strong>gnutls_oid_to_sign</strong> <em>(const char * <var>oid</var>)</em></dt>
<dd><p><var>oid</var>: is an object identifier
</p>
<p>Converts a textual object identifier to a <code>gnutls_sign_algorithm_t</code>  value.
</p>
<p><strong>Returns:</strong> a <code>gnutls_sign_algorithm_t</code>  id of the specified digest
algorithm, or <code>GNUTLS_SIGN_UNKNOWN</code>  on failure.
</p>
<p><strong>Since:</strong> 3.4.3
</p></dd></dl>

<span id="gnutls_005fopenpgp_005fsend_005fcert-1"></span><h4 class="subheading">gnutls_openpgp_send_cert</h4>
<span id="gnutls_005fopenpgp_005fsend_005fcert"></span><dl>
<dt id="index-gnutls_005fopenpgp_005fsend_005fcert">Function: <em>void</em> <strong>gnutls_openpgp_send_cert</strong> <em>(gnutls_session_t <var>session</var>, gnutls_openpgp_crt_status_t <var>status</var>)</em></dt>
<dd><p><var>session</var>: is a gnutls session
</p>
<p><var>status</var>: is ignored
</p>
<p>This function is no-op.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_UNIMPLEMENTED_FEATURE</code> .
</p></dd></dl>

<span id="gnutls_005fpacket_005fdeinit-1"></span><h4 class="subheading">gnutls_packet_deinit</h4>
<span id="gnutls_005fpacket_005fdeinit"></span><dl>
<dt id="index-gnutls_005fpacket_005fdeinit">Function: <em>void</em> <strong>gnutls_packet_deinit</strong> <em>(gnutls_packet_t <var>packet</var>)</em></dt>
<dd><p><var>packet</var>: is a pointer to a <code>gnutls_packet_st</code>  structure.
</p>
<p>This function will deinitialize all data associated with
the received packet.
</p>
<p><strong>Since:</strong> 3.3.5
</p></dd></dl>

<span id="gnutls_005fpacket_005fget-1"></span><h4 class="subheading">gnutls_packet_get</h4>
<span id="gnutls_005fpacket_005fget"></span><dl>
<dt id="index-gnutls_005fpacket_005fget">Function: <em>void</em> <strong>gnutls_packet_get</strong> <em>(gnutls_packet_t <var>packet</var>, gnutls_datum_t * <var>data</var>, unsigned char * <var>sequence</var>)</em></dt>
<dd><p><var>packet</var>: is a <code>gnutls_packet_t</code>  type.
</p>
<p><var>data</var>: will contain the data present in the  <code>packet</code> structure (may be <code>NULL</code> )
</p>
<p><var>sequence</var>: the 8-bytes of the packet sequence number (may be <code>NULL</code> )
</p>
<p>This function returns the data and sequence number associated with
the received packet.
</p>
<p><strong>Since:</strong> 3.3.5
</p></dd></dl>

<span id="gnutls_005fpem_005fbase64_005fdecode-1"></span><h4 class="subheading">gnutls_pem_base64_decode</h4>
<span id="gnutls_005fpem_005fbase64_005fdecode"></span><dl>
<dt id="index-gnutls_005fpem_005fbase64_005fdecode">Function: <em>int</em> <strong>gnutls_pem_base64_decode</strong> <em>(const char * <var>header</var>, const gnutls_datum_t * <var>b64_data</var>, unsigned char * <var>result</var>, size_t * <var>result_size</var>)</em></dt>
<dd><p><var>header</var>: A null terminated string with the PEM header (eg. CERTIFICATE)
</p>
<p><var>b64_data</var>: contain the encoded data
</p>
<p><var>result</var>: the place where decoded data will be copied
</p>
<p><var>result_size</var>: holds the size of the result
</p>
<p>This function will decode the given encoded data.  If the header
given is non <code>NULL</code>  this function will search for &quot;&mdash;&ndash;BEGIN header&quot;
and decode only this part.  Otherwise it will decode the first PEM
packet found.
</p>
<p><strong>Returns:</strong> On success <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
<code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  is returned if the buffer given is
not long enough, or 0 on success.
</p></dd></dl>

<span id="gnutls_005fpem_005fbase64_005fdecode2-1"></span><h4 class="subheading">gnutls_pem_base64_decode2</h4>
<span id="gnutls_005fpem_005fbase64_005fdecode2"></span><dl>
<dt id="index-gnutls_005fpem_005fbase64_005fdecode2">Function: <em>int</em> <strong>gnutls_pem_base64_decode2</strong> <em>(const char * <var>header</var>, const gnutls_datum_t * <var>b64_data</var>, gnutls_datum_t * <var>result</var>)</em></dt>
<dd><p><var>header</var>: The PEM header (eg. CERTIFICATE)
</p>
<p><var>b64_data</var>: contains the encoded data
</p>
<p><var>result</var>: the location of decoded data
</p>
<p>This function will decode the given encoded data. The decoded data
will be allocated, and stored into result.  If the header given is
non null this function will search for &quot;&mdash;&ndash;BEGIN header&quot; and
decode only this part. Otherwise it will decode the first PEM
packet found.
</p>
<p>You should use <code>gnutls_free()</code>  to free the returned data.
</p>
<p>Note, that prior to GnuTLS 3.4.0 this function was available
under the name <code>gnutls_pem_base64_decode_alloc()</code> . There is
compatibility macro pointing to this function.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fpem_005fbase64_005fencode-1"></span><h4 class="subheading">gnutls_pem_base64_encode</h4>
<span id="gnutls_005fpem_005fbase64_005fencode"></span><dl>
<dt id="index-gnutls_005fpem_005fbase64_005fencode">Function: <em>int</em> <strong>gnutls_pem_base64_encode</strong> <em>(const char * <var>msg</var>, const gnutls_datum_t * <var>data</var>, char * <var>result</var>, size_t * <var>result_size</var>)</em></dt>
<dd><p><var>msg</var>: is a message to be put in the header (may be <code>NULL</code> )
</p>
<p><var>data</var>: contain the raw data
</p>
<p><var>result</var>: the place where base64 data will be copied
</p>
<p><var>result_size</var>: holds the size of the result
</p>
<p>This function will convert the given data to printable data, using
the base64 encoding. This is the encoding used in PEM messages.
</p>
<p>The output string will be null terminated, although the output size will
not include the terminating null.
</p>
<p><strong>Returns:</strong> On success <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
<code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  is returned if the buffer given is
not long enough, or 0 on success.
</p></dd></dl>

<span id="gnutls_005fpem_005fbase64_005fencode2-1"></span><h4 class="subheading">gnutls_pem_base64_encode2</h4>
<span id="gnutls_005fpem_005fbase64_005fencode2"></span><dl>
<dt id="index-gnutls_005fpem_005fbase64_005fencode2">Function: <em>int</em> <strong>gnutls_pem_base64_encode2</strong> <em>(const char * <var>header</var>, const gnutls_datum_t * <var>data</var>, gnutls_datum_t * <var>result</var>)</em></dt>
<dd><p><var>header</var>: is a message to be put in the encoded header (may be <code>NULL</code> )
</p>
<p><var>data</var>: contains the raw data
</p>
<p><var>result</var>: will hold the newly allocated encoded data
</p>
<p>This function will convert the given data to printable data, using
the base64 encoding.  This is the encoding used in PEM messages.
This function will allocate the required memory to hold the encoded
data.
</p>
<p>You should use <code>gnutls_free()</code>  to free the returned data.
</p>
<p>Note, that prior to GnuTLS 3.4.0 this function was available
under the name <code>gnutls_pem_base64_encode_alloc()</code> . There is
compatibility macro pointing to this function.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fperror-1"></span><h4 class="subheading">gnutls_perror</h4>
<span id="gnutls_005fperror"></span><dl>
<dt id="index-gnutls_005fperror">Function: <em>void</em> <strong>gnutls_perror</strong> <em>(int <var>error</var>)</em></dt>
<dd><p><var>error</var>: is a GnuTLS error code, a negative error code
</p>
<p>This function is like <code>perror()</code> . The only difference is that it
accepts an error number returned by a gnutls function.
</p></dd></dl>

<span id="gnutls_005fpk_005falgorithm_005fget_005fname-1"></span><h4 class="subheading">gnutls_pk_algorithm_get_name</h4>
<span id="gnutls_005fpk_005falgorithm_005fget_005fname"></span><dl>
<dt id="index-gnutls_005fpk_005falgorithm_005fget_005fname">Function: <em>const char *</em> <strong>gnutls_pk_algorithm_get_name</strong> <em>(gnutls_pk_algorithm_t <var>algorithm</var>)</em></dt>
<dd><p><var>algorithm</var>: is a pk algorithm
</p>
<p>Convert a <code>gnutls_pk_algorithm_t</code>  value to a string.
</p>
<p><strong>Returns:</strong> a string that contains the name of the specified public
key algorithm, or <code>NULL</code> .
</p></dd></dl>

<span id="gnutls_005fpk_005fbits_005fto_005fsec_005fparam-1"></span><h4 class="subheading">gnutls_pk_bits_to_sec_param</h4>
<span id="gnutls_005fpk_005fbits_005fto_005fsec_005fparam"></span><dl>
<dt id="index-gnutls_005fpk_005fbits_005fto_005fsec_005fparam-1">Function: <em>gnutls_sec_param_t</em> <strong>gnutls_pk_bits_to_sec_param</strong> <em>(gnutls_pk_algorithm_t <var>algo</var>, unsigned int <var>bits</var>)</em></dt>
<dd><p><var>algo</var>: is a public key algorithm
</p>
<p><var>bits</var>: is the number of bits
</p>
<p>This is the inverse of <code>gnutls_sec_param_to_pk_bits()</code> . Given an algorithm
and the number of bits, it will return the security parameter. This is
a rough indication.
</p>
<p><strong>Returns:</strong> The security parameter.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fpk_005fget_005fid-1"></span><h4 class="subheading">gnutls_pk_get_id</h4>
<span id="gnutls_005fpk_005fget_005fid"></span><dl>
<dt id="index-gnutls_005fpk_005fget_005fid">Function: <em>gnutls_pk_algorithm_t</em> <strong>gnutls_pk_get_id</strong> <em>(const char * <var>name</var>)</em></dt>
<dd><p><var>name</var>: is a string containing a public key algorithm name.
</p>
<p>Convert a string to a <code>gnutls_pk_algorithm_t</code>  value.  The names are
compared in a case insensitive way.  For example,
gnutls_pk_get_id(&quot;RSA&quot;) will return <code>GNUTLS_PK_RSA</code> .
</p>
<p><strong>Returns:</strong> a <code>gnutls_pk_algorithm_t</code>  id of the specified public key
algorithm string, or <code>GNUTLS_PK_UNKNOWN</code>  on failures.
</p>
<p><strong>Since:</strong> 2.6.0
</p></dd></dl>

<span id="gnutls_005fpk_005fget_005fname-1"></span><h4 class="subheading">gnutls_pk_get_name</h4>
<span id="gnutls_005fpk_005fget_005fname"></span><dl>
<dt id="index-gnutls_005fpk_005fget_005fname">Function: <em>const char *</em> <strong>gnutls_pk_get_name</strong> <em>(gnutls_pk_algorithm_t <var>algorithm</var>)</em></dt>
<dd><p><var>algorithm</var>: is a public key algorithm
</p>
<p>Convert a <code>gnutls_pk_algorithm_t</code>  value to a string.
</p>
<p><strong>Returns:</strong> a pointer to a string that contains the name of the
specified public key algorithm, or <code>NULL</code> .
</p>
<p><strong>Since:</strong> 2.6.0
</p></dd></dl>

<span id="gnutls_005fpk_005fget_005foid-1"></span><h4 class="subheading">gnutls_pk_get_oid</h4>
<span id="gnutls_005fpk_005fget_005foid"></span><dl>
<dt id="index-gnutls_005fpk_005fget_005foid">Function: <em>const char *</em> <strong>gnutls_pk_get_oid</strong> <em>(gnutls_pk_algorithm_t <var>algorithm</var>)</em></dt>
<dd><p><var>algorithm</var>: is a public key algorithm
</p>
<p>Convert a <code>gnutls_pk_algorithm_t</code>  value to its object identifier string.
</p>
<p><strong>Returns:</strong> a pointer to a string that contains the object identifier of the
specified public key algorithm, or <code>NULL</code> .
</p>
<p><strong>Since:</strong> 3.4.3
</p></dd></dl>

<span id="gnutls_005fpk_005flist-1"></span><h4 class="subheading">gnutls_pk_list</h4>
<span id="gnutls_005fpk_005flist"></span><dl>
<dt id="index-gnutls_005fpk_005flist">Function: <em>const gnutls_pk_algorithm_t *</em> <strong>gnutls_pk_list</strong> <em>( <var>void</var>)</em></dt>
<dd>
<p>Get a list of supported public key algorithms.
</p>
<p>This function is not thread safe.
</p>
<p><strong>Returns:</strong> a (0)-terminated list of <code>gnutls_pk_algorithm_t</code>  integers
indicating the available ciphers.
</p>
<p><strong>Since:</strong> 2.6.0
</p></dd></dl>

<span id="gnutls_005fpk_005fto_005fsign-1"></span><h4 class="subheading">gnutls_pk_to_sign</h4>
<span id="gnutls_005fpk_005fto_005fsign"></span><dl>
<dt id="index-gnutls_005fpk_005fto_005fsign">Function: <em>gnutls_sign_algorithm_t</em> <strong>gnutls_pk_to_sign</strong> <em>(gnutls_pk_algorithm_t <var>pk</var>, gnutls_digest_algorithm_t <var>hash</var>)</em></dt>
<dd><p><var>pk</var>: is a public key algorithm
</p>
<p><var>hash</var>: a hash algorithm
</p>
<p>This function maps public key and hash algorithms combinations
to signature algorithms.
</p>
<p><strong>Returns:</strong> return a <code>gnutls_sign_algorithm_t</code>  value, or <code>GNUTLS_SIGN_UNKNOWN</code>  on error.
</p></dd></dl>

<span id="gnutls_005fprf-1"></span><h4 class="subheading">gnutls_prf</h4>
<span id="gnutls_005fprf"></span><dl>
<dt id="index-gnutls_005fprf">Function: <em>int</em> <strong>gnutls_prf</strong> <em>(gnutls_session_t <var>session</var>, size_t <var>label_size</var>, const char * <var>label</var>, int <var>server_random_first</var>, size_t <var>extra_size</var>, const char * <var>extra</var>, size_t <var>outsize</var>, char * <var>out</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>label_size</var>: length of the  <code>label</code> variable.
</p>
<p><var>label</var>: label used in PRF computation, typically a short string.
</p>
<p><var>server_random_first</var>: non-zero if server random field should be first in seed
</p>
<p><var>extra_size</var>: length of the  <code>extra</code> variable.
</p>
<p><var>extra</var>: optional extra data to seed the PRF with.
</p>
<p><var>outsize</var>: size of pre-allocated output buffer to hold the output.
</p>
<p><var>out</var>: pre-allocated buffer to hold the generated data.
</p>
<p>Applies the TLS Pseudo-Random-Function (PRF) on the master secret
and the provided data, seeded with the client and server random fields.
For the key expansion specified in RFC5705 see <code>gnutls_prf_rfc5705()</code> .
</p>
<p>The  <code>label</code> variable usually contains a string denoting the purpose
for the generated data.  The  <code>server_random_first</code> indicates whether
the client random field or the server random field should be first
in the seed.  Non-zero indicates that the server random field is first,
0 that the client random field is first.
</p>
<p>The  <code>extra</code> variable can be used to add more data to the seed, after
the random variables.  It can be used to make sure the
generated output is strongly connected to some additional data
(e.g., a string used in user authentication).
</p>
<p>The output is placed in  <code>out</code> , which must be pre-allocated.
</p>
<p><strong>Note:</strong> This function produces identical output with <code>gnutls_prf_rfc5705()</code> 
when  <code>server_random_first</code> is set to 0 and  <code>extra</code> is <code>NULL</code> . Under TLS1.3
this function will only operate when these conditions are true, or otherwise
return <code>GNUTLS_E_INVALID_REQUEST</code> .
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, or an error code.
</p></dd></dl>

<span id="gnutls_005fprf_005fearly-1"></span><h4 class="subheading">gnutls_prf_early</h4>
<span id="gnutls_005fprf_005fearly"></span><dl>
<dt id="index-gnutls_005fprf_005fearly">Function: <em>int</em> <strong>gnutls_prf_early</strong> <em>(gnutls_session_t <var>session</var>, size_t <var>label_size</var>, const char * <var>label</var>, size_t <var>context_size</var>, const char * <var>context</var>, size_t <var>outsize</var>, char * <var>out</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>label_size</var>: length of the  <code>label</code> variable.
</p>
<p><var>label</var>: label used in PRF computation, typically a short string.
</p>
<p><var>context_size</var>: length of the  <code>extra</code> variable.
</p>
<p><var>context</var>: optional extra data to seed the PRF with.
</p>
<p><var>outsize</var>: size of pre-allocated output buffer to hold the output.
</p>
<p><var>out</var>: pre-allocated buffer to hold the generated data.
</p>
<p>This function is similar to <code>gnutls_prf_rfc5705()</code> , but only works in
TLS 1.3 or later to export early keying material.
</p>
<p>Note that the keying material is only available after the
ClientHello message is processed and before the application traffic
keys are established.  Therefore this function shall be called in a
handshake hook function for <code>GNUTLS_HANDSHAKE_CLIENT_HELLO</code> .
</p>
<p>The  <code>label</code> variable usually contains a string denoting the purpose
for the generated data.
</p>
<p>The  <code>context</code> variable can be used to add more data to the seed, after
the random variables.  It can be used to make sure the
generated output is strongly connected to some additional data
(e.g., a string used in user authentication).
</p>
<p>The output is placed in  <code>out</code> , which must be pre-allocated.
</p>
<p>Note that, to provide the RFC5705 context, the  <code>context</code> variable
must be non-null.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, or an error code.
</p>
<p><strong>Since:</strong> 3.6.8
</p></dd></dl>

<span id="gnutls_005fprf_005fraw-1"></span><h4 class="subheading">gnutls_prf_raw</h4>
<span id="gnutls_005fprf_005fraw"></span><dl>
<dt id="index-gnutls_005fprf_005fraw">Function: <em>int</em> <strong>gnutls_prf_raw</strong> <em>(gnutls_session_t <var>session</var>, size_t <var>label_size</var>, const char * <var>label</var>, size_t <var>seed_size</var>, const char * <var>seed</var>, size_t <var>outsize</var>, char * <var>out</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>label_size</var>: length of the  <code>label</code> variable.
</p>
<p><var>label</var>: label used in PRF computation, typically a short string.
</p>
<p><var>seed_size</var>: length of the  <code>seed</code> variable.
</p>
<p><var>seed</var>: optional extra data to seed the PRF with.
</p>
<p><var>outsize</var>: size of pre-allocated output buffer to hold the output.
</p>
<p><var>out</var>: pre-allocated buffer to hold the generated data.
</p>
<p>Apply the TLS Pseudo-Random-Function (PRF) on the master secret
and the provided data.
</p>
<p>The  <code>label</code> variable usually contains a string denoting the purpose
for the generated data.  The  <code>seed</code> usually contains data such as the
client and server random, perhaps together with some additional
data that is added to guarantee uniqueness of the output for a
particular purpose.
</p>
<p>Because the output is not guaranteed to be unique for a particular
session unless  <code>seed</code> includes the client random and server random
fields (the PRF would output the same data on another connection
resumed from the first one), it is not recommended to use this
function directly.  The <code>gnutls_prf()</code>  function seeds the PRF with the
client and server random fields directly, and is recommended if you
want to generate pseudo random data unique for each session.
</p>
<p><strong>Note:</strong> This function will only operate under TLS versions prior to 1.3.
In TLS1.3 the use of PRF is replaced with HKDF and the generic
exporters like <code>gnutls_prf_rfc5705()</code>  should be used instead. Under
TLS1.3 this function returns <code>GNUTLS_E_INVALID_REQUEST</code> .
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, or an error code.
</p></dd></dl>

<span id="gnutls_005fprf_005frfc5705-1"></span><h4 class="subheading">gnutls_prf_rfc5705</h4>
<span id="gnutls_005fprf_005frfc5705"></span><dl>
<dt id="index-gnutls_005fprf_005frfc5705-1">Function: <em>int</em> <strong>gnutls_prf_rfc5705</strong> <em>(gnutls_session_t <var>session</var>, size_t <var>label_size</var>, const char * <var>label</var>, size_t <var>context_size</var>, const char * <var>context</var>, size_t <var>outsize</var>, char * <var>out</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>label_size</var>: length of the  <code>label</code> variable.
</p>
<p><var>label</var>: label used in PRF computation, typically a short string.
</p>
<p><var>context_size</var>: length of the  <code>extra</code> variable.
</p>
<p><var>context</var>: optional extra data to seed the PRF with.
</p>
<p><var>outsize</var>: size of pre-allocated output buffer to hold the output.
</p>
<p><var>out</var>: pre-allocated buffer to hold the generated data.
</p>
<p>Exports keying material from TLS/DTLS session to an application, as
specified in RFC5705.
</p>
<p>In the TLS versions prior to 1.3, it applies the TLS
Pseudo-Random-Function (PRF) on the master secret and the provided
data, seeded with the client and server random fields.
</p>
<p>In TLS 1.3, it applies HKDF on the exporter master secret derived
from the master secret.
</p>
<p>The  <code>label</code> variable usually contains a string denoting the purpose
for the generated data.
</p>
<p>The  <code>context</code> variable can be used to add more data to the seed, after
the random variables.  It can be used to make sure the
generated output is strongly connected to some additional data
(e.g., a string used in user authentication). 
</p>
<p>The output is placed in  <code>out</code> , which must be pre-allocated.
</p>
<p>Note that, to provide the RFC5705 context, the  <code>context</code> variable
must be non-null.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, or an error code.
</p>
<p><strong>Since:</strong> 3.4.4
</p></dd></dl>

<span id="gnutls_005fpriority_005fcertificate_005ftype_005flist-1"></span><h4 class="subheading">gnutls_priority_certificate_type_list</h4>
<span id="gnutls_005fpriority_005fcertificate_005ftype_005flist"></span><dl>
<dt id="index-gnutls_005fpriority_005fcertificate_005ftype_005flist">Function: <em>int</em> <strong>gnutls_priority_certificate_type_list</strong> <em>(gnutls_priority_t <var>pcache</var>, const unsigned int ** <var>list</var>)</em></dt>
<dd><p><var>pcache</var>: is a <code>gnutls_prioritity_t</code>  type.
</p>
<p><var>list</var>: will point to an integer list
</p>
<p>Get a list of available certificate types in the priority
structure.
</p>
<p>As of version 3.6.4 this function is an alias for
gnutls_priority_certificate_type_list2 with the target parameter
set to:
- GNUTLS_CTYPE_SERVER, if the <code>SERVER_PRECEDENCE</code>  option is set
- GNUTLS_CTYPE_CLIENT, otherwise.
</p>
<p><strong>Returns:</strong> the number of certificate types, or an error code.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fpriority_005fcertificate_005ftype_005flist2-1"></span><h4 class="subheading">gnutls_priority_certificate_type_list2</h4>
<span id="gnutls_005fpriority_005fcertificate_005ftype_005flist2"></span><dl>
<dt id="index-gnutls_005fpriority_005fcertificate_005ftype_005flist2">Function: <em>int</em> <strong>gnutls_priority_certificate_type_list2</strong> <em>(gnutls_priority_t <var>pcache</var>, const unsigned int ** <var>list</var>, gnutls_ctype_target_t <var>target</var>)</em></dt>
<dd><p><var>pcache</var>: is a <code>gnutls_prioritity_t</code>  type.
</p>
<p><var>list</var>: will point to an integer list.
</p>
<p><var>target</var>: is a <code>gnutls_ctype_target_t</code>  type. Valid arguments are
GNUTLS_CTYPE_CLIENT and GNUTLS_CTYPE_SERVER
</p>
<p>Get a list of available certificate types for the given target
in the priority structure.
</p>
<p><strong>Returns:</strong> the number of certificate types, or an error code.
</p>
<p><strong>Since:</strong> 3.6.4
</p></dd></dl>

<span id="gnutls_005fpriority_005fcipher_005flist-1"></span><h4 class="subheading">gnutls_priority_cipher_list</h4>
<span id="gnutls_005fpriority_005fcipher_005flist"></span><dl>
<dt id="index-gnutls_005fpriority_005fcipher_005flist">Function: <em>int</em> <strong>gnutls_priority_cipher_list</strong> <em>(gnutls_priority_t <var>pcache</var>, const unsigned int ** <var>list</var>)</em></dt>
<dd><p><var>pcache</var>: is a <code>gnutls_prioritity_t</code>  type.
</p>
<p><var>list</var>: will point to an integer list
</p>
<p>Get a list of available ciphers in the priority
structure.
</p>
<p><strong>Returns:</strong> the number of items, or an error code.
</p>
<p><strong>Since:</strong> 3.2.3
</p></dd></dl>

<span id="gnutls_005fpriority_005fdeinit-1"></span><h4 class="subheading">gnutls_priority_deinit</h4>
<span id="gnutls_005fpriority_005fdeinit"></span><dl>
<dt id="index-gnutls_005fpriority_005fdeinit">Function: <em>void</em> <strong>gnutls_priority_deinit</strong> <em>(gnutls_priority_t <var>priority_cache</var>)</em></dt>
<dd><p><var>priority_cache</var>: is a <code>gnutls_prioritity_t</code>  type.
</p>
<p>Deinitializes the priority cache.
</p></dd></dl>

<span id="gnutls_005fpriority_005fecc_005fcurve_005flist-1"></span><h4 class="subheading">gnutls_priority_ecc_curve_list</h4>
<span id="gnutls_005fpriority_005fecc_005fcurve_005flist"></span><dl>
<dt id="index-gnutls_005fpriority_005fecc_005fcurve_005flist">Function: <em>int</em> <strong>gnutls_priority_ecc_curve_list</strong> <em>(gnutls_priority_t <var>pcache</var>, const unsigned int ** <var>list</var>)</em></dt>
<dd><p><var>pcache</var>: is a <code>gnutls_prioritity_t</code>  type.
</p>
<p><var>list</var>: will point to an integer list
</p>
<p>Get a list of available elliptic curves in the priority
structure.
</p>
<p><strong>Deprecated:</strong> This function has been replaced by
<code>gnutls_priority_group_list()</code>  since 3.6.0.
</p>
<p><strong>Returns:</strong> the number of items, or an error code.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fpriority_005fget_005fcipher_005fsuite_005findex-1"></span><h4 class="subheading">gnutls_priority_get_cipher_suite_index</h4>
<span id="gnutls_005fpriority_005fget_005fcipher_005fsuite_005findex"></span><dl>
<dt id="index-gnutls_005fpriority_005fget_005fcipher_005fsuite_005findex">Function: <em>int</em> <strong>gnutls_priority_get_cipher_suite_index</strong> <em>(gnutls_priority_t <var>pcache</var>, unsigned int <var>idx</var>, unsigned int * <var>sidx</var>)</em></dt>
<dd><p><var>pcache</var>: is a <code>gnutls_prioritity_t</code>  type.
</p>
<p><var>idx</var>: is an index number.
</p>
<p><var>sidx</var>: internal index of cipher suite to get information about.
</p>
<p>Provides the internal ciphersuite index to be used with
<code>gnutls_cipher_suite_info()</code> . The index  <code>idx</code> provided is an
index kept at the priorities structure. It might be that a valid
priorities index does not correspond to a ciphersuite and in
that case <code>GNUTLS_E_UNKNOWN_CIPHER_SUITE</code>  will be returned.
Once the last available index is crossed then
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  will be returned.
</p>
<p><strong>Returns:</strong> On success it returns <code>GNUTLS_E_SUCCESS</code>  (0), or a negative error value otherwise.
</p>
<p><strong>Since:</strong> 3.0.9
</p></dd></dl>

<span id="gnutls_005fpriority_005fgroup_005flist-1"></span><h4 class="subheading">gnutls_priority_group_list</h4>
<span id="gnutls_005fpriority_005fgroup_005flist"></span><dl>
<dt id="index-gnutls_005fpriority_005fgroup_005flist">Function: <em>int</em> <strong>gnutls_priority_group_list</strong> <em>(gnutls_priority_t <var>pcache</var>, const unsigned int ** <var>list</var>)</em></dt>
<dd><p><var>pcache</var>: is a <code>gnutls_prioritity_t</code>  type.
</p>
<p><var>list</var>: will point to an integer list
</p>
<p>Get a list of available groups in the priority
structure.
</p>
<p><strong>Returns:</strong> the number of items, or an error code.
</p>
<p><strong>Since:</strong> 3.6.0
</p></dd></dl>

<span id="gnutls_005fpriority_005finit-1"></span><h4 class="subheading">gnutls_priority_init</h4>
<span id="gnutls_005fpriority_005finit"></span><dl>
<dt id="index-gnutls_005fpriority_005finit">Function: <em>int</em> <strong>gnutls_priority_init</strong> <em>(gnutls_priority_t * <var>priority_cache</var>, const char * <var>priorities</var>, const char ** <var>err_pos</var>)</em></dt>
<dd><p><var>priority_cache</var>: is a <code>gnutls_prioritity_t</code>  type.
</p>
<p><var>priorities</var>: is a string describing priorities (may be <code>NULL</code> )
</p>
<p><var>err_pos</var>: In case of an error this will have the position in the string the error occurred
</p>
<p>For applications that do not modify their crypto settings per release, consider
using <code>gnutls_priority_init2()</code>  with <code>GNUTLS_PRIORITY_INIT_DEF_APPEND</code>  flag
instead. We suggest to use centralized crypto settings handled by the GnuTLS
library, and applications modifying the default settings to their needs.
</p>
<p>This function is identical to <code>gnutls_priority_init2()</code>  with zero
flags.
</p>
<p>A <code>NULL</code>   <code>priorities</code> string indicates the default priorities to be
used (this is available since GnuTLS 3.3.0).
</p>
<p><strong>Returns:</strong> On syntax error <code>GNUTLS_E_INVALID_REQUEST</code>  is returned,
<code>GNUTLS_E_SUCCESS</code>  on success, or an error code.
</p></dd></dl>

<span id="gnutls_005fpriority_005finit2-1"></span><h4 class="subheading">gnutls_priority_init2</h4>
<span id="gnutls_005fpriority_005finit2"></span><dl>
<dt id="index-gnutls_005fpriority_005finit2">Function: <em>int</em> <strong>gnutls_priority_init2</strong> <em>(gnutls_priority_t * <var>priority_cache</var>, const char * <var>priorities</var>, const char ** <var>err_pos</var>, unsigned <var>flags</var>)</em></dt>
<dd><p><var>priority_cache</var>: is a <code>gnutls_prioritity_t</code>  type.
</p>
<p><var>priorities</var>: is a string describing priorities (may be <code>NULL</code> )
</p>
<p><var>err_pos</var>: In case of an error this will have the position in the string the error occurred
</p>
<p><var>flags</var>: zero or <code>GNUTLS_PRIORITY_INIT_DEF_APPEND</code> 
</p>
<p>Sets priorities for the ciphers, key exchange methods, and macs.
The  <code>priority_cache</code> should be deinitialized
using <code>gnutls_priority_deinit()</code> .
</p>
<p>The <code>priorities</code>  option allows you to specify a colon
separated list of the cipher priorities to enable.
Some keywords are defined to provide quick access
to common preferences.
</p>
<p>When  <code>flags</code> is set to <code>GNUTLS_PRIORITY_INIT_DEF_APPEND</code>  then the  <code>priorities</code> specified will be appended to the default options.
</p>
<p>Unless there is a special need, use the &quot;NORMAL&quot; keyword to
apply a reasonable security level, or &quot;NORMAL:%COMPAT&quot; for compatibility.
</p>
<p>&quot;PERFORMANCE&quot; means all the &quot;secure&quot; ciphersuites are enabled,
limited to 128 bit ciphers and sorted by terms of speed
performance.
</p>
<p>&quot;LEGACY&quot; the NORMAL settings for GnuTLS 3.2.x or earlier. There is
no verification profile set, and the allowed DH primes are considered
weak today.
</p>
<p>&quot;NORMAL&quot; means all &quot;secure&quot; ciphersuites. The 256-bit ciphers are
included as a fallback only.  The ciphers are sorted by security
margin.
</p>
<p>&quot;PFS&quot; means all &quot;secure&quot; ciphersuites that support perfect forward secrecy.
The 256-bit ciphers are included as a fallback only.
The ciphers are sorted by security margin.
</p>
<p>&quot;SECURE128&quot; means all &quot;secure&quot; ciphersuites of security level 128-bit
or more.
</p>
<p>&quot;SECURE192&quot; means all &quot;secure&quot; ciphersuites of security level 192-bit
or more.
</p>
<p>&quot;SUITEB128&quot; means all the NSA SuiteB ciphersuites with security level
of 128.
</p>
<p>&quot;SUITEB192&quot; means all the NSA SuiteB ciphersuites with security level
of 192.
</p>
<p>&quot;NONE&quot; means nothing is enabled.  This disables everything, including protocols.
</p>
<p>&quot;@KEYWORD1,KEYWORD2,...&quot; The system administrator imposed settings.
The provided keyword(s) will be expanded from a configuration-time
provided file - default is: /etc/gnutls/default-priorities.
Any attributes that follow it, will be appended to the expanded
string. If multiple keywords are provided, separated by commas,
then the first keyword that exists in the configuration file
will be used. At least one of the keywords must exist, or this
function will return an error. Typical usage would be to specify
an application specified keyword first, followed by &quot;SYSTEM&quot; as
a default fallback. e.g., &quot; <code>LIBVIRT</code> ,SYSTEM:!-VERS-SSL3.0&quot; will
first try to find a config file entry matching &quot;LIBVIRT&quot;, but if
that does not exist will use the entry for &quot;SYSTEM&quot;. If &quot;SYSTEM&quot;
does not exist either, an error will be returned. In all cases,
the SSL3.0 protocol will be disabled. The system priority file
entries should be formatted as &quot;KEYWORD=VALUE&quot;, e.g.,
&quot;SYSTEM=NORMAL:+ARCFOUR-128&quot;.
</p>
<p>Special keywords are &quot;!&quot;, &quot;-&quot; and &quot;+&quot;.
&quot;!&quot; or &quot;-&quot; appended with an algorithm will remove this algorithm.
&quot;+&quot; appended with an algorithm will add this algorithm.
</p>
<p>Check the GnuTLS manual section &quot;Priority strings&quot; for detailed
information.
</p>
<p><strong>Examples:</strong> 
&quot;NONE:+VERS-TLS-ALL:+MAC-ALL:+RSA:+AES-128-CBC:+SIGN-ALL:+COMP-NULL&quot;
</p>
<p>&quot;NORMAL:+ARCFOUR-128&quot; means normal ciphers plus ARCFOUR-128.
</p>
<p>&quot;SECURE128:-VERS-SSL3.0&quot; means that only secure ciphers are
and enabled, SSL3.0 is disabled.
</p>
<p>&quot;NONE:+VERS-TLS-ALL:+AES-128-CBC:+RSA:+SHA1:+COMP-NULL:+SIGN-RSA-SHA1&quot;,
</p>
<p>&quot;NONE:+VERS-TLS-ALL:+AES-128-CBC:+ECDHE-RSA:+SHA1:+COMP-NULL:+SIGN-RSA-SHA1:+CURVE-SECP256R1&quot;,
</p>
<p>&quot;SECURE256:+SECURE128&quot;,
</p>
<p>Note that &quot;NORMAL:%COMPAT&quot; is the most compatible mode.
</p>
<p>A <code>NULL</code>   <code>priorities</code> string indicates the default priorities to be
used (this is available since GnuTLS 3.3.0).
</p>
<p><strong>Returns:</strong> On syntax error <code>GNUTLS_E_INVALID_REQUEST</code>  is returned,
<code>GNUTLS_E_SUCCESS</code>  on success, or an error code.
</p>
<p><strong>Since:</strong> 3.6.3
</p></dd></dl>

<span id="gnutls_005fpriority_005fkx_005flist-1"></span><h4 class="subheading">gnutls_priority_kx_list</h4>
<span id="gnutls_005fpriority_005fkx_005flist"></span><dl>
<dt id="index-gnutls_005fpriority_005fkx_005flist">Function: <em>int</em> <strong>gnutls_priority_kx_list</strong> <em>(gnutls_priority_t <var>pcache</var>, const unsigned int ** <var>list</var>)</em></dt>
<dd><p><var>pcache</var>: is a <code>gnutls_prioritity_t</code>  type.
</p>
<p><var>list</var>: will point to an integer list
</p>
<p>Get a list of available key exchange methods in the priority
structure.
</p>
<p><strong>Returns:</strong> the number of items, or an error code.
</p>
<p><strong>Since:</strong> 3.2.3
</p></dd></dl>

<span id="gnutls_005fpriority_005fmac_005flist-1"></span><h4 class="subheading">gnutls_priority_mac_list</h4>
<span id="gnutls_005fpriority_005fmac_005flist"></span><dl>
<dt id="index-gnutls_005fpriority_005fmac_005flist">Function: <em>int</em> <strong>gnutls_priority_mac_list</strong> <em>(gnutls_priority_t <var>pcache</var>, const unsigned int ** <var>list</var>)</em></dt>
<dd><p><var>pcache</var>: is a <code>gnutls_prioritity_t</code>  type.
</p>
<p><var>list</var>: will point to an integer list
</p>
<p>Get a list of available MAC algorithms in the priority
structure.
</p>
<p><strong>Returns:</strong> the number of items, or an error code.
</p>
<p><strong>Since:</strong> 3.2.3
</p></dd></dl>

<span id="gnutls_005fpriority_005fprotocol_005flist-1"></span><h4 class="subheading">gnutls_priority_protocol_list</h4>
<span id="gnutls_005fpriority_005fprotocol_005flist"></span><dl>
<dt id="index-gnutls_005fpriority_005fprotocol_005flist">Function: <em>int</em> <strong>gnutls_priority_protocol_list</strong> <em>(gnutls_priority_t <var>pcache</var>, const unsigned int ** <var>list</var>)</em></dt>
<dd><p><var>pcache</var>: is a <code>gnutls_prioritity_t</code>  type.
</p>
<p><var>list</var>: will point to an integer list
</p>
<p>Get a list of available TLS version numbers in the priority
structure.
</p>
<p><strong>Returns:</strong> the number of protocols, or an error code.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fpriority_005fset-1"></span><h4 class="subheading">gnutls_priority_set</h4>
<span id="gnutls_005fpriority_005fset"></span><dl>
<dt id="index-gnutls_005fpriority_005fset">Function: <em>int</em> <strong>gnutls_priority_set</strong> <em>(gnutls_session_t <var>session</var>, gnutls_priority_t <var>priority</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>priority</var>: is a <code>gnutls_priority_t</code>  type.
</p>
<p>Sets the priorities to use on the ciphers, key exchange methods,
and macs. Note that this function is expected to be called once
per session; when called multiple times (e.g., before a re-handshake,
the caller should make sure that any new settings are not incompatible
with the original session).
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, or an error code on error.
</p></dd></dl>

<span id="gnutls_005fpriority_005fset_005fdirect-1"></span><h4 class="subheading">gnutls_priority_set_direct</h4>
<span id="gnutls_005fpriority_005fset_005fdirect"></span><dl>
<dt id="index-gnutls_005fpriority_005fset_005fdirect">Function: <em>int</em> <strong>gnutls_priority_set_direct</strong> <em>(gnutls_session_t <var>session</var>, const char * <var>priorities</var>, const char ** <var>err_pos</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>priorities</var>: is a string describing priorities
</p>
<p><var>err_pos</var>: In case of an error this will have the position in the string the error occurred
</p>
<p>Sets the priorities to use on the ciphers, key exchange methods,
and macs.  This function avoids keeping a
priority cache and is used to directly set string priorities to a
TLS session.  For documentation check the <code>gnutls_priority_init()</code> .
</p>
<p>To use a reasonable default, consider using <code>gnutls_set_default_priority()</code> ,
or <code>gnutls_set_default_priority_append()</code>  instead of this function.
</p>
<p><strong>Returns:</strong> On syntax error <code>GNUTLS_E_INVALID_REQUEST</code>  is returned,
<code>GNUTLS_E_SUCCESS</code>  on success, or an error code.
</p></dd></dl>

<span id="gnutls_005fpriority_005fsign_005flist-1"></span><h4 class="subheading">gnutls_priority_sign_list</h4>
<span id="gnutls_005fpriority_005fsign_005flist"></span><dl>
<dt id="index-gnutls_005fpriority_005fsign_005flist">Function: <em>int</em> <strong>gnutls_priority_sign_list</strong> <em>(gnutls_priority_t <var>pcache</var>, const unsigned int ** <var>list</var>)</em></dt>
<dd><p><var>pcache</var>: is a <code>gnutls_prioritity_t</code>  type.
</p>
<p><var>list</var>: will point to an integer list
</p>
<p>Get a list of available signature algorithms in the priority
structure.
</p>
<p><strong>Returns:</strong> the number of algorithms, or an error code.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fpriority_005fstring_005flist-1"></span><h4 class="subheading">gnutls_priority_string_list</h4>
<span id="gnutls_005fpriority_005fstring_005flist"></span><dl>
<dt id="index-gnutls_005fpriority_005fstring_005flist">Function: <em>const char *</em> <strong>gnutls_priority_string_list</strong> <em>(unsigned <var>iter</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>iter</var>: an integer counter starting from zero
</p>
<p><var>flags</var>: one of <code>GNUTLS_PRIORITY_LIST_INIT_KEYWORDS</code> , <code>GNUTLS_PRIORITY_LIST_SPECIAL</code> 
</p>
<p>Can be used to iterate all available priority strings.
Due to internal implementation details, there are cases where this
function can return the empty string. In that case that string should be ignored.
When no strings are available it returns <code>NULL</code> .
</p>
<p><strong>Returns:</strong> a priority string
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fprotocol_005fget_005fid-1"></span><h4 class="subheading">gnutls_protocol_get_id</h4>
<span id="gnutls_005fprotocol_005fget_005fid"></span><dl>
<dt id="index-gnutls_005fprotocol_005fget_005fid">Function: <em>gnutls_protocol_t</em> <strong>gnutls_protocol_get_id</strong> <em>(const char * <var>name</var>)</em></dt>
<dd><p><var>name</var>: is a protocol name
</p>
<p>The names are compared in a case insensitive way.
</p>
<p><strong>Returns:</strong> an id of the specified protocol, or
<code>GNUTLS_VERSION_UNKNOWN</code>  on error.
</p></dd></dl>

<span id="gnutls_005fprotocol_005fget_005fname-1"></span><h4 class="subheading">gnutls_protocol_get_name</h4>
<span id="gnutls_005fprotocol_005fget_005fname"></span><dl>
<dt id="index-gnutls_005fprotocol_005fget_005fname">Function: <em>const char *</em> <strong>gnutls_protocol_get_name</strong> <em>(gnutls_protocol_t <var>version</var>)</em></dt>
<dd><p><var>version</var>: is a (gnutls) version number
</p>
<p>Convert a <code>gnutls_protocol_t</code>  value to a string.
</p>
<p><strong>Returns:</strong> a string that contains the name of the specified TLS
version (e.g., &quot;TLS1.0&quot;), or <code>NULL</code> .
</p></dd></dl>

<span id="gnutls_005fprotocol_005fget_005fversion-1"></span><h4 class="subheading">gnutls_protocol_get_version</h4>
<span id="gnutls_005fprotocol_005fget_005fversion"></span><dl>
<dt id="index-gnutls_005fprotocol_005fget_005fversion">Function: <em>gnutls_protocol_t</em> <strong>gnutls_protocol_get_version</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Get TLS version, a <code>gnutls_protocol_t</code>  value.
</p>
<p><strong>Returns:</strong> The version of the currently used protocol.
</p></dd></dl>

<span id="gnutls_005fprotocol_005flist-1"></span><h4 class="subheading">gnutls_protocol_list</h4>
<span id="gnutls_005fprotocol_005flist"></span><dl>
<dt id="index-gnutls_005fprotocol_005flist">Function: <em>const gnutls_protocol_t *</em> <strong>gnutls_protocol_list</strong> <em>( <var>void</var>)</em></dt>
<dd>
<p>Get a list of supported protocols, e.g. SSL 3.0, TLS 1.0 etc.
</p>
<p>This function is not thread safe.
</p>
<p><strong>Returns:</strong> a (0)-terminated list of <code>gnutls_protocol_t</code>  integers
indicating the available protocols.
</p></dd></dl>

<span id="gnutls_005fpsk_005fallocate_005fclient_005fcredentials-1"></span><h4 class="subheading">gnutls_psk_allocate_client_credentials</h4>
<span id="gnutls_005fpsk_005fallocate_005fclient_005fcredentials"></span><dl>
<dt id="index-gnutls_005fpsk_005fallocate_005fclient_005fcredentials">Function: <em>int</em> <strong>gnutls_psk_allocate_client_credentials</strong> <em>(gnutls_psk_client_credentials_t *            <var>sc</var>)</em></dt>
<dd><p><var>sc</var>: is a pointer to a <code>gnutls_psk_server_credentials_t</code>  type.
</p>
<p>Allocate a gnutls_psk_client_credentials_t structure.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p></dd></dl>

<span id="gnutls_005fpsk_005fallocate_005fserver_005fcredentials-1"></span><h4 class="subheading">gnutls_psk_allocate_server_credentials</h4>
<span id="gnutls_005fpsk_005fallocate_005fserver_005fcredentials"></span><dl>
<dt id="index-gnutls_005fpsk_005fallocate_005fserver_005fcredentials">Function: <em>int</em> <strong>gnutls_psk_allocate_server_credentials</strong> <em>(gnutls_psk_server_credentials_t *            <var>sc</var>)</em></dt>
<dd><p><var>sc</var>: is a pointer to a <code>gnutls_psk_server_credentials_t</code>  type.
</p>
<p>Allocate a gnutls_psk_server_credentials_t structure.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p></dd></dl>

<span id="gnutls_005fpsk_005fclient_005fget_005fhint-1"></span><h4 class="subheading">gnutls_psk_client_get_hint</h4>
<span id="gnutls_005fpsk_005fclient_005fget_005fhint"></span><dl>
<dt id="index-gnutls_005fpsk_005fclient_005fget_005fhint">Function: <em>const char *</em> <strong>gnutls_psk_client_get_hint</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a gnutls session
</p>
<p>The PSK identity hint may give the client help in deciding which
username to use.  This should only be called in case of PSK
authentication and in case of a client.
</p>
<p><strong>Note:</strong> there is no hint in TLS 1.3, so this function will return <code>NULL</code> 
if TLS 1.3 has been negotiated.
</p>
<p><strong>Returns:</strong> the identity hint of the peer, or <code>NULL</code>  in case of an error or if TLS 1.3 is being used.
</p>
<p><strong>Since:</strong> 2.4.0
</p></dd></dl>

<span id="gnutls_005fpsk_005ffree_005fclient_005fcredentials-1"></span><h4 class="subheading">gnutls_psk_free_client_credentials</h4>
<span id="gnutls_005fpsk_005ffree_005fclient_005fcredentials"></span><dl>
<dt id="index-gnutls_005fpsk_005ffree_005fclient_005fcredentials">Function: <em>void</em> <strong>gnutls_psk_free_client_credentials</strong> <em>(gnutls_psk_client_credentials_t <var>sc</var>)</em></dt>
<dd><p><var>sc</var>: is a <code>gnutls_psk_client_credentials_t</code>  type.
</p>
<p>Free a gnutls_psk_client_credentials_t structure.
</p></dd></dl>

<span id="gnutls_005fpsk_005ffree_005fserver_005fcredentials-1"></span><h4 class="subheading">gnutls_psk_free_server_credentials</h4>
<span id="gnutls_005fpsk_005ffree_005fserver_005fcredentials"></span><dl>
<dt id="index-gnutls_005fpsk_005ffree_005fserver_005fcredentials">Function: <em>void</em> <strong>gnutls_psk_free_server_credentials</strong> <em>(gnutls_psk_server_credentials_t <var>sc</var>)</em></dt>
<dd><p><var>sc</var>: is a <code>gnutls_psk_server_credentials_t</code>  type.
</p>
<p>Free a gnutls_psk_server_credentials_t structure.
</p></dd></dl>

<span id="gnutls_005fpsk_005fserver_005fget_005fusername-1"></span><h4 class="subheading">gnutls_psk_server_get_username</h4>
<span id="gnutls_005fpsk_005fserver_005fget_005fusername"></span><dl>
<dt id="index-gnutls_005fpsk_005fserver_005fget_005fusername">Function: <em>const char *</em> <strong>gnutls_psk_server_get_username</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a gnutls session
</p>
<p>This should only be called in case of PSK authentication and in
case of a server.
</p>
<p><strong>Returns:</strong> the username of the peer, or <code>NULL</code>  in case of an error.
</p></dd></dl>

<span id="gnutls_005fpsk_005fset_005fclient_005fcredentials-1"></span><h4 class="subheading">gnutls_psk_set_client_credentials</h4>
<span id="gnutls_005fpsk_005fset_005fclient_005fcredentials"></span><dl>
<dt id="index-gnutls_005fpsk_005fset_005fclient_005fcredentials">Function: <em>int</em> <strong>gnutls_psk_set_client_credentials</strong> <em>(gnutls_psk_client_credentials_t <var>res</var>, const char * <var>username</var>, const gnutls_datum_t * <var>key</var>, gnutls_psk_key_flags <var>flags</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_psk_client_credentials_t</code>  type.
</p>
<p><var>username</var>: is the user&rsquo;s zero-terminated userid
</p>
<p><var>key</var>: is the user&rsquo;s key
</p>
<p><var>flags</var>: indicate the format of the key, either
<code>GNUTLS_PSK_KEY_RAW</code>  or <code>GNUTLS_PSK_KEY_HEX</code> .
</p>
<p>This function sets the username and password, in a
gnutls_psk_client_credentials_t type.  Those will be used in
PSK authentication.   <code>username</code> should be an ASCII string or UTF-8
string. In case of a UTF-8 string it is recommended to be following
the PRECIS framework for usernames (rfc8265). The key can be either
in raw byte format or in Hex format (without the 0x prefix).
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p></dd></dl>

<span id="gnutls_005fpsk_005fset_005fclient_005fcredentials_005ffunction-1"></span><h4 class="subheading">gnutls_psk_set_client_credentials_function</h4>
<span id="gnutls_005fpsk_005fset_005fclient_005fcredentials_005ffunction"></span><dl>
<dt id="index-gnutls_005fpsk_005fset_005fclient_005fcredentials_005ffunction-1">Function: <em>void</em> <strong>gnutls_psk_set_client_credentials_function</strong> <em>(gnutls_psk_client_credentials_t         <var>cred</var>, gnutls_psk_client_credentials_function         * <var>func</var>)</em></dt>
<dd><p><var>cred</var>: is a <code>gnutls_psk_server_credentials_t</code>  type.
</p>
<p><var>func</var>: is the callback function
</p>
<p>This function can be used to set a callback to retrieve the username and
password for client PSK authentication.
The callback&rsquo;s function form is:
int (*callback)(gnutls_session_t, char** username,
gnutls_datum_t* key);
</p>
<p>The  <code>username</code> and  <code>key</code> -&gt;data must be allocated using <code>gnutls_malloc()</code> .
The  <code>username</code> should be an ASCII string or UTF-8
string. In case of a UTF-8 string it is recommended to be following
the PRECIS framework for usernames (rfc8265).
</p>
<p>The callback function will be called once per handshake.
</p>
<p>The callback function should return 0 on success.
-1 indicates an error.
</p></dd></dl>

<span id="gnutls_005fpsk_005fset_005fparams_005ffunction-1"></span><h4 class="subheading">gnutls_psk_set_params_function</h4>
<span id="gnutls_005fpsk_005fset_005fparams_005ffunction"></span><dl>
<dt id="index-gnutls_005fpsk_005fset_005fparams_005ffunction">Function: <em>void</em> <strong>gnutls_psk_set_params_function</strong> <em>(gnutls_psk_server_credentials_t <var>res</var>, gnutls_params_function * <var>func</var>)</em></dt>
<dd><p><var>res</var>: is a gnutls_psk_server_credentials_t type
</p>
<p><var>func</var>: is the function to be called
</p>
<p>This function will set a callback in order for the server to get
the Diffie-Hellman or RSA parameters for PSK authentication.  The
callback should return <code>GNUTLS_E_SUCCESS</code>  (0) on success.
</p>
<p><strong>Deprecated:</strong> This function is unnecessary and discouraged on GnuTLS 3.6.0
or later. Since 3.6.0, DH parameters are negotiated
following RFC7919.
</p></dd></dl>

<span id="gnutls_005fpsk_005fset_005fserver_005fcredentials_005ffile-1"></span><h4 class="subheading">gnutls_psk_set_server_credentials_file</h4>
<span id="gnutls_005fpsk_005fset_005fserver_005fcredentials_005ffile"></span><dl>
<dt id="index-gnutls_005fpsk_005fset_005fserver_005fcredentials_005ffile-1">Function: <em>int</em> <strong>gnutls_psk_set_server_credentials_file</strong> <em>(gnutls_psk_server_credentials_t            <var>res</var>, const char * <var>password_file</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_psk_server_credentials_t</code>  type.
</p>
<p><var>password_file</var>: is the PSK password file (passwd.psk)
</p>
<p>This function sets the password file, in a
<code>gnutls_psk_server_credentials_t</code>  type.  This password file
holds usernames and keys and will be used for PSK authentication.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p></dd></dl>

<span id="gnutls_005fpsk_005fset_005fserver_005fcredentials_005ffunction-1"></span><h4 class="subheading">gnutls_psk_set_server_credentials_function</h4>
<span id="gnutls_005fpsk_005fset_005fserver_005fcredentials_005ffunction"></span><dl>
<dt id="index-gnutls_005fpsk_005fset_005fserver_005fcredentials_005ffunction">Function: <em>void</em> <strong>gnutls_psk_set_server_credentials_function</strong> <em>(gnutls_psk_server_credentials_t         <var>cred</var>, gnutls_psk_server_credentials_function         * <var>func</var>)</em></dt>
<dd><p><var>cred</var>: is a <code>gnutls_psk_server_credentials_t</code>  type.
</p>
<p><var>func</var>: is the callback function
</p>
<p>This function can be used to set a callback to retrieve the user&rsquo;s PSK credentials.
The callback&rsquo;s function form is:
int (*callback)(gnutls_session_t, const char* username,
gnutls_datum_t* key);
</p>
<p><code>username</code> contains the actual username.
The  <code>key</code> must be filled in using the <code>gnutls_malloc()</code> .
</p>
<p>In case the callback returned a negative number then gnutls will
assume that the username does not exist.
</p>
<p>The callback function will only be called once per handshake.  The
callback function should return 0 on success, while -1 indicates
an error.
</p></dd></dl>

<span id="gnutls_005fpsk_005fset_005fserver_005fcredentials_005fhint-1"></span><h4 class="subheading">gnutls_psk_set_server_credentials_hint</h4>
<span id="gnutls_005fpsk_005fset_005fserver_005fcredentials_005fhint"></span><dl>
<dt id="index-gnutls_005fpsk_005fset_005fserver_005fcredentials_005fhint">Function: <em>int</em> <strong>gnutls_psk_set_server_credentials_hint</strong> <em>(gnutls_psk_server_credentials_t <var>res</var>, const char * <var>hint</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_psk_server_credentials_t</code>  type.
</p>
<p><var>hint</var>: is the PSK identity hint string
</p>
<p>This function sets the identity hint, in a
<code>gnutls_psk_server_credentials_t</code>  type.  This hint is sent to
the client to help it chose a good PSK credential (i.e., username
and password).
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p>
<p><strong>Since:</strong> 2.4.0
</p></dd></dl>

<span id="gnutls_005fpsk_005fset_005fserver_005fdh_005fparams-1"></span><h4 class="subheading">gnutls_psk_set_server_dh_params</h4>
<span id="gnutls_005fpsk_005fset_005fserver_005fdh_005fparams"></span><dl>
<dt id="index-gnutls_005fpsk_005fset_005fserver_005fdh_005fparams">Function: <em>void</em> <strong>gnutls_psk_set_server_dh_params</strong> <em>(gnutls_psk_server_credentials_t <var>res</var>, gnutls_dh_params_t <var>dh_params</var>)</em></dt>
<dd><p><var>res</var>: is a gnutls_psk_server_credentials_t type
</p>
<p><var>dh_params</var>: is a structure that holds Diffie-Hellman parameters.
</p>
<p>This function will set the Diffie-Hellman parameters for an
anonymous server to use. These parameters will be used in
Diffie-Hellman exchange with PSK cipher suites.
</p>
<p><strong>Deprecated:</strong> This function is unnecessary and discouraged on GnuTLS 3.6.0
or later. Since 3.6.0, DH parameters are negotiated
following RFC7919.
</p></dd></dl>

<span id="gnutls_005fpsk_005fset_005fserver_005fknown_005fdh_005fparams-1"></span><h4 class="subheading">gnutls_psk_set_server_known_dh_params</h4>
<span id="gnutls_005fpsk_005fset_005fserver_005fknown_005fdh_005fparams"></span><dl>
<dt id="index-gnutls_005fpsk_005fset_005fserver_005fknown_005fdh_005fparams">Function: <em>int</em> <strong>gnutls_psk_set_server_known_dh_params</strong> <em>(gnutls_psk_server_credentials_t <var>res</var>, gnutls_sec_param_t <var>sec_param</var>)</em></dt>
<dd><p><var>res</var>: is a gnutls_psk_server_credentials_t type
</p>
<p><var>sec_param</var>: is an option of the <code>gnutls_sec_param_t</code>  enumeration
</p>
<p>This function will set the Diffie-Hellman parameters for a
PSK server to use. These parameters will be used in
Ephemeral Diffie-Hellman cipher suites and will be selected from
the FFDHE set of RFC7919 according to the security level provided.
</p>
<p><strong>Deprecated:</strong> This function is unnecessary and discouraged on GnuTLS 3.6.0
or later. Since 3.6.0, DH parameters are negotiated
following RFC7919.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.5.6
</p></dd></dl>

<span id="gnutls_005fpsk_005fset_005fserver_005fparams_005ffunction-1"></span><h4 class="subheading">gnutls_psk_set_server_params_function</h4>
<span id="gnutls_005fpsk_005fset_005fserver_005fparams_005ffunction"></span><dl>
<dt id="index-gnutls_005fpsk_005fset_005fserver_005fparams_005ffunction">Function: <em>void</em> <strong>gnutls_psk_set_server_params_function</strong> <em>(gnutls_psk_server_credentials_t <var>res</var>, gnutls_params_function * <var>func</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code>  type
</p>
<p><var>func</var>: is the function to be called
</p>
<p>This function will set a callback in order for the server to get
the Diffie-Hellman parameters for PSK authentication.  The callback
should return <code>GNUTLS_E_SUCCESS</code>  (0) on success.
</p>
<p><strong>Deprecated:</strong> This function is unnecessary and discouraged on GnuTLS 3.6.0
or later. Since 3.6.0, DH parameters are negotiated
following RFC7919.
</p></dd></dl>

<span id="gnutls_005frandom_005fart-1"></span><h4 class="subheading">gnutls_random_art</h4>
<span id="gnutls_005frandom_005fart"></span><dl>
<dt id="index-gnutls_005frandom_005fart">Function: <em>int</em> <strong>gnutls_random_art</strong> <em>(gnutls_random_art_t <var>type</var>, const char * <var>key_type</var>, unsigned int <var>key_size</var>, void * <var>fpr</var>, size_t <var>fpr_size</var>, gnutls_datum_t * <var>art</var>)</em></dt>
<dd><p><var>type</var>: The type of the random art (for now only <code>GNUTLS_RANDOM_ART_OPENSSH</code>  is supported)
</p>
<p><var>key_type</var>: The type of the key (RSA, DSA etc.)
</p>
<p><var>key_size</var>: The size of the key in bits
</p>
<p><var>fpr</var>: The fingerprint of the key
</p>
<p><var>fpr_size</var>: The size of the fingerprint
</p>
<p><var>art</var>: The returned random art
</p>
<p>This function will convert a given fingerprint to an &quot;artistic&quot;
image. The returned image is allocated using <code>gnutls_malloc()</code> , is
null-terminated but art-&gt;size will not account the terminating null.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p></dd></dl>

<span id="gnutls_005frange_005fsplit-1"></span><h4 class="subheading">gnutls_range_split</h4>
<span id="gnutls_005frange_005fsplit"></span><dl>
<dt id="index-gnutls_005frange_005fsplit">Function: <em>int</em> <strong>gnutls_range_split</strong> <em>(gnutls_session_t <var>session</var>, const gnutls_range_st * <var>orig</var>, gnutls_range_st * <var>next</var>, gnutls_range_st * <var>remainder</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type
</p>
<p><var>orig</var>: is the original range provided by the user
</p>
<p><var>next</var>: is the returned range that can be conveyed in a TLS record
</p>
<p><var>remainder</var>: is the returned remaining range
</p>
<p>This function should be used when it is required to hide the length
of very long data that cannot be directly provided to <code>gnutls_record_send_range()</code> .
In that case this function should be called with the desired length
hiding range in  <code>orig</code> . The returned  <code>next</code> value should then be used in
the next call to <code>gnutls_record_send_range()</code>  with the partial data.
That process should be repeated until  <code>remainder</code> is (0,0).
</p>
<p><strong>Returns:</strong> 0 in case splitting succeeds, non zero in case of error.
Note that  <code>orig</code> is not changed, while the values of  <code>next</code> and  <code>remainder</code> are modified to store the resulting values.
</p></dd></dl>

<span id="gnutls_005freauth-1"></span><h4 class="subheading">gnutls_reauth</h4>
<span id="gnutls_005freauth"></span><dl>
<dt id="index-gnutls_005freauth">Function: <em>int</em> <strong>gnutls_reauth</strong> <em>(gnutls_session_t <var>session</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>flags</var>: must be zero
</p>
<p>This function performs the post-handshake authentication
for TLS 1.3. The post-handshake authentication is initiated by the server
by calling this function. Clients respond when <code>GNUTLS_E_REAUTH_REQUEST</code> 
has been seen while receiving data.
</p>
<p>The non-fatal errors expected by this function are:
<code>GNUTLS_E_INTERRUPTED</code> , <code>GNUTLS_E_AGAIN</code> , as well as
<code>GNUTLS_E_GOT_APPLICATION_DATA</code>  when called on server side.
</p>
<p>The former two interrupt the authentication procedure due to the transport
layer being interrupted, and the latter because there were pending data prior
to peer initiating the re-authentication. The server should read/process that
data as unauthenticated and retry calling <code>gnutls_reauth()</code> .
</p>
<p>When this function is called under TLS1.2 or earlier or the peer didn&rsquo;t
advertise post-handshake auth, it always fails with
<code>GNUTLS_E_INVALID_REQUEST</code> . The verification of the received peers certificate
is delegated to the session or credentials verification callbacks. A
server can check whether post handshake authentication is supported
by the client by checking the session flags with <code>gnutls_session_get_flags()</code> .
</p>
<p>Prior to calling this function in server side, the function
<code>gnutls_certificate_server_set_request()</code>  must be called setting expectations
for the received certificate (request or require). If none are set
this function will return with <code>GNUTLS_E_INVALID_REQUEST</code> .
</p>
<p>Note that post handshake authentication is available irrespective
of the initial negotiation type (PSK or certificate). In all cases
however, certificate credentials must be set to the session prior
to calling this function.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on a successful authentication, otherwise a negative error code.
</p></dd></dl>

<span id="gnutls_005frecord_005fcan_005fuse_005flength_005fhiding-1"></span><h4 class="subheading">gnutls_record_can_use_length_hiding</h4>
<span id="gnutls_005frecord_005fcan_005fuse_005flength_005fhiding"></span><dl>
<dt id="index-gnutls_005frecord_005fcan_005fuse_005flength_005fhiding">Function: <em>unsigned</em> <strong>gnutls_record_can_use_length_hiding</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>If the session supports length-hiding padding, you can
invoke <code>gnutls_record_send_range()</code>  to send a message whose
length is hidden in the given range. If the session does not
support length hiding padding, you can use the standard
<code>gnutls_record_send()</code>  function, or <code>gnutls_record_send_range()</code> 
making sure that the range is the same as the length of the
message you are trying to send.
</p>
<p><strong>Returns:</strong> true (1) if the current session supports length-hiding
padding, false (0) if the current session does not.
</p></dd></dl>

<span id="gnutls_005frecord_005fcheck_005fcorked-1"></span><h4 class="subheading">gnutls_record_check_corked</h4>
<span id="gnutls_005frecord_005fcheck_005fcorked"></span><dl>
<dt id="index-gnutls_005frecord_005fcheck_005fcorked">Function: <em>size_t</em> <strong>gnutls_record_check_corked</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>This function checks if there pending corked
data in the gnutls buffers &ndash;see <code>gnutls_record_cork()</code> . 
</p>
<p><strong>Returns:</strong> Returns the size of the corked data or zero.
</p>
<p><strong>Since:</strong> 3.2.8
</p></dd></dl>

<span id="gnutls_005frecord_005fcheck_005fpending-1"></span><h4 class="subheading">gnutls_record_check_pending</h4>
<span id="gnutls_005frecord_005fcheck_005fpending"></span><dl>
<dt id="index-gnutls_005frecord_005fcheck_005fpending-1">Function: <em>size_t</em> <strong>gnutls_record_check_pending</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>This function checks if there are unread data
in the gnutls buffers. If the return value is
non-zero the next call to <code>gnutls_record_recv()</code> 
is guaranteed not to block.
</p>
<p><strong>Returns:</strong> Returns the size of the data or zero.
</p></dd></dl>

<span id="gnutls_005frecord_005fcork-1"></span><h4 class="subheading">gnutls_record_cork</h4>
<span id="gnutls_005frecord_005fcork"></span><dl>
<dt id="index-gnutls_005frecord_005fcork-1">Function: <em>void</em> <strong>gnutls_record_cork</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>If called, <code>gnutls_record_send()</code>  will no longer send any records.
Any sent records will be cached until <code>gnutls_record_uncork()</code>  is called.
</p>
<p>This function is safe to use with DTLS after GnuTLS 3.3.0.
</p>
<p><strong>Since:</strong> 3.1.9
</p></dd></dl>

<span id="gnutls_005frecord_005fdisable_005fpadding-1"></span><h4 class="subheading">gnutls_record_disable_padding</h4>
<span id="gnutls_005frecord_005fdisable_005fpadding"></span><dl>
<dt id="index-gnutls_005frecord_005fdisable_005fpadding">Function: <em>void</em> <strong>gnutls_record_disable_padding</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Used to disabled padding in TLS 1.0 and above.  Normally you do not
need to use this function, but there are buggy clients that
complain if a server pads the encrypted data.  This of course will
disable protection against statistical attacks on the data.
</p>
<p>This function is defunct since 3.1.7. Random padding is disabled
by default unless requested using <code>gnutls_record_send_range()</code> .
</p></dd></dl>

<span id="gnutls_005frecord_005fdiscard_005fqueued-1"></span><h4 class="subheading">gnutls_record_discard_queued</h4>
<span id="gnutls_005frecord_005fdiscard_005fqueued"></span><dl>
<dt id="index-gnutls_005frecord_005fdiscard_005fqueued">Function: <em>size_t</em> <strong>gnutls_record_discard_queued</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>This function discards all queued to be sent packets in a TLS or DTLS session.
These are the packets queued after an interrupted <code>gnutls_record_send()</code> .
</p>
<p><strong>Returns:</strong> The number of bytes discarded.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005frecord_005fget_005fdirection-1"></span><h4 class="subheading">gnutls_record_get_direction</h4>
<span id="gnutls_005frecord_005fget_005fdirection"></span><dl>
<dt id="index-gnutls_005frecord_005fget_005fdirection-1">Function: <em>int</em> <strong>gnutls_record_get_direction</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>This function is useful to determine whether a GnuTLS function was interrupted
while sending or receiving, so that <code>select()</code>  or <code>poll()</code>  may be called appropriately.
</p>
<p>It provides information about the internals of the record
protocol and is only useful if a prior gnutls function call,
e.g.  <code>gnutls_handshake()</code> , was interrupted and returned
<code>GNUTLS_E_INTERRUPTED</code>  or <code>GNUTLS_E_AGAIN</code> . After such an interrupt
applications may call <code>select()</code>  or <code>poll()</code>  before restoring the
interrupted GnuTLS function.
</p>
<p>This function&rsquo;s output is unreliable if you are using the same
 <code>session</code> in different threads for sending and receiving.
</p>
<p><strong>Returns:</strong> 0 if interrupted while trying to read data, or 1 while trying to write data.
</p></dd></dl>

<span id="gnutls_005frecord_005fget_005fmax_005fearly_005fdata_005fsize-1"></span><h4 class="subheading">gnutls_record_get_max_early_data_size</h4>
<span id="gnutls_005frecord_005fget_005fmax_005fearly_005fdata_005fsize"></span><dl>
<dt id="index-gnutls_005frecord_005fget_005fmax_005fearly_005fdata_005fsize">Function: <em>size_t</em> <strong>gnutls_record_get_max_early_data_size</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>This function returns the maximum early data size in this connection.
This property can only be set to servers.  The client may be
provided with the maximum allowed size through the &quot;early_data&quot;
extension of the NewSessionTicket handshake message.
</p>
<p><strong>Returns:</strong> The maximum early data size in this connection.
</p>
<p><strong>Since:</strong> 3.6.5
</p></dd></dl>

<span id="gnutls_005frecord_005fget_005fmax_005fsize-1"></span><h4 class="subheading">gnutls_record_get_max_size</h4>
<span id="gnutls_005frecord_005fget_005fmax_005fsize"></span><dl>
<dt id="index-gnutls_005frecord_005fget_005fmax_005fsize">Function: <em>size_t</em> <strong>gnutls_record_get_max_size</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Get the record size.  The maximum record size is negotiated by the
client after the first handshake message.
</p>
<p><strong>Returns:</strong> The maximum record packet size in this connection.
</p></dd></dl>

<span id="gnutls_005frecord_005fget_005fstate-1"></span><h4 class="subheading">gnutls_record_get_state</h4>
<span id="gnutls_005frecord_005fget_005fstate"></span><dl>
<dt id="index-gnutls_005frecord_005fget_005fstate">Function: <em>int</em> <strong>gnutls_record_get_state</strong> <em>(gnutls_session_t <var>session</var>, unsigned <var>read</var>, gnutls_datum_t * <var>mac_key</var>, gnutls_datum_t * <var>IV</var>, gnutls_datum_t * <var>cipher_key</var>, unsigned char [8] <var>seq_number</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type
</p>
<p><var>read</var>: if non-zero the read parameters are returned, otherwise the write
</p>
<p><var>mac_key</var>: the key used for MAC (if a MAC is used)
</p>
<p><var>IV</var>: the initialization vector or nonce used
</p>
<p><var>cipher_key</var>: the cipher key
</p>
<p><var>seq_number</var>: A 64-bit sequence number
</p>
<p>This function will return the parameters of the current record state.
These are only useful to be provided to an external off-loading device
or subsystem. The returned values should be considered constant
and valid for the lifetime of the session.
</p>
<p>In that case, to sync the state back you must call <code>gnutls_record_set_state()</code> .
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, or an error code.
</p>
<p>Since 3.4.0
</p></dd></dl>

<span id="gnutls_005frecord_005foverhead_005fsize-1"></span><h4 class="subheading">gnutls_record_overhead_size</h4>
<span id="gnutls_005frecord_005foverhead_005fsize"></span><dl>
<dt id="index-gnutls_005frecord_005foverhead_005fsize">Function: <em>size_t</em> <strong>gnutls_record_overhead_size</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is <code>gnutls_session_t</code> 
</p>
<p>This function will return the size in bytes of the overhead
due to TLS (or DTLS) per record. On certain occasions
(e.g., CBC ciphers) the returned value is the maximum
possible overhead.
</p>
<p><strong>Since:</strong> 3.2.2
</p></dd></dl>

<span id="gnutls_005frecord_005frecv-1"></span><h4 class="subheading">gnutls_record_recv</h4>
<span id="gnutls_005frecord_005frecv"></span><dl>
<dt id="index-gnutls_005frecord_005frecv-1">Function: <em>ssize_t</em> <strong>gnutls_record_recv</strong> <em>(gnutls_session_t <var>session</var>, void * <var>data</var>, size_t <var>data_size</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>data</var>: the buffer that the data will be read into
</p>
<p><var>data_size</var>: the number of requested bytes
</p>
<p>This function has the similar semantics with <code>recv()</code> .  The only
difference is that it accepts a GnuTLS session, and uses different
error codes.
In the special case that the peer requests a renegotiation, the
caller will receive an error code of <code>GNUTLS_E_REHANDSHAKE</code> .  In case
of a client, this message may be simply ignored, replied with an alert
<code>GNUTLS_A_NO_RENEGOTIATION</code> , or replied with a new handshake,
depending on the client&rsquo;s will. A server receiving this error code
can only initiate a new handshake or terminate the session.
</p>
<p>If <code>EINTR</code>  is returned by the internal pull function (the default
is <code>recv()</code> ) then <code>GNUTLS_E_INTERRUPTED</code>  will be returned.  If
<code>GNUTLS_E_INTERRUPTED</code>  or <code>GNUTLS_E_AGAIN</code>  is returned, you must
call this function again to get the data.  See also
<code>gnutls_record_get_direction()</code> .
</p>
<p><strong>Returns:</strong> The number of bytes received and zero on EOF (for stream
connections).  A negative error code is returned in case of an error.  
The number of bytes received might be less than the requested  <code>data_size</code> .
</p></dd></dl>

<span id="gnutls_005frecord_005frecv_005fearly_005fdata-1"></span><h4 class="subheading">gnutls_record_recv_early_data</h4>
<span id="gnutls_005frecord_005frecv_005fearly_005fdata"></span><dl>
<dt id="index-gnutls_005frecord_005frecv_005fearly_005fdata">Function: <em>ssize_t</em> <strong>gnutls_record_recv_early_data</strong> <em>(gnutls_session_t <var>session</var>, void * <var>data</var>, size_t <var>data_size</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>data</var>: the buffer that the data will be read into
</p>
<p><var>data_size</var>: the number of requested bytes
</p>
<p>This function can be used by a searver to retrieve data sent early
in the handshake processes when resuming a session.  This is used
to implement a zero-roundtrip (0-RTT) mode.  It has the same
semantics as <code>gnutls_record_recv()</code> .
</p>
<p>This function can be called either in a handshake hook, or after
the handshake is complete.
</p>
<p><strong>Returns:</strong> The number of bytes received and zero when early data
reading is complete.  A negative error code is returned in case of
an error.  If no early data is received during the handshake, this
function returns <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> .  The
number of bytes received might be less than the requested
 <code>data_size</code> .
</p>
<p><strong>Since:</strong> 3.6.5
</p></dd></dl>

<span id="gnutls_005frecord_005frecv_005fpacket-1"></span><h4 class="subheading">gnutls_record_recv_packet</h4>
<span id="gnutls_005frecord_005frecv_005fpacket"></span><dl>
<dt id="index-gnutls_005frecord_005frecv_005fpacket">Function: <em>ssize_t</em> <strong>gnutls_record_recv_packet</strong> <em>(gnutls_session_t <var>session</var>, gnutls_packet_t * <var>packet</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>packet</var>: the structure that will hold the packet data
</p>
<p>This is a lower-level function than <code>gnutls_record_recv()</code>  and allows
to directly receive the whole decrypted packet. That avoids a
memory copy, and is intended to be used by applications seeking high
performance.
</p>
<p>The received packet is accessed using <code>gnutls_packet_get()</code>  and 
must be deinitialized using <code>gnutls_packet_deinit()</code> . The returned
packet will be <code>NULL</code>  if the return value is zero (EOF).
</p>
<p><strong>Returns:</strong> The number of bytes received and zero on EOF (for stream
connections).  A negative error code is returned in case of an error.  
</p>
<p><strong>Since:</strong> 3.3.5
</p></dd></dl>

<span id="gnutls_005frecord_005frecv_005fseq-1"></span><h4 class="subheading">gnutls_record_recv_seq</h4>
<span id="gnutls_005frecord_005frecv_005fseq"></span><dl>
<dt id="index-gnutls_005frecord_005frecv_005fseq-1">Function: <em>ssize_t</em> <strong>gnutls_record_recv_seq</strong> <em>(gnutls_session_t <var>session</var>, void * <var>data</var>, size_t <var>data_size</var>, unsigned char * <var>seq</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>data</var>: the buffer that the data will be read into
</p>
<p><var>data_size</var>: the number of requested bytes
</p>
<p><var>seq</var>: is the packet&rsquo;s 64-bit sequence number. Should have space for 8 bytes.
</p>
<p>This function is the same as <code>gnutls_record_recv()</code> , except that
it returns in addition to data, the sequence number of the data.
This is useful in DTLS where record packets might be received
out-of-order. The returned 8-byte sequence number is an
integer in big-endian format and should be
treated as a unique message identification. 
</p>
<p><strong>Returns:</strong> The number of bytes received and zero on EOF.  A negative
error code is returned in case of an error.  The number of bytes
received might be less than  <code>data_size</code> .
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005frecord_005fsend-1"></span><h4 class="subheading">gnutls_record_send</h4>
<span id="gnutls_005frecord_005fsend"></span><dl>
<dt id="index-gnutls_005frecord_005fsend-1">Function: <em>ssize_t</em> <strong>gnutls_record_send</strong> <em>(gnutls_session_t <var>session</var>, const void * <var>data</var>, size_t <var>data_size</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>data</var>: contains the data to send
</p>
<p><var>data_size</var>: is the length of the data
</p>
<p>This function has the similar semantics with <code>send()</code> .  The only
difference is that it accepts a GnuTLS session, and uses different
error codes.
Note that if the send buffer is full, <code>send()</code>  will block this
function.  See the <code>send()</code>  documentation for more information.  
</p>
<p>You can replace the default push function which is <code>send()</code> , by using
<code>gnutls_transport_set_push_function()</code> .
</p>
<p>If the EINTR is returned by the internal push function 
then <code>GNUTLS_E_INTERRUPTED</code>  will be returned. If
<code>GNUTLS_E_INTERRUPTED</code>  or <code>GNUTLS_E_AGAIN</code>  is returned, you must
call this function again with the exact same parameters, or provide a
<code>NULL</code>  pointer for  <code>data</code> and 0 for  <code>data_size</code> , in order to write the
same data as before. If you wish to discard the previous data instead
of retrying, you must call <code>gnutls_record_discard_queued()</code>  before
calling this function with different parameters.
cf. <code>gnutls_record_get_direction()</code> . 
</p>
<p>Note that in DTLS this function will return the <code>GNUTLS_E_LARGE_PACKET</code> 
error code if the send data exceed the data MTU value - as returned
by <code>gnutls_dtls_get_data_mtu()</code> . The errno value EMSGSIZE
also maps to <code>GNUTLS_E_LARGE_PACKET</code> . 
Note that since 3.2.13 this function can be called under cork in DTLS
mode, and will refuse to send data over the MTU size by returning
<code>GNUTLS_E_LARGE_PACKET</code> .
</p>
<p><strong>Returns:</strong> The number of bytes sent, or a negative error code.  The
number of bytes sent might be less than  <code>data_size</code> .  The maximum
number of bytes this function can send in a single call depends
on the negotiated maximum record size.
</p></dd></dl>

<span id="gnutls_005frecord_005fsend2-1"></span><h4 class="subheading">gnutls_record_send2</h4>
<span id="gnutls_005frecord_005fsend2"></span><dl>
<dt id="index-gnutls_005frecord_005fsend2-1">Function: <em>ssize_t</em> <strong>gnutls_record_send2</strong> <em>(gnutls_session_t <var>session</var>, const void * <var>data</var>, size_t <var>data_size</var>, size_t <var>pad</var>, unsigned <var>flags</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>data</var>: contains the data to send
</p>
<p><var>data_size</var>: is the length of the data
</p>
<p><var>pad</var>: padding to be added to the record
</p>
<p><var>flags</var>: must be zero
</p>
<p>This function is identical to <code>gnutls_record_send()</code>  except that it
takes an extra argument to specify padding to be added the record.
To determine the maximum size of padding, use
<code>gnutls_record_get_max_size()</code>  and <code>gnutls_record_overhead_size()</code> .
</p>
<p>Note that in order for GnuTLS to provide constant time processing
of padding and data in TLS1.3, the flag <code>GNUTLS_SAFE_PADDING_CHECK</code> 
must be used in <code>gnutls_init()</code> .
</p>
<p><strong>Returns:</strong> The number of bytes sent, or a negative error code.  The
number of bytes sent might be less than  <code>data_size</code> .  The maximum
number of bytes this function can send in a single call depends
on the negotiated maximum record size.
</p>
<p><strong>Since:</strong> 3.6.3
</p></dd></dl>

<span id="gnutls_005frecord_005fsend_005fearly_005fdata-1"></span><h4 class="subheading">gnutls_record_send_early_data</h4>
<span id="gnutls_005frecord_005fsend_005fearly_005fdata"></span><dl>
<dt id="index-gnutls_005frecord_005fsend_005fearly_005fdata">Function: <em>ssize_t</em> <strong>gnutls_record_send_early_data</strong> <em>(gnutls_session_t <var>session</var>, const void * <var>data</var>, size_t <var>data_size</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>data</var>: contains the data to send
</p>
<p><var>data_size</var>: is the length of the data
</p>
<p>This function can be used by a client to send data early in the
handshake processes when resuming a session.  This is used to
implement a zero-roundtrip (0-RTT) mode.  It has the same semantics
as <code>gnutls_record_send()</code> .
</p>
<p>There may be a limit to the amount of data sent as early data.  Use
<code>gnutls_record_get_max_early_data_size()</code>  to check the limit.  If the
limit exceeds, this function returns
<code>GNUTLS_E_RECORD_LIMIT_REACHED</code> .
</p>
<p><strong>Returns:</strong> The number of bytes sent, or a negative error code.  The
number of bytes sent might be less than  <code>data_size</code> .  The maximum
number of bytes this function can send in a single call depends
on the negotiated maximum record size.
</p>
<p><strong>Since:</strong> 3.6.5
</p></dd></dl>

<span id="gnutls_005frecord_005fsend_005frange-1"></span><h4 class="subheading">gnutls_record_send_range</h4>
<span id="gnutls_005frecord_005fsend_005frange"></span><dl>
<dt id="index-gnutls_005frecord_005fsend_005frange">Function: <em>ssize_t</em> <strong>gnutls_record_send_range</strong> <em>(gnutls_session_t <var>session</var>, const void * <var>data</var>, size_t <var>data_size</var>, const gnutls_range_st * <var>range</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>data</var>: contains the data to send.
</p>
<p><var>data_size</var>: is the length of the data.
</p>
<p><var>range</var>: is the range of lengths in which the real data length must be hidden.
</p>
<p>This function operates like <code>gnutls_record_send()</code>  but, while
<code>gnutls_record_send()</code>  adds minimal padding to each TLS record,
this function uses the TLS extra-padding feature to conceal the real
data size within the range of lengths provided.
Some TLS sessions do not support extra padding (e.g. stream ciphers in standard
TLS or SSL3 sessions). To know whether the current session supports extra
padding, and hence length hiding, use the <code>gnutls_record_can_use_length_hiding()</code> 
function.
</p>
<p><strong>Note:</strong> This function currently is limited to blocking sockets.
</p>
<p><strong>Returns:</strong> The number of bytes sent (that is data_size in a successful invocation),
or a negative error code.
</p></dd></dl>

<span id="gnutls_005frecord_005fset_005fmax_005fearly_005fdata_005fsize-1"></span><h4 class="subheading">gnutls_record_set_max_early_data_size</h4>
<span id="gnutls_005frecord_005fset_005fmax_005fearly_005fdata_005fsize"></span><dl>
<dt id="index-gnutls_005frecord_005fset_005fmax_005fearly_005fdata_005fsize">Function: <em>int</em> <strong>gnutls_record_set_max_early_data_size</strong> <em>(gnutls_session_t <var>session</var>, size_t <var>size</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>size</var>: is the new size
</p>
<p>This function sets the maximum early data size in this connection.
This property can only be set to servers.  The client may be
provided with the maximum allowed size through the &quot;early_data&quot;
extension of the NewSessionTicket handshake message.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p>
<p><strong>Since:</strong> 3.6.4
</p></dd></dl>

<span id="gnutls_005frecord_005fset_005fmax_005frecv_005fsize-1"></span><h4 class="subheading">gnutls_record_set_max_recv_size</h4>
<span id="gnutls_005frecord_005fset_005fmax_005frecv_005fsize"></span><dl>
<dt id="index-gnutls_005frecord_005fset_005fmax_005frecv_005fsize">Function: <em>ssize_t</em> <strong>gnutls_record_set_max_recv_size</strong> <em>(gnutls_session_t <var>session</var>, size_t <var>size</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>size</var>: is the new size
</p>
<p>This function sets the maximum amount of plaintext received in a
record in this connection.
</p>
<p>The limit is also negotiated through a TLS extension called &rsquo;record
size limit&rsquo;.  Note that while the &rsquo;record size limit&rsquo; extension is
preferred, not all TLS implementations use or even understand the
extension.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p>
<p><strong>Since:</strong> 3.6.8
</p></dd></dl>

<span id="gnutls_005frecord_005fset_005fmax_005fsize-1"></span><h4 class="subheading">gnutls_record_set_max_size</h4>
<span id="gnutls_005frecord_005fset_005fmax_005fsize"></span><dl>
<dt id="index-gnutls_005frecord_005fset_005fmax_005fsize">Function: <em>ssize_t</em> <strong>gnutls_record_set_max_size</strong> <em>(gnutls_session_t <var>session</var>, size_t <var>size</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>size</var>: is the new size
</p>
<p>This function sets the maximum amount of plaintext sent and
received in a record in this connection.
</p>
<p>Prior to 3.6.4, this function was implemented using a TLS extension
called &rsquo;max fragment length&rsquo;, which limits the acceptable values to
512(=2^9), 1024(=2^10), 2048(=2^11) and 4096(=2^12).
</p>
<p>Since 3.6.4, the limit is also negotiated through a new TLS
extension called &rsquo;record size limit&rsquo;, which doesn&rsquo;t have the
limitation, as long as the value ranges between 512 and 16384.
Note that while the &rsquo;record size limit&rsquo; extension is preferred, not
all TLS implementations use or even understand the extension.
</p>
<p><strong>Deprecated:</strong> if the client can assume that the &rsquo;record size limit&rsquo;
extension is supported by the server, we recommend using
<code>gnutls_record_set_max_recv_size()</code>  instead.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p></dd></dl>

<span id="gnutls_005frecord_005fset_005fstate-1"></span><h4 class="subheading">gnutls_record_set_state</h4>
<span id="gnutls_005frecord_005fset_005fstate"></span><dl>
<dt id="index-gnutls_005frecord_005fset_005fstate">Function: <em>int</em> <strong>gnutls_record_set_state</strong> <em>(gnutls_session_t <var>session</var>, unsigned <var>read</var>, const unsigned char [8] <var>seq_number</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type
</p>
<p><var>read</var>: if non-zero the read parameters are returned, otherwise the write
</p>
<p><var>seq_number</var>: A 64-bit sequence number
</p>
<p>This function will set the sequence number in the current record state.
This function is useful if sending and receiving are offloaded from
gnutls. That is, if <code>gnutls_record_get_state()</code>  was used.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, or an error code.
</p>
<p>Since 3.4.0
</p></dd></dl>

<span id="gnutls_005frecord_005fset_005ftimeout-1"></span><h4 class="subheading">gnutls_record_set_timeout</h4>
<span id="gnutls_005frecord_005fset_005ftimeout"></span><dl>
<dt id="index-gnutls_005frecord_005fset_005ftimeout">Function: <em>void</em> <strong>gnutls_record_set_timeout</strong> <em>(gnutls_session_t <var>session</var>, unsigned int <var>ms</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>ms</var>: is a timeout value in milliseconds
</p>
<p>This function sets the receive timeout for the record layer
to the provided value. Use an  <code>ms</code> value of zero to disable
timeout (the default), or <code>GNUTLS_INDEFINITE_TIMEOUT</code> , to
set an indefinite timeout.
</p>
<p>This function requires to set a pull timeout callback. See
<code>gnutls_transport_set_pull_timeout_function()</code> .
</p>
<p><strong>Since:</strong> 3.1.7
</p></dd></dl>

<span id="gnutls_005frecord_005funcork-1"></span><h4 class="subheading">gnutls_record_uncork</h4>
<span id="gnutls_005frecord_005funcork"></span><dl>
<dt id="index-gnutls_005frecord_005funcork-1">Function: <em>int</em> <strong>gnutls_record_uncork</strong> <em>(gnutls_session_t <var>session</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>flags</var>: Could be zero or <code>GNUTLS_RECORD_WAIT</code> 
</p>
<p>This resets the effect of <code>gnutls_record_cork()</code> , and flushes any pending
data. If the <code>GNUTLS_RECORD_WAIT</code>  flag is specified then this
function will block until the data is sent or a fatal error
occurs (i.e., the function will retry on <code>GNUTLS_E_AGAIN</code>  and
<code>GNUTLS_E_INTERRUPTED</code> ).
</p>
<p>If the flag <code>GNUTLS_RECORD_WAIT</code>  is not specified and the function
is interrupted then the <code>GNUTLS_E_AGAIN</code>  or <code>GNUTLS_E_INTERRUPTED</code> 
errors will be returned. To obtain the data left in the corked
buffer use <code>gnutls_record_check_corked()</code> .
</p>
<p><strong>Returns:</strong> On success the number of transmitted data is returned, or 
otherwise a negative error code. 
</p>
<p><strong>Since:</strong> 3.1.9
</p></dd></dl>

<span id="gnutls_005frehandshake-1"></span><h4 class="subheading">gnutls_rehandshake</h4>
<span id="gnutls_005frehandshake"></span><dl>
<dt id="index-gnutls_005frehandshake-1">Function: <em>int</em> <strong>gnutls_rehandshake</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>This function can only be called in server side, and
instructs a TLS 1.2 or earlier client to renegotiate
parameters (perform a handshake), by sending a 
hello request message.
</p>
<p>If this function succeeds, the calling application
should call <code>gnutls_record_recv()</code>  until <code>GNUTLS_E_REHANDSHAKE</code> 
is returned to clear any pending data. If the <code>GNUTLS_E_REHANDSHAKE</code> 
error code is not seen, then the handshake request was
not followed by the peer (the TLS protocol does not require
the client to do, and such compliance should be handled
by the application protocol).
</p>
<p>Once the <code>GNUTLS_E_REHANDSHAKE</code>  error code is seen, the
calling application should proceed to calling
<code>gnutls_handshake()</code>  to negotiate the new
parameters.
</p>
<p>If the client does not wish to renegotiate parameters he 
may reply with an alert message, and in that case the return code seen
by subsequent <code>gnutls_record_recv()</code>  will be
<code>GNUTLS_E_WARNING_ALERT_RECEIVED</code>  with the specific alert being
<code>GNUTLS_A_NO_RENEGOTIATION</code> .  A client may also choose to ignore
this request.
</p>
<p>Under TLS 1.3 this function is equivalent to <code>gnutls_session_key_update()</code> 
with the <code>GNUTLS_KU_PEER</code>  flag. In that case subsequent calls to
<code>gnutls_record_recv()</code>  will not return <code>GNUTLS_E_REHANDSHAKE</code> , and
calls to <code>gnutls_handshake()</code>  in server side are a no-op.
</p>
<p>This function always fails with <code>GNUTLS_E_INVALID_REQUEST</code>  when
called in client side.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p></dd></dl>

<span id="gnutls_005fsafe_005frenegotiation_005fstatus-1"></span><h4 class="subheading">gnutls_safe_renegotiation_status</h4>
<span id="gnutls_005fsafe_005frenegotiation_005fstatus"></span><dl>
<dt id="index-gnutls_005fsafe_005frenegotiation_005fstatus-1">Function: <em>unsigned</em> <strong>gnutls_safe_renegotiation_status</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Can be used to check whether safe renegotiation is being used
in the current session.
</p>
<p><strong>Returns:</strong> 0 when safe renegotiation is not used and non (0) when
safe renegotiation is used.
</p>
<p><strong>Since:</strong> 2.10.0
</p></dd></dl>

<span id="gnutls_005fsec_005fparam_005fget_005fname-1"></span><h4 class="subheading">gnutls_sec_param_get_name</h4>
<span id="gnutls_005fsec_005fparam_005fget_005fname"></span><dl>
<dt id="index-gnutls_005fsec_005fparam_005fget_005fname">Function: <em>const char *</em> <strong>gnutls_sec_param_get_name</strong> <em>(gnutls_sec_param_t <var>param</var>)</em></dt>
<dd><p><var>param</var>: is a security parameter
</p>
<p>Convert a <code>gnutls_sec_param_t</code>  value to a string.
</p>
<p><strong>Returns:</strong> a pointer to a string that contains the name of the
specified security level, or <code>NULL</code> .
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fsec_005fparam_005fto_005fpk_005fbits-1"></span><h4 class="subheading">gnutls_sec_param_to_pk_bits</h4>
<span id="gnutls_005fsec_005fparam_005fto_005fpk_005fbits"></span><dl>
<dt id="index-gnutls_005fsec_005fparam_005fto_005fpk_005fbits-1">Function: <em>unsigned int</em> <strong>gnutls_sec_param_to_pk_bits</strong> <em>(gnutls_pk_algorithm_t <var>algo</var>, gnutls_sec_param_t <var>param</var>)</em></dt>
<dd><p><var>algo</var>: is a public key algorithm
</p>
<p><var>param</var>: is a security parameter
</p>
<p>When generating private and public key pairs a difficult question
is which size of &quot;bits&quot; the modulus will be in RSA and the group size
in DSA. The easy answer is 1024, which is also wrong. This function
will convert a human understandable security parameter to an
appropriate size for the specific algorithm.
</p>
<p><strong>Returns:</strong> The number of bits, or (0).
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fsec_005fparam_005fto_005fsymmetric_005fbits-1"></span><h4 class="subheading">gnutls_sec_param_to_symmetric_bits</h4>
<span id="gnutls_005fsec_005fparam_005fto_005fsymmetric_005fbits"></span><dl>
<dt id="index-gnutls_005fsec_005fparam_005fto_005fsymmetric_005fbits">Function: <em>unsigned int</em> <strong>gnutls_sec_param_to_symmetric_bits</strong> <em>(gnutls_sec_param_t <var>param</var>)</em></dt>
<dd><p><var>param</var>: is a security parameter
</p>
<p>This function will return the number of bits that correspond to
symmetric cipher strength for the given security parameter.
</p>
<p><strong>Returns:</strong> The number of bits, or (0).
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fserver_005fname_005fget-1"></span><h4 class="subheading">gnutls_server_name_get</h4>
<span id="gnutls_005fserver_005fname_005fget"></span><dl>
<dt id="index-gnutls_005fserver_005fname_005fget">Function: <em>int</em> <strong>gnutls_server_name_get</strong> <em>(gnutls_session_t <var>session</var>, void * <var>data</var>, size_t * <var>data_length</var>, unsigned int * <var>type</var>, unsigned int <var>indx</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>data</var>: will hold the data
</p>
<p><var>data_length</var>: will hold the data length. Must hold the maximum size of data.
</p>
<p><var>type</var>: will hold the server name indicator type
</p>
<p><var>indx</var>: is the index of the server_name
</p>
<p>This function will allow you to get the name indication (if any), a
client has sent.  The name indication may be any of the enumeration
gnutls_server_name_type_t.
</p>
<p>If  <code>type</code> is GNUTLS_NAME_DNS, then this function is to be used by
servers that support virtual hosting, and the data will be a null
terminated IDNA ACE string (prior to GnuTLS 3.4.0 it was a UTF-8 string).
</p>
<p>If  <code>data</code> has not enough size to hold the server name
GNUTLS_E_SHORT_MEMORY_BUFFER is returned, and  <code>data_length</code> will
hold the required size.
</p>
<p><code>indx</code> is used to retrieve more than one server names (if sent by
the client).  The first server name has an index of 0, the second 1
and so on.  If no name with the given index exists
GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE is returned.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, on UTF-8
decoding error <code>GNUTLS_E_IDNA_ERROR</code>  is returned, otherwise a negative
error code is returned.
</p></dd></dl>

<span id="gnutls_005fserver_005fname_005fset-1"></span><h4 class="subheading">gnutls_server_name_set</h4>
<span id="gnutls_005fserver_005fname_005fset"></span><dl>
<dt id="index-gnutls_005fserver_005fname_005fset">Function: <em>int</em> <strong>gnutls_server_name_set</strong> <em>(gnutls_session_t <var>session</var>, gnutls_server_name_type_t <var>type</var>, const void * <var>name</var>, size_t <var>name_length</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>type</var>: specifies the indicator type
</p>
<p><var>name</var>: is a string that contains the server name.
</p>
<p><var>name_length</var>: holds the length of name excluding the terminating null byte
</p>
<p>This function is to be used by clients that want to inform (via a
TLS extension mechanism) the server of the name they connected to.
This should be used by clients that connect to servers that do
virtual hosting.
</p>
<p>The value of  <code>name</code> depends on the  <code>type</code> type.  In case of
<code>GNUTLS_NAME_DNS</code> , a UTF-8 null-terminated domain name string,
without the trailing dot, is expected.
</p>
<p>IPv4 or IPv6 addresses are not permitted to be set by this function.
If the function is called with a name of  <code>name_length</code> zero it will clear
all server names set.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p></dd></dl>

<span id="gnutls_005fsession_005fchannel_005fbinding-1"></span><h4 class="subheading">gnutls_session_channel_binding</h4>
<span id="gnutls_005fsession_005fchannel_005fbinding"></span><dl>
<dt id="index-gnutls_005fsession_005fchannel_005fbinding">Function: <em>int</em> <strong>gnutls_session_channel_binding</strong> <em>(gnutls_session_t <var>session</var>, gnutls_channel_binding_t <var>cbtype</var>, gnutls_datum_t * <var>cb</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>cbtype</var>: an <code>gnutls_channel_binding_t</code>  enumeration type
</p>
<p><var>cb</var>: output buffer array with data
</p>
<p>Extract given channel binding data of the  <code>cbtype</code> (e.g.,
<code>GNUTLS_CB_TLS_UNIQUE</code> ) type.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success,
<code>GNUTLS_E_UNIMPLEMENTED_FEATURE</code>  if the  <code>cbtype</code> is unsupported,
<code>GNUTLS_E_CHANNEL_BINDING_NOT_AVAILABLE</code>  if the data is not
currently available, or an error code.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fsession_005fenable_005fcompatibility_005fmode-1"></span><h4 class="subheading">gnutls_session_enable_compatibility_mode</h4>
<span id="gnutls_005fsession_005fenable_005fcompatibility_005fmode"></span><dl>
<dt id="index-gnutls_005fsession_005fenable_005fcompatibility_005fmode">Function: <em>void</em> <strong>gnutls_session_enable_compatibility_mode</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>This function can be used to disable certain (security) features in
TLS in order to maintain maximum compatibility with buggy
clients. Because several trade-offs with security are enabled,
if required they will be reported through the audit subsystem.
</p>
<p>Normally only servers that require maximum compatibility with
everything out there, need to call this function.
</p>
<p>Note that this function must be called after any call to gnutls_priority
functions.
</p>
<p><strong>Since:</strong> 2.1.4
</p></dd></dl>

<span id="gnutls_005fsession_005fetm_005fstatus-1"></span><h4 class="subheading">gnutls_session_etm_status</h4>
<span id="gnutls_005fsession_005fetm_005fstatus"></span><dl>
<dt id="index-gnutls_005fsession_005fetm_005fstatus">Function: <em>unsigned</em> <strong>gnutls_session_etm_status</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Get the status of the encrypt-then-mac extension negotiation.
This is in accordance to rfc7366
</p>
<p><strong>Returns:</strong> Non-zero if the negotiation was successful or zero otherwise.
</p></dd></dl>

<span id="gnutls_005fsession_005fext_005fmaster_005fsecret_005fstatus-1"></span><h4 class="subheading">gnutls_session_ext_master_secret_status</h4>
<span id="gnutls_005fsession_005fext_005fmaster_005fsecret_005fstatus"></span><dl>
<dt id="index-gnutls_005fsession_005fext_005fmaster_005fsecret_005fstatus">Function: <em>unsigned</em> <strong>gnutls_session_ext_master_secret_status</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Get the status of the extended master secret extension negotiation.
This is in accordance to RFC7627. That information is also
available to the more generic <code>gnutls_session_get_flags()</code> .
</p>
<p><strong>Returns:</strong> Non-zero if the negotiation was successful or zero otherwise.
</p></dd></dl>

<span id="gnutls_005fsession_005fext_005fregister-1"></span><h4 class="subheading">gnutls_session_ext_register</h4>
<span id="gnutls_005fsession_005fext_005fregister"></span><dl>
<dt id="index-gnutls_005fsession_005fext_005fregister">Function: <em>int</em> <strong>gnutls_session_ext_register</strong> <em>(gnutls_session_t <var>session</var>, const char * <var>name</var>, int <var>id</var>, gnutls_ext_parse_type_t <var>parse_type</var>, gnutls_ext_recv_func <var>recv_func</var>, gnutls_ext_send_func <var>send_func</var>, gnutls_ext_deinit_data_func <var>deinit_func</var>, gnutls_ext_pack_func <var>pack_func</var>, gnutls_ext_unpack_func <var>unpack_func</var>, unsigned <var>flags</var>)</em></dt>
<dd><p><var>session</var>: the session for which this extension will be set
</p>
<p><var>name</var>: the name of the extension to register
</p>
<p><var>id</var>: the numeric id of the extension
</p>
<p><var>parse_type</var>: the parse type of the extension (see gnutls_ext_parse_type_t)
</p>
<p><var>recv_func</var>: a function to receive the data
</p>
<p><var>send_func</var>: a function to send the data
</p>
<p><var>deinit_func</var>: a function deinitialize any private data
</p>
<p><var>pack_func</var>: a function which serializes the extension&rsquo;s private data (used on session packing for resumption)
</p>
<p><var>unpack_func</var>: a function which will deserialize the extension&rsquo;s private data
</p>
<p><var>flags</var>: must be zero or flags from <code>gnutls_ext_flags_t</code> 
</p>
<p>This function will register a new extension type. The extension will be
only usable within the registered session. If the extension type
is already registered then <code>GNUTLS_E_ALREADY_REGISTERED</code>  will be returned,
unless the flag <code>GNUTLS_EXT_FLAG_OVERRIDE_INTERNAL</code>  is specified. The latter
flag when specified can be used to override certain extensions introduced
after 3.6.0. It is expected to be used by applications which handle
custom extensions that are not currently supported in GnuTLS, but direct
support for them may be added in the future.
</p>
<p>Each registered extension can store temporary data into the gnutls_session_t
structure using <code>gnutls_ext_set_data()</code> , and they can be retrieved using
<code>gnutls_ext_get_data()</code> .
</p>
<p>The validity of the extension registered can be given by the appropriate flags
of <code>gnutls_ext_flags_t</code> . If no validity is given, then the registered extension
will be valid for client and TLS1.2 server hello (or encrypted extensions for TLS1.3).
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p>
<p><strong>Since:</strong> 3.5.5
</p></dd></dl>

<span id="gnutls_005fsession_005fforce_005fvalid-1"></span><h4 class="subheading">gnutls_session_force_valid</h4>
<span id="gnutls_005fsession_005fforce_005fvalid"></span><dl>
<dt id="index-gnutls_005fsession_005fforce_005fvalid">Function: <em>void</em> <strong>gnutls_session_force_valid</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Clears the invalid flag in a session. That means
that sessions were corrupt or invalid data were received 
can be re-used. Use only when debugging or experimenting
with the TLS protocol. Should not be used in typical
applications.
</p></dd></dl>

<span id="gnutls_005fsession_005fget_005fdata-1"></span><h4 class="subheading">gnutls_session_get_data</h4>
<span id="gnutls_005fsession_005fget_005fdata"></span><dl>
<dt id="index-gnutls_005fsession_005fget_005fdata">Function: <em>int</em> <strong>gnutls_session_get_data</strong> <em>(gnutls_session_t <var>session</var>, void * <var>session_data</var>, size_t * <var>session_data_size</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>session_data</var>: is a pointer to space to hold the session.
</p>
<p><var>session_data_size</var>: is the session_data&rsquo;s size, or it will be set by the function.
</p>
<p>Returns all session parameters needed to be stored to support resumption,
in a pre-allocated buffer.
</p>
<p>See <code>gnutls_session_get_data2()</code>  for more information.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p></dd></dl>

<span id="gnutls_005fsession_005fget_005fdata2-1"></span><h4 class="subheading">gnutls_session_get_data2</h4>
<span id="gnutls_005fsession_005fget_005fdata2"></span><dl>
<dt id="index-gnutls_005fsession_005fget_005fdata2">Function: <em>int</em> <strong>gnutls_session_get_data2</strong> <em>(gnutls_session_t <var>session</var>, gnutls_datum_t * <var>data</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>data</var>: is a pointer to a datum that will hold the session.
</p>
<p>Returns necessary parameters to support resumption. The client
should call this function and store the returned session data. A session
can be resumed later by calling <code>gnutls_session_set_data()</code>  with the returned
data. Note that under TLS 1.3, it is recommended for clients to use
session parameters only once, to prevent passive-observers from correlating
the different connections.
</p>
<p>The returned  <code>data</code> are allocated and must be released using <code>gnutls_free()</code> .
</p>
<p>This function will fail if called prior to handshake completion. In
case of false start TLS, the handshake completes only after data have
been successfully received from the peer.
</p>
<p>Under TLS1.3 session resumption is possible only after a session ticket
is received by the client. To ensure that such a ticket has been received use
<code>gnutls_session_get_flags()</code>  and check for flag <code>GNUTLS_SFLAGS_SESSION_TICKET</code> ;
if this flag is not set, this function will wait for a new ticket within
an estimated rountrip, and if not received will return dummy data which
cannot lead to resumption.
</p>
<p>To get notified when new tickets are received by the server
use <code>gnutls_handshake_set_hook_function()</code>  to wait for <code>GNUTLS_HANDSHAKE_NEW_SESSION_TICKET</code> 
messages. Each call of <code>gnutls_session_get_data2()</code>  after a ticket is
received, will return session resumption data corresponding to the last
received ticket.
</p>
<p>Note that this function under TLS1.3 requires a callback to be set with
<code>gnutls_transport_set_pull_timeout_function()</code>  for successful operation. There
was a bug before 3.6.10 which could make this function fail if that callback
was not set. On later versions if not set, the function will return a successful
error code, but will return dummy data that cannot lead to a resumption.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p></dd></dl>

<span id="gnutls_005fsession_005fget_005fdesc-1"></span><h4 class="subheading">gnutls_session_get_desc</h4>
<span id="gnutls_005fsession_005fget_005fdesc"></span><dl>
<dt id="index-gnutls_005fsession_005fget_005fdesc">Function: <em>char *</em> <strong>gnutls_session_get_desc</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a gnutls session
</p>
<p>This function returns a string describing the current session.
The string is null terminated and allocated using <code>gnutls_malloc()</code> .
</p>
<p>If initial negotiation is not complete when this function is called,
<code>NULL</code>  will be returned.
</p>
<p><strong>Returns:</strong> a description of the protocols and algorithms in the current session.
</p>
<p><strong>Since:</strong> 3.1.10
</p></dd></dl>

<span id="gnutls_005fsession_005fget_005fflags-1"></span><h4 class="subheading">gnutls_session_get_flags</h4>
<span id="gnutls_005fsession_005fget_005fflags"></span><dl>
<dt id="index-gnutls_005fsession_005fget_005fflags">Function: <em>unsigned</em> <strong>gnutls_session_get_flags</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>This function will return a series (ORed) of flags, applicable
for the current session.
</p>
<p>This replaces individual informational functions such as
<code>gnutls_safe_renegotiation_status()</code> , <code>gnutls_session_ext_master_secret_status()</code> ,
etc.
</p>
<p><strong>Returns:</strong> An ORed sequence of flags (see <code>gnutls_session_flags_t</code> )
</p>
<p><strong>Since:</strong> 3.5.0
</p></dd></dl>

<span id="gnutls_005fsession_005fget_005fid-1"></span><h4 class="subheading">gnutls_session_get_id</h4>
<span id="gnutls_005fsession_005fget_005fid"></span><dl>
<dt id="index-gnutls_005fsession_005fget_005fid">Function: <em>int</em> <strong>gnutls_session_get_id</strong> <em>(gnutls_session_t <var>session</var>, void * <var>session_id</var>, size_t * <var>session_id_size</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>session_id</var>: is a pointer to space to hold the session id.
</p>
<p><var>session_id_size</var>: initially should contain the maximum  <code>session_id</code> size and will be updated.
</p>
<p>Returns the TLS session identifier. The session ID is selected by the
server, and in older versions of TLS was a unique identifier shared
between client and server which was persistent across resumption.
In the latest version of TLS (1.3) or TLS with session tickets, the
notion of session identifiers is undefined and cannot be relied for uniquely
identifying sessions across client and server.
</p>
<p>In client side this function returns the identifier returned by the
server, and cannot be assumed to have any relation to session resumption.
In server side this function is guaranteed to return a persistent
identifier of the session since GnuTLS 3.6.4, which may not necessarily
map into the TLS session ID value. Prior to that version the value
could only be considered a persistent identifier, under TLS1.2 or earlier
and when no session tickets were in use.
</p>
<p>The session identifier value returned is always less than
<code>GNUTLS_MAX_SESSION_ID_SIZE</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p></dd></dl>

<span id="gnutls_005fsession_005fget_005fid2-1"></span><h4 class="subheading">gnutls_session_get_id2</h4>
<span id="gnutls_005fsession_005fget_005fid2"></span><dl>
<dt id="index-gnutls_005fsession_005fget_005fid2-1">Function: <em>int</em> <strong>gnutls_session_get_id2</strong> <em>(gnutls_session_t <var>session</var>, gnutls_datum_t * <var>session_id</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>session_id</var>: will point to the session ID.
</p>
<p>Returns the TLS session identifier. The session ID is selected by the
server, and in older versions of TLS was a unique identifier shared
between client and server which was persistent across resumption.
In the latest version of TLS (1.3) or TLS 1.2 with session tickets, the
notion of session identifiers is undefined and cannot be relied for uniquely
identifying sessions across client and server.
</p>
<p>In client side this function returns the identifier returned by the
server, and cannot be assumed to have any relation to session resumption.
In server side this function is guaranteed to return a persistent
identifier of the session since GnuTLS 3.6.4, which may not necessarily
map into the TLS session ID value. Prior to that version the value
could only be considered a persistent identifier, under TLS1.2 or earlier
and when no session tickets were in use.
</p>
<p>The session identifier value returned is always less than
<code>GNUTLS_MAX_SESSION_ID_SIZE</code>  and should be treated as constant.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p>
<p><strong>Since:</strong> 3.1.4
</p></dd></dl>

<span id="gnutls_005fsession_005fget_005fmaster_005fsecret-1"></span><h4 class="subheading">gnutls_session_get_master_secret</h4>
<span id="gnutls_005fsession_005fget_005fmaster_005fsecret"></span><dl>
<dt id="index-gnutls_005fsession_005fget_005fmaster_005fsecret">Function: <em>void</em> <strong>gnutls_session_get_master_secret</strong> <em>(gnutls_session_t <var>session</var>, gnutls_datum_t * <var>secret</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>secret</var>: the session&rsquo;s master secret
</p>
<p>This function returns pointers to the master secret
used in the TLS session. The pointers are not to be modified or deallocated.
</p>
<p>This function is only applicable under TLS 1.2 or earlier versions.
</p>
<p><strong>Since:</strong> 3.5.0
</p></dd></dl>

<span id="gnutls_005fsession_005fget_005fptr-1"></span><h4 class="subheading">gnutls_session_get_ptr</h4>
<span id="gnutls_005fsession_005fget_005fptr"></span><dl>
<dt id="index-gnutls_005fsession_005fget_005fptr">Function: <em>void *</em> <strong>gnutls_session_get_ptr</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Get user pointer for session.  Useful in callbacks.  This is the
pointer set with <code>gnutls_session_set_ptr()</code> .
</p>
<p><strong>Returns:</strong> the user given pointer from the session structure, or
<code>NULL</code>  if it was never set.
</p></dd></dl>

<span id="gnutls_005fsession_005fget_005frandom-1"></span><h4 class="subheading">gnutls_session_get_random</h4>
<span id="gnutls_005fsession_005fget_005frandom"></span><dl>
<dt id="index-gnutls_005fsession_005fget_005frandom">Function: <em>void</em> <strong>gnutls_session_get_random</strong> <em>(gnutls_session_t <var>session</var>, gnutls_datum_t * <var>client</var>, gnutls_datum_t * <var>server</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>client</var>: the client part of the random
</p>
<p><var>server</var>: the server part of the random
</p>
<p>This function returns pointers to the client and server
random fields used in the TLS handshake. The pointers are
not to be modified or deallocated.
</p>
<p>If a client random value has not yet been established, the output
will be garbage.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fsession_005fget_005fverify_005fcert_005fstatus-1"></span><h4 class="subheading">gnutls_session_get_verify_cert_status</h4>
<span id="gnutls_005fsession_005fget_005fverify_005fcert_005fstatus"></span><dl>
<dt id="index-gnutls_005fsession_005fget_005fverify_005fcert_005fstatus">Function: <em>unsigned int</em> <strong>gnutls_session_get_verify_cert_status</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a gnutls session
</p>
<p>This function returns the status of the verification when initiated
via auto-verification, i.e., by <code>gnutls_session_set_verify_cert2()</code>  or
<code>gnutls_session_set_verify_cert()</code> . If no certificate verification
was occurred then the return value would be set to ((unsigned int)-1).
</p>
<p>The certificate verification status is the same as in <code>gnutls_certificate_verify_peers()</code> .
</p>
<p><strong>Returns:</strong> the certificate verification status.
</p>
<p><strong>Since:</strong> 3.4.6
</p></dd></dl>

<span id="gnutls_005fsession_005fis_005fresumed-1"></span><h4 class="subheading">gnutls_session_is_resumed</h4>
<span id="gnutls_005fsession_005fis_005fresumed"></span><dl>
<dt id="index-gnutls_005fsession_005fis_005fresumed-1">Function: <em>int</em> <strong>gnutls_session_is_resumed</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Checks whether session is resumed or not. This is functional
for both server and client side.
</p>
<p><strong>Returns:</strong> non zero if this session is resumed, or a zero if this is
a new session.
</p></dd></dl>

<span id="gnutls_005fsession_005fkey_005fupdate-1"></span><h4 class="subheading">gnutls_session_key_update</h4>
<span id="gnutls_005fsession_005fkey_005fupdate"></span><dl>
<dt id="index-gnutls_005fsession_005fkey_005fupdate">Function: <em>int</em> <strong>gnutls_session_key_update</strong> <em>(gnutls_session_t <var>session</var>, unsigned <var>flags</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>flags</var>: zero of <code>GNUTLS_KU_PEER</code> 
</p>
<p>This function will update/refresh the session keys when the
TLS protocol is 1.3 or better. The peer is notified of the
update by sending a message, so this function should be
treated similarly to <code>gnutls_record_send()</code>  &ndash;i.e., it may
return <code>GNUTLS_E_AGAIN</code>  or <code>GNUTLS_E_INTERRUPTED</code> .
</p>
<p>When this flag <code>GNUTLS_KU_PEER</code>  is specified, this function
in addition to updating the local keys, will ask the peer to
refresh its keys too.
</p>
<p>If the negotiated version is not TLS 1.3 or better this
function will return <code>GNUTLS_E_INVALID_REQUEST</code> .
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p>
<p><strong>Since:</strong> 3.6.3
</p></dd></dl>

<span id="gnutls_005fsession_005fresumption_005frequested-1"></span><h4 class="subheading">gnutls_session_resumption_requested</h4>
<span id="gnutls_005fsession_005fresumption_005frequested"></span><dl>
<dt id="index-gnutls_005fsession_005fresumption_005frequested-1">Function: <em>int</em> <strong>gnutls_session_resumption_requested</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Check whether the client has asked for session resumption.
This function is valid only on server side.
</p>
<p><strong>Returns:</strong> non zero if session resumption was asked, or a zero if not.
</p></dd></dl>

<span id="gnutls_005fsession_005fset_005fdata-1"></span><h4 class="subheading">gnutls_session_set_data</h4>
<span id="gnutls_005fsession_005fset_005fdata"></span><dl>
<dt id="index-gnutls_005fsession_005fset_005fdata">Function: <em>int</em> <strong>gnutls_session_set_data</strong> <em>(gnutls_session_t <var>session</var>, const void * <var>session_data</var>, size_t <var>session_data_size</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>session_data</var>: is a pointer to space to hold the session.
</p>
<p><var>session_data_size</var>: is the session&rsquo;s size
</p>
<p>Sets all session parameters, in order to resume a previously
established session.  The session data given must be the one
returned by <code>gnutls_session_get_data()</code> .  This function should be
called before <code>gnutls_handshake()</code> .
</p>
<p>Keep in mind that session resuming is advisory. The server may
choose not to resume the session, thus a full handshake will be
performed.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p></dd></dl>

<span id="gnutls_005fsession_005fset_005fid-1"></span><h4 class="subheading">gnutls_session_set_id</h4>
<span id="gnutls_005fsession_005fset_005fid"></span><dl>
<dt id="index-gnutls_005fsession_005fset_005fid">Function: <em>int</em> <strong>gnutls_session_set_id</strong> <em>(gnutls_session_t <var>session</var>, const gnutls_datum_t * <var>sid</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>sid</var>: the session identifier
</p>
<p>This function sets the session ID to be used in a client hello.
This is a function intended for exceptional uses. Do not use this
function unless you are implementing a custom protocol.
</p>
<p>To set session resumption parameters use <code>gnutls_session_set_data()</code>  instead.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p>
<p><strong>Since:</strong> 3.2.1
</p></dd></dl>

<span id="gnutls_005fsession_005fset_005fpremaster-1"></span><h4 class="subheading">gnutls_session_set_premaster</h4>
<span id="gnutls_005fsession_005fset_005fpremaster"></span><dl>
<dt id="index-gnutls_005fsession_005fset_005fpremaster">Function: <em>int</em> <strong>gnutls_session_set_premaster</strong> <em>(gnutls_session_t <var>session</var>, unsigned int <var>entity</var>, gnutls_protocol_t <var>version</var>, gnutls_kx_algorithm_t <var>kx</var>, gnutls_cipher_algorithm_t <var>cipher</var>, gnutls_mac_algorithm_t <var>mac</var>, gnutls_compression_method_t <var>comp</var>, const gnutls_datum_t * <var>master</var>, const gnutls_datum_t * <var>session_id</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>entity</var>: GNUTLS_SERVER or GNUTLS_CLIENT
</p>
<p><var>version</var>: the TLS protocol version
</p>
<p><var>kx</var>: the key exchange method
</p>
<p><var>cipher</var>: the cipher
</p>
<p><var>mac</var>: the MAC algorithm
</p>
<p><var>comp</var>: the compression method (ignored)
</p>
<p><var>master</var>: the master key to use
</p>
<p><var>session_id</var>: the session identifier
</p>
<p>This function sets the premaster secret in a session. This is
a function intended for exceptional uses. Do not use this
function unless you are implementing a legacy protocol.
Use <code>gnutls_session_set_data()</code>  instead.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p></dd></dl>

<span id="gnutls_005fsession_005fset_005fptr-1"></span><h4 class="subheading">gnutls_session_set_ptr</h4>
<span id="gnutls_005fsession_005fset_005fptr"></span><dl>
<dt id="index-gnutls_005fsession_005fset_005fptr">Function: <em>void</em> <strong>gnutls_session_set_ptr</strong> <em>(gnutls_session_t <var>session</var>, void * <var>ptr</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>ptr</var>: is the user pointer
</p>
<p>This function will set (associate) the user given pointer  <code>ptr</code> to
the session structure.  This pointer can be accessed with
<code>gnutls_session_get_ptr()</code> .
</p></dd></dl>

<span id="gnutls_005fsession_005fset_005fverify_005fcert-1"></span><h4 class="subheading">gnutls_session_set_verify_cert</h4>
<span id="gnutls_005fsession_005fset_005fverify_005fcert"></span><dl>
<dt id="index-gnutls_005fsession_005fset_005fverify_005fcert-1">Function: <em>void</em> <strong>gnutls_session_set_verify_cert</strong> <em>(gnutls_session_t <var>session</var>, const char * <var>hostname</var>, unsigned <var>flags</var>)</em></dt>
<dd><p><var>session</var>: is a gnutls session
</p>
<p><var>hostname</var>: is the expected name of the peer; may be <code>NULL</code> 
</p>
<p><var>flags</var>: flags for certificate verification &ndash; <code>gnutls_certificate_verify_flags</code> 
</p>
<p>This function instructs GnuTLS to verify the peer&rsquo;s certificate
using the provided hostname. If the verification fails the handshake
will also fail with <code>GNUTLS_E_CERTIFICATE_VERIFICATION_ERROR</code> . In that
case the verification result can be obtained using <code>gnutls_session_get_verify_cert_status()</code> .
</p>
<p>The  <code>hostname</code> pointer provided must remain valid for the lifetime
of the session. More precisely it should be available during any subsequent
handshakes. If no hostname is provided, no hostname verification
will be performed. For a more advanced verification function check
<code>gnutls_session_set_verify_cert2()</code> .
</p>
<p>If  <code>flags</code> is provided which contain a profile, this function should be
called after any session priority setting functions.
</p>
<p>The <code>gnutls_session_set_verify_cert()</code>  function is intended to be used by TLS
clients to verify the server&rsquo;s certificate.
</p>
<p><strong>Since:</strong> 3.4.6
</p></dd></dl>

<span id="gnutls_005fsession_005fset_005fverify_005fcert2-1"></span><h4 class="subheading">gnutls_session_set_verify_cert2</h4>
<span id="gnutls_005fsession_005fset_005fverify_005fcert2"></span><dl>
<dt id="index-gnutls_005fsession_005fset_005fverify_005fcert2">Function: <em>void</em> <strong>gnutls_session_set_verify_cert2</strong> <em>(gnutls_session_t <var>session</var>, gnutls_typed_vdata_st * <var>data</var>, unsigned <var>elements</var>, unsigned <var>flags</var>)</em></dt>
<dd><p><var>session</var>: is a gnutls session
</p>
<p><var>data</var>: an array of typed data
</p>
<p><var>elements</var>: the number of data elements
</p>
<p><var>flags</var>: flags for certificate verification &ndash; <code>gnutls_certificate_verify_flags</code> 
</p>
<p>This function instructs GnuTLS to verify the peer&rsquo;s certificate
using the provided typed data information. If the verification fails the handshake
will also fail with <code>GNUTLS_E_CERTIFICATE_VERIFICATION_ERROR</code> . In that
case the verification result can be obtained using <code>gnutls_session_get_verify_cert_status()</code> .
</p>
<p>The acceptable typed data are the same as in <code>gnutls_certificate_verify_peers()</code> ,
and once set must remain valid for the lifetime of the session. More precisely
they should be available during any subsequent handshakes.
</p>
<p>If  <code>flags</code> is provided which contain a profile, this function should be
called after any session priority setting functions.
</p>
<p><strong>Since:</strong> 3.4.6
</p></dd></dl>

<span id="gnutls_005fsession_005fset_005fverify_005ffunction-1"></span><h4 class="subheading">gnutls_session_set_verify_function</h4>
<span id="gnutls_005fsession_005fset_005fverify_005ffunction"></span><dl>
<dt id="index-gnutls_005fsession_005fset_005fverify_005ffunction">Function: <em>void</em> <strong>gnutls_session_set_verify_function</strong> <em>(gnutls_session_t <var>session</var>, gnutls_certificate_verify_function * <var>func</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>func</var>: is the callback function
</p>
<p>This function sets a callback to be called when peer&rsquo;s certificate
has been received in order to verify it on receipt rather than
doing after the handshake is completed. This overrides any callback
set using <code>gnutls_certificate_set_verify_function()</code> .
</p>
<p>The callback&rsquo;s function prototype is:
int (*callback)(gnutls_session_t);
</p>
<p>If the callback function is provided then gnutls will call it, in the
handshake, just after the certificate message has been received.
To verify or obtain the certificate the <code>gnutls_certificate_verify_peers2()</code> ,
<code>gnutls_certificate_type_get()</code> , <code>gnutls_certificate_get_peers()</code>  functions
can be used.
</p>
<p>The callback function should return 0 for the handshake to continue
or non-zero to terminate.
</p>
<p><strong>Since:</strong> 3.4.6
</p></dd></dl>

<span id="gnutls_005fsession_005fsupplemental_005fregister-1"></span><h4 class="subheading">gnutls_session_supplemental_register</h4>
<span id="gnutls_005fsession_005fsupplemental_005fregister"></span><dl>
<dt id="index-gnutls_005fsession_005fsupplemental_005fregister">Function: <em>int</em> <strong>gnutls_session_supplemental_register</strong> <em>(gnutls_session_t <var>session</var>, const char * <var>name</var>, gnutls_supplemental_data_format_type_t <var>type</var>, gnutls_supp_recv_func <var>recv_func</var>, gnutls_supp_send_func <var>send_func</var>, unsigned <var>flags</var>)</em></dt>
<dd><p><var>session</var>: the session for which this will be registered
</p>
<p><var>name</var>: the name of the supplemental data to register
</p>
<p><var>type</var>: the type of the supplemental data format
</p>
<p><var>recv_func</var>: the function to receive the data
</p>
<p><var>send_func</var>: the function to send the data
</p>
<p><var>flags</var>: must be zero
</p>
<p>This function will register a new supplemental data type (rfc4680).
The registered supplemental functions will be used for that specific
session. The provided  <code>type</code> must be an unassigned type in
<code>gnutls_supplemental_data_format_type_t</code> .
</p>
<p>If the type is already registered or handled by GnuTLS internally
<code>GNUTLS_E_ALREADY_REGISTERED</code>  will be returned.
</p>
<p>As supplemental data are not defined under TLS 1.3, this function will
disable TLS 1.3 support for the given session.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p>
<p><strong>Since:</strong> 3.5.5
</p></dd></dl>

<span id="gnutls_005fsession_005fticket_005fenable_005fclient-1"></span><h4 class="subheading">gnutls_session_ticket_enable_client</h4>
<span id="gnutls_005fsession_005fticket_005fenable_005fclient"></span><dl>
<dt id="index-gnutls_005fsession_005fticket_005fenable_005fclient">Function: <em>int</em> <strong>gnutls_session_ticket_enable_client</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Request that the client should attempt session resumption using
SessionTicket. This call is typically unnecessary as session
tickets are enabled by default.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, or an
error code.
</p>
<p><strong>Since:</strong> 2.10.0
</p></dd></dl>

<span id="gnutls_005fsession_005fticket_005fenable_005fserver-1"></span><h4 class="subheading">gnutls_session_ticket_enable_server</h4>
<span id="gnutls_005fsession_005fticket_005fenable_005fserver"></span><dl>
<dt id="index-gnutls_005fsession_005fticket_005fenable_005fserver-1">Function: <em>int</em> <strong>gnutls_session_ticket_enable_server</strong> <em>(gnutls_session_t <var>session</var>, const gnutls_datum_t * <var>key</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>key</var>: key to encrypt session parameters.
</p>
<p>Request that the server should attempt session resumption using
session tickets, i.e., by delegating storage to the client.
 <code>key</code> must be initialized using <code>gnutls_session_ticket_key_generate()</code> .
To avoid leaking that key, use <code>gnutls_memset()</code>  prior to
releasing it.
</p>
<p>The default ticket expiration time can be overridden using
<code>gnutls_db_set_cache_expiration()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, or an
error code.
</p>
<p><strong>Since:</strong> 2.10.0
</p></dd></dl>

<span id="gnutls_005fsession_005fticket_005fkey_005fgenerate-1"></span><h4 class="subheading">gnutls_session_ticket_key_generate</h4>
<span id="gnutls_005fsession_005fticket_005fkey_005fgenerate"></span><dl>
<dt id="index-gnutls_005fsession_005fticket_005fkey_005fgenerate-1">Function: <em>int</em> <strong>gnutls_session_ticket_key_generate</strong> <em>(gnutls_datum_t * <var>key</var>)</em></dt>
<dd><p><var>key</var>: is a pointer to a <code>gnutls_datum_t</code>  which will contain a newly
created key.
</p>
<p>Generate a random key to encrypt security parameters within
SessionTicket.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, or an
error code.
</p>
<p><strong>Since:</strong> 2.10.0
</p></dd></dl>

<span id="gnutls_005fsession_005fticket_005fsend-1"></span><h4 class="subheading">gnutls_session_ticket_send</h4>
<span id="gnutls_005fsession_005fticket_005fsend"></span><dl>
<dt id="index-gnutls_005fsession_005fticket_005fsend-1">Function: <em>int</em> <strong>gnutls_session_ticket_send</strong> <em>(gnutls_session_t <var>session</var>, unsigned <var>nr</var>, unsigned <var>flags</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>nr</var>: the number of tickets to send
</p>
<p><var>flags</var>: must be zero
</p>
<p>Sends a fresh session ticket to the peer. This is relevant only
in server side under TLS1.3. This function may also return <code>GNUTLS_E_AGAIN</code> 
or <code>GNUTLS_E_INTERRUPTED</code>  and in that case it must be called again.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, or a negative error code.
</p></dd></dl>

<span id="gnutls_005fset_005fdefault_005fpriority-1"></span><h4 class="subheading">gnutls_set_default_priority</h4>
<span id="gnutls_005fset_005fdefault_005fpriority"></span><dl>
<dt id="index-gnutls_005fset_005fdefault_005fpriority">Function: <em>int</em> <strong>gnutls_set_default_priority</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Sets the default priority on the ciphers, key exchange methods,
and macs. This is the recommended method of
setting the defaults, in order to promote consistency between applications
using GnuTLS, and to allow GnuTLS using applications to update settings
in par with the library. For client applications which require
maximum compatibility consider calling <code>gnutls_session_enable_compatibility_mode()</code> 
after this function.
</p>
<p>For an application to specify additional options to priority string
consider using <code>gnutls_set_default_priority_append()</code> .
</p>
<p>To allow a user to override the defaults (e.g., when a user interface
or configuration file is available), the functions
<code>gnutls_priority_set_direct()</code>  or <code>gnutls_priority_set()</code>  can
be used.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, or an error code.
</p>
<p><strong>Since:</strong> 2.1.4
</p></dd></dl>

<span id="gnutls_005fset_005fdefault_005fpriority_005fappend-1"></span><h4 class="subheading">gnutls_set_default_priority_append</h4>
<span id="gnutls_005fset_005fdefault_005fpriority_005fappend"></span><dl>
<dt id="index-gnutls_005fset_005fdefault_005fpriority_005fappend">Function: <em>int</em> <strong>gnutls_set_default_priority_append</strong> <em>(gnutls_session_t <var>session</var>, const char * <var>add_prio</var>, const char ** <var>err_pos</var>, unsigned <var>flags</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>add_prio</var>: is a string describing priorities to be appended to default
</p>
<p><var>err_pos</var>: In case of an error this will have the position in the string the error occurred
</p>
<p><var>flags</var>: must be zero
</p>
<p>Sets the default priority on the ciphers, key exchange methods,
and macs with the additional options in  <code>add_prio</code> . This is the recommended method of
setting the defaults when only few additional options are to be added. This promotes
consistency between applications using GnuTLS, and allows GnuTLS using applications
to update settings in par with the library.
</p>
<p>The  <code>add_prio</code> string should start as a normal priority string, e.g.,
&rsquo;-VERS-TLS-ALL:+VERS-TLS1.3:%COMPAT&rsquo; or &rsquo;%FORCE_ETM&rsquo;. That is, it must not start
with &rsquo;:&rsquo;.
</p>
<p>To allow a user to override the defaults (e.g., when a user interface
or configuration file is available), the functions
<code>gnutls_priority_set_direct()</code>  or <code>gnutls_priority_set()</code>  can
be used.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, or an error code.
</p>
<p><strong>Since:</strong> 3.6.3
</p></dd></dl>

<span id="gnutls_005fsign_005falgorithm_005fget-1"></span><h4 class="subheading">gnutls_sign_algorithm_get</h4>
<span id="gnutls_005fsign_005falgorithm_005fget"></span><dl>
<dt id="index-gnutls_005fsign_005falgorithm_005fget">Function: <em>int</em> <strong>gnutls_sign_algorithm_get</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Returns the signature algorithm that is (or will be) used in this
session by the server to sign data. This function should be
used only with TLS 1.2 or later.
</p>
<p><strong>Returns:</strong> The sign algorithm or <code>GNUTLS_SIGN_UNKNOWN</code> .
</p>
<p><strong>Since:</strong> 3.1.1
</p></dd></dl>

<span id="gnutls_005fsign_005falgorithm_005fget_005fclient-1"></span><h4 class="subheading">gnutls_sign_algorithm_get_client</h4>
<span id="gnutls_005fsign_005falgorithm_005fget_005fclient"></span><dl>
<dt id="index-gnutls_005fsign_005falgorithm_005fget_005fclient">Function: <em>int</em> <strong>gnutls_sign_algorithm_get_client</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Returns the signature algorithm that is (or will be) used in this
session by the client to sign data. This function should be
used only with TLS 1.2 or later.
</p>
<p><strong>Returns:</strong> The sign algorithm or <code>GNUTLS_SIGN_UNKNOWN</code> .
</p>
<p><strong>Since:</strong> 3.1.11
</p></dd></dl>

<span id="gnutls_005fsign_005falgorithm_005fget_005frequested-1"></span><h4 class="subheading">gnutls_sign_algorithm_get_requested</h4>
<span id="gnutls_005fsign_005falgorithm_005fget_005frequested"></span><dl>
<dt id="index-gnutls_005fsign_005falgorithm_005fget_005frequested">Function: <em>int</em> <strong>gnutls_sign_algorithm_get_requested</strong> <em>(gnutls_session_t <var>session</var>, size_t <var>indx</var>, gnutls_sign_algorithm_t * <var>algo</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>indx</var>: is an index of the signature algorithm to return
</p>
<p><var>algo</var>: the returned certificate type will be stored there
</p>
<p>Returns the signature algorithm specified by index that was
requested by the peer. If the specified index has no data available
this function returns <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> .  If
the negotiated TLS version does not support signature algorithms
then <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  will be returned even
for the first index.  The first index is 0.
</p>
<p>This function is useful in the certificate callback functions
to assist in selecting the correct certificate.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p>
<p><strong>Since:</strong> 2.10.0
</p></dd></dl>

<span id="gnutls_005fsign_005fget_005fhash_005falgorithm-1"></span><h4 class="subheading">gnutls_sign_get_hash_algorithm</h4>
<span id="gnutls_005fsign_005fget_005fhash_005falgorithm"></span><dl>
<dt id="index-gnutls_005fsign_005fget_005fhash_005falgorithm">Function: <em>gnutls_digest_algorithm_t</em> <strong>gnutls_sign_get_hash_algorithm</strong> <em>(gnutls_sign_algorithm_t <var>sign</var>)</em></dt>
<dd><p><var>sign</var>: is a signature algorithm
</p>
<p>This function returns the digest algorithm corresponding to
the given signature algorithms.
</p>
<p><strong>Since:</strong> 3.1.1
</p>
<p><strong>Returns:</strong> return a <code>gnutls_digest_algorithm_t</code>  value, or <code>GNUTLS_DIG_UNKNOWN</code>  on error.
</p></dd></dl>

<span id="gnutls_005fsign_005fget_005fid-1"></span><h4 class="subheading">gnutls_sign_get_id</h4>
<span id="gnutls_005fsign_005fget_005fid"></span><dl>
<dt id="index-gnutls_005fsign_005fget_005fid">Function: <em>gnutls_sign_algorithm_t</em> <strong>gnutls_sign_get_id</strong> <em>(const char * <var>name</var>)</em></dt>
<dd><p><var>name</var>: is a sign algorithm name
</p>
<p>The names are compared in a case insensitive way.
</p>
<p><strong>Returns:</strong> return a <code>gnutls_sign_algorithm_t</code>  value corresponding to
the specified algorithm, or <code>GNUTLS_SIGN_UNKNOWN</code>  on error.
</p></dd></dl>

<span id="gnutls_005fsign_005fget_005fname-1"></span><h4 class="subheading">gnutls_sign_get_name</h4>
<span id="gnutls_005fsign_005fget_005fname"></span><dl>
<dt id="index-gnutls_005fsign_005fget_005fname">Function: <em>const char *</em> <strong>gnutls_sign_get_name</strong> <em>(gnutls_sign_algorithm_t <var>algorithm</var>)</em></dt>
<dd><p><var>algorithm</var>: is a sign algorithm
</p>
<p>Convert a <code>gnutls_sign_algorithm_t</code>  value to a string.
</p>
<p><strong>Returns:</strong> a string that contains the name of the specified sign
algorithm, or <code>NULL</code> .
</p></dd></dl>

<span id="gnutls_005fsign_005fget_005foid-1"></span><h4 class="subheading">gnutls_sign_get_oid</h4>
<span id="gnutls_005fsign_005fget_005foid"></span><dl>
<dt id="index-gnutls_005fsign_005fget_005foid">Function: <em>const char *</em> <strong>gnutls_sign_get_oid</strong> <em>(gnutls_sign_algorithm_t <var>sign</var>)</em></dt>
<dd><p><var>sign</var>: is a sign algorithm
</p>
<p>Convert a <code>gnutls_sign_algorithm_t</code>  value to its object identifier.
</p>
<p><strong>Returns:</strong> a string that contains the object identifier of the specified sign
algorithm, or <code>NULL</code> .
</p>
<p><strong>Since:</strong> 3.4.3
</p></dd></dl>

<span id="gnutls_005fsign_005fget_005fpk_005falgorithm-1"></span><h4 class="subheading">gnutls_sign_get_pk_algorithm</h4>
<span id="gnutls_005fsign_005fget_005fpk_005falgorithm"></span><dl>
<dt id="index-gnutls_005fsign_005fget_005fpk_005falgorithm">Function: <em>gnutls_pk_algorithm_t</em> <strong>gnutls_sign_get_pk_algorithm</strong> <em>(gnutls_sign_algorithm_t <var>sign</var>)</em></dt>
<dd><p><var>sign</var>: is a signature algorithm
</p>
<p>This function returns the public key algorithm corresponding to
the given signature algorithms. Note that there may be multiple
public key algorithms supporting a particular signature type;
when dealing with such algorithms use instead <code>gnutls_sign_supports_pk_algorithm()</code> .
</p>
<p><strong>Since:</strong> 3.1.1
</p>
<p><strong>Returns:</strong> return a <code>gnutls_pk_algorithm_t</code>  value, or <code>GNUTLS_PK_UNKNOWN</code>  on error.
</p></dd></dl>

<span id="gnutls_005fsign_005fis_005fsecure-1"></span><h4 class="subheading">gnutls_sign_is_secure</h4>
<span id="gnutls_005fsign_005fis_005fsecure"></span><dl>
<dt id="index-gnutls_005fsign_005fis_005fsecure">Function: <em>unsigned</em> <strong>gnutls_sign_is_secure</strong> <em>(gnutls_sign_algorithm_t <var>algorithm</var>)</em></dt>
<dd><p><var>algorithm</var>: is a sign algorithm
</p>

<p><strong>Returns:</strong> Non-zero if the provided signature algorithm is considered to be secure.
</p></dd></dl>

<span id="gnutls_005fsign_005fis_005fsecure2-1"></span><h4 class="subheading">gnutls_sign_is_secure2</h4>
<span id="gnutls_005fsign_005fis_005fsecure2"></span><dl>
<dt id="index-gnutls_005fsign_005fis_005fsecure2">Function: <em>unsigned</em> <strong>gnutls_sign_is_secure2</strong> <em>(gnutls_sign_algorithm_t <var>algorithm</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>algorithm</var>: is a sign algorithm
</p>
<p><var>flags</var>: zero or <code>GNUTLS_SIGN_FLAG_SECURE_FOR_CERTS</code> 
</p>

<p><strong>Returns:</strong> Non-zero if the provided signature algorithm is considered to be secure.
</p></dd></dl>

<span id="gnutls_005fsign_005flist-1"></span><h4 class="subheading">gnutls_sign_list</h4>
<span id="gnutls_005fsign_005flist"></span><dl>
<dt id="index-gnutls_005fsign_005flist">Function: <em>const gnutls_sign_algorithm_t *</em> <strong>gnutls_sign_list</strong> <em>( <var>void</var>)</em></dt>
<dd>
<p>Get a list of supported public key signature algorithms.
This function is not thread safe.
</p>
<p><strong>Returns:</strong> a (0)-terminated list of <code>gnutls_sign_algorithm_t</code> 
integers indicating the available ciphers.
</p></dd></dl>

<span id="gnutls_005fsign_005fsupports_005fpk_005falgorithm-1"></span><h4 class="subheading">gnutls_sign_supports_pk_algorithm</h4>
<span id="gnutls_005fsign_005fsupports_005fpk_005falgorithm"></span><dl>
<dt id="index-gnutls_005fsign_005fsupports_005fpk_005falgorithm">Function: <em>unsigned</em> <strong>gnutls_sign_supports_pk_algorithm</strong> <em>(gnutls_sign_algorithm_t <var>sign</var>, gnutls_pk_algorithm_t <var>pk</var>)</em></dt>
<dd><p><var>sign</var>: is a signature algorithm
</p>
<p><var>pk</var>: is a public key algorithm
</p>
<p>This function returns non-zero if the public key algorithm corresponds to
the given signature algorithm. That is, if that signature can be generated
from the given private key algorithm.
</p>
<p><strong>Since:</strong> 3.6.0
</p>
<p><strong>Returns:</strong> return non-zero when the provided algorithms are compatible.
</p></dd></dl>

<span id="gnutls_005fsrp_005fallocate_005fclient_005fcredentials-1"></span><h4 class="subheading">gnutls_srp_allocate_client_credentials</h4>
<span id="gnutls_005fsrp_005fallocate_005fclient_005fcredentials"></span><dl>
<dt id="index-gnutls_005fsrp_005fallocate_005fclient_005fcredentials">Function: <em>int</em> <strong>gnutls_srp_allocate_client_credentials</strong> <em>(gnutls_srp_client_credentials_t *            <var>sc</var>)</em></dt>
<dd><p><var>sc</var>: is a pointer to a <code>gnutls_srp_server_credentials_t</code>  type.
</p>
<p>Allocate a gnutls_srp_client_credentials_t structure.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, or an
error code.
</p></dd></dl>

<span id="gnutls_005fsrp_005fallocate_005fserver_005fcredentials-1"></span><h4 class="subheading">gnutls_srp_allocate_server_credentials</h4>
<span id="gnutls_005fsrp_005fallocate_005fserver_005fcredentials"></span><dl>
<dt id="index-gnutls_005fsrp_005fallocate_005fserver_005fcredentials">Function: <em>int</em> <strong>gnutls_srp_allocate_server_credentials</strong> <em>(gnutls_srp_server_credentials_t *            <var>sc</var>)</em></dt>
<dd><p><var>sc</var>: is a pointer to a <code>gnutls_srp_server_credentials_t</code>  type.
</p>
<p>Allocate a gnutls_srp_server_credentials_t structure.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, or an
error code.
</p></dd></dl>

<span id="gnutls_005fsrp_005fbase64_005fdecode-1"></span><h4 class="subheading">gnutls_srp_base64_decode</h4>
<span id="gnutls_005fsrp_005fbase64_005fdecode"></span><dl>
<dt id="index-gnutls_005fsrp_005fbase64_005fdecode">Function: <em>int</em> <strong>gnutls_srp_base64_decode</strong> <em>(const gnutls_datum_t * <var>b64_data</var>, char * <var>result</var>, size_t * <var>result_size</var>)</em></dt>
<dd><p><var>b64_data</var>: contain the encoded data
</p>
<p><var>result</var>: the place where decoded data will be copied
</p>
<p><var>result_size</var>: holds the size of the result
</p>
<p>This function will decode the given encoded data, using the base64
encoding found in libsrp.
</p>
<p>Note that  <code>b64_data</code> should be null terminated.
</p>
<p>Warning!  This base64 encoding is not the &quot;standard&quot; encoding, so
do not use it for non-SRP purposes.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if the buffer given is not
long enough, or 0 on success.
</p></dd></dl>

<span id="gnutls_005fsrp_005fbase64_005fdecode2-1"></span><h4 class="subheading">gnutls_srp_base64_decode2</h4>
<span id="gnutls_005fsrp_005fbase64_005fdecode2"></span><dl>
<dt id="index-gnutls_005fsrp_005fbase64_005fdecode2">Function: <em>int</em> <strong>gnutls_srp_base64_decode2</strong> <em>(const gnutls_datum_t * <var>b64_data</var>, gnutls_datum_t * <var>result</var>)</em></dt>
<dd><p><var>b64_data</var>: contains the encoded data
</p>
<p><var>result</var>: the place where decoded data lie
</p>
<p>This function will decode the given encoded data. The decoded data
will be allocated, and stored into result.  It will decode using
the base64 algorithm as used in libsrp.
</p>
<p>You should use <code>gnutls_free()</code>  to free the returned data.
</p>
<p>Warning!  This base64 encoding is not the &quot;standard&quot; encoding, so
do not use it for non-SRP purposes.
</p>
<p><strong>Returns:</strong> 0 on success, or an error code.
</p></dd></dl>

<span id="gnutls_005fsrp_005fbase64_005fencode-1"></span><h4 class="subheading">gnutls_srp_base64_encode</h4>
<span id="gnutls_005fsrp_005fbase64_005fencode"></span><dl>
<dt id="index-gnutls_005fsrp_005fbase64_005fencode">Function: <em>int</em> <strong>gnutls_srp_base64_encode</strong> <em>(const gnutls_datum_t * <var>data</var>, char * <var>result</var>, size_t * <var>result_size</var>)</em></dt>
<dd><p><var>data</var>: contain the raw data
</p>
<p><var>result</var>: the place where base64 data will be copied
</p>
<p><var>result_size</var>: holds the size of the result
</p>
<p>This function will convert the given data to printable data, using
the base64 encoding, as used in the libsrp.  This is the encoding
used in SRP password files.  If the provided buffer is not long
enough GNUTLS_E_SHORT_MEMORY_BUFFER is returned.
</p>
<p>Warning!  This base64 encoding is not the &quot;standard&quot; encoding, so
do not use it for non-SRP purposes.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if the buffer given is not
long enough, or 0 on success.
</p></dd></dl>

<span id="gnutls_005fsrp_005fbase64_005fencode2-1"></span><h4 class="subheading">gnutls_srp_base64_encode2</h4>
<span id="gnutls_005fsrp_005fbase64_005fencode2"></span><dl>
<dt id="index-gnutls_005fsrp_005fbase64_005fencode2">Function: <em>int</em> <strong>gnutls_srp_base64_encode2</strong> <em>(const gnutls_datum_t * <var>data</var>, gnutls_datum_t * <var>result</var>)</em></dt>
<dd><p><var>data</var>: contains the raw data
</p>
<p><var>result</var>: will hold the newly allocated encoded data
</p>
<p>This function will convert the given data to printable data, using
the base64 encoding.  This is the encoding used in SRP password
files.  This function will allocate the required memory to hold
the encoded data.
</p>
<p>You should use <code>gnutls_free()</code>  to free the returned data.
</p>
<p>Warning!  This base64 encoding is not the &quot;standard&quot; encoding, so
do not use it for non-SRP purposes.
</p>
<p><strong>Returns:</strong> 0 on success, or an error code.
</p></dd></dl>

<span id="gnutls_005fsrp_005ffree_005fclient_005fcredentials-1"></span><h4 class="subheading">gnutls_srp_free_client_credentials</h4>
<span id="gnutls_005fsrp_005ffree_005fclient_005fcredentials"></span><dl>
<dt id="index-gnutls_005fsrp_005ffree_005fclient_005fcredentials">Function: <em>void</em> <strong>gnutls_srp_free_client_credentials</strong> <em>(gnutls_srp_client_credentials_t <var>sc</var>)</em></dt>
<dd><p><var>sc</var>: is a <code>gnutls_srp_client_credentials_t</code>  type.
</p>
<p>Free a gnutls_srp_client_credentials_t structure.
</p></dd></dl>

<span id="gnutls_005fsrp_005ffree_005fserver_005fcredentials-1"></span><h4 class="subheading">gnutls_srp_free_server_credentials</h4>
<span id="gnutls_005fsrp_005ffree_005fserver_005fcredentials"></span><dl>
<dt id="index-gnutls_005fsrp_005ffree_005fserver_005fcredentials">Function: <em>void</em> <strong>gnutls_srp_free_server_credentials</strong> <em>(gnutls_srp_server_credentials_t <var>sc</var>)</em></dt>
<dd><p><var>sc</var>: is a <code>gnutls_srp_server_credentials_t</code>  type.
</p>
<p>Free a gnutls_srp_server_credentials_t structure.
</p></dd></dl>

<span id="gnutls_005fsrp_005fserver_005fget_005fusername-1"></span><h4 class="subheading">gnutls_srp_server_get_username</h4>
<span id="gnutls_005fsrp_005fserver_005fget_005fusername"></span><dl>
<dt id="index-gnutls_005fsrp_005fserver_005fget_005fusername">Function: <em>const char *</em> <strong>gnutls_srp_server_get_username</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a gnutls session
</p>
<p>This function will return the username of the peer.  This should
only be called in case of SRP authentication and in case of a
server.  Returns NULL in case of an error.
</p>
<p><strong>Returns:</strong> SRP username of the peer, or NULL in case of error.
</p></dd></dl>

<span id="gnutls_005fsrp_005fset_005fclient_005fcredentials-1"></span><h4 class="subheading">gnutls_srp_set_client_credentials</h4>
<span id="gnutls_005fsrp_005fset_005fclient_005fcredentials"></span><dl>
<dt id="index-gnutls_005fsrp_005fset_005fclient_005fcredentials">Function: <em>int</em> <strong>gnutls_srp_set_client_credentials</strong> <em>(gnutls_srp_client_credentials_t <var>res</var>, const char * <var>username</var>, const char * <var>password</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_srp_client_credentials_t</code>  type.
</p>
<p><var>username</var>: is the user&rsquo;s userid
</p>
<p><var>password</var>: is the user&rsquo;s password
</p>
<p>This function sets the username and password, in a
<code>gnutls_srp_client_credentials_t</code>  type.  Those will be used in
SRP authentication.   <code>username</code> should be an ASCII string or UTF-8
string. In case of a UTF-8 string it is recommended to be following
the PRECIS framework for usernames (rfc8265). The password can
be in ASCII format, or normalized using <code>gnutls_utf8_password_normalize()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, or an
error code.
</p></dd></dl>

<span id="gnutls_005fsrp_005fset_005fclient_005fcredentials_005ffunction-1"></span><h4 class="subheading">gnutls_srp_set_client_credentials_function</h4>
<span id="gnutls_005fsrp_005fset_005fclient_005fcredentials_005ffunction"></span><dl>
<dt id="index-gnutls_005fsrp_005fset_005fclient_005fcredentials_005ffunction-1">Function: <em>void</em> <strong>gnutls_srp_set_client_credentials_function</strong> <em>(gnutls_srp_client_credentials_t         <var>cred</var>, gnutls_srp_client_credentials_function         * <var>func</var>)</em></dt>
<dd><p><var>cred</var>: is a <code>gnutls_srp_server_credentials_t</code>  type.
</p>
<p><var>func</var>: is the callback function
</p>
<p>This function can be used to set a callback to retrieve the
username and password for client SRP authentication.  The
callback&rsquo;s function form is:
</p>
<p>int (*callback)(gnutls_session_t, char** username, char**password);
</p>
<p>The  <code>username</code> and  <code>password</code> must be allocated using
<code>gnutls_malloc()</code> .
</p>
<p>The  <code>username</code> should be an ASCII string or UTF-8
string. In case of a UTF-8 string it is recommended to be following
the PRECIS framework for usernames (rfc8265). The password can
be in ASCII format, or normalized using <code>gnutls_utf8_password_normalize()</code> .
</p>
<p>The callback function will be called once per handshake before the
initial hello message is sent.
</p>
<p>The callback should not return a negative error code the second
time called, since the handshake procedure will be aborted.
</p>
<p>The callback function should return 0 on success.
-1 indicates an error.
</p></dd></dl>

<span id="gnutls_005fsrp_005fset_005fprime_005fbits-1"></span><h4 class="subheading">gnutls_srp_set_prime_bits</h4>
<span id="gnutls_005fsrp_005fset_005fprime_005fbits"></span><dl>
<dt id="index-gnutls_005fsrp_005fset_005fprime_005fbits">Function: <em>void</em> <strong>gnutls_srp_set_prime_bits</strong> <em>(gnutls_session_t <var>session</var>, unsigned int <var>bits</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>bits</var>: is the number of bits
</p>
<p>This function sets the minimum accepted number of bits, for use in
an SRP key exchange.  If zero, the default 2048 bits will be used.
</p>
<p>In the client side it sets the minimum accepted number of bits.  If
a server sends a prime with less bits than that
<code>GNUTLS_E_RECEIVED_ILLEGAL_PARAMETER</code>  will be returned by the
handshake.
</p>
<p>This function has no effect in server side.
</p>
<p><strong>Since:</strong> 2.6.0
</p></dd></dl>

<span id="gnutls_005fsrp_005fset_005fserver_005fcredentials_005ffile-1"></span><h4 class="subheading">gnutls_srp_set_server_credentials_file</h4>
<span id="gnutls_005fsrp_005fset_005fserver_005fcredentials_005ffile"></span><dl>
<dt id="index-gnutls_005fsrp_005fset_005fserver_005fcredentials_005ffile-1">Function: <em>int</em> <strong>gnutls_srp_set_server_credentials_file</strong> <em>(gnutls_srp_server_credentials_t <var>res</var>, const char * <var>password_file</var>, const char * <var>password_conf_file</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_srp_server_credentials_t</code>  type.
</p>
<p><var>password_file</var>: is the SRP password file (tpasswd)
</p>
<p><var>password_conf_file</var>: is the SRP password conf file (tpasswd.conf)
</p>
<p>This function sets the password files, in a
<code>gnutls_srp_server_credentials_t</code>  type.  Those password files
hold usernames and verifiers and will be used for SRP
authentication.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, or an
error code.
</p></dd></dl>

<span id="gnutls_005fsrp_005fset_005fserver_005fcredentials_005ffunction-1"></span><h4 class="subheading">gnutls_srp_set_server_credentials_function</h4>
<span id="gnutls_005fsrp_005fset_005fserver_005fcredentials_005ffunction"></span><dl>
<dt id="index-gnutls_005fsrp_005fset_005fserver_005fcredentials_005ffunction-1">Function: <em>void</em> <strong>gnutls_srp_set_server_credentials_function</strong> <em>(gnutls_srp_server_credentials_t         <var>cred</var>, gnutls_srp_server_credentials_function         * <var>func</var>)</em></dt>
<dd><p><var>cred</var>: is a <code>gnutls_srp_server_credentials_t</code>  type.
</p>
<p><var>func</var>: is the callback function
</p>
<p>This function can be used to set a callback to retrieve the user&rsquo;s
SRP credentials.  The callback&rsquo;s function form is:
</p>
<p>int (*callback)(gnutls_session_t, const char* username,
gnutls_datum_t *salt, gnutls_datum_t *verifier, gnutls_datum_t *generator,
gnutls_datum_t *prime);
</p>
<p><code>username</code> contains the actual username.
The  <code>salt</code> ,  <code>verifier</code> ,  <code>generator</code> and  <code>prime</code> must be filled
in using the <code>gnutls_malloc()</code> . For convenience  <code>prime</code> and  <code>generator</code> may also be one of the static parameters defined in gnutls.h.
</p>
<p>Initially, the data field is NULL in every <code>gnutls_datum_t</code> 
structure that the callback has to fill in. When the
callback is done GnuTLS deallocates all of those buffers
which are non-NULL, regardless of the return value.
</p>
<p>In order to prevent attackers from guessing valid usernames,
if a user does not exist, g and n values should be filled in
using a random user&rsquo;s parameters. In that case the callback must
return the special value (1).
See <code>gnutls_srp_set_server_fake_salt_seed</code>  too.
If this is not required for your application, return a negative
number from the callback to abort the handshake.
</p>
<p>The callback function will only be called once per handshake.
The callback function should return 0 on success, while
-1 indicates an error.
</p></dd></dl>

<span id="gnutls_005fsrp_005fset_005fserver_005ffake_005fsalt_005fseed-1"></span><h4 class="subheading">gnutls_srp_set_server_fake_salt_seed</h4>
<span id="gnutls_005fsrp_005fset_005fserver_005ffake_005fsalt_005fseed"></span><dl>
<dt id="index-gnutls_005fsrp_005fset_005fserver_005ffake_005fsalt_005fseed">Function: <em>void</em> <strong>gnutls_srp_set_server_fake_salt_seed</strong> <em>(gnutls_srp_server_credentials_t <var>cred</var>, const gnutls_datum_t * <var>seed</var>, unsigned int <var>salt_length</var>)</em></dt>
<dd><p><var>cred</var>: is a <code>gnutls_srp_server_credentials_t</code>  type
</p>
<p><var>seed</var>: is the seed data, only needs to be valid until the function
returns; size of the seed must be greater than zero
</p>
<p><var>salt_length</var>: is the length of the generated fake salts
</p>
<p>This function sets the seed that is used to generate salts for
invalid (non-existent) usernames.
</p>
<p>In order to prevent attackers from guessing valid usernames,
when a user does not exist gnutls generates a salt and a verifier
and proceeds with the protocol as usual.
The authentication will ultimately fail, but the client cannot tell
whether the username is valid (exists) or invalid.
</p>
<p>If an attacker learns the seed, given a salt (which is part of the
handshake) which was generated when the seed was in use, it can tell
whether or not the authentication failed because of an unknown username.
This seed cannot be used to reveal application data or passwords.
</p>
<p><code>salt_length</code> should represent the salt length your application uses.
Generating fake salts longer than 20 bytes is not supported.
</p>
<p>By default the seed is a random value, different each time a
<code>gnutls_srp_server_credentials_t</code>  is allocated and fake salts are
16 bytes long.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fsrp_005fverifier-1"></span><h4 class="subheading">gnutls_srp_verifier</h4>
<span id="gnutls_005fsrp_005fverifier"></span><dl>
<dt id="index-gnutls_005fsrp_005fverifier-1">Function: <em>int</em> <strong>gnutls_srp_verifier</strong> <em>(const char * <var>username</var>, const char * <var>password</var>, const gnutls_datum_t * <var>salt</var>, const gnutls_datum_t * <var>generator</var>, const gnutls_datum_t * <var>prime</var>, gnutls_datum_t * <var>res</var>)</em></dt>
<dd><p><var>username</var>: is the user&rsquo;s name
</p>
<p><var>password</var>: is the user&rsquo;s password
</p>
<p><var>salt</var>: should be some randomly generated bytes
</p>
<p><var>generator</var>: is the generator of the group
</p>
<p><var>prime</var>: is the group&rsquo;s prime
</p>
<p><var>res</var>: where the verifier will be stored.
</p>
<p>This function will create an SRP verifier, as specified in
RFC2945.  The  <code>prime</code> and  <code>generator</code> should be one of the static
parameters defined in gnutls/gnutls.h or may be generated.
</p>
<p>The verifier will be allocated with  <code>gnutls_malloc</code> () and will be stored in
 <code>res</code> using binary format.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, or an
error code.
</p></dd></dl>

<span id="gnutls_005fsrtp_005fget_005fkeys-1"></span><h4 class="subheading">gnutls_srtp_get_keys</h4>
<span id="gnutls_005fsrtp_005fget_005fkeys"></span><dl>
<dt id="index-gnutls_005fsrtp_005fget_005fkeys-1">Function: <em>int</em> <strong>gnutls_srtp_get_keys</strong> <em>(gnutls_session_t <var>session</var>, void * <var>key_material</var>, unsigned int <var>key_material_size</var>, gnutls_datum_t * <var>client_key</var>, gnutls_datum_t * <var>client_salt</var>, gnutls_datum_t * <var>server_key</var>, gnutls_datum_t * <var>server_salt</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>key_material</var>: Space to hold the generated key material
</p>
<p><var>key_material_size</var>: The maximum size of the key material
</p>
<p><var>client_key</var>: The master client write key, pointing inside the key material
</p>
<p><var>client_salt</var>: The master client write salt, pointing inside the key material
</p>
<p><var>server_key</var>: The master server write key, pointing inside the key material
</p>
<p><var>server_salt</var>: The master server write salt, pointing inside the key material
</p>
<p>This is a helper function to generate the keying material for SRTP.
It requires the space of the key material to be pre-allocated (should be at least
2x the maximum key size and salt size). The  <code>client_key</code> ,  <code>client_salt</code> ,  <code>server_key</code> and  <code>server_salt</code> are convenience datums that point inside the key material. They may
be <code>NULL</code> .
</p>
<p><strong>Returns:</strong> On success the size of the key material is returned,
otherwise, <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if the buffer given is not 
sufficient, or a negative error code.
</p>
<p>Since 3.1.4
</p></dd></dl>

<span id="gnutls_005fsrtp_005fget_005fmki-1"></span><h4 class="subheading">gnutls_srtp_get_mki</h4>
<span id="gnutls_005fsrtp_005fget_005fmki"></span><dl>
<dt id="index-gnutls_005fsrtp_005fget_005fmki">Function: <em>int</em> <strong>gnutls_srtp_get_mki</strong> <em>(gnutls_session_t <var>session</var>, gnutls_datum_t * <var>mki</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>mki</var>: will hold the MKI
</p>
<p>This function exports the negotiated Master Key Identifier,
received by the peer if any. The returned value in  <code>mki</code> should be 
treated as constant and valid only during the session&rsquo;s lifetime.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p>
<p>Since 3.1.4
</p></dd></dl>

<span id="gnutls_005fsrtp_005fget_005fprofile_005fid-1"></span><h4 class="subheading">gnutls_srtp_get_profile_id</h4>
<span id="gnutls_005fsrtp_005fget_005fprofile_005fid"></span><dl>
<dt id="index-gnutls_005fsrtp_005fget_005fprofile_005fid">Function: <em>int</em> <strong>gnutls_srtp_get_profile_id</strong> <em>(const char * <var>name</var>, gnutls_srtp_profile_t * <var>profile</var>)</em></dt>
<dd><p><var>name</var>: The name of the profile to look up
</p>
<p><var>profile</var>: Will hold the profile id
</p>
<p>This function allows you to look up a profile based on a string.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p>
<p>Since 3.1.4
</p></dd></dl>

<span id="gnutls_005fsrtp_005fget_005fprofile_005fname-1"></span><h4 class="subheading">gnutls_srtp_get_profile_name</h4>
<span id="gnutls_005fsrtp_005fget_005fprofile_005fname"></span><dl>
<dt id="index-gnutls_005fsrtp_005fget_005fprofile_005fname">Function: <em>const char *</em> <strong>gnutls_srtp_get_profile_name</strong> <em>(gnutls_srtp_profile_t <var>profile</var>)</em></dt>
<dd><p><var>profile</var>: The profile to look up a string for
</p>
<p>This function allows you to get the corresponding name for a
SRTP protection profile.
</p>
<p><strong>Returns:</strong> On success, the name of a SRTP profile as a string,
otherwise NULL.
</p>
<p>Since 3.1.4
</p></dd></dl>

<span id="gnutls_005fsrtp_005fget_005fselected_005fprofile-1"></span><h4 class="subheading">gnutls_srtp_get_selected_profile</h4>
<span id="gnutls_005fsrtp_005fget_005fselected_005fprofile"></span><dl>
<dt id="index-gnutls_005fsrtp_005fget_005fselected_005fprofile">Function: <em>int</em> <strong>gnutls_srtp_get_selected_profile</strong> <em>(gnutls_session_t <var>session</var>, gnutls_srtp_profile_t * <var>profile</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>profile</var>: will hold the profile
</p>
<p>This function allows you to get the negotiated SRTP profile.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p>
<p>Since 3.1.4
</p></dd></dl>

<span id="gnutls_005fsrtp_005fset_005fmki-1"></span><h4 class="subheading">gnutls_srtp_set_mki</h4>
<span id="gnutls_005fsrtp_005fset_005fmki"></span><dl>
<dt id="index-gnutls_005fsrtp_005fset_005fmki">Function: <em>int</em> <strong>gnutls_srtp_set_mki</strong> <em>(gnutls_session_t <var>session</var>, const gnutls_datum_t * <var>mki</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>mki</var>: holds the MKI
</p>
<p>This function sets the Master Key Identifier, to be
used by this session (if any).
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p>
<p>Since 3.1.4
</p></dd></dl>

<span id="gnutls_005fsrtp_005fset_005fprofile-1"></span><h4 class="subheading">gnutls_srtp_set_profile</h4>
<span id="gnutls_005fsrtp_005fset_005fprofile"></span><dl>
<dt id="index-gnutls_005fsrtp_005fset_005fprofile">Function: <em>int</em> <strong>gnutls_srtp_set_profile</strong> <em>(gnutls_session_t <var>session</var>, gnutls_srtp_profile_t <var>profile</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>profile</var>: is the profile id to add.
</p>
<p>This function is to be used by both clients and servers, to declare
what SRTP profiles they support, to negotiate with the peer.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p>
<p>Since 3.1.4
</p></dd></dl>

<span id="gnutls_005fsrtp_005fset_005fprofile_005fdirect-1"></span><h4 class="subheading">gnutls_srtp_set_profile_direct</h4>
<span id="gnutls_005fsrtp_005fset_005fprofile_005fdirect"></span><dl>
<dt id="index-gnutls_005fsrtp_005fset_005fprofile_005fdirect">Function: <em>int</em> <strong>gnutls_srtp_set_profile_direct</strong> <em>(gnutls_session_t <var>session</var>, const char * <var>profiles</var>, const char ** <var>err_pos</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>profiles</var>: is a string that contains the supported SRTP profiles,
separated by colons.
</p>
<p><var>err_pos</var>: In case of an error this will have the position in the string the error occurred, may be NULL.
</p>
<p>This function is to be used by both clients and servers, to declare
what SRTP profiles they support, to negotiate with the peer.
</p>
<p><strong>Returns:</strong> On syntax error <code>GNUTLS_E_INVALID_REQUEST</code>  is returned,
<code>GNUTLS_E_SUCCESS</code>  on success, or an error code.
</p>
<p>Since 3.1.4
</p></dd></dl>

<span id="gnutls_005fstore_005fcommitment-1"></span><h4 class="subheading">gnutls_store_commitment</h4>
<span id="gnutls_005fstore_005fcommitment"></span><dl>
<dt id="index-gnutls_005fstore_005fcommitment-1">Function: <em>int</em> <strong>gnutls_store_commitment</strong> <em>(const char * <var>db_name</var>, gnutls_tdb_t <var>tdb</var>, const char * <var>host</var>, const char * <var>service</var>, gnutls_digest_algorithm_t <var>hash_algo</var>, const gnutls_datum_t * <var>hash</var>, time_t <var>expiration</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>db_name</var>: A file specifying the stored keys (use NULL for the default)
</p>
<p><var>tdb</var>: A storage structure or NULL to use the default
</p>
<p><var>host</var>: The peer&rsquo;s name
</p>
<p><var>service</var>: non-NULL if this key is specific to a service (e.g. http)
</p>
<p><var>hash_algo</var>: The hash algorithm type
</p>
<p><var>hash</var>: The raw hash
</p>
<p><var>expiration</var>: The expiration time (use 0 to disable expiration)
</p>
<p><var>flags</var>: should be 0 or <code>GNUTLS_SCOMMIT_FLAG_ALLOW_BROKEN</code> .
</p>
<p>This function will store the provided hash commitment to
the list of stored public keys. The key with the given
hash will be considered valid until the provided expiration time.
</p>
<p>The  <code>tdb</code> variable if non-null specifies a custom backend for
the storage of entries. If it is NULL then the
default file backend will be used.
</p>
<p>Note that this function is not thread safe with the default backend.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fstore_005fpubkey-1"></span><h4 class="subheading">gnutls_store_pubkey</h4>
<span id="gnutls_005fstore_005fpubkey"></span><dl>
<dt id="index-gnutls_005fstore_005fpubkey-1">Function: <em>int</em> <strong>gnutls_store_pubkey</strong> <em>(const char * <var>db_name</var>, gnutls_tdb_t <var>tdb</var>, const char * <var>host</var>, const char * <var>service</var>, gnutls_certificate_type_t <var>cert_type</var>, const gnutls_datum_t * <var>cert</var>, time_t <var>expiration</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>db_name</var>: A file specifying the stored keys (use NULL for the default)
</p>
<p><var>tdb</var>: A storage structure or NULL to use the default
</p>
<p><var>host</var>: The peer&rsquo;s name
</p>
<p><var>service</var>: non-NULL if this key is specific to a service (e.g. http)
</p>
<p><var>cert_type</var>: The type of the certificate
</p>
<p><var>cert</var>: The data of the certificate
</p>
<p><var>expiration</var>: The expiration time (use 0 to disable expiration)
</p>
<p><var>flags</var>: should be 0.
</p>
<p>This function will store a raw public-key or a public-key provided via
a raw (DER-encoded) certificate to the list of stored public keys. The key
will be considered valid until the provided expiration time.
</p>
<p>The  <code>tdb</code> variable if non-null specifies a custom backend for
the storage of entries. If it is NULL then the
default file backend will be used.
</p>
<p>Unless an alternative  <code>tdb</code> is provided, the storage format is a textual format
consisting of a line for each host with fields separated by &rsquo;|&rsquo;. The contents of
the fields are a format-identifier which is set to &rsquo;g0&rsquo;, the hostname that the
rest of the data applies to, the numeric port or host name, the expiration
time in seconds since the epoch (0 for no expiration), and a base64
encoding of the raw (DER) public key information (SPKI) of the peer.
</p>
<p>As of GnuTLS 3.6.6 this function also accepts raw public keys.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.0.13
</p></dd></dl>

<span id="gnutls_005fstrerror-1"></span><h4 class="subheading">gnutls_strerror</h4>
<span id="gnutls_005fstrerror"></span><dl>
<dt id="index-gnutls_005fstrerror">Function: <em>const char *</em> <strong>gnutls_strerror</strong> <em>(int <var>error</var>)</em></dt>
<dd><p><var>error</var>: is a GnuTLS error code, a negative error code
</p>
<p>This function is similar to strerror.  The difference is that it
accepts an error number returned by a gnutls function; In case of
an unknown error a descriptive string is sent instead of <code>NULL</code> .
</p>
<p>Error codes are always a negative error code.
</p>
<p><strong>Returns:</strong> A string explaining the GnuTLS error message.
</p></dd></dl>

<span id="gnutls_005fstrerror_005fname-1"></span><h4 class="subheading">gnutls_strerror_name</h4>
<span id="gnutls_005fstrerror_005fname"></span><dl>
<dt id="index-gnutls_005fstrerror_005fname">Function: <em>const char *</em> <strong>gnutls_strerror_name</strong> <em>(int <var>error</var>)</em></dt>
<dd><p><var>error</var>: is an error returned by a gnutls function.
</p>
<p>Return the GnuTLS error code define as a string.  For example,
gnutls_strerror_name (GNUTLS_E_DH_PRIME_UNACCEPTABLE) will return
the string &quot;GNUTLS_E_DH_PRIME_UNACCEPTABLE&quot;.
</p>
<p><strong>Returns:</strong> A string corresponding to the symbol name of the error
code.
</p>
<p><strong>Since:</strong> 2.6.0
</p></dd></dl>

<span id="gnutls_005fsupplemental_005fget_005fname-1"></span><h4 class="subheading">gnutls_supplemental_get_name</h4>
<span id="gnutls_005fsupplemental_005fget_005fname"></span><dl>
<dt id="index-gnutls_005fsupplemental_005fget_005fname">Function: <em>const char     *</em> <strong>gnutls_supplemental_get_name</strong> <em>(gnutls_supplemental_data_format_type_t       <var>type</var>)</em></dt>
<dd><p><var>type</var>: is a supplemental data format type
</p>
<p>Convert a <code>gnutls_supplemental_data_format_type_t</code>  value to a
string.
</p>
<p><strong>Returns:</strong> a string that contains the name of the specified
supplemental data format type, or <code>NULL</code>  for unknown types.
</p></dd></dl>

<span id="gnutls_005fsupplemental_005frecv-1"></span><h4 class="subheading">gnutls_supplemental_recv</h4>
<span id="gnutls_005fsupplemental_005frecv"></span><dl>
<dt id="index-gnutls_005fsupplemental_005frecv">Function: <em>void</em> <strong>gnutls_supplemental_recv</strong> <em>(gnutls_session_t <var>session</var>, unsigned <var>do_recv_supplemental</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>do_recv_supplemental</var>: non-zero in order to expect supplemental data
</p>
<p>This function is to be called by an extension handler to
instruct gnutls to attempt to receive supplemental data
during the handshake process.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fsupplemental_005fregister-1"></span><h4 class="subheading">gnutls_supplemental_register</h4>
<span id="gnutls_005fsupplemental_005fregister"></span><dl>
<dt id="index-gnutls_005fsupplemental_005fregister">Function: <em>int</em> <strong>gnutls_supplemental_register</strong> <em>(const char * <var>name</var>, gnutls_supplemental_data_format_type_t <var>type</var>, gnutls_supp_recv_func <var>recv_func</var>, gnutls_supp_send_func <var>send_func</var>)</em></dt>
<dd><p><var>name</var>: the name of the supplemental data to register
</p>
<p><var>type</var>: the type of the supplemental data format
</p>
<p><var>recv_func</var>: the function to receive the data
</p>
<p><var>send_func</var>: the function to send the data
</p>
<p>This function will register a new supplemental data type (rfc4680).
The registered data will remain until <code>gnutls_global_deinit()</code> 
is called. The provided  <code>type</code> must be an unassigned type in
<code>gnutls_supplemental_data_format_type_t</code> . If the type is already
registered or handled by GnuTLS internally <code>GNUTLS_E_ALREADY_REGISTERED</code> 
will be returned.
</p>
<p>This function is not thread safe. As supplemental data are not defined under
TLS 1.3, this function will disable TLS 1.3 support globally.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fsupplemental_005fsend-1"></span><h4 class="subheading">gnutls_supplemental_send</h4>
<span id="gnutls_005fsupplemental_005fsend"></span><dl>
<dt id="index-gnutls_005fsupplemental_005fsend">Function: <em>void</em> <strong>gnutls_supplemental_send</strong> <em>(gnutls_session_t <var>session</var>, unsigned <var>do_send_supplemental</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>do_send_supplemental</var>: non-zero in order to send supplemental data
</p>
<p>This function is to be called by an extension handler to
instruct gnutls to send supplemental data during the handshake process.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fsystem_005frecv_005ftimeout-1"></span><h4 class="subheading">gnutls_system_recv_timeout</h4>
<span id="gnutls_005fsystem_005frecv_005ftimeout"></span><dl>
<dt id="index-gnutls_005fsystem_005frecv_005ftimeout">Function: <em>int</em> <strong>gnutls_system_recv_timeout</strong> <em>(gnutls_transport_ptr_t <var>ptr</var>, unsigned int <var>ms</var>)</em></dt>
<dd><p><var>ptr</var>: A file descriptor (wrapped in a gnutls_transport_ptr_t pointer)
</p>
<p><var>ms</var>: The number of milliseconds to wait.
</p>
<p>Wait for data to be received from the provided socket ( <code>ptr</code> ) within a
timeout period in milliseconds, using <code>select()</code>  on the provided  <code>ptr</code> .
</p>
<p>This function is provided as a helper for constructing custom
callbacks for <code>gnutls_transport_set_pull_timeout_function()</code> ,
which can be used if you rely on socket file descriptors.
</p>
<p>Returns -1 on error, 0 on timeout, positive value if data are available for reading.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005ftdb_005fdeinit-1"></span><h4 class="subheading">gnutls_tdb_deinit</h4>
<span id="gnutls_005ftdb_005fdeinit"></span><dl>
<dt id="index-gnutls_005ftdb_005fdeinit">Function: <em>void</em> <strong>gnutls_tdb_deinit</strong> <em>(gnutls_tdb_t <var>tdb</var>)</em></dt>
<dd><p><var>tdb</var>: The structure to be deinitialized
</p>
<p>This function will deinitialize a public key trust storage structure.
</p></dd></dl>

<span id="gnutls_005ftdb_005finit-1"></span><h4 class="subheading">gnutls_tdb_init</h4>
<span id="gnutls_005ftdb_005finit"></span><dl>
<dt id="index-gnutls_005ftdb_005finit">Function: <em>int</em> <strong>gnutls_tdb_init</strong> <em>(gnutls_tdb_t * <var>tdb</var>)</em></dt>
<dd><p><var>tdb</var>: A pointer to the type to be initialized
</p>
<p>This function will initialize a public key trust storage structure.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005ftdb_005fset_005fstore_005fcommitment_005ffunc-1"></span><h4 class="subheading">gnutls_tdb_set_store_commitment_func</h4>
<span id="gnutls_005ftdb_005fset_005fstore_005fcommitment_005ffunc"></span><dl>
<dt id="index-gnutls_005ftdb_005fset_005fstore_005fcommitment_005ffunc">Function: <em>void</em> <strong>gnutls_tdb_set_store_commitment_func</strong> <em>(gnutls_tdb_t <var>tdb</var>, gnutls_tdb_store_commitment_func        <var>cstore</var>)</em></dt>
<dd><p><var>tdb</var>: The trust storage
</p>
<p><var>cstore</var>: The commitment storage function
</p>
<p>This function will associate a commitment (hash) storage function with the
trust storage structure. The function is of the following form.
</p>
<p>int gnutls_tdb_store_commitment_func(const char* db_name, const char* host,
const char* service, time_t expiration,
gnutls_digest_algorithm_t, const gnutls_datum_t* hash);
</p>
<p>The  <code>db_name</code> should be used to pass any private data to this function.
</p></dd></dl>

<span id="gnutls_005ftdb_005fset_005fstore_005ffunc-1"></span><h4 class="subheading">gnutls_tdb_set_store_func</h4>
<span id="gnutls_005ftdb_005fset_005fstore_005ffunc"></span><dl>
<dt id="index-gnutls_005ftdb_005fset_005fstore_005ffunc">Function: <em>void</em> <strong>gnutls_tdb_set_store_func</strong> <em>(gnutls_tdb_t <var>tdb</var>, gnutls_tdb_store_func <var>store</var>)</em></dt>
<dd><p><var>tdb</var>: The trust storage
</p>
<p><var>store</var>: The storage function
</p>
<p>This function will associate a storage function with the
trust storage structure. The function is of the following form.
</p>
<p>int gnutls_tdb_store_func(const char* db_name, const char* host,
const char* service, time_t expiration,
const gnutls_datum_t* pubkey);
</p>
<p>The  <code>db_name</code> should be used to pass any private data to this function.
</p></dd></dl>

<span id="gnutls_005ftdb_005fset_005fverify_005ffunc-1"></span><h4 class="subheading">gnutls_tdb_set_verify_func</h4>
<span id="gnutls_005ftdb_005fset_005fverify_005ffunc"></span><dl>
<dt id="index-gnutls_005ftdb_005fset_005fverify_005ffunc">Function: <em>void</em> <strong>gnutls_tdb_set_verify_func</strong> <em>(gnutls_tdb_t <var>tdb</var>, gnutls_tdb_verify_func <var>verify</var>)</em></dt>
<dd><p><var>tdb</var>: The trust storage
</p>
<p><var>verify</var>: The verification function
</p>
<p>This function will associate a retrieval function with the
trust storage structure. The function is of the following form.
</p>
<p>int gnutls_tdb_verify_func(const char* db_name, const char* host,
const char* service, const gnutls_datum_t* pubkey);
</p>
<p>The verify function should return zero on a match, <code>GNUTLS_E_CERTIFICATE_KEY_MISMATCH</code> 
if there is a mismatch and any other negative error code otherwise.
</p>
<p>The  <code>db_name</code> should be used to pass any private data to this function.
</p></dd></dl>

<span id="gnutls_005ftransport_005fget_005fint-1"></span><h4 class="subheading">gnutls_transport_get_int</h4>
<span id="gnutls_005ftransport_005fget_005fint"></span><dl>
<dt id="index-gnutls_005ftransport_005fget_005fint">Function: <em>int</em> <strong>gnutls_transport_get_int</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Used to get the first argument of the transport function (like
PUSH and PULL).  This must have been set using
<code>gnutls_transport_set_int()</code> .
</p>
<p><strong>Returns:</strong> The first argument of the transport function.
</p>
<p><strong>Since:</strong> 3.1.9
</p></dd></dl>

<span id="gnutls_005ftransport_005fget_005fint2-1"></span><h4 class="subheading">gnutls_transport_get_int2</h4>
<span id="gnutls_005ftransport_005fget_005fint2"></span><dl>
<dt id="index-gnutls_005ftransport_005fget_005fint2">Function: <em>void</em> <strong>gnutls_transport_get_int2</strong> <em>(gnutls_session_t <var>session</var>, int * <var>recv_int</var>, int * <var>send_int</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>recv_int</var>: will hold the value for the pull function
</p>
<p><var>send_int</var>: will hold the value for the push function
</p>
<p>Used to get the arguments of the transport functions (like PUSH
and PULL).  These should have been set using
<code>gnutls_transport_set_int2()</code> .
</p>
<p><strong>Since:</strong> 3.1.9
</p></dd></dl>

<span id="gnutls_005ftransport_005fget_005fptr-1"></span><h4 class="subheading">gnutls_transport_get_ptr</h4>
<span id="gnutls_005ftransport_005fget_005fptr"></span><dl>
<dt id="index-gnutls_005ftransport_005fget_005fptr">Function: <em>gnutls_transport_ptr_t</em> <strong>gnutls_transport_get_ptr</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Used to get the first argument of the transport function (like
PUSH and PULL).  This must have been set using
<code>gnutls_transport_set_ptr()</code> .
</p>
<p><strong>Returns:</strong> The first argument of the transport function.
</p></dd></dl>

<span id="gnutls_005ftransport_005fget_005fptr2-1"></span><h4 class="subheading">gnutls_transport_get_ptr2</h4>
<span id="gnutls_005ftransport_005fget_005fptr2"></span><dl>
<dt id="index-gnutls_005ftransport_005fget_005fptr2">Function: <em>void</em> <strong>gnutls_transport_get_ptr2</strong> <em>(gnutls_session_t <var>session</var>, gnutls_transport_ptr_t * <var>recv_ptr</var>, gnutls_transport_ptr_t * <var>send_ptr</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>recv_ptr</var>: will hold the value for the pull function
</p>
<p><var>send_ptr</var>: will hold the value for the push function
</p>
<p>Used to get the arguments of the transport functions (like PUSH
and PULL).  These should have been set using
<code>gnutls_transport_set_ptr2()</code> .
</p></dd></dl>

<span id="gnutls_005ftransport_005fset_005ferrno-1"></span><h4 class="subheading">gnutls_transport_set_errno</h4>
<span id="gnutls_005ftransport_005fset_005ferrno"></span><dl>
<dt id="index-gnutls_005ftransport_005fset_005ferrno-1">Function: <em>void</em> <strong>gnutls_transport_set_errno</strong> <em>(gnutls_session_t <var>session</var>, int <var>err</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>err</var>: error value to store in session-specific errno variable.
</p>
<p>Store  <code>err</code> in the session-specific errno variable.  Useful values
for  <code>err</code> are EINTR, EAGAIN and EMSGSIZE, other values are treated will be
treated as real errors in the push/pull function.
</p>
<p>This function is useful in replacement push and pull functions set by
<code>gnutls_transport_set_push_function()</code>  and
<code>gnutls_transport_set_pull_function()</code>  under Windows, where the
replacements may not have access to the same  <code>errno</code> variable that is used by GnuTLS (e.g., the application is linked to
msvcr71.dll and gnutls is linked to msvcrt.dll).
</p>
<p>This function is unreliable if you are using the same
 <code>session</code> in different threads for sending and receiving.
</p></dd></dl>

<span id="gnutls_005ftransport_005fset_005ferrno_005ffunction-1"></span><h4 class="subheading">gnutls_transport_set_errno_function</h4>
<span id="gnutls_005ftransport_005fset_005ferrno_005ffunction"></span><dl>
<dt id="index-gnutls_005ftransport_005fset_005ferrno_005ffunction">Function: <em>void</em> <strong>gnutls_transport_set_errno_function</strong> <em>(gnutls_session_t <var>session</var>, gnutls_errno_func <var>errno_func</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>errno_func</var>: a callback function similar to <code>write()</code> 
</p>
<p>This is the function where you set a function to retrieve errno
after a failed push or pull operation.
</p>
<p><code>errno_func</code> is of the form,
int (*gnutls_errno_func)(gnutls_transport_ptr_t);
and should return the errno.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005ftransport_005fset_005fint-1"></span><h4 class="subheading">gnutls_transport_set_int</h4>
<span id="gnutls_005ftransport_005fset_005fint"></span><dl>
<dt id="index-gnutls_005ftransport_005fset_005fint">Function: <em>void</em> <strong>gnutls_transport_set_int</strong> <em>(gnutls_session_t <var>session</var>, int <var>fd</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>fd</var>: is the socket descriptor for the connection.
</p>
<p>This function sets the first argument of the transport function, such
as <code>send()</code>  and <code>recv()</code>  for the default callbacks using the
system&rsquo;s socket API.
</p>
<p>This function is equivalent to calling <code>gnutls_transport_set_ptr()</code> 
with the descriptor, but requires no casts.
</p>
<p><strong>Since:</strong> 3.1.9
</p></dd></dl>

<span id="gnutls_005ftransport_005fset_005fint2-1"></span><h4 class="subheading">gnutls_transport_set_int2</h4>
<span id="gnutls_005ftransport_005fset_005fint2"></span><dl>
<dt id="index-gnutls_005ftransport_005fset_005fint2">Function: <em>void</em> <strong>gnutls_transport_set_int2</strong> <em>(gnutls_session_t <var>session</var>, int <var>recv_fd</var>, int <var>send_fd</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>recv_fd</var>: is socket descriptor for the pull function
</p>
<p><var>send_fd</var>: is socket descriptor for the push function
</p>
<p>This function sets the first argument of the transport functions,
such as <code>send()</code>  and <code>recv()</code>  for the default callbacks using the
system&rsquo;s socket API. With this function you can set two different
descriptors for receiving and sending.
</p>
<p>This function is equivalent to calling <code>gnutls_transport_set_ptr2()</code> 
with the descriptors, but requires no casts.
</p>
<p><strong>Since:</strong> 3.1.9
</p></dd></dl>

<span id="gnutls_005ftransport_005fset_005fptr-1"></span><h4 class="subheading">gnutls_transport_set_ptr</h4>
<span id="gnutls_005ftransport_005fset_005fptr"></span><dl>
<dt id="index-gnutls_005ftransport_005fset_005fptr">Function: <em>void</em> <strong>gnutls_transport_set_ptr</strong> <em>(gnutls_session_t <var>session</var>, gnutls_transport_ptr_t <var>ptr</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>ptr</var>: is the value.
</p>
<p>Used to set the first argument of the transport function (for push
and pull callbacks). In berkeley style sockets this function will set the
connection descriptor.
</p></dd></dl>

<span id="gnutls_005ftransport_005fset_005fptr2-1"></span><h4 class="subheading">gnutls_transport_set_ptr2</h4>
<span id="gnutls_005ftransport_005fset_005fptr2"></span><dl>
<dt id="index-gnutls_005ftransport_005fset_005fptr2">Function: <em>void</em> <strong>gnutls_transport_set_ptr2</strong> <em>(gnutls_session_t <var>session</var>, gnutls_transport_ptr_t <var>recv_ptr</var>, gnutls_transport_ptr_t <var>send_ptr</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>recv_ptr</var>: is the value for the pull function
</p>
<p><var>send_ptr</var>: is the value for the push function
</p>
<p>Used to set the first argument of the transport function (for push
and pull callbacks). In berkeley style sockets this function will set the
connection descriptor.  With this function you can use two different
pointers for receiving and sending.
</p></dd></dl>

<span id="gnutls_005ftransport_005fset_005fpull_005ffunction-1"></span><h4 class="subheading">gnutls_transport_set_pull_function</h4>
<span id="gnutls_005ftransport_005fset_005fpull_005ffunction"></span><dl>
<dt id="index-gnutls_005ftransport_005fset_005fpull_005ffunction-1">Function: <em>void</em> <strong>gnutls_transport_set_pull_function</strong> <em>(gnutls_session_t <var>session</var>, gnutls_pull_func <var>pull_func</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>pull_func</var>: a callback function similar to <code>read()</code> 
</p>
<p>This is the function where you set a function for gnutls to receive
data.  Normally, if you use berkeley style sockets, do not need to
use this function since the default recv(2) will probably be ok.
The callback should return 0 on connection termination, a positive
number indicating the number of bytes received, and -1 on error.
</p>
<p><code>gnutls_pull_func</code> is of the form,
ssize_t (*gnutls_pull_func)(gnutls_transport_ptr_t, void*, size_t);
</p></dd></dl>

<span id="gnutls_005ftransport_005fset_005fpull_005ftimeout_005ffunction-1"></span><h4 class="subheading">gnutls_transport_set_pull_timeout_function</h4>
<span id="gnutls_005ftransport_005fset_005fpull_005ftimeout_005ffunction"></span><dl>
<dt id="index-gnutls_005ftransport_005fset_005fpull_005ftimeout_005ffunction-2">Function: <em>void</em> <strong>gnutls_transport_set_pull_timeout_function</strong> <em>(gnutls_session_t <var>session</var>, gnutls_pull_timeout_func <var>func</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>func</var>: a callback function
</p>
<p>This is the function where you set a function for gnutls to know
whether data are ready to be received. It should wait for data a
given time frame in milliseconds. The callback should return 0 on 
timeout, a positive number if data can be received, and -1 on error.
You&rsquo;ll need to override this function if <code>select()</code>  is not suitable
for the provided transport calls.
</p>
<p>As with <code>select()</code> , if the timeout value is zero the callback should return
zero if no data are immediately available. The special value
<code>GNUTLS_INDEFINITE_TIMEOUT</code>  indicates that the callback should wait indefinitely
for data.
</p>
<p><code>gnutls_pull_timeout_func</code> is of the form,
int (*gnutls_pull_timeout_func)(gnutls_transport_ptr_t, unsigned int ms);
</p>
<p>This callback is necessary when <code>gnutls_handshake_set_timeout()</code>  or 
<code>gnutls_record_set_timeout()</code>  are set, under TLS1.3 and for enforcing the DTLS
mode timeouts when in blocking mode.
</p>
<p>For compatibility with future GnuTLS versions this callback must be set when
a custom pull function is registered. The callback will not be used when the
session is in TLS mode with non-blocking sockets. That is, when <code>GNUTLS_NONBLOCK</code> 
is specified for a TLS session in <code>gnutls_init()</code> .
</p>
<p>The helper function <code>gnutls_system_recv_timeout()</code>  is provided to
simplify writing callbacks. 
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005ftransport_005fset_005fpush_005ffunction-1"></span><h4 class="subheading">gnutls_transport_set_push_function</h4>
<span id="gnutls_005ftransport_005fset_005fpush_005ffunction"></span><dl>
<dt id="index-gnutls_005ftransport_005fset_005fpush_005ffunction-1">Function: <em>void</em> <strong>gnutls_transport_set_push_function</strong> <em>(gnutls_session_t <var>session</var>, gnutls_push_func <var>push_func</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>push_func</var>: a callback function similar to <code>write()</code> 
</p>
<p>This is the function where you set a push function for gnutls to
use in order to send data.  If you are going to use berkeley style
sockets, you do not need to use this function since the default
send(2) will probably be ok.  Otherwise you should specify this
function for gnutls to be able to send data.
The callback should return a positive number indicating the
bytes sent, and -1 on error.
</p>
<p><code>push_func</code> is of the form,
ssize_t (*gnutls_push_func)(gnutls_transport_ptr_t, const void*, size_t);
</p></dd></dl>

<span id="gnutls_005ftransport_005fset_005fvec_005fpush_005ffunction-1"></span><h4 class="subheading">gnutls_transport_set_vec_push_function</h4>
<span id="gnutls_005ftransport_005fset_005fvec_005fpush_005ffunction"></span><dl>
<dt id="index-gnutls_005ftransport_005fset_005fvec_005fpush_005ffunction-1">Function: <em>void</em> <strong>gnutls_transport_set_vec_push_function</strong> <em>(gnutls_session_t <var>session</var>, gnutls_vec_push_func <var>vec_func</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>vec_func</var>: a callback function similar to <code>writev()</code> 
</p>
<p>Using this function you can override the default writev(2)
function for gnutls to send data. Setting this callback 
instead of <code>gnutls_transport_set_push_function()</code>  is recommended
since it introduces less overhead in the TLS handshake process.
</p>
<p><code>vec_func</code> is of the form,
ssize_t (*gnutls_vec_push_func) (gnutls_transport_ptr_t, const giovec_t * iov, int iovcnt);
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005furl_005fis_005fsupported-1"></span><h4 class="subheading">gnutls_url_is_supported</h4>
<span id="gnutls_005furl_005fis_005fsupported"></span><dl>
<dt id="index-gnutls_005furl_005fis_005fsupported-1">Function: <em>unsigned</em> <strong>gnutls_url_is_supported</strong> <em>(const char * <var>url</var>)</em></dt>
<dd><p><var>url</var>: A URI to be tested
</p>
<p>Check whether the provided  <code>url</code> is supported.  Depending on the system libraries
GnuTLS may support pkcs11, tpmkey or other URLs.
</p>
<p><strong>Returns:</strong> return non-zero if the given URL is supported, and zero if
it is not known.
</p>
<p><strong>Since:</strong> 3.1.0
</p></dd></dl>

<span id="gnutls_005futf8_005fpassword_005fnormalize-1"></span><h4 class="subheading">gnutls_utf8_password_normalize</h4>
<span id="gnutls_005futf8_005fpassword_005fnormalize"></span><dl>
<dt id="index-gnutls_005futf8_005fpassword_005fnormalize">Function: <em>int</em> <strong>gnutls_utf8_password_normalize</strong> <em>(const unsigned char * <var>password</var>, unsigned <var>plen</var>, gnutls_datum_t * <var>out</var>, unsigned <var>flags</var>)</em></dt>
<dd><p><var>password</var>: contain the UTF-8 formatted password
</p>
<p><var>plen</var>: the length of the provided password
</p>
<p><var>out</var>: the result in an null-terminated allocated string
</p>
<p><var>flags</var>: should be zero
</p>
<p>This function will convert the provided UTF-8 password according
to the normalization rules in RFC7613.
</p>
<p>If the flag <code>GNUTLS_UTF8_IGNORE_ERRS</code>  is specified, any UTF-8 encoding
errors will be ignored, and in that case the output will be a copy of the input.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_INVALID_UTF8_STRING</code>  on invalid UTF-8 data, or 0 on success.
</p>
<p><strong>Since:</strong> 3.5.7
</p></dd></dl>

<span id="gnutls_005fverify_005fstored_005fpubkey-1"></span><h4 class="subheading">gnutls_verify_stored_pubkey</h4>
<span id="gnutls_005fverify_005fstored_005fpubkey"></span><dl>
<dt id="index-gnutls_005fverify_005fstored_005fpubkey-1">Function: <em>int</em> <strong>gnutls_verify_stored_pubkey</strong> <em>(const char * <var>db_name</var>, gnutls_tdb_t <var>tdb</var>, const char * <var>host</var>, const char * <var>service</var>, gnutls_certificate_type_t <var>cert_type</var>, const gnutls_datum_t * <var>cert</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>db_name</var>: A file specifying the stored keys (use NULL for the default)
</p>
<p><var>tdb</var>: A storage structure or NULL to use the default
</p>
<p><var>host</var>: The peer&rsquo;s name
</p>
<p><var>service</var>: non-NULL if this key is specific to a service (e.g. http)
</p>
<p><var>cert_type</var>: The type of the certificate
</p>
<p><var>cert</var>: The raw (der) data of the certificate
</p>
<p><var>flags</var>: should be 0.
</p>
<p>This function will try to verify a raw public-key or a public-key provided via
a raw (DER-encoded) certificate using a list of stored public keys.
The  <code>service</code> field if non-NULL should be a port number.
</p>
<p>The  <code>db_name</code> variable if non-null specifies a custom backend for
the retrieval of entries. If it is NULL then the
default file backend will be used. In POSIX-like systems the
file backend uses the $HOME/.gnutls/known_hosts file.
</p>
<p>Note that if the custom storage backend is provided the
retrieval function should return <code>GNUTLS_E_CERTIFICATE_KEY_MISMATCH</code> 
if the host/service pair is found but key doesn&rsquo;t match,
<code>GNUTLS_E_NO_CERTIFICATE_FOUND</code>  if no such host/service with
the given key is found, and 0 if it was found. The storage
function should return 0 on success.
</p>
<p>As of GnuTLS 3.6.6 this function also verifies raw public keys.
</p>
<p><strong>Returns:</strong> If no associated public key is found
then <code>GNUTLS_E_NO_CERTIFICATE_FOUND</code>  will be returned. If a key
is found but does not match <code>GNUTLS_E_CERTIFICATE_KEY_MISMATCH</code> 
is returned. On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
or a negative error value on other errors.
</p>
<p><strong>Since:</strong> 3.0.13
</p></dd></dl>


<hr>
<span id="Datagram-TLS-API"></span><div class="header">
<p>
Next: <a href="#X509-certificate-API" accesskey="n" rel="next">X509 certificate API</a>, Previous: <a href="#Core-TLS-API" accesskey="p" rel="prev">Core TLS API</a>, Up: <a href="#API-reference" accesskey="u" rel="up">API reference</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Datagram-TLS-API-1"></span><h3 class="section">E.2 Datagram TLS API</h3>

<p>The prototypes for the following functions lie in
<samp>gnutls/dtls.h</samp>.
</p>

<span id="gnutls_005fdtls_005fcookie_005fsend-1"></span><h4 class="subheading">gnutls_dtls_cookie_send</h4>
<span id="gnutls_005fdtls_005fcookie_005fsend"></span><dl>
<dt id="index-gnutls_005fdtls_005fcookie_005fsend">Function: <em>int</em> <strong>gnutls_dtls_cookie_send</strong> <em>(gnutls_datum_t * <var>key</var>, void * <var>client_data</var>, size_t <var>client_data_size</var>, gnutls_dtls_prestate_st * <var>prestate</var>, gnutls_transport_ptr_t <var>ptr</var>, gnutls_push_func <var>push_func</var>)</em></dt>
<dd><p><var>key</var>: is a random key to be used at cookie generation
</p>
<p><var>client_data</var>: contains data identifying the client (i.e. address)
</p>
<p><var>client_data_size</var>: The size of client&rsquo;s data
</p>
<p><var>prestate</var>: The previous cookie returned by <code>gnutls_dtls_cookie_verify()</code> 
</p>
<p><var>ptr</var>: A transport pointer to be used by  <code>push_func</code> 
</p>
<p><var>push_func</var>: A function that will be used to reply
</p>
<p>This function can be used to prevent denial of service
attacks to a DTLS server by requiring the client to
reply using a cookie sent by this function. That way
it can be ensured that a client we allocated resources
for (i.e. <code>gnutls_session_t</code> ) is the one that the 
original incoming packet was originated from.
</p>
<p>This function must be called at the first incoming packet,
prior to allocating any resources and must be succeeded
by <code>gnutls_dtls_cookie_verify()</code> .
</p>
<p><strong>Returns:</strong> the number of bytes sent, or a negative error code.  
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fdtls_005fcookie_005fverify-1"></span><h4 class="subheading">gnutls_dtls_cookie_verify</h4>
<span id="gnutls_005fdtls_005fcookie_005fverify"></span><dl>
<dt id="index-gnutls_005fdtls_005fcookie_005fverify">Function: <em>int</em> <strong>gnutls_dtls_cookie_verify</strong> <em>(gnutls_datum_t * <var>key</var>, void * <var>client_data</var>, size_t <var>client_data_size</var>, void * <var>_msg</var>, size_t <var>msg_size</var>, gnutls_dtls_prestate_st * <var>prestate</var>)</em></dt>
<dd><p><var>key</var>: is a random key to be used at cookie generation
</p>
<p><var>client_data</var>: contains data identifying the client (i.e. address)
</p>
<p><var>client_data_size</var>: The size of client&rsquo;s data
</p>
<p><var>_msg</var>: An incoming message that initiates a connection.
</p>
<p><var>msg_size</var>: The size of the message.
</p>
<p><var>prestate</var>: The cookie of this client.
</p>
<p>This function will verify the received message for
a valid cookie. If a valid cookie is returned then
it should be associated with the session using
<code>gnutls_dtls_prestate_set()</code> ;
</p>
<p>This function must be called after <code>gnutls_dtls_cookie_send()</code> .
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  (0) on success, or a negative error code.  
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fdtls_005fget_005fdata_005fmtu-1"></span><h4 class="subheading">gnutls_dtls_get_data_mtu</h4>
<span id="gnutls_005fdtls_005fget_005fdata_005fmtu"></span><dl>
<dt id="index-gnutls_005fdtls_005fget_005fdata_005fmtu">Function: <em>unsigned int</em> <strong>gnutls_dtls_get_data_mtu</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>This function will return the actual maximum transfer unit for
application data. I.e. DTLS headers are subtracted from the
actual MTU which is set using <code>gnutls_dtls_set_mtu()</code> .
</p>
<p><strong>Returns:</strong> the maximum allowed transfer unit.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fdtls_005fget_005fmtu-1"></span><h4 class="subheading">gnutls_dtls_get_mtu</h4>
<span id="gnutls_005fdtls_005fget_005fmtu"></span><dl>
<dt id="index-gnutls_005fdtls_005fget_005fmtu">Function: <em>unsigned int</em> <strong>gnutls_dtls_get_mtu</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>This function will return the MTU size as set with
<code>gnutls_dtls_set_mtu()</code> . This is not the actual MTU
of data you can transmit. Use <code>gnutls_dtls_get_data_mtu()</code> 
for that reason.
</p>
<p><strong>Returns:</strong> the set maximum transfer unit.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fdtls_005fget_005ftimeout-1"></span><h4 class="subheading">gnutls_dtls_get_timeout</h4>
<span id="gnutls_005fdtls_005fget_005ftimeout"></span><dl>
<dt id="index-gnutls_005fdtls_005fget_005ftimeout-1">Function: <em>unsigned int</em> <strong>gnutls_dtls_get_timeout</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>This function will return the milliseconds remaining
for a retransmission of the previously sent handshake
message. This function is useful when DTLS is used in
non-blocking mode, to estimate when to call <code>gnutls_handshake()</code> 
if no packets have been received.
</p>
<p><strong>Returns:</strong> the remaining time in milliseconds.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fdtls_005fprestate_005fset-1"></span><h4 class="subheading">gnutls_dtls_prestate_set</h4>
<span id="gnutls_005fdtls_005fprestate_005fset"></span><dl>
<dt id="index-gnutls_005fdtls_005fprestate_005fset">Function: <em>void</em> <strong>gnutls_dtls_prestate_set</strong> <em>(gnutls_session_t <var>session</var>, gnutls_dtls_prestate_st * <var>prestate</var>)</em></dt>
<dd><p><var>session</var>: a new session
</p>
<p><var>prestate</var>: contains the client&rsquo;s prestate
</p>
<p>This function will associate the prestate acquired by
the cookie authentication with the client, with the newly 
established session.
</p>
<p>This functions must be called after a successful <code>gnutls_dtls_cookie_verify()</code> 
and should be succeeded by the actual DTLS handshake using <code>gnutls_handshake()</code> .
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fdtls_005fset_005fdata_005fmtu-1"></span><h4 class="subheading">gnutls_dtls_set_data_mtu</h4>
<span id="gnutls_005fdtls_005fset_005fdata_005fmtu"></span><dl>
<dt id="index-gnutls_005fdtls_005fset_005fdata_005fmtu">Function: <em>int</em> <strong>gnutls_dtls_set_data_mtu</strong> <em>(gnutls_session_t <var>session</var>, unsigned int <var>mtu</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>mtu</var>: The maximum unencrypted transfer unit of the session
</p>
<p>This function will set the maximum size of the *unencrypted* records
which will be sent over a DTLS session. It is equivalent to calculating
the DTLS packet overhead with the current encryption parameters, and
calling <code>gnutls_dtls_set_mtu()</code>  with that value. In particular, this means
that you may need to call this function again after any negotiation or
renegotiation, in order to ensure that the MTU is still sufficient to
account for the new protocol overhead.
</p>
<p>In most cases you only need to call <code>gnutls_dtls_set_mtu()</code>  with
the maximum MTU of your transport layer.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  (0) on success, or a negative error code.
</p>
<p><strong>Since:</strong> 3.1
</p></dd></dl>

<span id="gnutls_005fdtls_005fset_005fmtu-1"></span><h4 class="subheading">gnutls_dtls_set_mtu</h4>
<span id="gnutls_005fdtls_005fset_005fmtu"></span><dl>
<dt id="index-gnutls_005fdtls_005fset_005fmtu">Function: <em>void</em> <strong>gnutls_dtls_set_mtu</strong> <em>(gnutls_session_t <var>session</var>, unsigned int <var>mtu</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>mtu</var>: The maximum transfer unit of the transport
</p>
<p>This function will set the maximum transfer unit of the transport
that DTLS packets are sent over. Note that this should exclude
the IP (or IPv6) and UDP headers. So for DTLS over IPv6 on an
Ethernet device with MTU 1500, the DTLS MTU set with this function
would be 1500 - 40 (IPV6 header) - 8 (UDP header) = 1452.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fdtls_005fset_005ftimeouts-1"></span><h4 class="subheading">gnutls_dtls_set_timeouts</h4>
<span id="gnutls_005fdtls_005fset_005ftimeouts"></span><dl>
<dt id="index-gnutls_005fdtls_005fset_005ftimeouts">Function: <em>void</em> <strong>gnutls_dtls_set_timeouts</strong> <em>(gnutls_session_t <var>session</var>, unsigned int <var>retrans_timeout</var>, unsigned int <var>total_timeout</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>retrans_timeout</var>: The time at which a retransmission will occur in milliseconds
</p>
<p><var>total_timeout</var>: The time at which the connection will be aborted, in milliseconds.
</p>
<p>This function will set the timeouts required for the DTLS handshake
protocol. The retransmission timeout is the time after which a
message from the peer is not received, the previous messages will
be retransmitted. The total timeout is the time after which the
handshake will be aborted with <code>GNUTLS_E_TIMEDOUT</code> .
</p>
<p>The DTLS protocol recommends the values of 1 sec and 60 seconds
respectively, and these are the default values.
</p>
<p>To disable retransmissions set a  <code>retrans_timeout</code> larger than the  <code>total_timeout</code> .
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005frecord_005fget_005fdiscarded-1"></span><h4 class="subheading">gnutls_record_get_discarded</h4>
<span id="gnutls_005frecord_005fget_005fdiscarded"></span><dl>
<dt id="index-gnutls_005frecord_005fget_005fdiscarded">Function: <em>unsigned int</em> <strong>gnutls_record_get_discarded</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Returns the number of discarded packets in a
DTLS connection.
</p>
<p><strong>Returns:</strong> The number of discarded packets.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>


<hr>
<span id="X509-certificate-API"></span><div class="header">
<p>
Next: <a href="#PKCS-7-API" accesskey="n" rel="next">PKCS 7 API</a>, Previous: <a href="#Datagram-TLS-API" accesskey="p" rel="prev">Datagram TLS API</a>, Up: <a href="#API-reference" accesskey="u" rel="up">API reference</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="X_002e509-certificate-API"></span><h3 class="section">E.3 <acronym>X.509</acronym> certificate API</h3>
<span id="index-X_002e509-Functions"></span>

<p>The following functions are to be used for <acronym>X.509</acronym> certificate handling.
Their prototypes lie in <samp>gnutls/x509.h</samp>.
</p>

<span id="gnutls_005fcertificate_005fget_005ftrust_005flist-1"></span><h4 class="subheading">gnutls_certificate_get_trust_list</h4>
<span id="gnutls_005fcertificate_005fget_005ftrust_005flist"></span><dl>
<dt id="index-gnutls_005fcertificate_005fget_005ftrust_005flist">Function: <em>void</em> <strong>gnutls_certificate_get_trust_list</strong> <em>(gnutls_certificate_credentials_t <var>res</var>, gnutls_x509_trust_list_t * <var>tlist</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>tlist</var>: Location where to store the trust list.
</p>
<p>Obtains the list of trusted certificates stored in  <code>res</code> and writes a
pointer to it to the location  <code>tlist</code> . The pointer will point to memory
internal to  <code>res</code> , and must not be deinitialized. It will be automatically
deallocated when the  <code>res</code> structure is deinitialized.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fcertificate_005fset_005ftrust_005flist-1"></span><h4 class="subheading">gnutls_certificate_set_trust_list</h4>
<span id="gnutls_005fcertificate_005fset_005ftrust_005flist"></span><dl>
<dt id="index-gnutls_005fcertificate_005fset_005ftrust_005flist">Function: <em>void</em> <strong>gnutls_certificate_set_trust_list</strong> <em>(gnutls_certificate_credentials_t <var>res</var>, gnutls_x509_trust_list_t <var>tlist</var>, unsigned <var>flags</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>tlist</var>: is a <code>gnutls_x509_trust_list_t</code>  type
</p>
<p><var>flags</var>: must be zero
</p>
<p>This function sets a trust list in the gnutls_certificate_credentials_t type.
</p>
<p>Note that the  <code>tlist</code> will become part of the credentials
structure and must not be deallocated. It will be automatically deallocated
when the  <code>res</code> structure is deinitialized.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  (0) on success, or a negative error code.
</p>
<p><strong>Since:</strong> 3.2.2
</p></dd></dl>

<span id="gnutls_005fpkcs8_005finfo-1"></span><h4 class="subheading">gnutls_pkcs8_info</h4>
<span id="gnutls_005fpkcs8_005finfo"></span><dl>
<dt id="index-gnutls_005fpkcs8_005finfo">Function: <em>int</em> <strong>gnutls_pkcs8_info</strong> <em>(const gnutls_datum_t * <var>data</var>, gnutls_x509_crt_fmt_t <var>format</var>, unsigned int * <var>schema</var>, unsigned int * <var>cipher</var>, void * <var>salt</var>, unsigned int * <var>salt_size</var>, unsigned int * <var>iter_count</var>, char ** <var>oid</var>)</em></dt>
<dd><p><var>data</var>: Holds the PKCS <code>8</code>  data
</p>
<p><var>format</var>: the format of the PKCS <code>8</code>  data
</p>
<p><var>schema</var>: indicate the schema as one of <code>gnutls_pkcs_encrypt_flags_t</code> 
</p>
<p><var>cipher</var>: the cipher used as <code>gnutls_cipher_algorithm_t</code> 
</p>
<p><var>salt</var>: PBKDF2 salt (if non-NULL then  <code>salt_size</code> initially holds its size)
</p>
<p><var>salt_size</var>: PBKDF2 salt size
</p>
<p><var>iter_count</var>: PBKDF2 iteration count
</p>
<p><var>oid</var>: if non-NULL it will contain an allocated null-terminated variable with the OID
</p>
<p>This function will provide information on the algorithms used
in a particular PKCS <code>8</code>  structure. If the structure algorithms
are unknown the code <code>GNUTLS_E_UNKNOWN_CIPHER_TYPE</code>  will be returned,
and only  <code>oid</code> , will be set. That is,  <code>oid</code> will be set on encrypted PKCS <code>8</code> 
structures whether supported or not. It must be deinitialized using <code>gnutls_free()</code> .
The other variables are only set on supported structures.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_INVALID_REQUEST</code>  if the provided structure isn&rsquo;t an encrypted key,
<code>GNUTLS_E_UNKNOWN_CIPHER_TYPE</code>  if the structure&rsquo;s encryption isn&rsquo;t supported, or
another negative error code in case of a failure. Zero on success.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fpkcs_005fschema_005fget_005fname-1"></span><h4 class="subheading">gnutls_pkcs_schema_get_name</h4>
<span id="gnutls_005fpkcs_005fschema_005fget_005fname"></span><dl>
<dt id="index-gnutls_005fpkcs_005fschema_005fget_005fname">Function: <em>const char *</em> <strong>gnutls_pkcs_schema_get_name</strong> <em>(unsigned int <var>schema</var>)</em></dt>
<dd><p><var>schema</var>: Holds the PKCS <code>12</code>  or PBES2 schema (<code>gnutls_pkcs_encrypt_flags_t</code> )
</p>
<p>This function will return a human readable description of the
PKCS12 or PBES2 schema.
</p>
<p><strong>Returns:</strong> a constrant string or <code>NULL</code>  on error.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fpkcs_005fschema_005fget_005foid-1"></span><h4 class="subheading">gnutls_pkcs_schema_get_oid</h4>
<span id="gnutls_005fpkcs_005fschema_005fget_005foid"></span><dl>
<dt id="index-gnutls_005fpkcs_005fschema_005fget_005foid">Function: <em>const char *</em> <strong>gnutls_pkcs_schema_get_oid</strong> <em>(unsigned int <var>schema</var>)</em></dt>
<dd><p><var>schema</var>: Holds the PKCS <code>12</code>  or PBES2 schema (<code>gnutls_pkcs_encrypt_flags_t</code> )
</p>
<p>This function will return the object identifier of the
PKCS12 or PBES2 schema.
</p>
<p><strong>Returns:</strong> a constrant string or <code>NULL</code>  on error.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fsubject_005falt_005fnames_005fdeinit-1"></span><h4 class="subheading">gnutls_subject_alt_names_deinit</h4>
<span id="gnutls_005fsubject_005falt_005fnames_005fdeinit"></span><dl>
<dt id="index-gnutls_005fsubject_005falt_005fnames_005fdeinit">Function: <em>void</em> <strong>gnutls_subject_alt_names_deinit</strong> <em>(gnutls_subject_alt_names_t <var>sans</var>)</em></dt>
<dd><p><var>sans</var>: The alternative names
</p>
<p>This function will deinitialize an alternative names structure.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fsubject_005falt_005fnames_005fget-1"></span><h4 class="subheading">gnutls_subject_alt_names_get</h4>
<span id="gnutls_005fsubject_005falt_005fnames_005fget"></span><dl>
<dt id="index-gnutls_005fsubject_005falt_005fnames_005fget">Function: <em>int</em> <strong>gnutls_subject_alt_names_get</strong> <em>(gnutls_subject_alt_names_t <var>sans</var>, unsigned int <var>seq</var>, unsigned int * <var>san_type</var>, gnutls_datum_t * <var>san</var>, gnutls_datum_t * <var>othername_oid</var>)</em></dt>
<dd><p><var>sans</var>: The alternative names
</p>
<p><var>seq</var>: The index of the name to get
</p>
<p><var>san_type</var>: Will hold the type of the name (of <code>gnutls_subject_alt_names_t</code> )
</p>
<p><var>san</var>: The alternative name data (should be treated as constant)
</p>
<p><var>othername_oid</var>: The object identifier if  <code>san_type</code> is <code>GNUTLS_SAN_OTHERNAME</code>  (should be treated as constant)
</p>
<p>This function will return a specific alternative name as stored in
the  <code>sans</code> type. The returned values should be treated as constant
and valid for the lifetime of  <code>sans</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
if the index is out of bounds, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fsubject_005falt_005fnames_005finit-1"></span><h4 class="subheading">gnutls_subject_alt_names_init</h4>
<span id="gnutls_005fsubject_005falt_005fnames_005finit"></span><dl>
<dt id="index-gnutls_005fsubject_005falt_005fnames_005finit">Function: <em>int</em> <strong>gnutls_subject_alt_names_init</strong> <em>(gnutls_subject_alt_names_t * <var>sans</var>)</em></dt>
<dd><p><var>sans</var>: The alternative names
</p>
<p>This function will initialize an alternative names structure.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fsubject_005falt_005fnames_005fset-1"></span><h4 class="subheading">gnutls_subject_alt_names_set</h4>
<span id="gnutls_005fsubject_005falt_005fnames_005fset"></span><dl>
<dt id="index-gnutls_005fsubject_005falt_005fnames_005fset">Function: <em>int</em> <strong>gnutls_subject_alt_names_set</strong> <em>(gnutls_subject_alt_names_t <var>sans</var>, unsigned int <var>san_type</var>, const gnutls_datum_t * <var>san</var>, const char * <var>othername_oid</var>)</em></dt>
<dd><p><var>sans</var>: The alternative names
</p>
<p><var>san_type</var>: The type of the name (of <code>gnutls_subject_alt_names_t</code> )
</p>
<p><var>san</var>: The alternative name data
</p>
<p><var>othername_oid</var>: The object identifier if  <code>san_type</code> is <code>GNUTLS_SAN_OTHERNAME</code> 
</p>
<p>This function will store the specified alternative name in
the  <code>sans</code> .
</p>
<p>Since version 3.5.7 the <code>GNUTLS_SAN_RFC822NAME</code> , <code>GNUTLS_SAN_DNSNAME</code> , and
<code>GNUTLS_SAN_OTHERNAME_XMPP</code>  are converted to ACE format when necessary.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0), otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005faia_005fdeinit-1"></span><h4 class="subheading">gnutls_x509_aia_deinit</h4>
<span id="gnutls_005fx509_005faia_005fdeinit"></span><dl>
<dt id="index-gnutls_005fx509_005faia_005fdeinit">Function: <em>void</em> <strong>gnutls_x509_aia_deinit</strong> <em>(gnutls_x509_aia_t <var>aia</var>)</em></dt>
<dd><p><var>aia</var>: The authority info access
</p>
<p>This function will deinitialize an authority info access type.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005faia_005fget-1"></span><h4 class="subheading">gnutls_x509_aia_get</h4>
<span id="gnutls_005fx509_005faia_005fget"></span><dl>
<dt id="index-gnutls_005fx509_005faia_005fget">Function: <em>int</em> <strong>gnutls_x509_aia_get</strong> <em>(gnutls_x509_aia_t <var>aia</var>, unsigned int <var>seq</var>, gnutls_datum_t * <var>oid</var>, unsigned * <var>san_type</var>, gnutls_datum_t * <var>san</var>)</em></dt>
<dd><p><var>aia</var>: The authority info access
</p>
<p><var>seq</var>: specifies the sequence number of the access descriptor (0 for the first one, 1 for the second etc.)
</p>
<p><var>oid</var>: the type of available data; to be treated as constant.
</p>
<p><var>san_type</var>: Will hold the type of the name of <code>gnutls_subject_alt_names_t</code>  (may be null).
</p>
<p><var>san</var>: the access location name; to be treated as constant (may be null).
</p>
<p>This function reads from the Authority Information Access type.
</p>
<p>The  <code>seq</code> input parameter is used to indicate which member of the
sequence the caller is interested in.  The first member is 0, the
second member 1 and so on.  When the  <code>seq</code> value is out of bounds,
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  is returned.
</p>
<p>Typically  <code>oid</code> is <code>GNUTLS_OID_AD_CAISSUERS</code>  or <code>GNUTLS_OID_AD_OCSP</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005faia_005finit-1"></span><h4 class="subheading">gnutls_x509_aia_init</h4>
<span id="gnutls_005fx509_005faia_005finit"></span><dl>
<dt id="index-gnutls_005fx509_005faia_005finit">Function: <em>int</em> <strong>gnutls_x509_aia_init</strong> <em>(gnutls_x509_aia_t * <var>aia</var>)</em></dt>
<dd><p><var>aia</var>: The authority info access
</p>
<p>This function will initialize an authority info access type.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005faia_005fset-1"></span><h4 class="subheading">gnutls_x509_aia_set</h4>
<span id="gnutls_005fx509_005faia_005fset"></span><dl>
<dt id="index-gnutls_005fx509_005faia_005fset">Function: <em>int</em> <strong>gnutls_x509_aia_set</strong> <em>(gnutls_x509_aia_t <var>aia</var>, const char * <var>oid</var>, unsigned <var>san_type</var>, const gnutls_datum_t * <var>san</var>)</em></dt>
<dd><p><var>aia</var>: The authority info access
</p>
<p><var>oid</var>: the type of data.
</p>
<p><var>san_type</var>: The type of the name (of <code>gnutls_subject_alt_names_t</code> )
</p>
<p><var>san</var>: The alternative name data
</p>
<p>This function will store the specified alternative name in
the  <code>aia</code> type. 
</p>
<p>Typically the value for  <code>oid</code> should be <code>GNUTLS_OID_AD_OCSP</code> , or
<code>GNUTLS_OID_AD_CAISSUERS</code> .
</p>
<p>Since version 3.5.7 the <code>GNUTLS_SAN_RFC822NAME</code> , and <code>GNUTLS_SAN_DNSNAME</code> ,
are converted to ACE format when necessary.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0), otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005faki_005fdeinit-1"></span><h4 class="subheading">gnutls_x509_aki_deinit</h4>
<span id="gnutls_005fx509_005faki_005fdeinit"></span><dl>
<dt id="index-gnutls_005fx509_005faki_005fdeinit">Function: <em>void</em> <strong>gnutls_x509_aki_deinit</strong> <em>(gnutls_x509_aki_t <var>aki</var>)</em></dt>
<dd><p><var>aki</var>: The authority key identifier type
</p>
<p>This function will deinitialize an authority key identifier.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005faki_005fget_005fcert_005fissuer-1"></span><h4 class="subheading">gnutls_x509_aki_get_cert_issuer</h4>
<span id="gnutls_005fx509_005faki_005fget_005fcert_005fissuer"></span><dl>
<dt id="index-gnutls_005fx509_005faki_005fget_005fcert_005fissuer">Function: <em>int</em> <strong>gnutls_x509_aki_get_cert_issuer</strong> <em>(gnutls_x509_aki_t <var>aki</var>, unsigned int <var>seq</var>, unsigned int * <var>san_type</var>, gnutls_datum_t * <var>san</var>, gnutls_datum_t * <var>othername_oid</var>, gnutls_datum_t * <var>serial</var>)</em></dt>
<dd><p><var>aki</var>: The authority key ID
</p>
<p><var>seq</var>: The index of the name to get
</p>
<p><var>san_type</var>: Will hold the type of the name (of <code>gnutls_subject_alt_names_t</code> )
</p>
<p><var>san</var>: The alternative name data
</p>
<p><var>othername_oid</var>: The object identifier if  <code>san_type</code> is <code>GNUTLS_SAN_OTHERNAME</code> 
</p>
<p><var>serial</var>: The authorityCertSerialNumber number
</p>
<p>This function will return a specific authorityCertIssuer name as stored in
the  <code>aki</code> type, as well as the authorityCertSerialNumber. All the returned
values should be treated as constant, and may be set to <code>NULL</code>  when are not required.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
if the index is out of bounds, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005faki_005fget_005fid-1"></span><h4 class="subheading">gnutls_x509_aki_get_id</h4>
<span id="gnutls_005fx509_005faki_005fget_005fid"></span><dl>
<dt id="index-gnutls_005fx509_005faki_005fget_005fid">Function: <em>int</em> <strong>gnutls_x509_aki_get_id</strong> <em>(gnutls_x509_aki_t <var>aki</var>, gnutls_datum_t * <var>id</var>)</em></dt>
<dd><p><var>aki</var>: The authority key ID
</p>
<p><var>id</var>: Will hold the identifier
</p>
<p>This function will return the key identifier as stored in
the  <code>aki</code> type. The identifier should be treated as constant.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
if the index is out of bounds, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005faki_005finit-1"></span><h4 class="subheading">gnutls_x509_aki_init</h4>
<span id="gnutls_005fx509_005faki_005finit"></span><dl>
<dt id="index-gnutls_005fx509_005faki_005finit">Function: <em>int</em> <strong>gnutls_x509_aki_init</strong> <em>(gnutls_x509_aki_t * <var>aki</var>)</em></dt>
<dd><p><var>aki</var>: The authority key ID type
</p>
<p>This function will initialize an authority key ID.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005faki_005fset_005fcert_005fissuer-1"></span><h4 class="subheading">gnutls_x509_aki_set_cert_issuer</h4>
<span id="gnutls_005fx509_005faki_005fset_005fcert_005fissuer"></span><dl>
<dt id="index-gnutls_005fx509_005faki_005fset_005fcert_005fissuer">Function: <em>int</em> <strong>gnutls_x509_aki_set_cert_issuer</strong> <em>(gnutls_x509_aki_t <var>aki</var>, unsigned int <var>san_type</var>, const gnutls_datum_t * <var>san</var>, const char * <var>othername_oid</var>, const gnutls_datum_t * <var>serial</var>)</em></dt>
<dd><p><var>aki</var>: The authority key ID
</p>
<p><var>san_type</var>: the type of the name (of <code>gnutls_subject_alt_names_t</code> ), may be null
</p>
<p><var>san</var>: The alternative name data
</p>
<p><var>othername_oid</var>: The object identifier if  <code>san_type</code> is <code>GNUTLS_SAN_OTHERNAME</code> 
</p>
<p><var>serial</var>: The authorityCertSerialNumber number (may be null)
</p>
<p>This function will set the authorityCertIssuer name and the authorityCertSerialNumber 
to be stored in the  <code>aki</code> type. When storing multiple names, the serial
should be set on the first call, and subsequent calls should use a <code>NULL</code>  serial.
</p>
<p>Since version 3.5.7 the <code>GNUTLS_SAN_RFC822NAME</code> , <code>GNUTLS_SAN_DNSNAME</code> , and
<code>GNUTLS_SAN_OTHERNAME_XMPP</code>  are converted to ACE format when necessary.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005faki_005fset_005fid-1"></span><h4 class="subheading">gnutls_x509_aki_set_id</h4>
<span id="gnutls_005fx509_005faki_005fset_005fid"></span><dl>
<dt id="index-gnutls_005fx509_005faki_005fset_005fid">Function: <em>int</em> <strong>gnutls_x509_aki_set_id</strong> <em>(gnutls_x509_aki_t <var>aki</var>, const gnutls_datum_t * <var>id</var>)</em></dt>
<dd><p><var>aki</var>: The authority key ID
</p>
<p><var>id</var>: the key identifier
</p>
<p>This function will set the keyIdentifier to be stored in the  <code>aki</code> type.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcidr_005fto_005frfc5280-1"></span><h4 class="subheading">gnutls_x509_cidr_to_rfc5280</h4>
<span id="gnutls_005fx509_005fcidr_005fto_005frfc5280"></span><dl>
<dt id="index-gnutls_005fx509_005fcidr_005fto_005frfc5280">Function: <em>int</em> <strong>gnutls_x509_cidr_to_rfc5280</strong> <em>(const char * <var>cidr</var>, gnutls_datum_t * <var>cidr_rfc5280</var>)</em></dt>
<dd><p><var>cidr</var>: CIDR in RFC4632 format (IP/prefix), null-terminated
</p>
<p><var>cidr_rfc5280</var>: CIDR range converted to RFC5280 format
</p>
<p>This function will convert text CIDR range with prefix (such as &rsquo;10.0.0.0/8&rsquo;)
to RFC5280 (IP address in network byte order followed by its network mask).
Works for both IPv4 and IPv6.
</p>
<p>The resulting object is directly usable for IP name constraints usage,
for example in functions <code>gnutls_x509_name_constraints_add_permitted</code> 
or <code>gnutls_x509_name_constraints_add_excluded</code> .
</p>
<p>The data in datum needs to be deallocated using <code>gnutls_free()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.5.4
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005fcheck_005fissuer-1"></span><h4 class="subheading">gnutls_x509_crl_check_issuer</h4>
<span id="gnutls_005fx509_005fcrl_005fcheck_005fissuer"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005fcheck_005fissuer">Function: <em>unsigned</em> <strong>gnutls_x509_crl_check_issuer</strong> <em>(gnutls_x509_crl_t <var>crl</var>, gnutls_x509_crt_t <var>issuer</var>)</em></dt>
<dd><p><var>crl</var>: is the CRL to be checked
</p>
<p><var>issuer</var>: is the certificate of a possible issuer
</p>
<p>This function will check if the given CRL was issued by the given
issuer certificate.  
</p>
<p><strong>Returns:</strong> true (1) if the given CRL was issued by the given issuer, 
and false (0) if not.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005fdeinit-1"></span><h4 class="subheading">gnutls_x509_crl_deinit</h4>
<span id="gnutls_005fx509_005fcrl_005fdeinit"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005fdeinit">Function: <em>void</em> <strong>gnutls_x509_crl_deinit</strong> <em>(gnutls_x509_crl_t <var>crl</var>)</em></dt>
<dd><p><var>crl</var>: The data to be deinitialized
</p>
<p>This function will deinitialize a CRL structure.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005fdist_005fpoints_005fdeinit-1"></span><h4 class="subheading">gnutls_x509_crl_dist_points_deinit</h4>
<span id="gnutls_005fx509_005fcrl_005fdist_005fpoints_005fdeinit"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005fdist_005fpoints_005fdeinit">Function: <em>void</em> <strong>gnutls_x509_crl_dist_points_deinit</strong> <em>(gnutls_x509_crl_dist_points_t <var>cdp</var>)</em></dt>
<dd><p><var>cdp</var>: The CRL distribution points
</p>
<p>This function will deinitialize a CRL distribution points type.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005fdist_005fpoints_005fget-1"></span><h4 class="subheading">gnutls_x509_crl_dist_points_get</h4>
<span id="gnutls_005fx509_005fcrl_005fdist_005fpoints_005fget"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005fdist_005fpoints_005fget">Function: <em>int</em> <strong>gnutls_x509_crl_dist_points_get</strong> <em>(gnutls_x509_crl_dist_points_t <var>cdp</var>, unsigned int <var>seq</var>, unsigned int * <var>type</var>, gnutls_datum_t * <var>san</var>, unsigned int * <var>reasons</var>)</em></dt>
<dd><p><var>cdp</var>: The CRL distribution points
</p>
<p><var>seq</var>: specifies the sequence number of the distribution point (0 for the first one, 1 for the second etc.)
</p>
<p><var>type</var>: The name type of the corresponding name (gnutls_x509_subject_alt_name_t)
</p>
<p><var>san</var>: The distribution point names (to be treated as constant)
</p>
<p><var>reasons</var>: Revocation reasons. An ORed sequence of flags from <code>gnutls_x509_crl_reason_flags_t</code> .
</p>
<p>This function retrieves the individual CRL distribution points (2.5.29.31),
contained in provided type. 
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
if the index is out of bounds, otherwise a negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005fdist_005fpoints_005finit-1"></span><h4 class="subheading">gnutls_x509_crl_dist_points_init</h4>
<span id="gnutls_005fx509_005fcrl_005fdist_005fpoints_005finit"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005fdist_005fpoints_005finit">Function: <em>int</em> <strong>gnutls_x509_crl_dist_points_init</strong> <em>(gnutls_x509_crl_dist_points_t * <var>cdp</var>)</em></dt>
<dd><p><var>cdp</var>: The CRL distribution points
</p>
<p>This function will initialize a CRL distribution points type.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005fdist_005fpoints_005fset-1"></span><h4 class="subheading">gnutls_x509_crl_dist_points_set</h4>
<span id="gnutls_005fx509_005fcrl_005fdist_005fpoints_005fset"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005fdist_005fpoints_005fset">Function: <em>int</em> <strong>gnutls_x509_crl_dist_points_set</strong> <em>(gnutls_x509_crl_dist_points_t <var>cdp</var>, gnutls_x509_subject_alt_name_t <var>type</var>, const gnutls_datum_t * <var>san</var>, unsigned int <var>reasons</var>)</em></dt>
<dd><p><var>cdp</var>: The CRL distribution points
</p>
<p><var>type</var>: The type of the name (of <code>gnutls_subject_alt_names_t</code> )
</p>
<p><var>san</var>: The point name data
</p>
<p><var>reasons</var>: Revocation reasons. An ORed sequence of flags from <code>gnutls_x509_crl_reason_flags_t</code> .
</p>
<p>This function will store the specified CRL distribution point value
the  <code>cdp</code> type.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0), otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005fexport-1"></span><h4 class="subheading">gnutls_x509_crl_export</h4>
<span id="gnutls_005fx509_005fcrl_005fexport"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005fexport">Function: <em>int</em> <strong>gnutls_x509_crl_export</strong> <em>(gnutls_x509_crl_t <var>crl</var>, gnutls_x509_crt_fmt_t <var>format</var>, void * <var>output_data</var>, size_t * <var>output_data_size</var>)</em></dt>
<dd><p><var>crl</var>: Holds the revocation list
</p>
<p><var>format</var>: the format of output params. One of PEM or DER.
</p>
<p><var>output_data</var>: will contain a private key PEM or DER encoded
</p>
<p><var>output_data_size</var>: holds the size of output_data (and will
be replaced by the actual size of parameters)
</p>
<p>This function will export the revocation list to DER or PEM format.
</p>
<p>If the buffer provided is not long enough to hold the output, then
<code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  will be returned.
</p>
<p>If the structure is PEM encoded, it will have a header
of &quot;BEGIN X509 CRL&quot;.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005fexport2-1"></span><h4 class="subheading">gnutls_x509_crl_export2</h4>
<span id="gnutls_005fx509_005fcrl_005fexport2"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005fexport2">Function: <em>int</em> <strong>gnutls_x509_crl_export2</strong> <em>(gnutls_x509_crl_t <var>crl</var>, gnutls_x509_crt_fmt_t <var>format</var>, gnutls_datum_t * <var>out</var>)</em></dt>
<dd><p><var>crl</var>: Holds the revocation list
</p>
<p><var>format</var>: the format of output params. One of PEM or DER.
</p>
<p><var>out</var>: will contain a private key PEM or DER encoded
</p>
<p>This function will export the revocation list to DER or PEM format.
</p>
<p>The output buffer is allocated using <code>gnutls_malloc()</code> .
</p>
<p>If the structure is PEM encoded, it will have a header
of &quot;BEGIN X509 CRL&quot;.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p>Since 3.1.3
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005fget_005fauthority_005fkey_005fgn_005fserial-1"></span><h4 class="subheading">gnutls_x509_crl_get_authority_key_gn_serial</h4>
<span id="gnutls_005fx509_005fcrl_005fget_005fauthority_005fkey_005fgn_005fserial"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005fget_005fauthority_005fkey_005fgn_005fserial">Function: <em>int</em> <strong>gnutls_x509_crl_get_authority_key_gn_serial</strong> <em>(gnutls_x509_crl_t <var>crl</var>, unsigned int <var>seq</var>, void * <var>alt</var>, size_t * <var>alt_size</var>, unsigned int * <var>alt_type</var>, void * <var>serial</var>, size_t * <var>serial_size</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>crl</var>: should contain a <code>gnutls_x509_crl_t</code>  type
</p>
<p><var>seq</var>: specifies the sequence number of the alt name (0 for the first one, 1 for the second etc.)
</p>
<p><var>alt</var>: is the place where the alternative name will be copied to
</p>
<p><var>alt_size</var>: holds the size of alt.
</p>
<p><var>alt_type</var>: holds the type of the alternative name (one of gnutls_x509_subject_alt_name_t).
</p>
<p><var>serial</var>: buffer to store the serial number (may be null)
</p>
<p><var>serial_size</var>: Holds the size of the serial field (may be null)
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical (may be null)
</p>
<p>This function will return the X.509 authority key
identifier when stored as a general name (authorityCertIssuer) 
and serial number.
</p>
<p>Because more than one general names might be stored
 <code>seq</code> can be used as a counter to request them all until 
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  is returned.
</p>
<p><strong>Returns:</strong> Returns 0 on success, or an error code.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005fget_005fauthority_005fkey_005fid-1"></span><h4 class="subheading">gnutls_x509_crl_get_authority_key_id</h4>
<span id="gnutls_005fx509_005fcrl_005fget_005fauthority_005fkey_005fid"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005fget_005fauthority_005fkey_005fid">Function: <em>int</em> <strong>gnutls_x509_crl_get_authority_key_id</strong> <em>(gnutls_x509_crl_t <var>crl</var>, void * <var>id</var>, size_t * <var>id_size</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>crl</var>: should contain a <code>gnutls_x509_crl_t</code>  type
</p>
<p><var>id</var>: The place where the identifier will be copied
</p>
<p><var>id_size</var>: Holds the size of the result field.
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical
(may be null)
</p>
<p>This function will return the CRL authority&rsquo;s key identifier.  This
is obtained by the X.509 Authority Key identifier extension field
(2.5.29.35).  Note that this function 
only returns the keyIdentifier field of the extension and
<code>GNUTLS_E_X509_UNSUPPORTED_EXTENSION</code> , if the extension contains
the name and serial number of the certificate. In that case
<code>gnutls_x509_crl_get_authority_key_gn_serial()</code>  may be used.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error code in case of an error.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005fget_005fcrt_005fcount-1"></span><h4 class="subheading">gnutls_x509_crl_get_crt_count</h4>
<span id="gnutls_005fx509_005fcrl_005fget_005fcrt_005fcount"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005fget_005fcrt_005fcount">Function: <em>int</em> <strong>gnutls_x509_crl_get_crt_count</strong> <em>(gnutls_x509_crl_t <var>crl</var>)</em></dt>
<dd><p><var>crl</var>: should contain a <code>gnutls_x509_crl_t</code>  type
</p>
<p>This function will return the number of revoked certificates in the
given CRL.
</p>
<p><strong>Returns:</strong> number of certificates, a negative error code on failure.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005fget_005fcrt_005fserial-1"></span><h4 class="subheading">gnutls_x509_crl_get_crt_serial</h4>
<span id="gnutls_005fx509_005fcrl_005fget_005fcrt_005fserial"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005fget_005fcrt_005fserial-1">Function: <em>int</em> <strong>gnutls_x509_crl_get_crt_serial</strong> <em>(gnutls_x509_crl_t <var>crl</var>, unsigned <var>indx</var>, unsigned char * <var>serial</var>, size_t * <var>serial_size</var>, time_t * <var>t</var>)</em></dt>
<dd><p><var>crl</var>: should contain a <code>gnutls_x509_crl_t</code>  type
</p>
<p><var>indx</var>: the index of the certificate to extract (starting from 0)
</p>
<p><var>serial</var>: where the serial number will be copied
</p>
<p><var>serial_size</var>: initially holds the size of serial
</p>
<p><var>t</var>: if non null, will hold the time this certificate was revoked
</p>
<p>This function will retrieve the serial number of the specified, by
the index, revoked certificate.
</p>
<p>Note that this function will have performance issues in large sequences
of revoked certificates. In that case use <code>gnutls_x509_crl_iter_crt_serial()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005fget_005fdn_005foid-1"></span><h4 class="subheading">gnutls_x509_crl_get_dn_oid</h4>
<span id="gnutls_005fx509_005fcrl_005fget_005fdn_005foid"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005fget_005fdn_005foid">Function: <em>int</em> <strong>gnutls_x509_crl_get_dn_oid</strong> <em>(gnutls_x509_crl_t <var>crl</var>, unsigned <var>indx</var>, void * <var>oid</var>, size_t * <var>sizeof_oid</var>)</em></dt>
<dd><p><var>crl</var>: should contain a gnutls_x509_crl_t type
</p>
<p><var>indx</var>: Specifies which DN OID to send. Use (0) to get the first one.
</p>
<p><var>oid</var>: a pointer to store the OID (may be null)
</p>
<p><var>sizeof_oid</var>: initially holds the size of &rsquo;oid&rsquo;
</p>
<p>This function will extract the requested OID of the name of the CRL
issuer, specified by the given index.
</p>
<p>If oid is null then only the size will be filled.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if the provided buffer is
not long enough, and in that case the sizeof_oid will be updated
with the required size.  On success 0 is returned.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005fget_005fextension_005fdata-1"></span><h4 class="subheading">gnutls_x509_crl_get_extension_data</h4>
<span id="gnutls_005fx509_005fcrl_005fget_005fextension_005fdata"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005fget_005fextension_005fdata">Function: <em>int</em> <strong>gnutls_x509_crl_get_extension_data</strong> <em>(gnutls_x509_crl_t <var>crl</var>, unsigned <var>indx</var>, void * <var>data</var>, size_t * <var>sizeof_data</var>)</em></dt>
<dd><p><var>crl</var>: should contain a <code>gnutls_x509_crl_t</code>  type
</p>
<p><var>indx</var>: Specifies which extension OID to send. Use (0) to get the first one.
</p>
<p><var>data</var>: a pointer to a structure to hold the data (may be null)
</p>
<p><var>sizeof_data</var>: initially holds the size of  <code>oid</code> 
</p>
<p>This function will return the requested extension data in the CRL.
The extension data will be stored as a string in the provided
buffer.
</p>
<p>Use <code>gnutls_x509_crl_get_extension_info()</code>  to extract the OID and
critical flag.  Use <code>gnutls_x509_crl_get_extension_info()</code>  instead,
if you want to get data indexed by the extension OID rather than
sequence.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error code in case of an error.  If your have reached the
last extension available <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
will be returned.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005fget_005fextension_005fdata2-1"></span><h4 class="subheading">gnutls_x509_crl_get_extension_data2</h4>
<span id="gnutls_005fx509_005fcrl_005fget_005fextension_005fdata2"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005fget_005fextension_005fdata2">Function: <em>int</em> <strong>gnutls_x509_crl_get_extension_data2</strong> <em>(gnutls_x509_crl_t <var>crl</var>, unsigned <var>indx</var>, gnutls_datum_t * <var>data</var>)</em></dt>
<dd><p><var>crl</var>: should contain a <code>gnutls_x509_crl_t</code>  type
</p>
<p><var>indx</var>: Specifies which extension OID to read. Use (0) to get the first one.
</p>
<p><var>data</var>: will contain the extension DER-encoded data
</p>
<p>This function will return the requested by the index extension data in the
certificate revocation list.  The extension data will be allocated using
<code>gnutls_malloc()</code> .
</p>
<p>Use <code>gnutls_x509_crt_get_extension_info()</code>  to extract the OID.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.  If you have reached the
last extension available <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
will be returned.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005fget_005fextension_005finfo-1"></span><h4 class="subheading">gnutls_x509_crl_get_extension_info</h4>
<span id="gnutls_005fx509_005fcrl_005fget_005fextension_005finfo"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005fget_005fextension_005finfo">Function: <em>int</em> <strong>gnutls_x509_crl_get_extension_info</strong> <em>(gnutls_x509_crl_t <var>crl</var>, unsigned <var>indx</var>, void * <var>oid</var>, size_t * <var>sizeof_oid</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>crl</var>: should contain a <code>gnutls_x509_crl_t</code>  type
</p>
<p><var>indx</var>: Specifies which extension OID to send, use (0) to get the first one.
</p>
<p><var>oid</var>: a pointer to store the OID
</p>
<p><var>sizeof_oid</var>: initially holds the maximum size of  <code>oid</code> , on return
holds actual size of  <code>oid</code> .
</p>
<p><var>critical</var>: output variable with critical flag, may be NULL.
</p>
<p>This function will return the requested extension OID in the CRL,
and the critical flag for it.  The extension OID will be stored as
a string in the provided buffer.  Use
<code>gnutls_x509_crl_get_extension_data()</code>  to extract the data.
</p>
<p>If the buffer provided is not long enough to hold the output, then
* <code>sizeof_oid</code> is updated and <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  will be
returned.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error code in case of an error.  If your have reached the
last extension available <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
will be returned.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005fget_005fextension_005foid-1"></span><h4 class="subheading">gnutls_x509_crl_get_extension_oid</h4>
<span id="gnutls_005fx509_005fcrl_005fget_005fextension_005foid"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005fget_005fextension_005foid">Function: <em>int</em> <strong>gnutls_x509_crl_get_extension_oid</strong> <em>(gnutls_x509_crl_t <var>crl</var>, unsigned <var>indx</var>, void * <var>oid</var>, size_t * <var>sizeof_oid</var>)</em></dt>
<dd><p><var>crl</var>: should contain a <code>gnutls_x509_crl_t</code>  type
</p>
<p><var>indx</var>: Specifies which extension OID to send, use (0) to get the first one.
</p>
<p><var>oid</var>: a pointer to store the OID (may be null)
</p>
<p><var>sizeof_oid</var>: initially holds the size of  <code>oid</code> 
</p>
<p>This function will return the requested extension OID in the CRL.
The extension OID will be stored as a string in the provided
buffer.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error code in case of an error.  If your have reached the
last extension available <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
will be returned.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005fget_005fissuer_005fdn-1"></span><h4 class="subheading">gnutls_x509_crl_get_issuer_dn</h4>
<span id="gnutls_005fx509_005fcrl_005fget_005fissuer_005fdn"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005fget_005fissuer_005fdn">Function: <em>int</em> <strong>gnutls_x509_crl_get_issuer_dn</strong> <em>(gnutls_x509_crl_t <var>crl</var>, char * <var>buf</var>, size_t * <var>sizeof_buf</var>)</em></dt>
<dd><p><var>crl</var>: should contain a gnutls_x509_crl_t type
</p>
<p><var>buf</var>: a pointer to a structure to hold the peer&rsquo;s name (may be null)
</p>
<p><var>sizeof_buf</var>: initially holds the size of  <code>buf</code> 
</p>
<p>This function will copy the name of the CRL issuer in the provided
buffer. The name will be in the form &quot;C=xxxx,O=yyyy,CN=zzzz&quot; as
described in RFC4514. The output string will be ASCII or UTF-8
encoded, depending on the certificate data.
</p>
<p>If buf is <code>NULL</code>  then only the size will be filled.
</p>
<p>This function does not output a fully RFC4514 compliant string, if
that is required see <code>gnutls_x509_crl_get_issuer_dn3()</code> .
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if the provided buffer is
not long enough, and in that case the sizeof_buf will be updated
with the required size, and 0 on success.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005fget_005fissuer_005fdn2-1"></span><h4 class="subheading">gnutls_x509_crl_get_issuer_dn2</h4>
<span id="gnutls_005fx509_005fcrl_005fget_005fissuer_005fdn2"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005fget_005fissuer_005fdn2">Function: <em>int</em> <strong>gnutls_x509_crl_get_issuer_dn2</strong> <em>(gnutls_x509_crl_t <var>crl</var>, gnutls_datum_t * <var>dn</var>)</em></dt>
<dd><p><var>crl</var>: should contain a <code>gnutls_x509_crl_t</code>  type
</p>
<p><var>dn</var>: a pointer to a structure to hold the name
</p>
<p>This function will allocate buffer and copy the name of the CRL issuer.
The name will be in the form &quot;C=xxxx,O=yyyy,CN=zzzz&quot; as
described in RFC4514. The output string will be ASCII or UTF-8
encoded, depending on the certificate data.
</p>
<p>This function does not output a fully RFC4514 compliant string, if
that is required see <code>gnutls_x509_crl_get_issuer_dn3()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.1.10
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005fget_005fissuer_005fdn3-1"></span><h4 class="subheading">gnutls_x509_crl_get_issuer_dn3</h4>
<span id="gnutls_005fx509_005fcrl_005fget_005fissuer_005fdn3"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005fget_005fissuer_005fdn3">Function: <em>int</em> <strong>gnutls_x509_crl_get_issuer_dn3</strong> <em>(gnutls_x509_crl_t <var>crl</var>, gnutls_datum_t * <var>dn</var>, unsigned <var>flags</var>)</em></dt>
<dd><p><var>crl</var>: should contain a <code>gnutls_x509_crl_t</code>  type
</p>
<p><var>dn</var>: a pointer to a structure to hold the name
</p>
<p><var>flags</var>: zero or <code>GNUTLS_X509_DN_FLAG_COMPAT</code> 
</p>
<p>This function will allocate buffer and copy the name of the CRL issuer.
The name will be in the form &quot;C=xxxx,O=yyyy,CN=zzzz&quot; as
described in RFC4514. The output string will be ASCII or UTF-8
encoded, depending on the certificate data.
</p>
<p>When the flag <code>GNUTLS_X509_DN_FLAG_COMPAT</code>  is specified, the output
format will match the format output by previous to 3.5.6 versions of GnuTLS
which was not not fully RFC4514-compliant.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.5.7
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005fget_005fissuer_005fdn_005fby_005foid-1"></span><h4 class="subheading">gnutls_x509_crl_get_issuer_dn_by_oid</h4>
<span id="gnutls_005fx509_005fcrl_005fget_005fissuer_005fdn_005fby_005foid"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005fget_005fissuer_005fdn_005fby_005foid">Function: <em>int</em> <strong>gnutls_x509_crl_get_issuer_dn_by_oid</strong> <em>(gnutls_x509_crl_t <var>crl</var>, const char * <var>oid</var>, unsigned <var>indx</var>, unsigned int <var>raw_flag</var>, void * <var>buf</var>, size_t * <var>sizeof_buf</var>)</em></dt>
<dd><p><var>crl</var>: should contain a gnutls_x509_crl_t type
</p>
<p><var>oid</var>: holds an Object Identified in null terminated string
</p>
<p><var>indx</var>: In case multiple same OIDs exist in the RDN, this specifies which to send. Use (0) to get the first one.
</p>
<p><var>raw_flag</var>: If non-zero returns the raw DER data of the DN part.
</p>
<p><var>buf</var>: a pointer to a structure to hold the peer&rsquo;s name (may be null)
</p>
<p><var>sizeof_buf</var>: initially holds the size of  <code>buf</code> 
</p>
<p>This function will extract the part of the name of the CRL issuer
specified by the given OID. The output will be encoded as described
in RFC4514. The output string will be ASCII or UTF-8 encoded,
depending on the certificate data.
</p>
<p>Some helper macros with popular OIDs can be found in gnutls/x509.h
If raw flag is (0), this function will only return known OIDs as
text. Other OIDs will be DER encoded, as described in RFC4514 &ndash; in
hex format with a &rsquo;#&rsquo; prefix.  You can check about known OIDs
using <code>gnutls_x509_dn_oid_known()</code> .
</p>
<p>If buf is null then only the size will be filled.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if the provided buffer is
not long enough, and in that case the sizeof_buf will be updated
with the required size, and 0 on success.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005fget_005fnext_005fupdate-1"></span><h4 class="subheading">gnutls_x509_crl_get_next_update</h4>
<span id="gnutls_005fx509_005fcrl_005fget_005fnext_005fupdate"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005fget_005fnext_005fupdate">Function: <em>time_t</em> <strong>gnutls_x509_crl_get_next_update</strong> <em>(gnutls_x509_crl_t <var>crl</var>)</em></dt>
<dd><p><var>crl</var>: should contain a <code>gnutls_x509_crl_t</code>  type
</p>
<p>This function will return the time the next CRL will be issued.
This field is optional in a CRL so it might be normal to get an
error instead.
</p>
<p><strong>Returns:</strong> when the next CRL will be issued, or (time_t)-1 on error.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005fget_005fnumber-1"></span><h4 class="subheading">gnutls_x509_crl_get_number</h4>
<span id="gnutls_005fx509_005fcrl_005fget_005fnumber"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005fget_005fnumber">Function: <em>int</em> <strong>gnutls_x509_crl_get_number</strong> <em>(gnutls_x509_crl_t <var>crl</var>, void * <var>ret</var>, size_t * <var>ret_size</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>crl</var>: should contain a <code>gnutls_x509_crl_t</code>  type
</p>
<p><var>ret</var>: The place where the number will be copied
</p>
<p><var>ret_size</var>: Holds the size of the result field.
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical
(may be null)
</p>
<p>This function will return the CRL number extension.  This is
obtained by the CRL Number extension field (2.5.29.20).
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error code in case of an error.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005fget_005fraw_005fissuer_005fdn-1"></span><h4 class="subheading">gnutls_x509_crl_get_raw_issuer_dn</h4>
<span id="gnutls_005fx509_005fcrl_005fget_005fraw_005fissuer_005fdn"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005fget_005fraw_005fissuer_005fdn">Function: <em>int</em> <strong>gnutls_x509_crl_get_raw_issuer_dn</strong> <em>(gnutls_x509_crl_t <var>crl</var>, gnutls_datum_t * <var>dn</var>)</em></dt>
<dd><p><var>crl</var>: should contain a gnutls_x509_crl_t type
</p>
<p><var>dn</var>: will hold the starting point of the DN
</p>
<p>This function will return a pointer to the DER encoded DN structure
and the length.
</p>
<p><strong>Returns:</strong> a negative error code on error, and (0) on success.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005fget_005fsignature-1"></span><h4 class="subheading">gnutls_x509_crl_get_signature</h4>
<span id="gnutls_005fx509_005fcrl_005fget_005fsignature"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005fget_005fsignature">Function: <em>int</em> <strong>gnutls_x509_crl_get_signature</strong> <em>(gnutls_x509_crl_t <var>crl</var>, char * <var>sig</var>, size_t * <var>sizeof_sig</var>)</em></dt>
<dd><p><var>crl</var>: should contain a gnutls_x509_crl_t type
</p>
<p><var>sig</var>: a pointer where the signature part will be copied (may be null).
</p>
<p><var>sizeof_sig</var>: initially holds the size of  <code>sig</code> 
</p>
<p>This function will extract the signature field of a CRL.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value. 
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005fget_005fsignature_005falgorithm-1"></span><h4 class="subheading">gnutls_x509_crl_get_signature_algorithm</h4>
<span id="gnutls_005fx509_005fcrl_005fget_005fsignature_005falgorithm"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005fget_005fsignature_005falgorithm">Function: <em>int</em> <strong>gnutls_x509_crl_get_signature_algorithm</strong> <em>(gnutls_x509_crl_t <var>crl</var>)</em></dt>
<dd><p><var>crl</var>: should contain a <code>gnutls_x509_crl_t</code>  type
</p>
<p>This function will return a value of the <code>gnutls_sign_algorithm_t</code> 
enumeration that is the signature algorithm.
</p>
<p>Since 3.6.0 this function never returns a negative error code.
Error cases and unknown/unsupported signature algorithms are
mapped to <code>GNUTLS_SIGN_UNKNOWN</code> .
</p>
<p><strong>Returns:</strong> a <code>gnutls_sign_algorithm_t</code>  value
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005fget_005fsignature_005foid-1"></span><h4 class="subheading">gnutls_x509_crl_get_signature_oid</h4>
<span id="gnutls_005fx509_005fcrl_005fget_005fsignature_005foid"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005fget_005fsignature_005foid">Function: <em>int</em> <strong>gnutls_x509_crl_get_signature_oid</strong> <em>(gnutls_x509_crl_t <var>crl</var>, char * <var>oid</var>, size_t * <var>oid_size</var>)</em></dt>
<dd><p><var>crl</var>: should contain a <code>gnutls_x509_crl_t</code>  type
</p>
<p><var>oid</var>: a pointer to a buffer to hold the OID (may be null)
</p>
<p><var>oid_size</var>: initially holds the size of  <code>oid</code> 
</p>
<p>This function will return the OID of the signature algorithm
that has been used to sign this CRL. This is function
is useful in the case <code>gnutls_x509_crl_get_signature_algorithm()</code> 
returned <code>GNUTLS_SIGN_UNKNOWN</code> .
</p>
<p><strong>Returns:</strong> zero or a negative error code on error.
</p>
<p><strong>Since:</strong> 3.5.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005fget_005fthis_005fupdate-1"></span><h4 class="subheading">gnutls_x509_crl_get_this_update</h4>
<span id="gnutls_005fx509_005fcrl_005fget_005fthis_005fupdate"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005fget_005fthis_005fupdate">Function: <em>time_t</em> <strong>gnutls_x509_crl_get_this_update</strong> <em>(gnutls_x509_crl_t <var>crl</var>)</em></dt>
<dd><p><var>crl</var>: should contain a <code>gnutls_x509_crl_t</code>  type
</p>
<p>This function will return the time this CRL was issued.
</p>
<p><strong>Returns:</strong> when the CRL was issued, or (time_t)-1 on error.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005fget_005fversion-1"></span><h4 class="subheading">gnutls_x509_crl_get_version</h4>
<span id="gnutls_005fx509_005fcrl_005fget_005fversion"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005fget_005fversion">Function: <em>int</em> <strong>gnutls_x509_crl_get_version</strong> <em>(gnutls_x509_crl_t <var>crl</var>)</em></dt>
<dd><p><var>crl</var>: should contain a <code>gnutls_x509_crl_t</code>  type
</p>
<p>This function will return the version of the specified CRL.
</p>
<p><strong>Returns:</strong> The version number, or a negative error code on error.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005fimport-1"></span><h4 class="subheading">gnutls_x509_crl_import</h4>
<span id="gnutls_005fx509_005fcrl_005fimport"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005fimport">Function: <em>int</em> <strong>gnutls_x509_crl_import</strong> <em>(gnutls_x509_crl_t <var>crl</var>, const gnutls_datum_t * <var>data</var>, gnutls_x509_crt_fmt_t <var>format</var>)</em></dt>
<dd><p><var>crl</var>: The data to store the parsed CRL.
</p>
<p><var>data</var>: The DER or PEM encoded CRL.
</p>
<p><var>format</var>: One of DER or PEM
</p>
<p>This function will convert the given DER or PEM encoded CRL
to the native <code>gnutls_x509_crl_t</code>  format. The output will be stored in &rsquo;crl&rsquo;.
</p>
<p>If the CRL is PEM encoded it should have a header of &quot;X509 CRL&quot;.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005finit-1"></span><h4 class="subheading">gnutls_x509_crl_init</h4>
<span id="gnutls_005fx509_005fcrl_005finit"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005finit">Function: <em>int</em> <strong>gnutls_x509_crl_init</strong> <em>(gnutls_x509_crl_t * <var>crl</var>)</em></dt>
<dd><p><var>crl</var>: A pointer to the type to be initialized
</p>
<p>This function will initialize a CRL structure. CRL stands for
Certificate Revocation List. A revocation list usually contains
lists of certificate serial numbers that have been revoked by an
Authority. The revocation lists are always signed with the
authority&rsquo;s private key.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005fiter_005fcrt_005fserial-1"></span><h4 class="subheading">gnutls_x509_crl_iter_crt_serial</h4>
<span id="gnutls_005fx509_005fcrl_005fiter_005fcrt_005fserial"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005fiter_005fcrt_005fserial">Function: <em>int</em> <strong>gnutls_x509_crl_iter_crt_serial</strong> <em>(gnutls_x509_crl_t <var>crl</var>, gnutls_x509_crl_iter_t * <var>iter</var>, unsigned char * <var>serial</var>, size_t * <var>serial_size</var>, time_t * <var>t</var>)</em></dt>
<dd><p><var>crl</var>: should contain a <code>gnutls_x509_crl_t</code>  type
</p>
<p><var>iter</var>: A pointer to an iterator (initially the iterator should be <code>NULL</code> )
</p>
<p><var>serial</var>: where the serial number will be copied
</p>
<p><var>serial_size</var>: initially holds the size of serial
</p>
<p><var>t</var>: if non null, will hold the time this certificate was revoked
</p>
<p>This function performs the same as <code>gnutls_x509_crl_get_crt_serial()</code> ,
but reads sequentially and keeps state in the iterator 
between calls. That allows it to provide better performance in sequences 
with many elements (50000+).
</p>
<p>When past the last element is accessed <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
is returned and the iterator is reset.
</p>
<p>After use, the iterator must be deinitialized using <code>gnutls_x509_crl_iter_deinit()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005fiter_005fdeinit-1"></span><h4 class="subheading">gnutls_x509_crl_iter_deinit</h4>
<span id="gnutls_005fx509_005fcrl_005fiter_005fdeinit"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005fiter_005fdeinit">Function: <em>void</em> <strong>gnutls_x509_crl_iter_deinit</strong> <em>(gnutls_x509_crl_iter_t <var>iter</var>)</em></dt>
<dd><p><var>iter</var>: The iterator to be deinitialized
</p>
<p>This function will deinitialize an iterator type.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005flist_005fimport-1"></span><h4 class="subheading">gnutls_x509_crl_list_import</h4>
<span id="gnutls_005fx509_005fcrl_005flist_005fimport"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005flist_005fimport">Function: <em>int</em> <strong>gnutls_x509_crl_list_import</strong> <em>(gnutls_x509_crl_t * <var>crls</var>, unsigned int * <var>crl_max</var>, const gnutls_datum_t * <var>data</var>, gnutls_x509_crt_fmt_t <var>format</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>crls</var>: Indicates where the parsed CRLs will be copied to. Must not be initialized.
</p>
<p><var>crl_max</var>: Initially must hold the maximum number of crls. It will be updated with the number of crls available.
</p>
<p><var>data</var>: The PEM encoded CRLs
</p>
<p><var>format</var>: One of DER or PEM.
</p>
<p><var>flags</var>: must be (0) or an OR&rsquo;d sequence of gnutls_certificate_import_flags.
</p>
<p>This function will convert the given PEM encoded CRL list
to the native gnutls_x509_crl_t format. The output will be stored
in  <code>crls</code> .  They will be automatically initialized.
</p>
<p>If the Certificate is PEM encoded it should have a header of &quot;X509 CRL&quot;.
</p>
<p><strong>Returns:</strong> the number of certificates read or a negative error value.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005flist_005fimport2-1"></span><h4 class="subheading">gnutls_x509_crl_list_import2</h4>
<span id="gnutls_005fx509_005fcrl_005flist_005fimport2"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005flist_005fimport2">Function: <em>int</em> <strong>gnutls_x509_crl_list_import2</strong> <em>(gnutls_x509_crl_t ** <var>crls</var>, unsigned int * <var>size</var>, const gnutls_datum_t * <var>data</var>, gnutls_x509_crt_fmt_t <var>format</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>crls</var>: Will contain the parsed crl list.
</p>
<p><var>size</var>: It will contain the size of the list.
</p>
<p><var>data</var>: The PEM encoded CRL.
</p>
<p><var>format</var>: One of DER or PEM.
</p>
<p><var>flags</var>: must be (0) or an OR&rsquo;d sequence of gnutls_certificate_import_flags.
</p>
<p>This function will convert the given PEM encoded CRL list
to the native gnutls_x509_crl_t format. The output will be stored
in  <code>crls</code> .  They will be automatically initialized.
</p>
<p>If the Certificate is PEM encoded it should have a header of &quot;X509
CRL&quot;.
</p>
<p><strong>Returns:</strong> the number of certificates read or a negative error value.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005fprint-1"></span><h4 class="subheading">gnutls_x509_crl_print</h4>
<span id="gnutls_005fx509_005fcrl_005fprint"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005fprint">Function: <em>int</em> <strong>gnutls_x509_crl_print</strong> <em>(gnutls_x509_crl_t <var>crl</var>, gnutls_certificate_print_formats_t <var>format</var>, gnutls_datum_t * <var>out</var>)</em></dt>
<dd><p><var>crl</var>: The data to be printed
</p>
<p><var>format</var>: Indicate the format to use
</p>
<p><var>out</var>: Newly allocated datum with null terminated string.
</p>
<p>This function will pretty print a X.509 certificate revocation
list, suitable for display to a human.
</p>
<p>The output  <code>out</code> needs to be deallocated using <code>gnutls_free()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005fset_005fauthority_005fkey_005fid-1"></span><h4 class="subheading">gnutls_x509_crl_set_authority_key_id</h4>
<span id="gnutls_005fx509_005fcrl_005fset_005fauthority_005fkey_005fid"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005fset_005fauthority_005fkey_005fid">Function: <em>int</em> <strong>gnutls_x509_crl_set_authority_key_id</strong> <em>(gnutls_x509_crl_t <var>crl</var>, const void * <var>id</var>, size_t <var>id_size</var>)</em></dt>
<dd><p><var>crl</var>: a CRL of type <code>gnutls_x509_crl_t</code> 
</p>
<p><var>id</var>: The key ID
</p>
<p><var>id_size</var>: Holds the size of the serial field.
</p>
<p>This function will set the CRL&rsquo;s authority key ID extension.  Only
the keyIdentifier field can be set with this function. This may
be used by an authority that holds multiple private keys, to distinguish
the used key.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005fset_005fcrt-1"></span><h4 class="subheading">gnutls_x509_crl_set_crt</h4>
<span id="gnutls_005fx509_005fcrl_005fset_005fcrt"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005fset_005fcrt">Function: <em>int</em> <strong>gnutls_x509_crl_set_crt</strong> <em>(gnutls_x509_crl_t <var>crl</var>, gnutls_x509_crt_t <var>crt</var>, time_t <var>revocation_time</var>)</em></dt>
<dd><p><var>crl</var>: should contain a gnutls_x509_crl_t type
</p>
<p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code>  with the revoked certificate
</p>
<p><var>revocation_time</var>: The time this certificate was revoked
</p>
<p>This function will set a revoked certificate&rsquo;s serial number to the CRL.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005fset_005fcrt_005fserial-1"></span><h4 class="subheading">gnutls_x509_crl_set_crt_serial</h4>
<span id="gnutls_005fx509_005fcrl_005fset_005fcrt_005fserial"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005fset_005fcrt_005fserial">Function: <em>int</em> <strong>gnutls_x509_crl_set_crt_serial</strong> <em>(gnutls_x509_crl_t <var>crl</var>, const void * <var>serial</var>, size_t <var>serial_size</var>, time_t <var>revocation_time</var>)</em></dt>
<dd><p><var>crl</var>: should contain a gnutls_x509_crl_t type
</p>
<p><var>serial</var>: The revoked certificate&rsquo;s serial number
</p>
<p><var>serial_size</var>: Holds the size of the serial field.
</p>
<p><var>revocation_time</var>: The time this certificate was revoked
</p>
<p>This function will set a revoked certificate&rsquo;s serial number to the CRL.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005fset_005fnext_005fupdate-1"></span><h4 class="subheading">gnutls_x509_crl_set_next_update</h4>
<span id="gnutls_005fx509_005fcrl_005fset_005fnext_005fupdate"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005fset_005fnext_005fupdate">Function: <em>int</em> <strong>gnutls_x509_crl_set_next_update</strong> <em>(gnutls_x509_crl_t <var>crl</var>, time_t <var>exp_time</var>)</em></dt>
<dd><p><var>crl</var>: should contain a gnutls_x509_crl_t type
</p>
<p><var>exp_time</var>: The actual time
</p>
<p>This function will set the time this CRL will be updated.
This is an optional value to be set on a CRL and this call
can be omitted when generating a CRL.
</p>
<p>Prior to GnuTLS 3.5.7, setting a nextUpdate field was required
in order to generate a CRL.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005fset_005fnumber-1"></span><h4 class="subheading">gnutls_x509_crl_set_number</h4>
<span id="gnutls_005fx509_005fcrl_005fset_005fnumber"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005fset_005fnumber">Function: <em>int</em> <strong>gnutls_x509_crl_set_number</strong> <em>(gnutls_x509_crl_t <var>crl</var>, const void * <var>nr</var>, size_t <var>nr_size</var>)</em></dt>
<dd><p><var>crl</var>: a CRL of type <code>gnutls_x509_crl_t</code> 
</p>
<p><var>nr</var>: The CRL number
</p>
<p><var>nr_size</var>: Holds the size of the nr field.
</p>
<p>This function will set the CRL&rsquo;s number extension. This
is to be used as a unique and monotonic number assigned to
the CRL by the authority.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005fset_005fthis_005fupdate-1"></span><h4 class="subheading">gnutls_x509_crl_set_this_update</h4>
<span id="gnutls_005fx509_005fcrl_005fset_005fthis_005fupdate"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005fset_005fthis_005fupdate">Function: <em>int</em> <strong>gnutls_x509_crl_set_this_update</strong> <em>(gnutls_x509_crl_t <var>crl</var>, time_t <var>act_time</var>)</em></dt>
<dd><p><var>crl</var>: should contain a gnutls_x509_crl_t type
</p>
<p><var>act_time</var>: The actual time
</p>
<p>This function will set the time this CRL was issued.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005fset_005fversion-1"></span><h4 class="subheading">gnutls_x509_crl_set_version</h4>
<span id="gnutls_005fx509_005fcrl_005fset_005fversion"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005fset_005fversion">Function: <em>int</em> <strong>gnutls_x509_crl_set_version</strong> <em>(gnutls_x509_crl_t <var>crl</var>, unsigned int <var>version</var>)</em></dt>
<dd><p><var>crl</var>: should contain a gnutls_x509_crl_t type
</p>
<p><var>version</var>: holds the version number. For CRLv1 crls must be 1.
</p>
<p>This function will set the version of the CRL. This
must be one for CRL version 1, and so on. The CRLs generated
by gnutls should have a version number of 2.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005fsign-1"></span><h4 class="subheading">gnutls_x509_crl_sign</h4>
<span id="gnutls_005fx509_005fcrl_005fsign"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005fsign">Function: <em>int</em> <strong>gnutls_x509_crl_sign</strong> <em>(gnutls_x509_crl_t <var>crl</var>, gnutls_x509_crt_t <var>issuer</var>, gnutls_x509_privkey_t <var>issuer_key</var>)</em></dt>
<dd><p><var>crl</var>: should contain a gnutls_x509_crl_t type
</p>
<p><var>issuer</var>: is the certificate of the certificate issuer
</p>
<p><var>issuer_key</var>: holds the issuer&rsquo;s private key
</p>
<p>This function is the same a <code>gnutls_x509_crl_sign2()</code>  with no flags,
and an appropriate hash algorithm. The hash algorithm used may
vary between versions of GnuTLS, and it is tied to the security
level of the issuer&rsquo;s public key.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005fsign2-1"></span><h4 class="subheading">gnutls_x509_crl_sign2</h4>
<span id="gnutls_005fx509_005fcrl_005fsign2"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005fsign2-1">Function: <em>int</em> <strong>gnutls_x509_crl_sign2</strong> <em>(gnutls_x509_crl_t <var>crl</var>, gnutls_x509_crt_t <var>issuer</var>, gnutls_x509_privkey_t <var>issuer_key</var>, gnutls_digest_algorithm_t <var>dig</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>crl</var>: should contain a gnutls_x509_crl_t type
</p>
<p><var>issuer</var>: is the certificate of the certificate issuer
</p>
<p><var>issuer_key</var>: holds the issuer&rsquo;s private key
</p>
<p><var>dig</var>: The message digest to use. GNUTLS_DIG_SHA256 is the safe choice unless you know what you&rsquo;re doing.
</p>
<p><var>flags</var>: must be 0
</p>
<p>This function will sign the CRL with the issuer&rsquo;s private key, and
will copy the issuer&rsquo;s information into the CRL.
</p>
<p>This must be the last step in a certificate CRL since all
the previously set parameters are now signed.
</p>
<p>A known limitation of this function is, that a newly-signed CRL will not
be fully functional (e.g., for signature verification), until it
is exported an re-imported.
</p>
<p>After GnuTLS 3.6.1 the value of  <code>dig</code> may be <code>GNUTLS_DIG_UNKNOWN</code> ,
and in that case, a suitable but reasonable for the key algorithm will be selected.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005fverify-1"></span><h4 class="subheading">gnutls_x509_crl_verify</h4>
<span id="gnutls_005fx509_005fcrl_005fverify"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005fverify">Function: <em>int</em> <strong>gnutls_x509_crl_verify</strong> <em>(gnutls_x509_crl_t <var>crl</var>, const gnutls_x509_crt_t * <var>trusted_cas</var>, unsigned <var>tcas_size</var>, unsigned int <var>flags</var>, unsigned int * <var>verify</var>)</em></dt>
<dd><p><var>crl</var>: is the crl to be verified
</p>
<p><var>trusted_cas</var>: is a certificate list that is considered to be trusted one
</p>
<p><var>tcas_size</var>: holds the number of CA certificates in CA_list
</p>
<p><var>flags</var>: Flags that may be used to change the verification algorithm. Use OR of the gnutls_certificate_verify_flags enumerations.
</p>
<p><var>verify</var>: will hold the crl verification output.
</p>
<p>This function will try to verify the given crl and return its verification status.
See <code>gnutls_x509_crt_list_verify()</code>  for a detailed description of
return values. Note that since GnuTLS 3.1.4 this function includes
the time checks.
</p>
<p>Note that value in  <code>verify</code> is set only when the return value of this 
function is success (i.e, failure to trust a CRL a certificate does not imply 
a negative return value).
</p>
<p>Before GnuTLS 3.5.7 this function would return zero or a positive
number on success.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0), otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fdeinit-1"></span><h4 class="subheading">gnutls_x509_crq_deinit</h4>
<span id="gnutls_005fx509_005fcrq_005fdeinit"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fdeinit">Function: <em>void</em> <strong>gnutls_x509_crq_deinit</strong> <em>(gnutls_x509_crq_t <var>crq</var>)</em></dt>
<dd><p><var>crq</var>: the type to be deinitialized
</p>
<p>This function will deinitialize a PKCS<code>10</code>  certificate request
structure.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fexport-1"></span><h4 class="subheading">gnutls_x509_crq_export</h4>
<span id="gnutls_005fx509_005fcrq_005fexport"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fexport">Function: <em>int</em> <strong>gnutls_x509_crq_export</strong> <em>(gnutls_x509_crq_t <var>crq</var>, gnutls_x509_crt_fmt_t <var>format</var>, void * <var>output_data</var>, size_t * <var>output_data_size</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>format</var>: the format of output params. One of PEM or DER.
</p>
<p><var>output_data</var>: will contain a certificate request PEM or DER encoded
</p>
<p><var>output_data_size</var>: holds the size of output_data (and will be
replaced by the actual size of parameters)
</p>
<p>This function will export the certificate request to a PEM or DER
encoded PKCS10 structure.
</p>
<p>If the buffer provided is not long enough to hold the output, then
<code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  will be returned and
* <code>output_data_size</code> will be updated.
</p>
<p>If the structure is PEM encoded, it will have a header of &quot;BEGIN
NEW CERTIFICATE REQUEST&quot;.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fexport2-1"></span><h4 class="subheading">gnutls_x509_crq_export2</h4>
<span id="gnutls_005fx509_005fcrq_005fexport2"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fexport2">Function: <em>int</em> <strong>gnutls_x509_crq_export2</strong> <em>(gnutls_x509_crq_t <var>crq</var>, gnutls_x509_crt_fmt_t <var>format</var>, gnutls_datum_t * <var>out</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>format</var>: the format of output params. One of PEM or DER.
</p>
<p><var>out</var>: will contain a certificate request PEM or DER encoded
</p>
<p>This function will export the certificate request to a PEM or DER
encoded PKCS10 structure.
</p>
<p>The output buffer is allocated using <code>gnutls_malloc()</code> .
</p>
<p>If the structure is PEM encoded, it will have a header of &quot;BEGIN
NEW CERTIFICATE REQUEST&quot;.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p>Since 3.1.3
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fget_005fattribute_005fby_005foid-1"></span><h4 class="subheading">gnutls_x509_crq_get_attribute_by_oid</h4>
<span id="gnutls_005fx509_005fcrq_005fget_005fattribute_005fby_005foid"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fget_005fattribute_005fby_005foid">Function: <em>int</em> <strong>gnutls_x509_crq_get_attribute_by_oid</strong> <em>(gnutls_x509_crq_t <var>crq</var>, const char * <var>oid</var>, unsigned <var>indx</var>, void * <var>buf</var>, size_t * <var>buf_size</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>oid</var>: holds an Object Identifier in null-terminated string
</p>
<p><var>indx</var>: In case multiple same OIDs exist in the attribute list, this
specifies which to get, use (0) to get the first one
</p>
<p><var>buf</var>: a pointer to a structure to hold the attribute data (may be <code>NULL</code> )
</p>
<p><var>buf_size</var>: initially holds the size of  <code>buf</code> 
</p>
<p>This function will return the attribute in the certificate request
specified by the given Object ID.  The attribute will be DER
encoded.
</p>
<p>Attributes in a certificate request is an optional set of data
appended to the request. Their interpretation depends on the CA policy.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fget_005fattribute_005fdata-1"></span><h4 class="subheading">gnutls_x509_crq_get_attribute_data</h4>
<span id="gnutls_005fx509_005fcrq_005fget_005fattribute_005fdata"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fget_005fattribute_005fdata">Function: <em>int</em> <strong>gnutls_x509_crq_get_attribute_data</strong> <em>(gnutls_x509_crq_t <var>crq</var>, unsigned <var>indx</var>, void * <var>data</var>, size_t * <var>sizeof_data</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>indx</var>: Specifies which attribute number to get. Use (0) to get the first one.
</p>
<p><var>data</var>: a pointer to a structure to hold the data (may be null)
</p>
<p><var>sizeof_data</var>: initially holds the size of  <code>oid</code> 
</p>
<p>This function will return the requested attribute data in the
certificate request.  The attribute data will be stored as a string in the
provided buffer.
</p>
<p>Use <code>gnutls_x509_crq_get_attribute_info()</code>  to extract the OID.
Use <code>gnutls_x509_crq_get_attribute_by_oid()</code>  instead,
if you want to get data indexed by the attribute OID rather than
sequence.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error code in case of an error.  If your have reached the
last extension available <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
will be returned.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fget_005fattribute_005finfo-1"></span><h4 class="subheading">gnutls_x509_crq_get_attribute_info</h4>
<span id="gnutls_005fx509_005fcrq_005fget_005fattribute_005finfo"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fget_005fattribute_005finfo">Function: <em>int</em> <strong>gnutls_x509_crq_get_attribute_info</strong> <em>(gnutls_x509_crq_t <var>crq</var>, unsigned <var>indx</var>, void * <var>oid</var>, size_t * <var>sizeof_oid</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>indx</var>: Specifies which attribute number to get. Use (0) to get the first one.
</p>
<p><var>oid</var>: a pointer to a structure to hold the OID
</p>
<p><var>sizeof_oid</var>: initially holds the maximum size of  <code>oid</code> , on return
holds actual size of  <code>oid</code> .
</p>
<p>This function will return the requested attribute OID in the
certificate, and the critical flag for it.  The attribute OID will
be stored as a string in the provided buffer.  Use
<code>gnutls_x509_crq_get_attribute_data()</code>  to extract the data.
</p>
<p>If the buffer provided is not long enough to hold the output, then
* <code>sizeof_oid</code> is updated and <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  will be
returned.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error code in case of an error.  If your have reached the
last extension available <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
will be returned.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fget_005fbasic_005fconstraints-1"></span><h4 class="subheading">gnutls_x509_crq_get_basic_constraints</h4>
<span id="gnutls_005fx509_005fcrq_005fget_005fbasic_005fconstraints"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fget_005fbasic_005fconstraints">Function: <em>int</em> <strong>gnutls_x509_crq_get_basic_constraints</strong> <em>(gnutls_x509_crq_t <var>crq</var>, unsigned int * <var>critical</var>, unsigned int * <var>ca</var>, int * <var>pathlen</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical
</p>
<p><var>ca</var>: pointer to output integer indicating CA status, may be NULL,
value is 1 if the certificate CA flag is set, 0 otherwise.
</p>
<p><var>pathlen</var>: pointer to output integer indicating path length (may be
NULL), non-negative error codes indicate a present pathLenConstraint
field and the actual value, -1 indicate that the field is absent.
</p>
<p>This function will read the certificate&rsquo;s basic constraints, and
return the certificates CA status.  It reads the basicConstraints
X.509 extension (2.5.29.19).
</p>
<p><strong>Returns:</strong> If the certificate is a CA a positive value will be
returned, or (0) if the certificate does not have CA flag set.
A negative error code may be returned in case of errors.  If the
certificate does not contain the basicConstraints extension
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  will be returned.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fget_005fchallenge_005fpassword-1"></span><h4 class="subheading">gnutls_x509_crq_get_challenge_password</h4>
<span id="gnutls_005fx509_005fcrq_005fget_005fchallenge_005fpassword"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fget_005fchallenge_005fpassword">Function: <em>int</em> <strong>gnutls_x509_crq_get_challenge_password</strong> <em>(gnutls_x509_crq_t <var>crq</var>, char * <var>pass</var>, size_t * <var>pass_size</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>pass</var>: will hold a (0)-terminated password string
</p>
<p><var>pass_size</var>: Initially holds the size of  <code>pass</code> .
</p>
<p>This function will return the challenge password in the request.
The challenge password is intended to be used for requesting a
revocation of the certificate.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fget_005fdn-1"></span><h4 class="subheading">gnutls_x509_crq_get_dn</h4>
<span id="gnutls_005fx509_005fcrq_005fget_005fdn"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fget_005fdn">Function: <em>int</em> <strong>gnutls_x509_crq_get_dn</strong> <em>(gnutls_x509_crq_t <var>crq</var>, char * <var>buf</var>, size_t * <var>buf_size</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>buf</var>: a pointer to a structure to hold the name (may be <code>NULL</code> )
</p>
<p><var>buf_size</var>: initially holds the size of  <code>buf</code> 
</p>
<p>This function will copy the name of the Certificate request subject
to the provided buffer.  The name will be in the form
&quot;C=xxxx,O=yyyy,CN=zzzz&quot; as described in RFC 2253. The output string
 <code>buf</code> will be ASCII or UTF-8 encoded, depending on the certificate
data.
</p>
<p>This function does not output a fully RFC4514 compliant string, if
that is required see <code>gnutls_x509_crq_get_dn3()</code> .
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if the provided buffer is not
long enough, and in that case the * <code>buf_size</code> will be updated with
the required size.  On success 0 is returned.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fget_005fdn2-1"></span><h4 class="subheading">gnutls_x509_crq_get_dn2</h4>
<span id="gnutls_005fx509_005fcrq_005fget_005fdn2"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fget_005fdn2">Function: <em>int</em> <strong>gnutls_x509_crq_get_dn2</strong> <em>(gnutls_x509_crq_t <var>crq</var>, gnutls_datum_t * <var>dn</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>dn</var>: a pointer to a structure to hold the name
</p>
<p>This function will allocate buffer and copy the name of the Certificate 
request. The name will be in the form &quot;C=xxxx,O=yyyy,CN=zzzz&quot; as
described in RFC4514. The output string will be ASCII or UTF-8
encoded, depending on the certificate data.
</p>
<p>This function does not output a fully RFC4514 compliant string, if
that is required see <code>gnutls_x509_crq_get_dn3()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value. and a negative error code on error.
</p>
<p><strong>Since:</strong> 3.1.10
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fget_005fdn3-1"></span><h4 class="subheading">gnutls_x509_crq_get_dn3</h4>
<span id="gnutls_005fx509_005fcrq_005fget_005fdn3"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fget_005fdn3">Function: <em>int</em> <strong>gnutls_x509_crq_get_dn3</strong> <em>(gnutls_x509_crq_t <var>crq</var>, gnutls_datum_t * <var>dn</var>, unsigned <var>flags</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>dn</var>: a pointer to a structure to hold the name
</p>
<p><var>flags</var>: zero or <code>GNUTLS_X509_DN_FLAG_COMPAT</code> 
</p>
<p>This function will allocate buffer and copy the name of the Certificate 
request. The name will be in the form &quot;C=xxxx,O=yyyy,CN=zzzz&quot; as
described in RFC4514. The output string will be ASCII or UTF-8
encoded, depending on the certificate data.
</p>
<p>When the flag <code>GNUTLS_X509_DN_FLAG_COMPAT</code>  is specified, the output
format will match the format output by previous to 3.5.6 versions of GnuTLS
which was not not fully RFC4514-compliant.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value. and a negative error code on error.
</p>
<p><strong>Since:</strong> 3.5.7
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fget_005fdn_005fby_005foid-1"></span><h4 class="subheading">gnutls_x509_crq_get_dn_by_oid</h4>
<span id="gnutls_005fx509_005fcrq_005fget_005fdn_005fby_005foid"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fget_005fdn_005fby_005foid">Function: <em>int</em> <strong>gnutls_x509_crq_get_dn_by_oid</strong> <em>(gnutls_x509_crq_t <var>crq</var>, const char * <var>oid</var>, unsigned <var>indx</var>, unsigned int <var>raw_flag</var>, void * <var>buf</var>, size_t * <var>buf_size</var>)</em></dt>
<dd><p><var>crq</var>: should contain a gnutls_x509_crq_t type
</p>
<p><var>oid</var>: holds an Object Identifier in a null terminated string
</p>
<p><var>indx</var>: In case multiple same OIDs exist in the RDN, this specifies
which to get. Use (0) to get the first one.
</p>
<p><var>raw_flag</var>: If non-zero returns the raw DER data of the DN part.
</p>
<p><var>buf</var>: a pointer to a structure to hold the name (may be <code>NULL</code> )
</p>
<p><var>buf_size</var>: initially holds the size of  <code>buf</code> 
</p>
<p>This function will extract the part of the name of the Certificate
request subject, specified by the given OID. The output will be
encoded as described in RFC2253. The output string will be ASCII
or UTF-8 encoded, depending on the certificate data.
</p>
<p>Some helper macros with popular OIDs can be found in gnutls/x509.h
If raw flag is (0), this function will only return known OIDs as
text. Other OIDs will be DER encoded, as described in RFC2253 &ndash;
in hex format with a &rsquo;\#&rsquo; prefix.  You can check about known OIDs
using <code>gnutls_x509_dn_oid_known()</code> .
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if the provided buffer is
not long enough, and in that case the * <code>buf_size</code> will be
updated with the required size.  On success 0 is returned.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fget_005fdn_005foid-1"></span><h4 class="subheading">gnutls_x509_crq_get_dn_oid</h4>
<span id="gnutls_005fx509_005fcrq_005fget_005fdn_005foid"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fget_005fdn_005foid">Function: <em>int</em> <strong>gnutls_x509_crq_get_dn_oid</strong> <em>(gnutls_x509_crq_t <var>crq</var>, unsigned <var>indx</var>, void * <var>oid</var>, size_t * <var>sizeof_oid</var>)</em></dt>
<dd><p><var>crq</var>: should contain a gnutls_x509_crq_t type
</p>
<p><var>indx</var>: Specifies which DN OID to get. Use (0) to get the first one.
</p>
<p><var>oid</var>: a pointer to a structure to hold the name (may be <code>NULL</code> )
</p>
<p><var>sizeof_oid</var>: initially holds the size of  <code>oid</code> 
</p>
<p>This function will extract the requested OID of the name of the
certificate request subject, specified by the given index.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if the provided buffer is
not long enough, and in that case the * <code>sizeof_oid</code> will be
updated with the required size.  On success 0 is returned.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fget_005fextension_005fby_005foid-1"></span><h4 class="subheading">gnutls_x509_crq_get_extension_by_oid</h4>
<span id="gnutls_005fx509_005fcrq_005fget_005fextension_005fby_005foid"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fget_005fextension_005fby_005foid">Function: <em>int</em> <strong>gnutls_x509_crq_get_extension_by_oid</strong> <em>(gnutls_x509_crq_t <var>crq</var>, const char * <var>oid</var>, unsigned <var>indx</var>, void * <var>buf</var>, size_t * <var>buf_size</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>oid</var>: holds an Object Identifier in a null terminated string
</p>
<p><var>indx</var>: In case multiple same OIDs exist in the extensions, this
specifies which to get. Use (0) to get the first one.
</p>
<p><var>buf</var>: a pointer to a structure to hold the name (may be null)
</p>
<p><var>buf_size</var>: initially holds the size of  <code>buf</code> 
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical
</p>
<p>This function will return the extension specified by the OID in
the certificate.  The extensions will be returned as binary data
DER encoded, in the provided buffer.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error code in case of an error.  If the certificate does not
contain the specified extension
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  will be returned.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fget_005fextension_005fby_005foid2-1"></span><h4 class="subheading">gnutls_x509_crq_get_extension_by_oid2</h4>
<span id="gnutls_005fx509_005fcrq_005fget_005fextension_005fby_005foid2"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fget_005fextension_005fby_005foid2">Function: <em>int</em> <strong>gnutls_x509_crq_get_extension_by_oid2</strong> <em>(gnutls_x509_crq_t <var>crq</var>, const char * <var>oid</var>, unsigned <var>indx</var>, gnutls_datum_t * <var>output</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>oid</var>: holds an Object Identifier in a null terminated string
</p>
<p><var>indx</var>: In case multiple same OIDs exist in the extensions, this
specifies which to get. Use (0) to get the first one.
</p>
<p><var>output</var>: will hold the allocated extension data
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical
</p>
<p>This function will return the extension specified by the OID in
the certificate.  The extensions will be returned as binary data
DER encoded, in the provided buffer.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error code in case of an error.  If the certificate does not
contain the specified extension
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  will be returned.
</p>
<p><strong>Since:</strong> 3.3.8
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fget_005fextension_005fdata-1"></span><h4 class="subheading">gnutls_x509_crq_get_extension_data</h4>
<span id="gnutls_005fx509_005fcrq_005fget_005fextension_005fdata"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fget_005fextension_005fdata">Function: <em>int</em> <strong>gnutls_x509_crq_get_extension_data</strong> <em>(gnutls_x509_crq_t <var>crq</var>, unsigned <var>indx</var>, void * <var>data</var>, size_t * <var>sizeof_data</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>indx</var>: Specifies which extension number to get. Use (0) to get the first one.
</p>
<p><var>data</var>: a pointer to a structure to hold the data (may be null)
</p>
<p><var>sizeof_data</var>: initially holds the size of  <code>oid</code> 
</p>
<p>This function will return the requested extension data in the
certificate.  The extension data will be stored as a string in the
provided buffer.
</p>
<p>Use <code>gnutls_x509_crq_get_extension_info()</code>  to extract the OID and
critical flag.  Use <code>gnutls_x509_crq_get_extension_by_oid()</code>  instead,
if you want to get data indexed by the extension OID rather than
sequence.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error code in case of an error.  If your have reached the
last extension available <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
will be returned.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fget_005fextension_005fdata2-1"></span><h4 class="subheading">gnutls_x509_crq_get_extension_data2</h4>
<span id="gnutls_005fx509_005fcrq_005fget_005fextension_005fdata2"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fget_005fextension_005fdata2">Function: <em>int</em> <strong>gnutls_x509_crq_get_extension_data2</strong> <em>(gnutls_x509_crq_t <var>crq</var>, unsigned <var>indx</var>, gnutls_datum_t * <var>data</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>indx</var>: Specifies which extension OID to read. Use (0) to get the first one.
</p>
<p><var>data</var>: will contain the extension DER-encoded data
</p>
<p>This function will return the requested extension data in the
certificate request.  The extension data will be allocated using
<code>gnutls_malloc()</code> .
</p>
<p>Use <code>gnutls_x509_crq_get_extension_info()</code>  to extract the OID.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.  If you have reached the
last extension available <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
will be returned.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fget_005fextension_005finfo-1"></span><h4 class="subheading">gnutls_x509_crq_get_extension_info</h4>
<span id="gnutls_005fx509_005fcrq_005fget_005fextension_005finfo"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fget_005fextension_005finfo">Function: <em>int</em> <strong>gnutls_x509_crq_get_extension_info</strong> <em>(gnutls_x509_crq_t <var>crq</var>, unsigned <var>indx</var>, void * <var>oid</var>, size_t * <var>sizeof_oid</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>indx</var>: Specifies which extension number to get. Use (0) to get the first one.
</p>
<p><var>oid</var>: a pointer to store the OID
</p>
<p><var>sizeof_oid</var>: initially holds the maximum size of  <code>oid</code> , on return
holds actual size of  <code>oid</code> .
</p>
<p><var>critical</var>: output variable with critical flag, may be NULL.
</p>
<p>This function will return the requested extension OID in the
certificate, and the critical flag for it.  The extension OID will
be stored as a string in the provided buffer.  Use
<code>gnutls_x509_crq_get_extension_data()</code>  to extract the data.
</p>
<p>If the buffer provided is not long enough to hold the output, then
* <code>sizeof_oid</code> is updated and <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  will be
returned.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error code in case of an error.  If your have reached the
last extension available <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
will be returned.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fget_005fkey_005fid-1"></span><h4 class="subheading">gnutls_x509_crq_get_key_id</h4>
<span id="gnutls_005fx509_005fcrq_005fget_005fkey_005fid"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fget_005fkey_005fid">Function: <em>int</em> <strong>gnutls_x509_crq_get_key_id</strong> <em>(gnutls_x509_crq_t <var>crq</var>, unsigned int <var>flags</var>, unsigned char * <var>output_data</var>, size_t * <var>output_data_size</var>)</em></dt>
<dd><p><var>crq</var>: a certificate of type <code>gnutls_x509_crq_t</code> 
</p>
<p><var>flags</var>: should be one of the flags from <code>gnutls_keyid_flags_t</code> 
</p>
<p><var>output_data</var>: will contain the key ID
</p>
<p><var>output_data_size</var>: holds the size of output_data (and will be
replaced by the actual size of parameters)
</p>
<p>This function will return a unique ID that depends on the public key
parameters.  This ID can be used in checking whether a certificate
corresponds to the given private key.
</p>
<p>If the buffer provided is not long enough to hold the output, then
* <code>output_data_size</code> is updated and GNUTLS_E_SHORT_MEMORY_BUFFER will
be returned.  The output will normally be a SHA-1 hash output,
which is 20 bytes.
</p>
<p><strong>Returns:</strong> In case of failure a negative error code will be
returned, and 0 on success.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fget_005fkey_005fpurpose_005foid-1"></span><h4 class="subheading">gnutls_x509_crq_get_key_purpose_oid</h4>
<span id="gnutls_005fx509_005fcrq_005fget_005fkey_005fpurpose_005foid"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fget_005fkey_005fpurpose_005foid">Function: <em>int</em> <strong>gnutls_x509_crq_get_key_purpose_oid</strong> <em>(gnutls_x509_crq_t <var>crq</var>, unsigned <var>indx</var>, void * <var>oid</var>, size_t * <var>sizeof_oid</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>indx</var>: This specifies which OID to return, use (0) to get the first one
</p>
<p><var>oid</var>: a pointer to store the OID (may be <code>NULL</code> )
</p>
<p><var>sizeof_oid</var>: initially holds the size of  <code>oid</code> 
</p>
<p><var>critical</var>: output variable with critical flag, may be <code>NULL</code> .
</p>
<p>This function will extract the key purpose OIDs of the Certificate
specified by the given index.  These are stored in the Extended Key
Usage extension (2.5.29.37).  See the GNUTLS_KP_* definitions for
human readable names.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if the provided buffer is
not long enough, and in that case the * <code>sizeof_oid</code> will be
updated with the required size.  On success 0 is returned.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fget_005fkey_005frsa_005fraw-1"></span><h4 class="subheading">gnutls_x509_crq_get_key_rsa_raw</h4>
<span id="gnutls_005fx509_005fcrq_005fget_005fkey_005frsa_005fraw"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fget_005fkey_005frsa_005fraw">Function: <em>int</em> <strong>gnutls_x509_crq_get_key_rsa_raw</strong> <em>(gnutls_x509_crq_t <var>crq</var>, gnutls_datum_t * <var>m</var>, gnutls_datum_t * <var>e</var>)</em></dt>
<dd><p><var>crq</var>: Holds the certificate
</p>
<p><var>m</var>: will hold the modulus
</p>
<p><var>e</var>: will hold the public exponent
</p>
<p>This function will export the RSA public key&rsquo;s parameters found in
the given structure.  The new parameters will be allocated using
<code>gnutls_malloc()</code>  and will be stored in the appropriate datum.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fget_005fkey_005fusage-1"></span><h4 class="subheading">gnutls_x509_crq_get_key_usage</h4>
<span id="gnutls_005fx509_005fcrq_005fget_005fkey_005fusage"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fget_005fkey_005fusage">Function: <em>int</em> <strong>gnutls_x509_crq_get_key_usage</strong> <em>(gnutls_x509_crq_t <var>crq</var>, unsigned int * <var>key_usage</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>key_usage</var>: where the key usage bits will be stored
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical
</p>
<p>This function will return certificate&rsquo;s key usage, by reading the
keyUsage X.509 extension (2.5.29.15).  The key usage value will
ORed values of the: <code>GNUTLS_KEY_DIGITAL_SIGNATURE</code> ,
<code>GNUTLS_KEY_NON_REPUDIATION</code> , <code>GNUTLS_KEY_KEY_ENCIPHERMENT</code> ,
<code>GNUTLS_KEY_DATA_ENCIPHERMENT</code> , <code>GNUTLS_KEY_KEY_AGREEMENT</code> ,
<code>GNUTLS_KEY_KEY_CERT_SIGN</code> , <code>GNUTLS_KEY_CRL_SIGN</code> ,
<code>GNUTLS_KEY_ENCIPHER_ONLY</code> , <code>GNUTLS_KEY_DECIPHER_ONLY</code> .
</p>
<p><strong>Returns:</strong> the certificate key usage, or a negative error code in case of
parsing error.  If the certificate does not contain the keyUsage
extension <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  will be
returned.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fget_005fpk_005falgorithm-1"></span><h4 class="subheading">gnutls_x509_crq_get_pk_algorithm</h4>
<span id="gnutls_005fx509_005fcrq_005fget_005fpk_005falgorithm"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fget_005fpk_005falgorithm">Function: <em>int</em> <strong>gnutls_x509_crq_get_pk_algorithm</strong> <em>(gnutls_x509_crq_t <var>crq</var>, unsigned int * <var>bits</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>bits</var>: if bits is non-<code>NULL</code>  it will hold the size of the parameters&rsquo; in bits
</p>
<p>This function will return the public key algorithm of a PKCS<code>10</code> 
certificate request.
</p>
<p>If bits is non-<code>NULL</code> , it should have enough size to hold the
parameters size in bits.  For RSA the bits returned is the modulus.
For DSA the bits returned are of the public exponent.
</p>
<p><strong>Returns:</strong> a member of the <code>gnutls_pk_algorithm_t</code>  enumeration on
success, or a negative error code on error.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fget_005fpk_005foid-1"></span><h4 class="subheading">gnutls_x509_crq_get_pk_oid</h4>
<span id="gnutls_005fx509_005fcrq_005fget_005fpk_005foid"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fget_005fpk_005foid">Function: <em>int</em> <strong>gnutls_x509_crq_get_pk_oid</strong> <em>(gnutls_x509_crq_t <var>crq</var>, char * <var>oid</var>, size_t * <var>oid_size</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>oid</var>: a pointer to a buffer to hold the OID (may be null)
</p>
<p><var>oid_size</var>: initially holds the size of  <code>oid</code> 
</p>
<p>This function will return the OID of the public key algorithm
on that certificate request. This is function
is useful in the case <code>gnutls_x509_crq_get_pk_algorithm()</code> 
returned <code>GNUTLS_PK_UNKNOWN</code> .
</p>
<p><strong>Returns:</strong> zero or a negative error code on error.
</p>
<p><strong>Since:</strong> 3.5.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fget_005fprivate_005fkey_005fusage_005fperiod-1"></span><h4 class="subheading">gnutls_x509_crq_get_private_key_usage_period</h4>
<span id="gnutls_005fx509_005fcrq_005fget_005fprivate_005fkey_005fusage_005fperiod"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fget_005fprivate_005fkey_005fusage_005fperiod">Function: <em>int</em> <strong>gnutls_x509_crq_get_private_key_usage_period</strong> <em>(gnutls_x509_crq_t <var>crq</var>, time_t * <var>activation</var>, time_t * <var>expiration</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>activation</var>: The activation time
</p>
<p><var>expiration</var>: The expiration time
</p>
<p><var>critical</var>: the extension status
</p>
<p>This function will return the expiration and activation
times of the private key of the certificate.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
if the extension is not present, otherwise a negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fget_005fsignature_005falgorithm-1"></span><h4 class="subheading">gnutls_x509_crq_get_signature_algorithm</h4>
<span id="gnutls_005fx509_005fcrq_005fget_005fsignature_005falgorithm"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fget_005fsignature_005falgorithm">Function: <em>int</em> <strong>gnutls_x509_crq_get_signature_algorithm</strong> <em>(gnutls_x509_crq_t <var>crq</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_cr_t</code>  type
</p>
<p>This function will return a value of the <code>gnutls_sign_algorithm_t</code> 
enumeration that is the signature algorithm that has been used to
sign this certificate request.
</p>
<p>Since 3.6.0 this function never returns a negative error code.
Error cases and unknown/unsupported signature algorithms are
mapped to <code>GNUTLS_SIGN_UNKNOWN</code> .
</p>
<p><strong>Returns:</strong> a <code>gnutls_sign_algorithm_t</code>  value
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fget_005fsignature_005foid-1"></span><h4 class="subheading">gnutls_x509_crq_get_signature_oid</h4>
<span id="gnutls_005fx509_005fcrq_005fget_005fsignature_005foid"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fget_005fsignature_005foid">Function: <em>int</em> <strong>gnutls_x509_crq_get_signature_oid</strong> <em>(gnutls_x509_crq_t <var>crq</var>, char * <var>oid</var>, size_t * <var>oid_size</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>oid</var>: a pointer to a buffer to hold the OID (may be null)
</p>
<p><var>oid_size</var>: initially holds the size of  <code>oid</code> 
</p>
<p>This function will return the OID of the signature algorithm
that has been used to sign this certificate request. This is function
is useful in the case <code>gnutls_x509_crq_get_signature_algorithm()</code> 
returned <code>GNUTLS_SIGN_UNKNOWN</code> .
</p>
<p><strong>Returns:</strong> zero or a negative error code on error.
</p>
<p><strong>Since:</strong> 3.5.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fget_005fspki-1"></span><h4 class="subheading">gnutls_x509_crq_get_spki</h4>
<span id="gnutls_005fx509_005fcrq_005fget_005fspki"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fget_005fspki">Function: <em>int</em> <strong>gnutls_x509_crq_get_spki</strong> <em>(gnutls_x509_crq_t <var>crq</var>, gnutls_x509_spki_t <var>spki</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>spki</var>: a SubjectPublicKeyInfo structure of type <code>gnutls_x509_spki_t</code> 
</p>
<p><var>flags</var>: must be zero
</p>
<p>This function will return the public key information of a PKCS<code>10</code> 
certificate request. The provided  <code>spki</code> must be initialized.
</p>
<p><strong>Returns:</strong> Zero on success, or a negative error code on error.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fget_005fsubject_005falt_005fname-1"></span><h4 class="subheading">gnutls_x509_crq_get_subject_alt_name</h4>
<span id="gnutls_005fx509_005fcrq_005fget_005fsubject_005falt_005fname"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fget_005fsubject_005falt_005fname">Function: <em>int</em> <strong>gnutls_x509_crq_get_subject_alt_name</strong> <em>(gnutls_x509_crq_t <var>crq</var>, unsigned int <var>seq</var>, void * <var>ret</var>, size_t * <var>ret_size</var>, unsigned int * <var>ret_type</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>seq</var>: specifies the sequence number of the alt name, 0 for the
first one, 1 for the second etc.
</p>
<p><var>ret</var>: is the place where the alternative name will be copied to
</p>
<p><var>ret_size</var>: holds the size of ret.
</p>
<p><var>ret_type</var>: holds the <code>gnutls_x509_subject_alt_name_t</code>  name type
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical
(may be null)
</p>
<p>This function will return the alternative names, contained in the
given certificate.  It is the same as
<code>gnutls_x509_crq_get_subject_alt_name()</code>  except for the fact that it
will return the type of the alternative name in  <code>ret_type</code> even if
the function fails for some reason (i.e.  the buffer provided is
not enough).
</p>
<p><strong>Returns:</strong> the alternative subject name type on success, one of the
enumerated <code>gnutls_x509_subject_alt_name_t</code> .  It will return
<code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if  <code>ret_size</code> is not large enough to
hold the value.  In that case  <code>ret_size</code> will be updated with the
required size.  If the certificate request does not have an
Alternative name with the specified sequence number then
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  is returned.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fget_005fsubject_005falt_005fothername_005foid-1"></span><h4 class="subheading">gnutls_x509_crq_get_subject_alt_othername_oid</h4>
<span id="gnutls_005fx509_005fcrq_005fget_005fsubject_005falt_005fothername_005foid"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fget_005fsubject_005falt_005fothername_005foid">Function: <em>int</em> <strong>gnutls_x509_crq_get_subject_alt_othername_oid</strong> <em>(gnutls_x509_crq_t <var>crq</var>, unsigned int <var>seq</var>, void * <var>ret</var>, size_t * <var>ret_size</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>seq</var>: specifies the sequence number of the alt name (0 for the first one, 1 for the second etc.)
</p>
<p><var>ret</var>: is the place where the otherName OID will be copied to
</p>
<p><var>ret_size</var>: holds the size of ret.
</p>
<p>This function will extract the type OID of an otherName Subject
Alternative Name, contained in the given certificate, and return
the type as an enumerated element.
</p>
<p>This function is only useful if
<code>gnutls_x509_crq_get_subject_alt_name()</code>  returned
<code>GNUTLS_SAN_OTHERNAME</code> .
</p>
<p><strong>Returns:</strong> the alternative subject name type on success, one of the
enumerated gnutls_x509_subject_alt_name_t.  For supported OIDs,
it will return one of the virtual (GNUTLS_SAN_OTHERNAME_*) types,
e.g. <code>GNUTLS_SAN_OTHERNAME_XMPP</code> , and <code>GNUTLS_SAN_OTHERNAME</code>  for
unknown OIDs.  It will return <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if
 <code>ret_size</code> is not large enough to hold the value.  In that case
 <code>ret_size</code> will be updated with the required size.  If the
certificate does not have an Alternative name with the specified
sequence number and with the otherName type then
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  is returned.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fget_005ftlsfeatures-1"></span><h4 class="subheading">gnutls_x509_crq_get_tlsfeatures</h4>
<span id="gnutls_005fx509_005fcrq_005fget_005ftlsfeatures"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fget_005ftlsfeatures">Function: <em>int</em> <strong>gnutls_x509_crq_get_tlsfeatures</strong> <em>(gnutls_x509_crq_t <var>crq</var>, gnutls_x509_tlsfeatures_t <var>features</var>, unsigned int <var>flags</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>crq</var>: An X.509 certificate request
</p>
<p><var>features</var>: If the function succeeds, the
features will be stored in this variable.
</p>
<p><var>flags</var>: zero or <code>GNUTLS_EXT_FLAG_APPEND</code> 
</p>
<p><var>critical</var>: the extension status
</p>
<p>This function will get the X.509 TLS features
extension structure from the certificate request.
The returned structure needs to be freed using
<code>gnutls_x509_tlsfeatures_deinit()</code> .
</p>
<p>When the  <code>flags</code> is set to <code>GNUTLS_EXT_FLAG_APPEND</code> ,
then if the  <code>features</code> structure is empty this function will behave
identically as if the flag was not set. Otherwise if there are elements 
in the  <code>features</code> structure then they will be merged with.
</p>
<p>Note that  <code>features</code> must be initialized prior to calling this function.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.5.1
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fget_005fversion-1"></span><h4 class="subheading">gnutls_x509_crq_get_version</h4>
<span id="gnutls_005fx509_005fcrq_005fget_005fversion"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fget_005fversion">Function: <em>int</em> <strong>gnutls_x509_crq_get_version</strong> <em>(gnutls_x509_crq_t <var>crq</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p>This function will return the version of the specified Certificate
request.
</p>
<p><strong>Returns:</strong> version of certificate request, or a negative error code on
error.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fimport-1"></span><h4 class="subheading">gnutls_x509_crq_import</h4>
<span id="gnutls_005fx509_005fcrq_005fimport"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fimport">Function: <em>int</em> <strong>gnutls_x509_crq_import</strong> <em>(gnutls_x509_crq_t <var>crq</var>, const gnutls_datum_t * <var>data</var>, gnutls_x509_crt_fmt_t <var>format</var>)</em></dt>
<dd><p><var>crq</var>: The data to store the parsed certificate request.
</p>
<p><var>data</var>: The DER or PEM encoded certificate.
</p>
<p><var>format</var>: One of DER or PEM
</p>
<p>This function will convert the given DER or PEM encoded certificate
request to a <code>gnutls_x509_crq_t</code>  type.  The output will be
stored in  <code>crq</code> .
</p>
<p>If the Certificate is PEM encoded it should have a header of &quot;NEW
CERTIFICATE REQUEST&quot;.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005finit-1"></span><h4 class="subheading">gnutls_x509_crq_init</h4>
<span id="gnutls_005fx509_005fcrq_005finit"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005finit">Function: <em>int</em> <strong>gnutls_x509_crq_init</strong> <em>(gnutls_x509_crq_t * <var>crq</var>)</em></dt>
<dd><p><var>crq</var>: A pointer to the type to be initialized
</p>
<p>This function will initialize a PKCS<code>10</code>  certificate request
structure.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fprint-1"></span><h4 class="subheading">gnutls_x509_crq_print</h4>
<span id="gnutls_005fx509_005fcrq_005fprint"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fprint">Function: <em>int</em> <strong>gnutls_x509_crq_print</strong> <em>(gnutls_x509_crq_t <var>crq</var>, gnutls_certificate_print_formats_t <var>format</var>, gnutls_datum_t * <var>out</var>)</em></dt>
<dd><p><var>crq</var>: The data to be printed
</p>
<p><var>format</var>: Indicate the format to use
</p>
<p><var>out</var>: Newly allocated datum with null terminated string.
</p>
<p>This function will pretty print a certificate request, suitable for
display to a human.
</p>
<p>The output  <code>out</code> needs to be deallocated using <code>gnutls_free()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fset_005fattribute_005fby_005foid-1"></span><h4 class="subheading">gnutls_x509_crq_set_attribute_by_oid</h4>
<span id="gnutls_005fx509_005fcrq_005fset_005fattribute_005fby_005foid"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fset_005fattribute_005fby_005foid">Function: <em>int</em> <strong>gnutls_x509_crq_set_attribute_by_oid</strong> <em>(gnutls_x509_crq_t <var>crq</var>, const char * <var>oid</var>, void * <var>buf</var>, size_t <var>buf_size</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>oid</var>: holds an Object Identifier in a null-terminated string
</p>
<p><var>buf</var>: a pointer to a structure that holds the attribute data
</p>
<p><var>buf_size</var>: holds the size of  <code>buf</code> 
</p>
<p>This function will set the attribute in the certificate request
specified by the given Object ID. The provided attribute must be be DER
encoded.
</p>
<p>Attributes in a certificate request is an optional set of data
appended to the request. Their interpretation depends on the CA policy.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fset_005fbasic_005fconstraints-1"></span><h4 class="subheading">gnutls_x509_crq_set_basic_constraints</h4>
<span id="gnutls_005fx509_005fcrq_005fset_005fbasic_005fconstraints"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fset_005fbasic_005fconstraints">Function: <em>int</em> <strong>gnutls_x509_crq_set_basic_constraints</strong> <em>(gnutls_x509_crq_t <var>crq</var>, unsigned int <var>ca</var>, int <var>pathLenConstraint</var>)</em></dt>
<dd><p><var>crq</var>: a certificate request of type <code>gnutls_x509_crq_t</code> 
</p>
<p><var>ca</var>: true(1) or false(0) depending on the Certificate authority status.
</p>
<p><var>pathLenConstraint</var>: non-negative error codes indicate maximum length of path,
and negative error codes indicate that the pathLenConstraints field should
not be present.
</p>
<p>This function will set the basicConstraints certificate extension.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fset_005fchallenge_005fpassword-1"></span><h4 class="subheading">gnutls_x509_crq_set_challenge_password</h4>
<span id="gnutls_005fx509_005fcrq_005fset_005fchallenge_005fpassword"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fset_005fchallenge_005fpassword">Function: <em>int</em> <strong>gnutls_x509_crq_set_challenge_password</strong> <em>(gnutls_x509_crq_t <var>crq</var>, const char * <var>pass</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>pass</var>: holds a (0)-terminated password
</p>
<p>This function will set a challenge password to be used when
revoking the request.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fset_005fdn-1"></span><h4 class="subheading">gnutls_x509_crq_set_dn</h4>
<span id="gnutls_005fx509_005fcrq_005fset_005fdn"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fset_005fdn">Function: <em>int</em> <strong>gnutls_x509_crq_set_dn</strong> <em>(gnutls_x509_crq_t <var>crq</var>, const char * <var>dn</var>, const char ** <var>err</var>)</em></dt>
<dd><p><var>crq</var>: a certificate of type <code>gnutls_x509_crq_t</code> 
</p>
<p><var>dn</var>: a comma separated DN string (RFC4514)
</p>
<p><var>err</var>: indicates the error position (if any)
</p>
<p>This function will set the DN on the provided certificate.
The input string should be plain ASCII or UTF-8 encoded. On
DN parsing error <code>GNUTLS_E_PARSING_ERROR</code>  is returned.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fset_005fdn_005fby_005foid-1"></span><h4 class="subheading">gnutls_x509_crq_set_dn_by_oid</h4>
<span id="gnutls_005fx509_005fcrq_005fset_005fdn_005fby_005foid"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fset_005fdn_005fby_005foid">Function: <em>int</em> <strong>gnutls_x509_crq_set_dn_by_oid</strong> <em>(gnutls_x509_crq_t <var>crq</var>, const char * <var>oid</var>, unsigned int <var>raw_flag</var>, const void * <var>data</var>, unsigned int <var>sizeof_data</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>oid</var>: holds an Object Identifier in a (0)-terminated string
</p>
<p><var>raw_flag</var>: must be 0, or 1 if the data are DER encoded
</p>
<p><var>data</var>: a pointer to the input data
</p>
<p><var>sizeof_data</var>: holds the size of  <code>data</code> 
</p>
<p>This function will set the part of the name of the Certificate
request subject, specified by the given OID.  The input string
should be ASCII or UTF-8 encoded.
</p>
<p>Some helper macros with popular OIDs can be found in gnutls/x509.h
With this function you can only set the known OIDs.  You can test
for known OIDs using <code>gnutls_x509_dn_oid_known()</code> .  For OIDs that are
not known (by gnutls) you should properly DER encode your data, and
call this function with raw_flag set.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fset_005fextension_005fby_005foid-1"></span><h4 class="subheading">gnutls_x509_crq_set_extension_by_oid</h4>
<span id="gnutls_005fx509_005fcrq_005fset_005fextension_005fby_005foid"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fset_005fextension_005fby_005foid">Function: <em>int</em> <strong>gnutls_x509_crq_set_extension_by_oid</strong> <em>(gnutls_x509_crq_t <var>crq</var>, const char * <var>oid</var>, const void * <var>buf</var>, size_t <var>sizeof_buf</var>, unsigned int <var>critical</var>)</em></dt>
<dd><p><var>crq</var>: a certificate of type <code>gnutls_x509_crq_t</code> 
</p>
<p><var>oid</var>: holds an Object Identifier in null terminated string
</p>
<p><var>buf</var>: a pointer to a DER encoded data
</p>
<p><var>sizeof_buf</var>: holds the size of  <code>buf</code> 
</p>
<p><var>critical</var>: should be non-zero if the extension is to be marked as critical
</p>
<p>This function will set an the extension, by the specified OID, in
the certificate request.  The extension data should be binary data DER
encoded.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fset_005fkey-1"></span><h4 class="subheading">gnutls_x509_crq_set_key</h4>
<span id="gnutls_005fx509_005fcrq_005fset_005fkey"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fset_005fkey-1">Function: <em>int</em> <strong>gnutls_x509_crq_set_key</strong> <em>(gnutls_x509_crq_t <var>crq</var>, gnutls_x509_privkey_t <var>key</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>key</var>: holds a private key
</p>
<p>This function will set the public parameters from the given private
key to the request.  
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fset_005fkey_005fpurpose_005foid-1"></span><h4 class="subheading">gnutls_x509_crq_set_key_purpose_oid</h4>
<span id="gnutls_005fx509_005fcrq_005fset_005fkey_005fpurpose_005foid"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fset_005fkey_005fpurpose_005foid">Function: <em>int</em> <strong>gnutls_x509_crq_set_key_purpose_oid</strong> <em>(gnutls_x509_crq_t <var>crq</var>, const void * <var>oid</var>, unsigned int <var>critical</var>)</em></dt>
<dd><p><var>crq</var>: a certificate of type <code>gnutls_x509_crq_t</code> 
</p>
<p><var>oid</var>: a pointer to a null-terminated string that holds the OID
</p>
<p><var>critical</var>: Whether this extension will be critical or not
</p>
<p>This function will set the key purpose OIDs of the Certificate.
These are stored in the Extended Key Usage extension (2.5.29.37)
See the GNUTLS_KP_* definitions for human readable names.
</p>
<p>Subsequent calls to this function will append OIDs to the OID list.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fset_005fkey_005frsa_005fraw-1"></span><h4 class="subheading">gnutls_x509_crq_set_key_rsa_raw</h4>
<span id="gnutls_005fx509_005fcrq_005fset_005fkey_005frsa_005fraw"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fset_005fkey_005frsa_005fraw">Function: <em>int</em> <strong>gnutls_x509_crq_set_key_rsa_raw</strong> <em>(gnutls_x509_crq_t <var>crq</var>, const gnutls_datum_t * <var>m</var>, const gnutls_datum_t * <var>e</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>m</var>: holds the modulus
</p>
<p><var>e</var>: holds the public exponent
</p>
<p>This function will set the public parameters from the given private
key to the request. Only RSA keys are currently supported.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.6.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fset_005fkey_005fusage-1"></span><h4 class="subheading">gnutls_x509_crq_set_key_usage</h4>
<span id="gnutls_005fx509_005fcrq_005fset_005fkey_005fusage"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fset_005fkey_005fusage">Function: <em>int</em> <strong>gnutls_x509_crq_set_key_usage</strong> <em>(gnutls_x509_crq_t <var>crq</var>, unsigned int <var>usage</var>)</em></dt>
<dd><p><var>crq</var>: a certificate request of type <code>gnutls_x509_crq_t</code> 
</p>
<p><var>usage</var>: an ORed sequence of the GNUTLS_KEY_* elements.
</p>
<p>This function will set the keyUsage certificate extension.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fset_005fprivate_005fkey_005fusage_005fperiod-1"></span><h4 class="subheading">gnutls_x509_crq_set_private_key_usage_period</h4>
<span id="gnutls_005fx509_005fcrq_005fset_005fprivate_005fkey_005fusage_005fperiod"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fset_005fprivate_005fkey_005fusage_005fperiod">Function: <em>int</em> <strong>gnutls_x509_crq_set_private_key_usage_period</strong> <em>(gnutls_x509_crq_t <var>crq</var>, time_t <var>activation</var>, time_t <var>expiration</var>)</em></dt>
<dd><p><var>crq</var>: a certificate of type <code>gnutls_x509_crq_t</code> 
</p>
<p><var>activation</var>: The activation time
</p>
<p><var>expiration</var>: The expiration time
</p>
<p>This function will set the private key usage period extension (2.5.29.16).
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fset_005fspki-1"></span><h4 class="subheading">gnutls_x509_crq_set_spki</h4>
<span id="gnutls_005fx509_005fcrq_005fset_005fspki"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fset_005fspki">Function: <em>int</em> <strong>gnutls_x509_crq_set_spki</strong> <em>(gnutls_x509_crq_t <var>crq</var>, const gnutls_x509_spki_t <var>spki</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>crq</var>: a certificate request of type <code>gnutls_x509_crq_t</code> 
</p>
<p><var>spki</var>: a SubjectPublicKeyInfo structure of type <code>gnutls_x509_spki_t</code> 
</p>
<p><var>flags</var>: must be zero
</p>
<p>This function will set the certificate request&rsquo;s subject public key
information explicitly. This is intended to be used in the cases
where a single public key (e.g., RSA) can be used for multiple
signature algorithms (RSA PKCS1-1.5, and RSA-PSS).
</p>
<p>To export the public key (i.e., the SubjectPublicKeyInfo part), check
<code>gnutls_pubkey_import_x509()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.6.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fset_005fsubject_005falt_005fname-1"></span><h4 class="subheading">gnutls_x509_crq_set_subject_alt_name</h4>
<span id="gnutls_005fx509_005fcrq_005fset_005fsubject_005falt_005fname"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fset_005fsubject_005falt_005fname">Function: <em>int</em> <strong>gnutls_x509_crq_set_subject_alt_name</strong> <em>(gnutls_x509_crq_t <var>crq</var>, gnutls_x509_subject_alt_name_t <var>nt</var>, const void * <var>data</var>, unsigned int <var>data_size</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>crq</var>: a certificate request of type <code>gnutls_x509_crq_t</code> 
</p>
<p><var>nt</var>: is one of the <code>gnutls_x509_subject_alt_name_t</code>  enumerations
</p>
<p><var>data</var>: The data to be set
</p>
<p><var>data_size</var>: The size of data to be set
</p>
<p><var>flags</var>: <code>GNUTLS_FSAN_SET</code>  to clear previous data or
<code>GNUTLS_FSAN_APPEND</code>  to append.
</p>
<p>This function will set the subject alternative name certificate
extension.  It can set the following types:
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fset_005fsubject_005falt_005fothername-1"></span><h4 class="subheading">gnutls_x509_crq_set_subject_alt_othername</h4>
<span id="gnutls_005fx509_005fcrq_005fset_005fsubject_005falt_005fothername"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fset_005fsubject_005falt_005fothername">Function: <em>int</em> <strong>gnutls_x509_crq_set_subject_alt_othername</strong> <em>(gnutls_x509_crq_t <var>crq</var>, const char * <var>oid</var>, const void * <var>data</var>, unsigned int <var>data_size</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>crq</var>: a certificate request of type <code>gnutls_x509_crq_t</code> 
</p>
<p><var>oid</var>: is the othername OID
</p>
<p><var>data</var>: The data to be set
</p>
<p><var>data_size</var>: The size of data to be set
</p>
<p><var>flags</var>: <code>GNUTLS_FSAN_SET</code>  to clear previous data or
<code>GNUTLS_FSAN_APPEND</code>  to append.
</p>
<p>This function will set the subject alternative name certificate
extension.  It can set the following types:
</p>
<p>The values set must be binary values and must be properly DER encoded.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.5.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fset_005ftlsfeatures-1"></span><h4 class="subheading">gnutls_x509_crq_set_tlsfeatures</h4>
<span id="gnutls_005fx509_005fcrq_005fset_005ftlsfeatures"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fset_005ftlsfeatures">Function: <em>int</em> <strong>gnutls_x509_crq_set_tlsfeatures</strong> <em>(gnutls_x509_crq_t <var>crq</var>, gnutls_x509_tlsfeatures_t <var>features</var>)</em></dt>
<dd><p><var>crq</var>: An X.509 certificate request
</p>
<p><var>features</var>: If the function succeeds, the
features will be added to the certificate
request.
</p>
<p>This function will set the certificate request&rsquo;s
X.509 TLS extension from the given structure.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.5.1
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fset_005fversion-1"></span><h4 class="subheading">gnutls_x509_crq_set_version</h4>
<span id="gnutls_005fx509_005fcrq_005fset_005fversion"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fset_005fversion">Function: <em>int</em> <strong>gnutls_x509_crq_set_version</strong> <em>(gnutls_x509_crq_t <var>crq</var>, unsigned int <var>version</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>version</var>: holds the version number, for v1 Requests must be 1
</p>
<p>This function will set the version of the certificate request.  For
version 1 requests this must be one.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fsign-1"></span><h4 class="subheading">gnutls_x509_crq_sign</h4>
<span id="gnutls_005fx509_005fcrq_005fsign"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fsign">Function: <em>int</em> <strong>gnutls_x509_crq_sign</strong> <em>(gnutls_x509_crq_t <var>crq</var>, gnutls_x509_privkey_t <var>key</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>key</var>: holds a private key
</p>
<p>This function is the same a <code>gnutls_x509_crq_sign2()</code>  with no flags,
and an appropriate hash algorithm. The hash algorithm used may
vary between versions of GnuTLS, and it is tied to the security
level of the issuer&rsquo;s public key.
</p>
<p>A known limitation of this function is, that a newly-signed request will not
be fully functional (e.g., for signature verification), until it
is exported an re-imported.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fsign2-1"></span><h4 class="subheading">gnutls_x509_crq_sign2</h4>
<span id="gnutls_005fx509_005fcrq_005fsign2"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fsign2-1">Function: <em>int</em> <strong>gnutls_x509_crq_sign2</strong> <em>(gnutls_x509_crq_t <var>crq</var>, gnutls_x509_privkey_t <var>key</var>, gnutls_digest_algorithm_t <var>dig</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>key</var>: holds a private key
</p>
<p><var>dig</var>: The message digest to use, i.e., <code>GNUTLS_DIG_SHA256</code> 
</p>
<p><var>flags</var>: must be 0
</p>
<p>This function will sign the certificate request with a private key.
This must be the same key as the one used in
<code>gnutls_x509_crt_set_key()</code>  since a certificate request is self
signed.
</p>
<p>This must be the last step in a certificate request generation
since all the previously set parameters are now signed.
</p>
<p>A known limitation of this function is, that a newly-signed request will not
be fully functional (e.g., for signature verification), until it
is exported an re-imported.
</p>
<p>After GnuTLS 3.6.1 the value of  <code>dig</code> may be <code>GNUTLS_DIG_UNKNOWN</code> ,
and in that case, a suitable but reasonable for the key algorithm will be selected.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
<code>GNUTLS_E_ASN1_VALUE_NOT_FOUND</code>  is returned if you didn&rsquo;t set all
information in the certificate request (e.g., the version using
<code>gnutls_x509_crq_set_version()</code> ).
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fverify-1"></span><h4 class="subheading">gnutls_x509_crq_verify</h4>
<span id="gnutls_005fx509_005fcrq_005fverify"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fverify">Function: <em>int</em> <strong>gnutls_x509_crq_verify</strong> <em>(gnutls_x509_crq_t <var>crq</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>crq</var>: is the crq to be verified
</p>
<p><var>flags</var>: Flags that may be used to change the verification algorithm. Use OR of the gnutls_certificate_verify_flags enumerations.
</p>
<p>This function will verify self signature in the certificate
request and return its status.
</p>
<p><strong>Returns:</strong> In case of a verification failure <code>GNUTLS_E_PK_SIG_VERIFY_FAILED</code>  
is returned, and zero or positive code on success.
</p>
<p>Since 2.12.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fcheck_005femail-1"></span><h4 class="subheading">gnutls_x509_crt_check_email</h4>
<span id="gnutls_005fx509_005fcrt_005fcheck_005femail"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fcheck_005femail">Function: <em>unsigned</em> <strong>gnutls_x509_crt_check_email</strong> <em>(gnutls_x509_crt_t <var>cert</var>, const char * <var>email</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>cert</var>: should contain an gnutls_x509_crt_t type
</p>
<p><var>email</var>: A null terminated string that contains an email address (RFC822)
</p>
<p><var>flags</var>: should be zero
</p>
<p>This function will check if the given certificate&rsquo;s subject matches
the given email address.
</p>
<p><strong>Returns:</strong> non-zero for a successful match, and zero on failure.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fcheck_005fhostname-1"></span><h4 class="subheading">gnutls_x509_crt_check_hostname</h4>
<span id="gnutls_005fx509_005fcrt_005fcheck_005fhostname"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fcheck_005fhostname">Function: <em>unsigned</em> <strong>gnutls_x509_crt_check_hostname</strong> <em>(gnutls_x509_crt_t <var>cert</var>, const char * <var>hostname</var>)</em></dt>
<dd><p><var>cert</var>: should contain an gnutls_x509_crt_t type
</p>
<p><var>hostname</var>: A null terminated string that contains a DNS name
</p>
<p>This function will check if the given certificate&rsquo;s subject matches
the given hostname.  This is a basic implementation of the matching
described in RFC6125, and takes into account wildcards,
and the DNSName/IPAddress subject alternative name PKIX extension.
</p>
<p>For details see also <code>gnutls_x509_crt_check_hostname2()</code> .
</p>
<p><strong>Returns:</strong> non-zero for a successful match, and zero on failure.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fcheck_005fhostname2-1"></span><h4 class="subheading">gnutls_x509_crt_check_hostname2</h4>
<span id="gnutls_005fx509_005fcrt_005fcheck_005fhostname2"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fcheck_005fhostname2">Function: <em>unsigned</em> <strong>gnutls_x509_crt_check_hostname2</strong> <em>(gnutls_x509_crt_t <var>cert</var>, const char * <var>hostname</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>cert</var>: should contain an gnutls_x509_crt_t type
</p>
<p><var>hostname</var>: A null terminated string that contains a DNS name
</p>
<p><var>flags</var>: gnutls_certificate_verify_flags
</p>
<p>This function will check if the given certificate&rsquo;s subject matches
the given hostname.  This is a basic implementation of the matching
described in RFC6125, and takes into account wildcards,
and the DNSName/IPAddress subject alternative name PKIX extension.
</p>
<p>IPv4 addresses are accepted by this function in the dotted-decimal
format (e.g, ddd.ddd.ddd.ddd), and IPv6 addresses in the hexadecimal
x:x:x:x:x:x:x:x format. For them the IPAddress subject alternative
name extension is consulted. Previous versions to 3.6.0 of GnuTLS
in case of a non-match would consult (in a non-standard extension)
the DNSname and CN fields. This is no longer the case.
</p>
<p>When the flag <code>GNUTLS_VERIFY_DO_NOT_ALLOW_WILDCARDS</code>  is specified no
wildcards are considered. Otherwise they are only considered if the
domain name consists of three components or more, and the wildcard
starts at the leftmost position.
When the flag <code>GNUTLS_VERIFY_DO_NOT_ALLOW_IP_MATCHES</code>  is specified,
the input will be treated as a DNS name, and matching of textual IP addresses
against the IPAddress part of the alternative name will not be allowed.
</p>
<p>The function <code>gnutls_x509_crt_check_ip()</code>  is available for matching
IP addresses.
</p>
<p><strong>Returns:</strong> non-zero for a successful match, and zero on failure.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fcheck_005fip-1"></span><h4 class="subheading">gnutls_x509_crt_check_ip</h4>
<span id="gnutls_005fx509_005fcrt_005fcheck_005fip"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fcheck_005fip">Function: <em>unsigned</em> <strong>gnutls_x509_crt_check_ip</strong> <em>(gnutls_x509_crt_t <var>cert</var>, const unsigned char * <var>ip</var>, unsigned int <var>ip_size</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>cert</var>: should contain an gnutls_x509_crt_t type
</p>
<p><var>ip</var>: A pointer to the raw IP address
</p>
<p><var>ip_size</var>: the number of bytes in ip (4 or 16)
</p>
<p><var>flags</var>: should be zero
</p>
<p>This function will check if the IP allowed IP addresses in 
the certificate&rsquo;s subject alternative name match the provided
IP address.
</p>
<p><strong>Returns:</strong> non-zero for a successful match, and zero on failure.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fcheck_005fissuer-1"></span><h4 class="subheading">gnutls_x509_crt_check_issuer</h4>
<span id="gnutls_005fx509_005fcrt_005fcheck_005fissuer"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fcheck_005fissuer">Function: <em>unsigned</em> <strong>gnutls_x509_crt_check_issuer</strong> <em>(gnutls_x509_crt_t <var>cert</var>, gnutls_x509_crt_t <var>issuer</var>)</em></dt>
<dd><p><var>cert</var>: is the certificate to be checked
</p>
<p><var>issuer</var>: is the certificate of a possible issuer
</p>
<p>This function will check if the given certificate was issued by the
given issuer. It checks the DN fields and the authority
key identifier and subject key identifier fields match.
</p>
<p>If the same certificate is provided at the  <code>cert</code> and  <code>issuer</code> fields,
it will check whether the certificate is self-signed.
</p>
<p><strong>Returns:</strong> It will return true (1) if the given certificate is issued
by the given issuer, and false (0) if not.  
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fcheck_005fkey_005fpurpose-1"></span><h4 class="subheading">gnutls_x509_crt_check_key_purpose</h4>
<span id="gnutls_005fx509_005fcrt_005fcheck_005fkey_005fpurpose"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fcheck_005fkey_005fpurpose">Function: <em>unsigned</em> <strong>gnutls_x509_crt_check_key_purpose</strong> <em>(gnutls_x509_crt_t <var>cert</var>, const char * <var>purpose</var>, unsigned <var>flags</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>purpose</var>: a key purpose OID (e.g., <code>GNUTLS_KP_CODE_SIGNING</code> )
</p>
<p><var>flags</var>: zero or <code>GNUTLS_KP_FLAG_DISALLOW_ANY</code> 
</p>
<p>This function will check whether the given certificate matches
the provided key purpose. If  <code>flags</code> contains <code>GNUTLS_KP_FLAG_ALLOW_ANY</code>  then
it a certificate marked for any purpose will not match.
</p>
<p><strong>Returns:</strong> zero if the key purpose doesn&rsquo;t match, and non-zero otherwise.
</p>
<p><strong>Since:</strong> 3.5.6
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fcheck_005frevocation-1"></span><h4 class="subheading">gnutls_x509_crt_check_revocation</h4>
<span id="gnutls_005fx509_005fcrt_005fcheck_005frevocation"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fcheck_005frevocation">Function: <em>int</em> <strong>gnutls_x509_crt_check_revocation</strong> <em>(gnutls_x509_crt_t <var>cert</var>, const gnutls_x509_crl_t * <var>crl_list</var>, unsigned <var>crl_list_length</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>crl_list</var>: should contain a list of gnutls_x509_crl_t types
</p>
<p><var>crl_list_length</var>: the length of the crl_list
</p>
<p>This function will check if the given certificate is
revoked.  It is assumed that the CRLs have been verified before.
</p>
<p><strong>Returns:</strong> 0 if the certificate is NOT revoked, and 1 if it is.  A
negative error code is returned on error.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fcpy_005fcrl_005fdist_005fpoints-1"></span><h4 class="subheading">gnutls_x509_crt_cpy_crl_dist_points</h4>
<span id="gnutls_005fx509_005fcrt_005fcpy_005fcrl_005fdist_005fpoints"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fcpy_005fcrl_005fdist_005fpoints">Function: <em>int</em> <strong>gnutls_x509_crt_cpy_crl_dist_points</strong> <em>(gnutls_x509_crt_t <var>dst</var>, gnutls_x509_crt_t <var>src</var>)</em></dt>
<dd><p><var>dst</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>src</var>: the certificate where the dist points will be copied from
</p>
<p>This function will copy the CRL distribution points certificate
extension, from the source to the destination certificate.
This may be useful to copy from a CA certificate to issued ones.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fdeinit-1"></span><h4 class="subheading">gnutls_x509_crt_deinit</h4>
<span id="gnutls_005fx509_005fcrt_005fdeinit"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fdeinit">Function: <em>void</em> <strong>gnutls_x509_crt_deinit</strong> <em>(gnutls_x509_crt_t <var>cert</var>)</em></dt>
<dd><p><var>cert</var>: The data to be deinitialized
</p>
<p>This function will deinitialize a certificate structure.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fequals-1"></span><h4 class="subheading">gnutls_x509_crt_equals</h4>
<span id="gnutls_005fx509_005fcrt_005fequals"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fequals">Function: <em>unsigned</em> <strong>gnutls_x509_crt_equals</strong> <em>(gnutls_x509_crt_t <var>cert1</var>, gnutls_x509_crt_t <var>cert2</var>)</em></dt>
<dd><p><var>cert1</var>: The first certificate
</p>
<p><var>cert2</var>: The second certificate
</p>
<p>This function will compare two X.509 certificate structures.
</p>
<p><strong>Returns:</strong> On equality non-zero is returned, otherwise zero.
</p>
<p><strong>Since:</strong> 3.5.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fequals2-1"></span><h4 class="subheading">gnutls_x509_crt_equals2</h4>
<span id="gnutls_005fx509_005fcrt_005fequals2"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fequals2">Function: <em>unsigned</em> <strong>gnutls_x509_crt_equals2</strong> <em>(gnutls_x509_crt_t <var>cert1</var>, const gnutls_datum_t * <var>der</var>)</em></dt>
<dd><p><var>cert1</var>: The first certificate
</p>
<p><var>der</var>: A DER encoded certificate
</p>
<p>This function will compare an X.509 certificate structures, with DER
encoded certificate data.
</p>
<p><strong>Returns:</strong> On equality non-zero is returned, otherwise zero.
</p>
<p><strong>Since:</strong> 3.5.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fexport-1"></span><h4 class="subheading">gnutls_x509_crt_export</h4>
<span id="gnutls_005fx509_005fcrt_005fexport"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fexport">Function: <em>int</em> <strong>gnutls_x509_crt_export</strong> <em>(gnutls_x509_crt_t <var>cert</var>, gnutls_x509_crt_fmt_t <var>format</var>, void * <var>output_data</var>, size_t * <var>output_data_size</var>)</em></dt>
<dd><p><var>cert</var>: Holds the certificate
</p>
<p><var>format</var>: the format of output params. One of PEM or DER.
</p>
<p><var>output_data</var>: will contain a certificate PEM or DER encoded
</p>
<p><var>output_data_size</var>: holds the size of output_data (and will be
replaced by the actual size of parameters)
</p>
<p>This function will export the certificate to DER or PEM format.
</p>
<p>If the buffer provided is not long enough to hold the output, then
*output_data_size is updated and GNUTLS_E_SHORT_MEMORY_BUFFER will
be returned.
</p>
<p>If the structure is PEM encoded, it will have a header
of &quot;BEGIN CERTIFICATE&quot;.
</p>
<p><strong>Returns:</strong> In case of failure a negative error code will be
returned, and 0 on success.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fexport2-1"></span><h4 class="subheading">gnutls_x509_crt_export2</h4>
<span id="gnutls_005fx509_005fcrt_005fexport2"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fexport2">Function: <em>int</em> <strong>gnutls_x509_crt_export2</strong> <em>(gnutls_x509_crt_t <var>cert</var>, gnutls_x509_crt_fmt_t <var>format</var>, gnutls_datum_t * <var>out</var>)</em></dt>
<dd><p><var>cert</var>: Holds the certificate
</p>
<p><var>format</var>: the format of output params. One of PEM or DER.
</p>
<p><var>out</var>: will contain a certificate PEM or DER encoded
</p>
<p>This function will export the certificate to DER or PEM format.
The output buffer is allocated using <code>gnutls_malloc()</code> .
</p>
<p>If the structure is PEM encoded, it will have a header
of &quot;BEGIN CERTIFICATE&quot;.
</p>
<p><strong>Returns:</strong> In case of failure a negative error code will be
returned, and 0 on success.
</p>
<p><strong>Since:</strong> 3.1.3
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005factivation_005ftime-1"></span><h4 class="subheading">gnutls_x509_crt_get_activation_time</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005factivation_005ftime"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005factivation_005ftime">Function: <em>time_t</em> <strong>gnutls_x509_crt_get_activation_time</strong> <em>(gnutls_x509_crt_t <var>cert</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p>This function will return the time this Certificate was or will be
activated.
</p>
<p><strong>Returns:</strong> activation time, or (time_t)-1 on error.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fauthority_005finfo_005faccess-1"></span><h4 class="subheading">gnutls_x509_crt_get_authority_info_access</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fauthority_005finfo_005faccess"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fauthority_005finfo_005faccess">Function: <em>int</em> <strong>gnutls_x509_crt_get_authority_info_access</strong> <em>(gnutls_x509_crt_t <var>crt</var>, unsigned int <var>seq</var>, int <var>what</var>, gnutls_datum_t * <var>data</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>crt</var>: Holds the certificate
</p>
<p><var>seq</var>: specifies the sequence number of the access descriptor (0 for the first one, 1 for the second etc.)
</p>
<p><var>what</var>: what data to get, a <code>gnutls_info_access_what_t</code>  type.
</p>
<p><var>data</var>: output data to be freed with <code>gnutls_free()</code> .
</p>
<p><var>critical</var>: pointer to output integer that is set to non-zero if the extension is marked as critical (may be <code>NULL</code> )
</p>
<p>Note that a simpler API to access the authority info data is provided
by <code>gnutls_x509_aia_get()</code>  and <code>gnutls_x509_ext_import_aia()</code> .
</p>
<p>This function extracts the Authority Information Access (AIA)
extension, see RFC 5280 section 4.2.2.1 for more information.  The
AIA extension holds a sequence of AccessDescription (AD) data.
</p>
<p>The  <code>seq</code> input parameter is used to indicate which member of the
sequence the caller is interested in.  The first member is 0, the
second member 1 and so on.  When the  <code>seq</code> value is out of bounds,
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  is returned.
</p>
<p>The type of data returned in  <code>data</code> is specified via  <code>what</code> which
should be <code>gnutls_info_access_what_t</code>  values.
</p>
<p>If  <code>what</code> is <code>GNUTLS_IA_ACCESSMETHOD_OID</code>  then  <code>data</code> will hold the
accessMethod OID (e.g., &quot;1.3.6.1.5.5.7.48.1&quot;).
</p>
<p>If  <code>what</code> is <code>GNUTLS_IA_ACCESSLOCATION_GENERALNAME_TYPE</code> ,  <code>data</code> will
hold the accessLocation GeneralName type (e.g.,
&quot;uniformResourceIdentifier&quot;).
</p>
<p>If  <code>what</code> is <code>GNUTLS_IA_URI</code> ,  <code>data</code> will hold the accessLocation URI
data.  Requesting this  <code>what</code> value leads to an error if the
accessLocation is not of the &quot;uniformResourceIdentifier&quot; type. 
</p>
<p>If  <code>what</code> is <code>GNUTLS_IA_OCSP_URI</code> ,  <code>data</code> will hold the OCSP URI.
Requesting this  <code>what</code> value leads to an error if the accessMethod
is not 1.3.6.1.5.5.7.48.1 aka OCSP, or if accessLocation is not of
the &quot;uniformResourceIdentifier&quot; type. In that case <code>GNUTLS_E_UNKNOWN_ALGORITHM</code> 
will be returned, and  <code>seq</code> should be increased and this function
called again.
</p>
<p>If  <code>what</code> is <code>GNUTLS_IA_CAISSUERS_URI</code> ,  <code>data</code> will hold the caIssuers
URI.  Requesting this  <code>what</code> value leads to an error if the
accessMethod is not 1.3.6.1.5.5.7.48.2 aka caIssuers, or if
accessLocation is not of the &quot;uniformResourceIdentifier&quot; type.
In that case handle as in <code>GNUTLS_IA_OCSP_URI</code> .
</p>
<p>More  <code>what</code> values may be allocated in the future as needed.
</p>
<p>If  <code>data</code> is NULL, the function does the same without storing the
output data, that is, it will set  <code>critical</code> and do error checking
as usual.
</p>
<p>The value of the critical flag is returned in * <code>critical</code> .  Supply a
NULL  <code>critical</code> if you want the function to make sure the extension
is non-critical, as required by RFC 5280.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, <code>GNUTLS_E_INVALID_REQUEST</code>  on
invalid  <code>crt</code> , <code>GNUTLS_E_CONSTRAINT_ERROR</code>  if the extension is
incorrectly marked as critical (use a non-NULL  <code>critical</code> to
override), <code>GNUTLS_E_UNKNOWN_ALGORITHM</code>  if the requested OID does
not match (e.g., when using <code>GNUTLS_IA_OCSP_URI</code> ), otherwise a
negative error code.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fauthority_005fkey_005fgn_005fserial-1"></span><h4 class="subheading">gnutls_x509_crt_get_authority_key_gn_serial</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fauthority_005fkey_005fgn_005fserial"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fauthority_005fkey_005fgn_005fserial">Function: <em>int</em> <strong>gnutls_x509_crt_get_authority_key_gn_serial</strong> <em>(gnutls_x509_crt_t <var>cert</var>, unsigned int <var>seq</var>, void * <var>alt</var>, size_t * <var>alt_size</var>, unsigned int * <var>alt_type</var>, void * <var>serial</var>, size_t * <var>serial_size</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>seq</var>: specifies the sequence number of the alt name (0 for the first one, 1 for the second etc.)
</p>
<p><var>alt</var>: is the place where the alternative name will be copied to
</p>
<p><var>alt_size</var>: holds the size of alt.
</p>
<p><var>alt_type</var>: holds the type of the alternative name (one of gnutls_x509_subject_alt_name_t).
</p>
<p><var>serial</var>: buffer to store the serial number (may be null)
</p>
<p><var>serial_size</var>: Holds the size of the serial field (may be null)
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical (may be null)
</p>
<p>This function will return the X.509 authority key
identifier when stored as a general name (authorityCertIssuer) 
and serial number.
</p>
<p>Because more than one general names might be stored
 <code>seq</code> can be used as a counter to request them all until 
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  is returned.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
if the extension is not present, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fauthority_005fkey_005fid-1"></span><h4 class="subheading">gnutls_x509_crt_get_authority_key_id</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fauthority_005fkey_005fid"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fauthority_005fkey_005fid">Function: <em>int</em> <strong>gnutls_x509_crt_get_authority_key_id</strong> <em>(gnutls_x509_crt_t <var>cert</var>, void * <var>id</var>, size_t * <var>id_size</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>id</var>: The place where the identifier will be copied
</p>
<p><var>id_size</var>: Holds the size of the id field.
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical (may be null)
</p>
<p>This function will return the X.509v3 certificate authority&rsquo;s key
identifier.  This is obtained by the X.509 Authority Key
identifier extension field (2.5.29.35). Note that this function
only returns the keyIdentifier field of the extension and
<code>GNUTLS_E_X509_UNSUPPORTED_EXTENSION</code> , if the extension contains
the name and serial number of the certificate. In that case
<code>gnutls_x509_crt_get_authority_key_gn_serial()</code>  may be used.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
if the extension is not present, otherwise a negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fbasic_005fconstraints-1"></span><h4 class="subheading">gnutls_x509_crt_get_basic_constraints</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fbasic_005fconstraints"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fbasic_005fconstraints">Function: <em>int</em> <strong>gnutls_x509_crt_get_basic_constraints</strong> <em>(gnutls_x509_crt_t <var>cert</var>, unsigned int * <var>critical</var>, unsigned int * <var>ca</var>, int * <var>pathlen</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical
</p>
<p><var>ca</var>: pointer to output integer indicating CA status, may be NULL,
value is 1 if the certificate CA flag is set, 0 otherwise.
</p>
<p><var>pathlen</var>: pointer to output integer indicating path length (may be
NULL), non-negative error codes indicate a present pathLenConstraint
field and the actual value, -1 indicate that the field is absent.
</p>
<p>This function will read the certificate&rsquo;s basic constraints, and
return the certificates CA status.  It reads the basicConstraints
X.509 extension (2.5.29.19).
</p>
<p><strong>Returns:</strong> If the certificate is a CA a positive value will be
returned, or (0) if the certificate does not have CA flag set.  A
negative error code may be returned in case of errors.  If the
certificate does not contain the basicConstraints extension
GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE will be returned.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fca_005fstatus-1"></span><h4 class="subheading">gnutls_x509_crt_get_ca_status</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fca_005fstatus"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fca_005fstatus">Function: <em>int</em> <strong>gnutls_x509_crt_get_ca_status</strong> <em>(gnutls_x509_crt_t <var>cert</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical
</p>
<p>This function will return certificates CA status, by reading the
basicConstraints X.509 extension (2.5.29.19). If the certificate is
a CA a positive value will be returned, or (0) if the certificate
does not have CA flag set.
</p>
<p>Use <code>gnutls_x509_crt_get_basic_constraints()</code>  if you want to read the
pathLenConstraint field too.
</p>
<p><strong>Returns:</strong> If the certificate is a CA a positive value will be
returned, or (0) if the certificate does not have CA flag set.  A
negative error code may be returned in case of errors.  If the
certificate does not contain the basicConstraints extension
GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE will be returned.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fcrl_005fdist_005fpoints-1"></span><h4 class="subheading">gnutls_x509_crt_get_crl_dist_points</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fcrl_005fdist_005fpoints"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fcrl_005fdist_005fpoints">Function: <em>int</em> <strong>gnutls_x509_crt_get_crl_dist_points</strong> <em>(gnutls_x509_crt_t <var>cert</var>, unsigned int <var>seq</var>, void * <var>san</var>, size_t * <var>san_size</var>, unsigned int * <var>reason_flags</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>seq</var>: specifies the sequence number of the distribution point (0 for the first one, 1 for the second etc.)
</p>
<p><var>san</var>: is the place where the distribution point will be copied to
</p>
<p><var>san_size</var>: holds the size of ret.
</p>
<p><var>reason_flags</var>: Revocation reasons. An ORed sequence of flags from <code>gnutls_x509_crl_reason_flags_t</code> .
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical (may be null)
</p>
<p>This function retrieves the CRL distribution points (2.5.29.31),
contained in the given certificate in the X509v3 Certificate
Extensions.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  and updates  <code>ret_size</code> if
 <code>ret_size</code> is not enough to hold the distribution point, or the
type of the distribution point if everything was ok. The type is
one of the enumerated <code>gnutls_x509_subject_alt_name_t</code> .  If the
certificate does not have an Alternative name with the specified
sequence number then <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  is
returned.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fdn-1"></span><h4 class="subheading">gnutls_x509_crt_get_dn</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fdn"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fdn">Function: <em>int</em> <strong>gnutls_x509_crt_get_dn</strong> <em>(gnutls_x509_crt_t <var>cert</var>, char * <var>buf</var>, size_t * <var>buf_size</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>buf</var>: a pointer to a structure to hold the name (may be null)
</p>
<p><var>buf_size</var>: initially holds the size of  <code>buf</code> 
</p>
<p>This function will copy the name of the Certificate in the provided
buffer. The name will be in the form &quot;C=xxxx,O=yyyy,CN=zzzz&quot; as
described in RFC4514. The output string will be ASCII or UTF-8
encoded, depending on the certificate data.
</p>
<p>If  <code>buf</code> is null then only the size will be filled. 
</p>
<p>This function does not output a fully RFC4514 compliant string, if
that is required see <code>gnutls_x509_crt_get_dn3()</code> .
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if the provided buffer is not
long enough, and in that case the  <code>buf_size</code> will be updated
with the required size. <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  if
the DN does not exist, or another error value on error. On success 0 is returned.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fdn2-1"></span><h4 class="subheading">gnutls_x509_crt_get_dn2</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fdn2"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fdn2-1">Function: <em>int</em> <strong>gnutls_x509_crt_get_dn2</strong> <em>(gnutls_x509_crt_t <var>cert</var>, gnutls_datum_t * <var>dn</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>dn</var>: a pointer to a structure to hold the name
</p>
<p>This function will allocate buffer and copy the name of the Certificate.
The name will be in the form &quot;C=xxxx,O=yyyy,CN=zzzz&quot; as
described in RFC4514. The output string will be ASCII or UTF-8
encoded, depending on the certificate data.
</p>
<p>This function does not output a fully RFC4514 compliant string, if
that is required see <code>gnutls_x509_crt_get_dn3()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.1.10
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fdn3-1"></span><h4 class="subheading">gnutls_x509_crt_get_dn3</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fdn3"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fdn3">Function: <em>int</em> <strong>gnutls_x509_crt_get_dn3</strong> <em>(gnutls_x509_crt_t <var>cert</var>, gnutls_datum_t * <var>dn</var>, unsigned <var>flags</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>dn</var>: a pointer to a structure to hold the name
</p>
<p><var>flags</var>: zero or <code>GNUTLS_X509_DN_FLAG_COMPAT</code> 
</p>
<p>This function will allocate buffer and copy the name of the Certificate.
The name will be in the form &quot;C=xxxx,O=yyyy,CN=zzzz&quot; as
described in RFC4514. The output string will be ASCII or UTF-8
encoded, depending on the certificate data.
</p>
<p>When the flag <code>GNUTLS_X509_DN_FLAG_COMPAT</code>  is specified, the output
format will match the format output by previous to 3.5.6 versions of GnuTLS
which was not not fully RFC4514-compliant.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.5.7
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fdn_005fby_005foid-1"></span><h4 class="subheading">gnutls_x509_crt_get_dn_by_oid</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fdn_005fby_005foid"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fdn_005fby_005foid">Function: <em>int</em> <strong>gnutls_x509_crt_get_dn_by_oid</strong> <em>(gnutls_x509_crt_t <var>cert</var>, const char * <var>oid</var>, unsigned <var>indx</var>, unsigned int <var>raw_flag</var>, void * <var>buf</var>, size_t * <var>buf_size</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>oid</var>: holds an Object Identified in null terminated string
</p>
<p><var>indx</var>: In case multiple same OIDs exist in the RDN, this specifies which to send. Use (0) to get the first one.
</p>
<p><var>raw_flag</var>: If non-zero returns the raw DER data of the DN part.
</p>
<p><var>buf</var>: a pointer where the DN part will be copied (may be null).
</p>
<p><var>buf_size</var>: initially holds the size of  <code>buf</code> 
</p>
<p>This function will extract the part of the name of the Certificate
subject specified by the given OID. The output, if the raw flag is
not used, will be encoded as described in RFC4514. Thus a string
that is ASCII or UTF-8 encoded, depending on the certificate data.
</p>
<p>Some helper macros with popular OIDs can be found in gnutls/x509.h
If raw flag is (0), this function will only return known OIDs as
text. Other OIDs will be DER encoded, as described in RFC4514 &ndash;
in hex format with a &rsquo;#&rsquo; prefix.  You can check about known OIDs
using <code>gnutls_x509_dn_oid_known()</code> .
</p>
<p>If  <code>buf</code> is null then only the size will be filled. If the  <code>raw_flag</code> is not specified the output is always null terminated, although the
 <code>buf_size</code> will not include the null character.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if the provided buffer is not
long enough, and in that case the  <code>buf_size</code> will be updated with
the required size. <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  if there 
are no data in the current index. On success 0 is returned.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fdn_005foid-1"></span><h4 class="subheading">gnutls_x509_crt_get_dn_oid</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fdn_005foid"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fdn_005foid">Function: <em>int</em> <strong>gnutls_x509_crt_get_dn_oid</strong> <em>(gnutls_x509_crt_t <var>cert</var>, unsigned <var>indx</var>, void * <var>oid</var>, size_t * <var>oid_size</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>indx</var>: This specifies which OID to return. Use (0) to get the first one.
</p>
<p><var>oid</var>: a pointer to a buffer to hold the OID (may be null)
</p>
<p><var>oid_size</var>: initially holds the size of  <code>oid</code> 
</p>
<p>This function will extract the OIDs of the name of the Certificate
subject specified by the given index.
</p>
<p>If  <code>oid</code> is null then only the size will be filled. The  <code>oid</code> returned will be null terminated, although  <code>oid_size</code> will not
account for the trailing null.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if the provided buffer is not
long enough, and in that case the  <code>buf_size</code> will be updated with
the required size. <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  if there 
are no data in the current index. On success 0 is returned.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fexpiration_005ftime-1"></span><h4 class="subheading">gnutls_x509_crt_get_expiration_time</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fexpiration_005ftime"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fexpiration_005ftime">Function: <em>time_t</em> <strong>gnutls_x509_crt_get_expiration_time</strong> <em>(gnutls_x509_crt_t <var>cert</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p>This function will return the time this certificate was or will be
expired.
</p>
<p><strong>Returns:</strong> expiration time, or (time_t)-1 on error.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fextension_005fby_005foid-1"></span><h4 class="subheading">gnutls_x509_crt_get_extension_by_oid</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fextension_005fby_005foid"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fextension_005fby_005foid">Function: <em>int</em> <strong>gnutls_x509_crt_get_extension_by_oid</strong> <em>(gnutls_x509_crt_t <var>cert</var>, const char * <var>oid</var>, unsigned <var>indx</var>, void * <var>buf</var>, size_t * <var>buf_size</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>oid</var>: holds an Object Identified in null terminated string
</p>
<p><var>indx</var>: In case multiple same OIDs exist in the extensions, this specifies which to send. Use (0) to get the first one.
</p>
<p><var>buf</var>: a pointer to a structure to hold the name (may be null)
</p>
<p><var>buf_size</var>: initially holds the size of  <code>buf</code> 
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical
</p>
<p>This function will return the extension specified by the OID in the
certificate.  The extensions will be returned as binary data DER
encoded, in the provided buffer.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned. If the certificate does not
contain the specified extension
GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE will be returned.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fextension_005fby_005foid2-1"></span><h4 class="subheading">gnutls_x509_crt_get_extension_by_oid2</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fextension_005fby_005foid2"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fextension_005fby_005foid2">Function: <em>int</em> <strong>gnutls_x509_crt_get_extension_by_oid2</strong> <em>(gnutls_x509_crt_t <var>cert</var>, const char * <var>oid</var>, unsigned <var>indx</var>, gnutls_datum_t * <var>output</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>oid</var>: holds an Object Identified in null terminated string
</p>
<p><var>indx</var>: In case multiple same OIDs exist in the extensions, this specifies which to send. Use (0) to get the first one.
</p>
<p><var>output</var>: will hold the allocated extension data
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical
</p>
<p>This function will return the extension specified by the OID in the
certificate.  The extensions will be returned as binary data DER
encoded, in the provided buffer.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned. If the certificate does not
contain the specified extension
GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE will be returned.
</p>
<p><strong>Since:</strong> 3.3.8
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fextension_005fdata-1"></span><h4 class="subheading">gnutls_x509_crt_get_extension_data</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fextension_005fdata"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fextension_005fdata">Function: <em>int</em> <strong>gnutls_x509_crt_get_extension_data</strong> <em>(gnutls_x509_crt_t <var>cert</var>, unsigned <var>indx</var>, void * <var>data</var>, size_t * <var>sizeof_data</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>indx</var>: Specifies which extension OID to send. Use (0) to get the first one.
</p>
<p><var>data</var>: a pointer to a structure to hold the data (may be null)
</p>
<p><var>sizeof_data</var>: initially holds the size of  <code>data</code> 
</p>
<p>This function will return the requested extension data in the
certificate.  The extension data will be stored in the
provided buffer.
</p>
<p>Use <code>gnutls_x509_crt_get_extension_info()</code>  to extract the OID and
critical flag.  Use <code>gnutls_x509_crt_get_extension_by_oid()</code>  instead,
if you want to get data indexed by the extension OID rather than
sequence.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.  If you have reached the
last extension available <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
will be returned.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fextension_005fdata2-1"></span><h4 class="subheading">gnutls_x509_crt_get_extension_data2</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fextension_005fdata2"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fextension_005fdata2">Function: <em>int</em> <strong>gnutls_x509_crt_get_extension_data2</strong> <em>(gnutls_x509_crt_t <var>cert</var>, unsigned <var>indx</var>, gnutls_datum_t * <var>data</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>indx</var>: Specifies which extension OID to read. Use (0) to get the first one.
</p>
<p><var>data</var>: will contain the extension DER-encoded data
</p>
<p>This function will return the requested by the index extension data in the
certificate.  The extension data will be allocated using
<code>gnutls_malloc()</code> .
</p>
<p>Use <code>gnutls_x509_crt_get_extension_info()</code>  to extract the OID.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.  If you have reached the
last extension available <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
will be returned.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fextension_005finfo-1"></span><h4 class="subheading">gnutls_x509_crt_get_extension_info</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fextension_005finfo"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fextension_005finfo">Function: <em>int</em> <strong>gnutls_x509_crt_get_extension_info</strong> <em>(gnutls_x509_crt_t <var>cert</var>, unsigned <var>indx</var>, void * <var>oid</var>, size_t * <var>oid_size</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>indx</var>: Specifies which extension OID to send. Use (0) to get the first one.
</p>
<p><var>oid</var>: a pointer to a structure to hold the OID
</p>
<p><var>oid_size</var>: initially holds the maximum size of  <code>oid</code> , on return
holds actual size of  <code>oid</code> .
</p>
<p><var>critical</var>: output variable with critical flag, may be NULL.
</p>
<p>This function will return the requested extension OID in the
certificate, and the critical flag for it.  The extension OID will
be stored as a string in the provided buffer.  Use
<code>gnutls_x509_crt_get_extension()</code>  to extract the data.
</p>
<p>If the buffer provided is not long enough to hold the output, then
 <code>oid_size</code> is updated and <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  will be
returned. The  <code>oid</code> returned will be null terminated, although 
 <code>oid_size</code> will not account for the trailing null (the latter is not
true for GnuTLS prior to 3.6.0).
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.  If you have reached the
last extension available <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
will be returned.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fextension_005foid-1"></span><h4 class="subheading">gnutls_x509_crt_get_extension_oid</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fextension_005foid"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fextension_005foid">Function: <em>int</em> <strong>gnutls_x509_crt_get_extension_oid</strong> <em>(gnutls_x509_crt_t <var>cert</var>, unsigned <var>indx</var>, void * <var>oid</var>, size_t * <var>oid_size</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>indx</var>: Specifies which extension OID to send. Use (0) to get the first one.
</p>
<p><var>oid</var>: a pointer to a structure to hold the OID (may be null)
</p>
<p><var>oid_size</var>: initially holds the size of  <code>oid</code> 
</p>
<p>This function will return the requested extension OID in the certificate.
The extension OID will be stored as a string in the provided buffer.
</p>
<p>The  <code>oid</code> returned will be null terminated, although  <code>oid_size</code> will not
account for the trailing null.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.  If you have reached the
last extension available <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
will be returned.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005ffingerprint-1"></span><h4 class="subheading">gnutls_x509_crt_get_fingerprint</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005ffingerprint"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005ffingerprint">Function: <em>int</em> <strong>gnutls_x509_crt_get_fingerprint</strong> <em>(gnutls_x509_crt_t <var>cert</var>, gnutls_digest_algorithm_t <var>algo</var>, void * <var>buf</var>, size_t * <var>buf_size</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>algo</var>: is a digest algorithm
</p>
<p><var>buf</var>: a pointer to a structure to hold the fingerprint (may be null)
</p>
<p><var>buf_size</var>: initially holds the size of  <code>buf</code> 
</p>
<p>This function will calculate and copy the certificate&rsquo;s fingerprint
in the provided buffer. The fingerprint is a hash of the DER-encoded
data of the certificate.
</p>
<p>If the buffer is null then only the size will be filled.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if the provided buffer is
not long enough, and in that case the *buf_size will be updated
with the required size.  On success 0 is returned.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005finhibit_005fanypolicy-1"></span><h4 class="subheading">gnutls_x509_crt_get_inhibit_anypolicy</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005finhibit_005fanypolicy"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005finhibit_005fanypolicy">Function: <em>int</em> <strong>gnutls_x509_crt_get_inhibit_anypolicy</strong> <em>(gnutls_x509_crt_t <var>cert</var>, unsigned int * <var>skipcerts</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>skipcerts</var>: will hold the number of certificates after which anypolicy is no longer acceptable.
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical
</p>
<p>This function will return certificate&rsquo;s value of the SkipCerts, i.e.,
the Inhibit anyPolicy X.509 extension (2.5.29.54).
</p>
<p>The returned value is the number of additional certificates that
may appear in the path before the anyPolicy is no longer acceptable.
</p>
<p><strong>Returns:</strong> zero on success, or a negative error code in case of
parsing error.  If the certificate does not contain the Inhibit anyPolicy
extension <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  will be
returned.
</p>
<p><strong>Since:</strong> 3.6.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fissuer-1"></span><h4 class="subheading">gnutls_x509_crt_get_issuer</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fissuer"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fissuer">Function: <em>int</em> <strong>gnutls_x509_crt_get_issuer</strong> <em>(gnutls_x509_crt_t <var>cert</var>, gnutls_x509_dn_t * <var>dn</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>dn</var>: output variable with pointer to uint8_t DN
</p>
<p>Return the Certificate&rsquo;s Issuer DN as a <code>gnutls_x509_dn_t</code>  data type,
that can be decoded using <code>gnutls_x509_dn_get_rdn_ava()</code> . 
</p>
<p>Note that  <code>dn</code> should be treated as constant. Because it points 
into the  <code>cert</code> object, you should not use  <code>dn</code> after  <code>cert</code> is
deallocated.
</p>
<p><strong>Returns:</strong> Returns 0 on success, or an error code.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fissuer_005falt_005fname-1"></span><h4 class="subheading">gnutls_x509_crt_get_issuer_alt_name</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fissuer_005falt_005fname"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fissuer_005falt_005fname">Function: <em>int</em> <strong>gnutls_x509_crt_get_issuer_alt_name</strong> <em>(gnutls_x509_crt_t <var>cert</var>, unsigned int <var>seq</var>, void * <var>ian</var>, size_t * <var>ian_size</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>seq</var>: specifies the sequence number of the alt name (0 for the first one, 1 for the second etc.)
</p>
<p><var>ian</var>: is the place where the alternative name will be copied to
</p>
<p><var>ian_size</var>: holds the size of ian.
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical (may be null)
</p>
<p>This function retrieves the Issuer Alternative Name (2.5.29.18),
contained in the given certificate in the X509v3 Certificate
Extensions.
</p>
<p>When the SAN type is otherName, it will extract the data in the
otherName&rsquo;s value field, and <code>GNUTLS_SAN_OTHERNAME</code>  is returned.
You may use <code>gnutls_x509_crt_get_subject_alt_othername_oid()</code>  to get
the corresponding OID and the &quot;virtual&quot; SAN types (e.g.,
<code>GNUTLS_SAN_OTHERNAME_XMPP</code> ).
</p>
<p>If an otherName OID is known, the data will be decoded.  Otherwise
the returned data will be DER encoded, and you will have to decode
it yourself.  Currently, only the RFC 3920 id-on-xmppAddr Issuer
AltName is recognized.
</p>
<p><strong>Returns:</strong> the alternative issuer name type on success, one of the
enumerated <code>gnutls_x509_subject_alt_name_t</code> .  It will return
<code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if  <code>ian_size</code> is not large enough
to hold the value.  In that case  <code>ian_size</code> will be updated with
the required size.  If the certificate does not have an
Alternative name with the specified sequence number then
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  is returned.
</p>
<p><strong>Since:</strong> 2.10.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fissuer_005falt_005fname2-1"></span><h4 class="subheading">gnutls_x509_crt_get_issuer_alt_name2</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fissuer_005falt_005fname2"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fissuer_005falt_005fname2">Function: <em>int</em> <strong>gnutls_x509_crt_get_issuer_alt_name2</strong> <em>(gnutls_x509_crt_t <var>cert</var>, unsigned int <var>seq</var>, void * <var>ian</var>, size_t * <var>ian_size</var>, unsigned int * <var>ian_type</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>seq</var>: specifies the sequence number of the alt name (0 for the first one, 1 for the second etc.)
</p>
<p><var>ian</var>: is the place where the alternative name will be copied to
</p>
<p><var>ian_size</var>: holds the size of ret.
</p>
<p><var>ian_type</var>: holds the type of the alternative name (one of gnutls_x509_subject_alt_name_t).
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical (may be null)
</p>
<p>This function will return the alternative names, contained in the
given certificate. It is the same as
<code>gnutls_x509_crt_get_issuer_alt_name()</code>  except for the fact that it
will return the type of the alternative name in  <code>ian_type</code> even if
the function fails for some reason (i.e.  the buffer provided is
not enough).
</p>
<p><strong>Returns:</strong> the alternative issuer name type on success, one of the
enumerated <code>gnutls_x509_subject_alt_name_t</code> .  It will return
<code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if  <code>ian_size</code> is not large enough
to hold the value.  In that case  <code>ian_size</code> will be updated with
the required size.  If the certificate does not have an
Alternative name with the specified sequence number then
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  is returned.
</p>
<p><strong>Since:</strong> 2.10.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fissuer_005falt_005fothername_005foid-1"></span><h4 class="subheading">gnutls_x509_crt_get_issuer_alt_othername_oid</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fissuer_005falt_005fothername_005foid"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fissuer_005falt_005fothername_005foid">Function: <em>int</em> <strong>gnutls_x509_crt_get_issuer_alt_othername_oid</strong> <em>(gnutls_x509_crt_t <var>cert</var>, unsigned int <var>seq</var>, void * <var>ret</var>, size_t * <var>ret_size</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>seq</var>: specifies the sequence number of the alt name (0 for the first one, 1 for the second etc.)
</p>
<p><var>ret</var>: is the place where the otherName OID will be copied to
</p>
<p><var>ret_size</var>: holds the size of ret.
</p>
<p>This function will extract the type OID of an otherName Subject
Alternative Name, contained in the given certificate, and return
the type as an enumerated element.
</p>
<p>If  <code>oid</code> is null then only the size will be filled. The  <code>oid</code> returned will be null terminated, although  <code>oid_size</code> will not
account for the trailing null.
</p>
<p>This function is only useful if
<code>gnutls_x509_crt_get_issuer_alt_name()</code>  returned
<code>GNUTLS_SAN_OTHERNAME</code> .
</p>
<p><strong>Returns:</strong> the alternative issuer name type on success, one of the
enumerated gnutls_x509_subject_alt_name_t.  For supported OIDs, it
will return one of the virtual (GNUTLS_SAN_OTHERNAME_*) types,
e.g. <code>GNUTLS_SAN_OTHERNAME_XMPP</code> , and <code>GNUTLS_SAN_OTHERNAME</code>  for
unknown OIDs.  It will return <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if
 <code>ret_size</code> is not large enough to hold the value.  In that case
 <code>ret_size</code> will be updated with the required size.  If the
certificate does not have an Alternative name with the specified
sequence number and with the otherName type then
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  is returned.
</p>
<p><strong>Since:</strong> 2.10.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fissuer_005fdn-1"></span><h4 class="subheading">gnutls_x509_crt_get_issuer_dn</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fissuer_005fdn"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fissuer_005fdn">Function: <em>int</em> <strong>gnutls_x509_crt_get_issuer_dn</strong> <em>(gnutls_x509_crt_t <var>cert</var>, char * <var>buf</var>, size_t * <var>buf_size</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>buf</var>: a pointer to a structure to hold the name (may be null)
</p>
<p><var>buf_size</var>: initially holds the size of  <code>buf</code> 
</p>
<p>This function will copy the name of the Certificate issuer in the
provided buffer. The name will be in the form
&quot;C=xxxx,O=yyyy,CN=zzzz&quot; as described in RFC4514. The output string
will be ASCII or UTF-8 encoded, depending on the certificate data.
</p>
<p>If  <code>buf</code> is null then only the size will be filled. 
</p>
<p>This function does not output a fully RFC4514 compliant string, if
that is required see <code>gnutls_x509_crt_get_issuer_dn3()</code> .
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if the provided buffer is not
long enough, and in that case the  <code>buf_size</code> will be updated
with the required size. <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  if
the DN does not exist, or another error value on error. On success 0 is returned.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fissuer_005fdn2-1"></span><h4 class="subheading">gnutls_x509_crt_get_issuer_dn2</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fissuer_005fdn2"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fissuer_005fdn2">Function: <em>int</em> <strong>gnutls_x509_crt_get_issuer_dn2</strong> <em>(gnutls_x509_crt_t <var>cert</var>, gnutls_datum_t * <var>dn</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>dn</var>: a pointer to a structure to hold the name
</p>
<p>This function will allocate buffer and copy the name of issuer of the Certificate.
The name will be in the form &quot;C=xxxx,O=yyyy,CN=zzzz&quot; as
described in RFC4514. The output string will be ASCII or UTF-8
encoded, depending on the certificate data.
</p>
<p>This function does not output a fully RFC4514 compliant string, if
that is required see <code>gnutls_x509_crt_get_issuer_dn3()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.1.10
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fissuer_005fdn3-1"></span><h4 class="subheading">gnutls_x509_crt_get_issuer_dn3</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fissuer_005fdn3"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fissuer_005fdn3">Function: <em>int</em> <strong>gnutls_x509_crt_get_issuer_dn3</strong> <em>(gnutls_x509_crt_t <var>cert</var>, gnutls_datum_t * <var>dn</var>, unsigned <var>flags</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>dn</var>: a pointer to a structure to hold the name
</p>
<p><var>flags</var>: zero or <code>GNUTLS_X509_DN_FLAG_COMPAT</code> 
</p>
<p>This function will allocate buffer and copy the name of issuer of the Certificate.
The name will be in the form &quot;C=xxxx,O=yyyy,CN=zzzz&quot; as
described in RFC4514. The output string will be ASCII or UTF-8
encoded, depending on the certificate data.
</p>
<p>When the flag <code>GNUTLS_X509_DN_FLAG_COMPAT</code>  is specified, the output
format will match the format output by previous to 3.5.6 versions of GnuTLS
which was not not fully RFC4514-compliant.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.5.7
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fissuer_005fdn_005fby_005foid-1"></span><h4 class="subheading">gnutls_x509_crt_get_issuer_dn_by_oid</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fissuer_005fdn_005fby_005foid"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fissuer_005fdn_005fby_005foid">Function: <em>int</em> <strong>gnutls_x509_crt_get_issuer_dn_by_oid</strong> <em>(gnutls_x509_crt_t <var>cert</var>, const char * <var>oid</var>, unsigned <var>indx</var>, unsigned int <var>raw_flag</var>, void * <var>buf</var>, size_t * <var>buf_size</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>oid</var>: holds an Object Identified in null terminated string
</p>
<p><var>indx</var>: In case multiple same OIDs exist in the RDN, this specifies which to send. Use (0) to get the first one.
</p>
<p><var>raw_flag</var>: If non-zero returns the raw DER data of the DN part.
</p>
<p><var>buf</var>: a pointer to a structure to hold the name (may be null)
</p>
<p><var>buf_size</var>: initially holds the size of  <code>buf</code> 
</p>
<p>This function will extract the part of the name of the Certificate
issuer specified by the given OID. The output, if the raw flag is not
used, will be encoded as described in RFC4514. Thus a string that is
ASCII or UTF-8 encoded, depending on the certificate data.
</p>
<p>Some helper macros with popular OIDs can be found in gnutls/x509.h
If raw flag is (0), this function will only return known OIDs as
text. Other OIDs will be DER encoded, as described in RFC4514 &ndash;
in hex format with a &rsquo;#&rsquo; prefix.  You can check about known OIDs
using <code>gnutls_x509_dn_oid_known()</code> .
</p>
<p>If  <code>buf</code> is null then only the size will be filled. If the  <code>raw_flag</code> is not specified the output is always null terminated, although the
 <code>buf_size</code> will not include the null character.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if the provided buffer is not
long enough, and in that case the  <code>buf_size</code> will be updated with
the required size. <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  if there 
are no data in the current index. On success 0 is returned.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fissuer_005fdn_005foid-1"></span><h4 class="subheading">gnutls_x509_crt_get_issuer_dn_oid</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fissuer_005fdn_005foid"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fissuer_005fdn_005foid">Function: <em>int</em> <strong>gnutls_x509_crt_get_issuer_dn_oid</strong> <em>(gnutls_x509_crt_t <var>cert</var>, unsigned <var>indx</var>, void * <var>oid</var>, size_t * <var>oid_size</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>indx</var>: This specifies which OID to return. Use (0) to get the first one.
</p>
<p><var>oid</var>: a pointer to a buffer to hold the OID (may be null)
</p>
<p><var>oid_size</var>: initially holds the size of  <code>oid</code> 
</p>
<p>This function will extract the OIDs of the name of the Certificate
issuer specified by the given index.
</p>
<p>If  <code>oid</code> is null then only the size will be filled. The  <code>oid</code> returned will be null terminated, although  <code>oid_size</code> will not
account for the trailing null.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if the provided buffer is not
long enough, and in that case the  <code>buf_size</code> will be updated with
the required size. <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  if there 
are no data in the current index. On success 0 is returned.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fissuer_005funique_005fid-1"></span><h4 class="subheading">gnutls_x509_crt_get_issuer_unique_id</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fissuer_005funique_005fid"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fissuer_005funique_005fid">Function: <em>int</em> <strong>gnutls_x509_crt_get_issuer_unique_id</strong> <em>(gnutls_x509_crt_t <var>crt</var>, char * <var>buf</var>, size_t * <var>buf_size</var>)</em></dt>
<dd><p><var>crt</var>: Holds the certificate
</p>
<p><var>buf</var>: user allocated memory buffer, will hold the unique id
</p>
<p><var>buf_size</var>: size of user allocated memory buffer (on input), will hold
actual size of the unique ID on return.
</p>
<p>This function will extract the issuerUniqueID value (if present) for
the given certificate.
</p>
<p>If the user allocated memory buffer is not large enough to hold the
full subjectUniqueID, then a GNUTLS_E_SHORT_MEMORY_BUFFER error will be
returned, and buf_size will be set to the actual length.
</p>
<p>This function had a bug prior to 3.4.8 that prevented the setting
of <code>NULL</code>   <code>buf</code> to discover the  <code>buf_size</code> . To use this function safely
with the older versions the  <code>buf</code> must be a valid buffer that can hold
at least a single byte if  <code>buf_size</code> is zero.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fkey_005fid-1"></span><h4 class="subheading">gnutls_x509_crt_get_key_id</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fkey_005fid"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fkey_005fid-1">Function: <em>int</em> <strong>gnutls_x509_crt_get_key_id</strong> <em>(gnutls_x509_crt_t <var>crt</var>, unsigned int <var>flags</var>, unsigned char * <var>output_data</var>, size_t * <var>output_data_size</var>)</em></dt>
<dd><p><var>crt</var>: Holds the certificate
</p>
<p><var>flags</var>: should be one of the flags from <code>gnutls_keyid_flags_t</code> 
</p>
<p><var>output_data</var>: will contain the key ID
</p>
<p><var>output_data_size</var>: holds the size of output_data (and will be
replaced by the actual size of parameters)
</p>
<p>This function will return a unique ID that depends on the public
key parameters. This ID can be used in checking whether a
certificate corresponds to the given private key.
</p>
<p>If the buffer provided is not long enough to hold the output, then
*output_data_size is updated and GNUTLS_E_SHORT_MEMORY_BUFFER will
be returned.  The output will normally be a SHA-1 hash output,
which is 20 bytes.
</p>
<p><strong>Returns:</strong> In case of failure a negative error code will be
returned, and 0 on success.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fkey_005fpurpose_005foid-1"></span><h4 class="subheading">gnutls_x509_crt_get_key_purpose_oid</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fkey_005fpurpose_005foid"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fkey_005fpurpose_005foid">Function: <em>int</em> <strong>gnutls_x509_crt_get_key_purpose_oid</strong> <em>(gnutls_x509_crt_t <var>cert</var>, unsigned <var>indx</var>, void * <var>oid</var>, size_t * <var>oid_size</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>indx</var>: This specifies which OID to return. Use (0) to get the first one.
</p>
<p><var>oid</var>: a pointer to a buffer to hold the OID (may be null)
</p>
<p><var>oid_size</var>: initially holds the size of  <code>oid</code> 
</p>
<p><var>critical</var>: output flag to indicate criticality of extension
</p>
<p>This function will extract the key purpose OIDs of the Certificate
specified by the given index.  These are stored in the Extended Key
Usage extension (2.5.29.37) See the GNUTLS_KP_* definitions for
human readable names.
</p>
<p>If  <code>oid</code> is null then only the size will be filled. The  <code>oid</code> returned will be null terminated, although  <code>oid_size</code> will not
account for the trailing null.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if the provided buffer is
not long enough, and in that case the *oid_size will be updated
with the required size.  On success 0 is returned.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fkey_005fusage-1"></span><h4 class="subheading">gnutls_x509_crt_get_key_usage</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fkey_005fusage"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fkey_005fusage">Function: <em>int</em> <strong>gnutls_x509_crt_get_key_usage</strong> <em>(gnutls_x509_crt_t <var>cert</var>, unsigned int * <var>key_usage</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>key_usage</var>: where the key usage bits will be stored
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical
</p>
<p>This function will return certificate&rsquo;s key usage, by reading the
keyUsage X.509 extension (2.5.29.15). The key usage value will ORed
values of the: <code>GNUTLS_KEY_DIGITAL_SIGNATURE</code> ,
<code>GNUTLS_KEY_NON_REPUDIATION</code> , <code>GNUTLS_KEY_KEY_ENCIPHERMENT</code> ,
<code>GNUTLS_KEY_DATA_ENCIPHERMENT</code> , <code>GNUTLS_KEY_KEY_AGREEMENT</code> ,
<code>GNUTLS_KEY_KEY_CERT_SIGN</code> , <code>GNUTLS_KEY_CRL_SIGN</code> ,
<code>GNUTLS_KEY_ENCIPHER_ONLY</code> , <code>GNUTLS_KEY_DECIPHER_ONLY</code> .
</p>
<p><strong>Returns:</strong> zero on success, or a negative error code in case of
parsing error.  If the certificate does not contain the keyUsage
extension <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  will be
returned.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fname_005fconstraints-1"></span><h4 class="subheading">gnutls_x509_crt_get_name_constraints</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fname_005fconstraints"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fname_005fconstraints">Function: <em>int</em> <strong>gnutls_x509_crt_get_name_constraints</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_x509_name_constraints_t <var>nc</var>, unsigned int <var>flags</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>crt</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>nc</var>: The nameconstraints intermediate type
</p>
<p><var>flags</var>: zero or <code>GNUTLS_EXT_FLAG_APPEND</code> 
</p>
<p><var>critical</var>: the extension status
</p>
<p>This function will return an intermediate type containing
the name constraints of the provided CA certificate. That
structure can be used in combination with <code>gnutls_x509_name_constraints_check()</code> 
to verify whether a server&rsquo;s name is in accordance with the constraints.
</p>
<p>When the  <code>flags</code> is set to <code>GNUTLS_EXT_FLAG_APPEND</code> ,
then if the  <code>nc</code> structure is empty this function will behave
identically as if the flag was not set.
Otherwise if there are elements in the  <code>nc</code> structure then the
constraints will be merged with the existing constraints following
RFC5280 p6.1.4 (excluded constraints will be appended, permitted
will be intersected).
</p>
<p>Note that  <code>nc</code> must be initialized prior to calling this function.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
if the extension is not present, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fpk_005falgorithm-1"></span><h4 class="subheading">gnutls_x509_crt_get_pk_algorithm</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fpk_005falgorithm"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fpk_005falgorithm">Function: <em>int</em> <strong>gnutls_x509_crt_get_pk_algorithm</strong> <em>(gnutls_x509_crt_t <var>cert</var>, unsigned int * <var>bits</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>bits</var>: if bits is non null it will hold the size of the parameters&rsquo; in bits
</p>
<p>This function will return the public key algorithm of an X.509
certificate.
</p>
<p>If bits is non null, it should have enough size to hold the parameters
size in bits. For RSA the bits returned is the modulus.
For DSA the bits returned are of the public
exponent.
</p>
<p>Unknown/unsupported algorithms are mapped to <code>GNUTLS_PK_UNKNOWN</code> .
</p>
<p><strong>Returns:</strong> a member of the <code>gnutls_pk_algorithm_t</code>  enumeration on
success, or a negative error code on error.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fpk_005fdsa_005fraw-1"></span><h4 class="subheading">gnutls_x509_crt_get_pk_dsa_raw</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fpk_005fdsa_005fraw"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fpk_005fdsa_005fraw">Function: <em>int</em> <strong>gnutls_x509_crt_get_pk_dsa_raw</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_datum_t * <var>p</var>, gnutls_datum_t * <var>q</var>, gnutls_datum_t * <var>g</var>, gnutls_datum_t * <var>y</var>)</em></dt>
<dd><p><var>crt</var>: Holds the certificate
</p>
<p><var>p</var>: will hold the p
</p>
<p><var>q</var>: will hold the q
</p>
<p><var>g</var>: will hold the g
</p>
<p><var>y</var>: will hold the y
</p>
<p>This function will export the DSA public key&rsquo;s parameters found in
the given certificate.  The new parameters will be allocated using
<code>gnutls_malloc()</code>  and will be stored in the appropriate datum.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fpk_005fecc_005fraw-1"></span><h4 class="subheading">gnutls_x509_crt_get_pk_ecc_raw</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fpk_005fecc_005fraw"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fpk_005fecc_005fraw">Function: <em>int</em> <strong>gnutls_x509_crt_get_pk_ecc_raw</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_ecc_curve_t * <var>curve</var>, gnutls_datum_t * <var>x</var>, gnutls_datum_t * <var>y</var>)</em></dt>
<dd><p><var>crt</var>: Holds the certificate
</p>
<p><var>curve</var>: will hold the curve
</p>
<p><var>x</var>: will hold the x-coordinate
</p>
<p><var>y</var>: will hold the y-coordinate
</p>
<p>This function will export the ECC public key&rsquo;s parameters found in
the given certificate.  The new parameters will be allocated using
<code>gnutls_malloc()</code>  and will be stored in the appropriate datum.
</p>
<p>In EdDSA curves the  <code>y</code> parameter will be <code>NULL</code>  and the other parameters
will be in the native format for the curve.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p>
<p><strong>Since:</strong> 3.4.1
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fpk_005fgost_005fraw-1"></span><h4 class="subheading">gnutls_x509_crt_get_pk_gost_raw</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fpk_005fgost_005fraw"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fpk_005fgost_005fraw">Function: <em>int</em> <strong>gnutls_x509_crt_get_pk_gost_raw</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_ecc_curve_t * <var>curve</var>, gnutls_digest_algorithm_t * <var>digest</var>, gnutls_gost_paramset_t * <var>paramset</var>, gnutls_datum_t * <var>x</var>, gnutls_datum_t * <var>y</var>)</em></dt>
<dd><p><var>crt</var>: Holds the certificate
</p>
<p><var>curve</var>: will hold the curve
</p>
<p><var>digest</var>: will hold the digest
</p>
<p><var>paramset</var>: will hold the GOST parameter set ID
</p>
<p><var>x</var>: will hold the x-coordinate
</p>
<p><var>y</var>: will hold the y-coordinate
</p>
<p>This function will export the GOST public key&rsquo;s parameters found in
the given certificate.  The new parameters will be allocated using
<code>gnutls_malloc()</code>  and will be stored in the appropriate datum.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p>
<p><strong>Since:</strong> 3.6.3
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fpk_005foid-1"></span><h4 class="subheading">gnutls_x509_crt_get_pk_oid</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fpk_005foid"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fpk_005foid">Function: <em>int</em> <strong>gnutls_x509_crt_get_pk_oid</strong> <em>(gnutls_x509_crt_t <var>cert</var>, char * <var>oid</var>, size_t * <var>oid_size</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>oid</var>: a pointer to a buffer to hold the OID (may be null)
</p>
<p><var>oid_size</var>: initially holds the size of  <code>oid</code> 
</p>
<p>This function will return the OID of the public key algorithm
on that certificate. This is function
is useful in the case <code>gnutls_x509_crt_get_pk_algorithm()</code> 
returned <code>GNUTLS_PK_UNKNOWN</code> .
</p>
<p><strong>Returns:</strong> zero or a negative error code on error.
</p>
<p><strong>Since:</strong> 3.5.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fpk_005frsa_005fraw-1"></span><h4 class="subheading">gnutls_x509_crt_get_pk_rsa_raw</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fpk_005frsa_005fraw"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fpk_005frsa_005fraw">Function: <em>int</em> <strong>gnutls_x509_crt_get_pk_rsa_raw</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_datum_t * <var>m</var>, gnutls_datum_t * <var>e</var>)</em></dt>
<dd><p><var>crt</var>: Holds the certificate
</p>
<p><var>m</var>: will hold the modulus
</p>
<p><var>e</var>: will hold the public exponent
</p>
<p>This function will export the RSA public key&rsquo;s parameters found in
the given structure.  The new parameters will be allocated using
<code>gnutls_malloc()</code>  and will be stored in the appropriate datum.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fpolicy-1"></span><h4 class="subheading">gnutls_x509_crt_get_policy</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fpolicy"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fpolicy">Function: <em>int</em> <strong>gnutls_x509_crt_get_policy</strong> <em>(gnutls_x509_crt_t <var>crt</var>, unsigned <var>indx</var>, struct gnutls_x509_policy_st * <var>policy</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>crt</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>indx</var>: This specifies which policy to return. Use (0) to get the first one.
</p>
<p><var>policy</var>: A pointer to a policy structure.
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical
</p>
<p>This function will extract the certificate policy (extension 2.5.29.32) 
specified by the given index. 
</p>
<p>The policy returned by this function must be deinitialized by using
<code>gnutls_x509_policy_release()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
if the extension is not present, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.1.5
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fprivate_005fkey_005fusage_005fperiod-1"></span><h4 class="subheading">gnutls_x509_crt_get_private_key_usage_period</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fprivate_005fkey_005fusage_005fperiod"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fprivate_005fkey_005fusage_005fperiod">Function: <em>int</em> <strong>gnutls_x509_crt_get_private_key_usage_period</strong> <em>(gnutls_x509_crt_t <var>cert</var>, time_t * <var>activation</var>, time_t * <var>expiration</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>activation</var>: The activation time
</p>
<p><var>expiration</var>: The expiration time
</p>
<p><var>critical</var>: the extension status
</p>
<p>This function will return the expiration and activation
times of the private key of the certificate. It relies on
the PKIX extension 2.5.29.16 being present.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
if the extension is not present, otherwise a negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fproxy-1"></span><h4 class="subheading">gnutls_x509_crt_get_proxy</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fproxy"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fproxy">Function: <em>int</em> <strong>gnutls_x509_crt_get_proxy</strong> <em>(gnutls_x509_crt_t <var>cert</var>, unsigned int * <var>critical</var>, int * <var>pathlen</var>, char ** <var>policyLanguage</var>, char ** <var>policy</var>, size_t * <var>sizeof_policy</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical
</p>
<p><var>pathlen</var>: pointer to output integer indicating path length (may be
NULL), non-negative error codes indicate a present pCPathLenConstraint
field and the actual value, -1 indicate that the field is absent.
</p>
<p><var>policyLanguage</var>: output variable with OID of policy language
</p>
<p><var>policy</var>: output variable with policy data
</p>
<p><var>sizeof_policy</var>: output variable size of policy data
</p>
<p>This function will get information from a proxy certificate.  It
reads the ProxyCertInfo X.509 extension (1.3.6.1.5.5.7.1.14).
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fraw_005fdn-1"></span><h4 class="subheading">gnutls_x509_crt_get_raw_dn</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fraw_005fdn"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fraw_005fdn">Function: <em>int</em> <strong>gnutls_x509_crt_get_raw_dn</strong> <em>(gnutls_x509_crt_t <var>cert</var>, gnutls_datum_t * <var>dn</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>dn</var>: will hold the starting point of the DN
</p>
<p>This function will return a pointer to the DER encoded DN structure and
the length. This points to allocated data that must be free&rsquo;d using <code>gnutls_free()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value. or a negative error code on error.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fraw_005fissuer_005fdn-1"></span><h4 class="subheading">gnutls_x509_crt_get_raw_issuer_dn</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fraw_005fissuer_005fdn"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fraw_005fissuer_005fdn">Function: <em>int</em> <strong>gnutls_x509_crt_get_raw_issuer_dn</strong> <em>(gnutls_x509_crt_t <var>cert</var>, gnutls_datum_t * <var>dn</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>dn</var>: will hold the starting point of the DN
</p>
<p>This function will return a pointer to the DER encoded DN structure
and the length. This points to allocated data that must be free&rsquo;d using <code>gnutls_free()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.or a negative error code on error.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fserial-1"></span><h4 class="subheading">gnutls_x509_crt_get_serial</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fserial"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fserial">Function: <em>int</em> <strong>gnutls_x509_crt_get_serial</strong> <em>(gnutls_x509_crt_t <var>cert</var>, void * <var>result</var>, size_t * <var>result_size</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>result</var>: The place where the serial number will be copied
</p>
<p><var>result_size</var>: Holds the size of the result field.
</p>
<p>This function will return the X.509 certificate&rsquo;s serial number.
This is obtained by the X509 Certificate serialNumber field. Serial
is not always a 32 or 64bit number. Some CAs use large serial
numbers, thus it may be wise to handle it as something uint8_t.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fsignature-1"></span><h4 class="subheading">gnutls_x509_crt_get_signature</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fsignature"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fsignature">Function: <em>int</em> <strong>gnutls_x509_crt_get_signature</strong> <em>(gnutls_x509_crt_t <var>cert</var>, char * <var>sig</var>, size_t * <var>sig_size</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>sig</var>: a pointer where the signature part will be copied (may be null).
</p>
<p><var>sig_size</var>: initially holds the size of  <code>sig</code> 
</p>
<p>This function will extract the signature field of a certificate.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fsignature_005falgorithm-1"></span><h4 class="subheading">gnutls_x509_crt_get_signature_algorithm</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fsignature_005falgorithm"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fsignature_005falgorithm">Function: <em>int</em> <strong>gnutls_x509_crt_get_signature_algorithm</strong> <em>(gnutls_x509_crt_t <var>cert</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p>This function will return a value of the <code>gnutls_sign_algorithm_t</code> 
enumeration that is the signature algorithm that has been used to
sign this certificate.
</p>
<p>Since 3.6.0 this function never returns a negative error code.
Error cases and unknown/unsupported signature algorithms are
mapped to <code>GNUTLS_SIGN_UNKNOWN</code> .
</p>
<p><strong>Returns:</strong> a <code>gnutls_sign_algorithm_t</code>  value
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fsignature_005foid-1"></span><h4 class="subheading">gnutls_x509_crt_get_signature_oid</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fsignature_005foid"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fsignature_005foid">Function: <em>int</em> <strong>gnutls_x509_crt_get_signature_oid</strong> <em>(gnutls_x509_crt_t <var>cert</var>, char * <var>oid</var>, size_t * <var>oid_size</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>oid</var>: a pointer to a buffer to hold the OID (may be null)
</p>
<p><var>oid_size</var>: initially holds the size of  <code>oid</code> 
</p>
<p>This function will return the OID of the signature algorithm
that has been used to sign this certificate. This is function
is useful in the case <code>gnutls_x509_crt_get_signature_algorithm()</code> 
returned <code>GNUTLS_SIGN_UNKNOWN</code> .
</p>
<p><strong>Returns:</strong> zero or a negative error code on error.
</p>
<p><strong>Since:</strong> 3.5.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fspki-1"></span><h4 class="subheading">gnutls_x509_crt_get_spki</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fspki"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fspki">Function: <em>int</em> <strong>gnutls_x509_crt_get_spki</strong> <em>(gnutls_x509_crt_t <var>cert</var>, gnutls_x509_spki_t <var>spki</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>cert</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>spki</var>: a SubjectPublicKeyInfo structure of type <code>gnutls_x509_spki_t</code> 
</p>
<p><var>flags</var>: must be zero
</p>
<p>This function will return the public key information of an X.509
certificate. The provided  <code>spki</code> must be initialized.
</p>
<p><strong>Since:</strong> 3.6.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fsubject-1"></span><h4 class="subheading">gnutls_x509_crt_get_subject</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fsubject"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fsubject">Function: <em>int</em> <strong>gnutls_x509_crt_get_subject</strong> <em>(gnutls_x509_crt_t <var>cert</var>, gnutls_x509_dn_t * <var>dn</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>dn</var>: output variable with pointer to uint8_t DN.
</p>
<p>Return the Certificate&rsquo;s Subject DN as a <code>gnutls_x509_dn_t</code>  data type,
that can be decoded using <code>gnutls_x509_dn_get_rdn_ava()</code> . 
</p>
<p>Note that  <code>dn</code> should be treated as constant. Because it points 
into the  <code>cert</code> object, you should not use  <code>dn</code> after  <code>cert</code> is
deallocated.
</p>
<p><strong>Returns:</strong> Returns 0 on success, or an error code.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fsubject_005falt_005fname-1"></span><h4 class="subheading">gnutls_x509_crt_get_subject_alt_name</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fsubject_005falt_005fname"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fsubject_005falt_005fname">Function: <em>int</em> <strong>gnutls_x509_crt_get_subject_alt_name</strong> <em>(gnutls_x509_crt_t <var>cert</var>, unsigned int <var>seq</var>, void * <var>san</var>, size_t * <var>san_size</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>seq</var>: specifies the sequence number of the alt name (0 for the first one, 1 for the second etc.)
</p>
<p><var>san</var>: is the place where the alternative name will be copied to
</p>
<p><var>san_size</var>: holds the size of san.
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical (may be null)
</p>
<p>This function retrieves the Alternative Name (2.5.29.17), contained
in the given certificate in the X509v3 Certificate Extensions.
</p>
<p>When the SAN type is otherName, it will extract the data in the
otherName&rsquo;s value field, and <code>GNUTLS_SAN_OTHERNAME</code>  is returned.
You may use <code>gnutls_x509_crt_get_subject_alt_othername_oid()</code>  to get
the corresponding OID and the &quot;virtual&quot; SAN types (e.g.,
<code>GNUTLS_SAN_OTHERNAME_XMPP</code> ).
</p>
<p>If an otherName OID is known, the data will be decoded.  Otherwise
the returned data will be DER encoded, and you will have to decode
it yourself.  Currently, only the RFC 3920 id-on-xmppAddr SAN is
recognized.
</p>
<p><strong>Returns:</strong> the alternative subject name type on success, one of the
enumerated <code>gnutls_x509_subject_alt_name_t</code> .  It will return
<code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if  <code>san_size</code> is not large enough to
hold the value.  In that case  <code>san_size</code> will be updated with the
required size.  If the certificate does not have an Alternative
name with the specified sequence number then
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  is returned.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fsubject_005falt_005fname2-1"></span><h4 class="subheading">gnutls_x509_crt_get_subject_alt_name2</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fsubject_005falt_005fname2"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fsubject_005falt_005fname2">Function: <em>int</em> <strong>gnutls_x509_crt_get_subject_alt_name2</strong> <em>(gnutls_x509_crt_t <var>cert</var>, unsigned int <var>seq</var>, void * <var>san</var>, size_t * <var>san_size</var>, unsigned int * <var>san_type</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>seq</var>: specifies the sequence number of the alt name (0 for the first one, 1 for the second etc.)
</p>
<p><var>san</var>: is the place where the alternative name will be copied to
</p>
<p><var>san_size</var>: holds the size of ret.
</p>
<p><var>san_type</var>: holds the type of the alternative name (one of gnutls_x509_subject_alt_name_t).
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical (may be null)
</p>
<p>This function will return the alternative names, contained in the
given certificate. It is the same as
<code>gnutls_x509_crt_get_subject_alt_name()</code>  except for the fact that it
will return the type of the alternative name in  <code>san_type</code> even if
the function fails for some reason (i.e.  the buffer provided is
not enough).
</p>
<p><strong>Returns:</strong> the alternative subject name type on success, one of the
enumerated <code>gnutls_x509_subject_alt_name_t</code> .  It will return
<code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if  <code>san_size</code> is not large enough
to hold the value.  In that case  <code>san_size</code> will be updated with
the required size.  If the certificate does not have an
Alternative name with the specified sequence number then
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  is returned.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fsubject_005falt_005fothername_005foid-1"></span><h4 class="subheading">gnutls_x509_crt_get_subject_alt_othername_oid</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fsubject_005falt_005fothername_005foid"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fsubject_005falt_005fothername_005foid">Function: <em>int</em> <strong>gnutls_x509_crt_get_subject_alt_othername_oid</strong> <em>(gnutls_x509_crt_t <var>cert</var>, unsigned int <var>seq</var>, void * <var>oid</var>, size_t * <var>oid_size</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>seq</var>: specifies the sequence number of the alt name (0 for the first one, 1 for the second etc.)
</p>
<p><var>oid</var>: is the place where the otherName OID will be copied to
</p>
<p><var>oid_size</var>: holds the size of ret.
</p>
<p>This function will extract the type OID of an otherName Subject
Alternative Name, contained in the given certificate, and return
the type as an enumerated element.
</p>
<p>This function is only useful if
<code>gnutls_x509_crt_get_subject_alt_name()</code>  returned
<code>GNUTLS_SAN_OTHERNAME</code> .
</p>
<p>If  <code>oid</code> is null then only the size will be filled. The  <code>oid</code> returned will be null terminated, although  <code>oid_size</code> will not
account for the trailing null.
</p>
<p><strong>Returns:</strong> the alternative subject name type on success, one of the
enumerated gnutls_x509_subject_alt_name_t.  For supported OIDs, it
will return one of the virtual (GNUTLS_SAN_OTHERNAME_*) types,
e.g. <code>GNUTLS_SAN_OTHERNAME_XMPP</code> , and <code>GNUTLS_SAN_OTHERNAME</code>  for
unknown OIDs.  It will return <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  if
 <code>ian_size</code> is not large enough to hold the value.  In that case
 <code>ian_size</code> will be updated with the required size.  If the
certificate does not have an Alternative name with the specified
sequence number and with the otherName type then
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  is returned.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fsubject_005fkey_005fid-1"></span><h4 class="subheading">gnutls_x509_crt_get_subject_key_id</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fsubject_005fkey_005fid"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fsubject_005fkey_005fid">Function: <em>int</em> <strong>gnutls_x509_crt_get_subject_key_id</strong> <em>(gnutls_x509_crt_t <var>cert</var>, void * <var>ret</var>, size_t * <var>ret_size</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>ret</var>: The place where the identifier will be copied
</p>
<p><var>ret_size</var>: Holds the size of the result field.
</p>
<p><var>critical</var>: will be non-zero if the extension is marked as critical (may be null)
</p>
<p>This function will return the X.509v3 certificate&rsquo;s subject key
identifier.  This is obtained by the X.509 Subject Key identifier
extension field (2.5.29.14).
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
if the extension is not present, otherwise a negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fsubject_005funique_005fid-1"></span><h4 class="subheading">gnutls_x509_crt_get_subject_unique_id</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fsubject_005funique_005fid"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fsubject_005funique_005fid">Function: <em>int</em> <strong>gnutls_x509_crt_get_subject_unique_id</strong> <em>(gnutls_x509_crt_t <var>crt</var>, char * <var>buf</var>, size_t * <var>buf_size</var>)</em></dt>
<dd><p><var>crt</var>: Holds the certificate
</p>
<p><var>buf</var>: user allocated memory buffer, will hold the unique id
</p>
<p><var>buf_size</var>: size of user allocated memory buffer (on input), will hold
actual size of the unique ID on return.
</p>
<p>This function will extract the subjectUniqueID value (if present) for
the given certificate.
</p>
<p>If the user allocated memory buffer is not large enough to hold the
full subjectUniqueID, then a GNUTLS_E_SHORT_MEMORY_BUFFER error will be
returned, and buf_size will be set to the actual length.
</p>
<p>This function had a bug prior to 3.4.8 that prevented the setting
of <code>NULL</code>   <code>buf</code> to discover the  <code>buf_size</code> . To use this function safely
with the older versions the  <code>buf</code> must be a valid buffer that can hold
at least a single byte if  <code>buf_size</code> is zero.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005ftlsfeatures-1"></span><h4 class="subheading">gnutls_x509_crt_get_tlsfeatures</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005ftlsfeatures"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005ftlsfeatures">Function: <em>int</em> <strong>gnutls_x509_crt_get_tlsfeatures</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_x509_tlsfeatures_t <var>features</var>, unsigned int <var>flags</var>, unsigned int * <var>critical</var>)</em></dt>
<dd><p><var>crt</var>: A X.509 certificate
</p>
<p><var>features</var>: If the function succeeds, the
features will be stored in this variable.
</p>
<p><var>flags</var>: zero or <code>GNUTLS_EXT_FLAG_APPEND</code> 
</p>
<p><var>critical</var>: the extension status
</p>
<p>This function will get the X.509 TLS features
extension structure from the certificate. The
returned structure needs to be freed using
<code>gnutls_x509_tlsfeatures_deinit()</code> .
</p>
<p>When the  <code>flags</code> is set to <code>GNUTLS_EXT_FLAG_APPEND</code> ,
then if the  <code>features</code> structure is empty this function will behave
identically as if the flag was not set. Otherwise if there are elements 
in the  <code>features</code> structure then they will be merged with.
</p>
<p>Note that  <code>features</code> must be initialized prior to calling this function.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.5.1
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fversion-1"></span><h4 class="subheading">gnutls_x509_crt_get_version</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fversion"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fversion">Function: <em>int</em> <strong>gnutls_x509_crt_get_version</strong> <em>(gnutls_x509_crt_t <var>cert</var>)</em></dt>
<dd><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p>This function will return the version of the specified Certificate.
</p>
<p><strong>Returns:</strong> version of certificate, or a negative error code on error.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fimport-1"></span><h4 class="subheading">gnutls_x509_crt_import</h4>
<span id="gnutls_005fx509_005fcrt_005fimport"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fimport">Function: <em>int</em> <strong>gnutls_x509_crt_import</strong> <em>(gnutls_x509_crt_t <var>cert</var>, const gnutls_datum_t * <var>data</var>, gnutls_x509_crt_fmt_t <var>format</var>)</em></dt>
<dd><p><var>cert</var>: The data to store the parsed certificate.
</p>
<p><var>data</var>: The DER or PEM encoded certificate.
</p>
<p><var>format</var>: One of DER or PEM
</p>
<p>This function will convert the given DER or PEM encoded Certificate
to the native gnutls_x509_crt_t format. The output will be stored
in  <code>cert</code> .
</p>
<p>If the Certificate is PEM encoded it should have a header of &quot;X509
CERTIFICATE&quot;, or &quot;CERTIFICATE&quot;.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fimport_005furl-1"></span><h4 class="subheading">gnutls_x509_crt_import_url</h4>
<span id="gnutls_005fx509_005fcrt_005fimport_005furl"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fimport_005furl">Function: <em>int</em> <strong>gnutls_x509_crt_import_url</strong> <em>(gnutls_x509_crt_t <var>crt</var>, const char * <var>url</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>crt</var>: A certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>url</var>: A PKCS 11 url
</p>
<p><var>flags</var>: One of GNUTLS_PKCS11_OBJ_* flags for PKCS<code>11</code>  URLs or zero otherwise
</p>
<p>This function will import a certificate present in a PKCS<code>11</code>  token
or any type of back-end that supports URLs.
</p>
<p>In previous versions of gnutls this function was named
gnutls_x509_crt_import_pkcs11_url, and the old name is
an alias to this one.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005finit-1"></span><h4 class="subheading">gnutls_x509_crt_init</h4>
<span id="gnutls_005fx509_005fcrt_005finit"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005finit">Function: <em>int</em> <strong>gnutls_x509_crt_init</strong> <em>(gnutls_x509_crt_t * <var>cert</var>)</em></dt>
<dd><p><var>cert</var>: A pointer to the type to be initialized
</p>
<p>This function will initialize an X.509 certificate structure.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005flist_005fimport-1"></span><h4 class="subheading">gnutls_x509_crt_list_import</h4>
<span id="gnutls_005fx509_005fcrt_005flist_005fimport"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005flist_005fimport">Function: <em>int</em> <strong>gnutls_x509_crt_list_import</strong> <em>(gnutls_x509_crt_t * <var>certs</var>, unsigned int * <var>cert_max</var>, const gnutls_datum_t * <var>data</var>, gnutls_x509_crt_fmt_t <var>format</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>certs</var>: Indicates where the parsed list will be copied to. Must not be initialized.
</p>
<p><var>cert_max</var>: Initially must hold the maximum number of certs. It will be updated with the number of certs available.
</p>
<p><var>data</var>: The PEM encoded certificate.
</p>
<p><var>format</var>: One of DER or PEM.
</p>
<p><var>flags</var>: must be (0) or an OR&rsquo;d sequence of gnutls_certificate_import_flags.
</p>
<p>This function will convert the given PEM encoded certificate list
to the native gnutls_x509_crt_t format. The output will be stored
in  <code>certs</code> .  They will be automatically initialized.
</p>
<p>The flag <code>GNUTLS_X509_CRT_LIST_IMPORT_FAIL_IF_EXCEED</code>  will cause
import to fail if the certificates in the provided buffer are more
than the available structures. The <code>GNUTLS_X509_CRT_LIST_FAIL_IF_UNSORTED</code> 
flag will cause the function to fail if the provided list is not
sorted from subject to issuer.
</p>
<p>If the Certificate is PEM encoded it should have a header of &quot;X509
CERTIFICATE&quot;, or &quot;CERTIFICATE&quot;.
</p>
<p><strong>Returns:</strong> the number of certificates read or a negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005flist_005fimport2-1"></span><h4 class="subheading">gnutls_x509_crt_list_import2</h4>
<span id="gnutls_005fx509_005fcrt_005flist_005fimport2"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005flist_005fimport2">Function: <em>int</em> <strong>gnutls_x509_crt_list_import2</strong> <em>(gnutls_x509_crt_t ** <var>certs</var>, unsigned int * <var>size</var>, const gnutls_datum_t * <var>data</var>, gnutls_x509_crt_fmt_t <var>format</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>certs</var>: Will hold the parsed certificate list.
</p>
<p><var>size</var>: It will contain the size of the list.
</p>
<p><var>data</var>: The PEM encoded certificate.
</p>
<p><var>format</var>: One of DER or PEM.
</p>
<p><var>flags</var>: must be (0) or an OR&rsquo;d sequence of gnutls_certificate_import_flags.
</p>
<p>This function will convert the given PEM encoded certificate list
to the native gnutls_x509_crt_t format. The output will be stored
in  <code>certs</code> which will be allocated and initialized.
</p>
<p>If the Certificate is PEM encoded it should have a header of &quot;X509
CERTIFICATE&quot;, or &quot;CERTIFICATE&quot;.
</p>
<p>To deinitialize  <code>certs</code> , you need to deinitialize each crt structure
independently, and use <code>gnutls_free()</code>  at  <code>certs</code> .
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005flist_005fimport_005furl-1"></span><h4 class="subheading">gnutls_x509_crt_list_import_url</h4>
<span id="gnutls_005fx509_005fcrt_005flist_005fimport_005furl"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005flist_005fimport_005furl">Function: <em>int</em> <strong>gnutls_x509_crt_list_import_url</strong> <em>(gnutls_x509_crt_t ** <var>certs</var>, unsigned int * <var>size</var>, const char * <var>url</var>, gnutls_pin_callback_t <var>pin_fn</var>, void * <var>pin_fn_userdata</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>certs</var>: Will hold the allocated certificate list.
</p>
<p><var>size</var>: It will contain the size of the list.
</p>
<p><var>url</var>: A PKCS 11 url
</p>
<p><var>pin_fn</var>: a PIN callback if not globally set
</p>
<p><var>pin_fn_userdata</var>: parameter for the PIN callback
</p>
<p><var>flags</var>: One of GNUTLS_PKCS11_OBJ_* flags for PKCS<code>11</code>  URLs or zero otherwise
</p>
<p>This function will import a certificate chain present in a PKCS<code>11</code>  token
or any type of back-end that supports URLs. The certificates
must be deinitialized afterwards using <code>gnutls_x509_crt_deinit()</code> 
and the returned pointer must be freed using <code>gnutls_free()</code> .
</p>
<p>The URI provided must be the first certificate in the chain; subsequent
certificates will be retrieved using <code>gnutls_pkcs11_get_raw_issuer()</code>  or
equivalent functionality for the supported URI.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.6.3
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005flist_005fverify-1"></span><h4 class="subheading">gnutls_x509_crt_list_verify</h4>
<span id="gnutls_005fx509_005fcrt_005flist_005fverify"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005flist_005fverify">Function: <em>int</em> <strong>gnutls_x509_crt_list_verify</strong> <em>(const gnutls_x509_crt_t * <var>cert_list</var>, unsigned <var>cert_list_length</var>, const gnutls_x509_crt_t * <var>CA_list</var>, unsigned <var>CA_list_length</var>, const gnutls_x509_crl_t * <var>CRL_list</var>, unsigned <var>CRL_list_length</var>, unsigned int <var>flags</var>, unsigned int * <var>verify</var>)</em></dt>
<dd><p><var>cert_list</var>: is the certificate list to be verified
</p>
<p><var>cert_list_length</var>: holds the number of certificate in cert_list
</p>
<p><var>CA_list</var>: is the CA list which will be used in verification
</p>
<p><var>CA_list_length</var>: holds the number of CA certificate in CA_list
</p>
<p><var>CRL_list</var>: holds a list of CRLs.
</p>
<p><var>CRL_list_length</var>: the length of CRL list.
</p>
<p><var>flags</var>: Flags that may be used to change the verification algorithm. Use OR of the gnutls_certificate_verify_flags enumerations.
</p>
<p><var>verify</var>: will hold the certificate verification output.
</p>

<p>This function will try to verify the given certificate list and
return its status. The details of the verification are the same
as in <code>gnutls_x509_trust_list_verify_crt2()</code> .
</p>
<p>You must check the peer&rsquo;s name in order to check if the verified
certificate belongs to the actual peer.
</p>
<p>The certificate verification output will be put in  <code>verify</code> and will
be one or more of the gnutls_certificate_status_t enumerated
elements bitwise or&rsquo;d.  For a more detailed verification status use
<code>gnutls_x509_crt_verify()</code>  per list element.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fprint-1"></span><h4 class="subheading">gnutls_x509_crt_print</h4>
<span id="gnutls_005fx509_005fcrt_005fprint"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fprint">Function: <em>int</em> <strong>gnutls_x509_crt_print</strong> <em>(gnutls_x509_crt_t <var>cert</var>, gnutls_certificate_print_formats_t <var>format</var>, gnutls_datum_t * <var>out</var>)</em></dt>
<dd><p><var>cert</var>: The data to be printed
</p>
<p><var>format</var>: Indicate the format to use
</p>
<p><var>out</var>: Newly allocated datum with null terminated string.
</p>
<p>This function will pretty print a X.509 certificate, suitable for
display to a human.
</p>
<p>If the format is <code>GNUTLS_CRT_PRINT_FULL</code>  then all fields of the
certificate will be output, on multiple lines.  The
<code>GNUTLS_CRT_PRINT_ONELINE</code>  format will generate one line with some
selected fields, which is useful for logging purposes.
</p>
<p>The output  <code>out</code> needs to be deallocated using <code>gnutls_free()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fset_005factivation_005ftime-1"></span><h4 class="subheading">gnutls_x509_crt_set_activation_time</h4>
<span id="gnutls_005fx509_005fcrt_005fset_005factivation_005ftime"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fset_005factivation_005ftime">Function: <em>int</em> <strong>gnutls_x509_crt_set_activation_time</strong> <em>(gnutls_x509_crt_t <var>cert</var>, time_t <var>act_time</var>)</em></dt>
<dd><p><var>cert</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>act_time</var>: The actual time
</p>
<p>This function will set the time this certificate was or will be
activated.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fset_005fauthority_005finfo_005faccess-1"></span><h4 class="subheading">gnutls_x509_crt_set_authority_info_access</h4>
<span id="gnutls_005fx509_005fcrt_005fset_005fauthority_005finfo_005faccess"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fset_005fauthority_005finfo_005faccess">Function: <em>int</em> <strong>gnutls_x509_crt_set_authority_info_access</strong> <em>(gnutls_x509_crt_t <var>crt</var>, int <var>what</var>, gnutls_datum_t * <var>data</var>)</em></dt>
<dd><p><var>crt</var>: Holds the certificate
</p>
<p><var>what</var>: what data to get, a <code>gnutls_info_access_what_t</code>  type.
</p>
<p><var>data</var>: output data to be freed with <code>gnutls_free()</code> .
</p>
<p>This function sets the Authority Information Access (AIA)
extension, see RFC 5280 section 4.2.2.1 for more information.  
</p>
<p>The type of data stored in  <code>data</code> is specified via  <code>what</code> which
should be <code>gnutls_info_access_what_t</code>  values.
</p>
<p>If  <code>what</code> is <code>GNUTLS_IA_OCSP_URI</code> ,  <code>data</code> will hold the OCSP URI.
If  <code>what</code> is <code>GNUTLS_IA_CAISSUERS_URI</code> ,  <code>data</code> will hold the caIssuers
URI.  
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fset_005fauthority_005fkey_005fid-1"></span><h4 class="subheading">gnutls_x509_crt_set_authority_key_id</h4>
<span id="gnutls_005fx509_005fcrt_005fset_005fauthority_005fkey_005fid"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fset_005fauthority_005fkey_005fid">Function: <em>int</em> <strong>gnutls_x509_crt_set_authority_key_id</strong> <em>(gnutls_x509_crt_t <var>cert</var>, const void * <var>id</var>, size_t <var>id_size</var>)</em></dt>
<dd><p><var>cert</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>id</var>: The key ID
</p>
<p><var>id_size</var>: Holds the size of the key ID field.
</p>
<p>This function will set the X.509 certificate&rsquo;s authority key ID extension.
Only the keyIdentifier field can be set with this function.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fset_005fbasic_005fconstraints-1"></span><h4 class="subheading">gnutls_x509_crt_set_basic_constraints</h4>
<span id="gnutls_005fx509_005fcrt_005fset_005fbasic_005fconstraints"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fset_005fbasic_005fconstraints">Function: <em>int</em> <strong>gnutls_x509_crt_set_basic_constraints</strong> <em>(gnutls_x509_crt_t <var>crt</var>, unsigned int <var>ca</var>, int <var>pathLenConstraint</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>ca</var>: true(1) or false(0). Depending on the Certificate authority status.
</p>
<p><var>pathLenConstraint</var>: non-negative error codes indicate maximum length of path,
and negative error codes indicate that the pathLenConstraints field should
not be present.
</p>
<p>This function will set the basicConstraints certificate extension.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fset_005fca_005fstatus-1"></span><h4 class="subheading">gnutls_x509_crt_set_ca_status</h4>
<span id="gnutls_005fx509_005fcrt_005fset_005fca_005fstatus"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fset_005fca_005fstatus">Function: <em>int</em> <strong>gnutls_x509_crt_set_ca_status</strong> <em>(gnutls_x509_crt_t <var>crt</var>, unsigned int <var>ca</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>ca</var>: true(1) or false(0). Depending on the Certificate authority status.
</p>
<p>This function will set the basicConstraints certificate extension.
Use <code>gnutls_x509_crt_set_basic_constraints()</code>  if you want to control
the pathLenConstraint field too.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fset_005fcrl_005fdist_005fpoints-1"></span><h4 class="subheading">gnutls_x509_crt_set_crl_dist_points</h4>
<span id="gnutls_005fx509_005fcrt_005fset_005fcrl_005fdist_005fpoints"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fset_005fcrl_005fdist_005fpoints">Function: <em>int</em> <strong>gnutls_x509_crt_set_crl_dist_points</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_x509_subject_alt_name_t <var>type</var>, const void * <var>data_string</var>, unsigned int <var>reason_flags</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>type</var>: is one of the gnutls_x509_subject_alt_name_t enumerations
</p>
<p><var>data_string</var>: The data to be set
</p>
<p><var>reason_flags</var>: revocation reasons
</p>
<p>This function will set the CRL distribution points certificate extension.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fset_005fcrl_005fdist_005fpoints2-1"></span><h4 class="subheading">gnutls_x509_crt_set_crl_dist_points2</h4>
<span id="gnutls_005fx509_005fcrt_005fset_005fcrl_005fdist_005fpoints2"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fset_005fcrl_005fdist_005fpoints2">Function: <em>int</em> <strong>gnutls_x509_crt_set_crl_dist_points2</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_x509_subject_alt_name_t <var>type</var>, const void * <var>data</var>, unsigned int <var>data_size</var>, unsigned int <var>reason_flags</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>type</var>: is one of the gnutls_x509_subject_alt_name_t enumerations
</p>
<p><var>data</var>: The data to be set
</p>
<p><var>data_size</var>: The data size
</p>
<p><var>reason_flags</var>: revocation reasons
</p>
<p>This function will set the CRL distribution points certificate extension.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.6.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fset_005fcrq-1"></span><h4 class="subheading">gnutls_x509_crt_set_crq</h4>
<span id="gnutls_005fx509_005fcrt_005fset_005fcrq"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fset_005fcrq">Function: <em>int</em> <strong>gnutls_x509_crt_set_crq</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_x509_crq_t <var>crq</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>crq</var>: holds a certificate request
</p>
<p>This function will set the name and public parameters as well as
the extensions from the given certificate request to the certificate. 
Only RSA keys are currently supported.
</p>
<p>Note that this function will only set the  <code>crq</code> if it is self
signed and the signature is correct. See <code>gnutls_x509_crq_sign2()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fset_005fcrq_005fextension_005fby_005foid-1"></span><h4 class="subheading">gnutls_x509_crt_set_crq_extension_by_oid</h4>
<span id="gnutls_005fx509_005fcrt_005fset_005fcrq_005fextension_005fby_005foid"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fset_005fcrq_005fextension_005fby_005foid">Function: <em>int</em> <strong>gnutls_x509_crt_set_crq_extension_by_oid</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_x509_crq_t <var>crq</var>, const char * <var>oid</var>, unsigned <var>flags</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>crq</var>: holds a certificate request
</p>
<p><var>oid</var>: the object identifier of the OID to copy
</p>
<p><var>flags</var>: should be zero
</p>
<p>This function will set the extension specify by  <code>oid</code> from the given request to the
certificate.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.5.1
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fset_005fcrq_005fextensions-1"></span><h4 class="subheading">gnutls_x509_crt_set_crq_extensions</h4>
<span id="gnutls_005fx509_005fcrt_005fset_005fcrq_005fextensions"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fset_005fcrq_005fextensions">Function: <em>int</em> <strong>gnutls_x509_crt_set_crq_extensions</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_x509_crq_t <var>crq</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>crq</var>: holds a certificate request
</p>
<p>This function will set the extensions from the given request to the
certificate.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.8.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fset_005fdn-1"></span><h4 class="subheading">gnutls_x509_crt_set_dn</h4>
<span id="gnutls_005fx509_005fcrt_005fset_005fdn"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fset_005fdn">Function: <em>int</em> <strong>gnutls_x509_crt_set_dn</strong> <em>(gnutls_x509_crt_t <var>crt</var>, const char * <var>dn</var>, const char ** <var>err</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>dn</var>: a comma separated DN string (RFC4514)
</p>
<p><var>err</var>: indicates the error position (if any)
</p>
<p>This function will set the DN on the provided certificate.
The input string should be plain ASCII or UTF-8 encoded. On
DN parsing error <code>GNUTLS_E_PARSING_ERROR</code>  is returned.
</p>
<p>Note that DNs are not expected to hold DNS information, and thus
no automatic IDNA conversions are attempted when using this function.
If that is required (e.g., store a domain in CN), process the corresponding
input with <code>gnutls_idna_map()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fset_005fdn_005fby_005foid-1"></span><h4 class="subheading">gnutls_x509_crt_set_dn_by_oid</h4>
<span id="gnutls_005fx509_005fcrt_005fset_005fdn_005fby_005foid"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fset_005fdn_005fby_005foid">Function: <em>int</em> <strong>gnutls_x509_crt_set_dn_by_oid</strong> <em>(gnutls_x509_crt_t <var>crt</var>, const char * <var>oid</var>, unsigned int <var>raw_flag</var>, const void * <var>name</var>, unsigned int <var>sizeof_name</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>oid</var>: holds an Object Identifier in a null terminated string
</p>
<p><var>raw_flag</var>: must be 0, or 1 if the data are DER encoded
</p>
<p><var>name</var>: a pointer to the name
</p>
<p><var>sizeof_name</var>: holds the size of  <code>name</code> 
</p>
<p>This function will set the part of the name of the Certificate
subject, specified by the given OID. The input string should be
ASCII or UTF-8 encoded.
</p>
<p>Some helper macros with popular OIDs can be found in gnutls/x509.h
With this function you can only set the known OIDs. You can test
for known OIDs using <code>gnutls_x509_dn_oid_known()</code> . For OIDs that are
not known (by gnutls) you should properly DER encode your data,
and call this function with  <code>raw_flag</code> set.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fset_005fexpiration_005ftime-1"></span><h4 class="subheading">gnutls_x509_crt_set_expiration_time</h4>
<span id="gnutls_005fx509_005fcrt_005fset_005fexpiration_005ftime"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fset_005fexpiration_005ftime">Function: <em>int</em> <strong>gnutls_x509_crt_set_expiration_time</strong> <em>(gnutls_x509_crt_t <var>cert</var>, time_t <var>exp_time</var>)</em></dt>
<dd><p><var>cert</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>exp_time</var>: The actual time
</p>
<p>This function will set the time this Certificate will expire.
Setting an expiration time to (time_t)-1 will set
to the no well-defined expiration date value.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fset_005fextension_005fby_005foid-1"></span><h4 class="subheading">gnutls_x509_crt_set_extension_by_oid</h4>
<span id="gnutls_005fx509_005fcrt_005fset_005fextension_005fby_005foid"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fset_005fextension_005fby_005foid">Function: <em>int</em> <strong>gnutls_x509_crt_set_extension_by_oid</strong> <em>(gnutls_x509_crt_t <var>crt</var>, const char * <var>oid</var>, const void * <var>buf</var>, size_t <var>sizeof_buf</var>, unsigned int <var>critical</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>oid</var>: holds an Object Identifier in null terminated string
</p>
<p><var>buf</var>: a pointer to a DER encoded data
</p>
<p><var>sizeof_buf</var>: holds the size of  <code>buf</code> 
</p>
<p><var>critical</var>: should be non-zero if the extension is to be marked as critical
</p>
<p>This function will set an the extension, by the specified OID, in
the certificate.  The extension data should be binary data DER
encoded.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fset_005fflags-1"></span><h4 class="subheading">gnutls_x509_crt_set_flags</h4>
<span id="gnutls_005fx509_005fcrt_005fset_005fflags"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fset_005fflags">Function: <em>void</em> <strong>gnutls_x509_crt_set_flags</strong> <em>(gnutls_x509_crt_t <var>cert</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>cert</var>: A type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>flags</var>: flags from the <code>gnutls_x509_crt_flags</code> 
</p>
<p>This function will set flags for the specified certificate.
Currently this is useful for the <code>GNUTLS_X509_CRT_FLAG_IGNORE_SANITY</code> 
which allows importing certificates even if they have known issues.
</p>
<p><strong>Since:</strong> 3.6.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fset_005finhibit_005fanypolicy-1"></span><h4 class="subheading">gnutls_x509_crt_set_inhibit_anypolicy</h4>
<span id="gnutls_005fx509_005fcrt_005fset_005finhibit_005fanypolicy"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fset_005finhibit_005fanypolicy">Function: <em>int</em> <strong>gnutls_x509_crt_set_inhibit_anypolicy</strong> <em>(gnutls_x509_crt_t <var>crt</var>, unsigned int <var>skipcerts</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>skipcerts</var>: number of certificates after which anypolicy is no longer acceptable.
</p>
<p>This function will set the Inhibit anyPolicy certificate extension.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fset_005fissuer_005falt_005fname-1"></span><h4 class="subheading">gnutls_x509_crt_set_issuer_alt_name</h4>
<span id="gnutls_005fx509_005fcrt_005fset_005fissuer_005falt_005fname"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fset_005fissuer_005falt_005fname">Function: <em>int</em> <strong>gnutls_x509_crt_set_issuer_alt_name</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_x509_subject_alt_name_t <var>type</var>, const void * <var>data</var>, unsigned int <var>data_size</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>type</var>: is one of the gnutls_x509_subject_alt_name_t enumerations
</p>
<p><var>data</var>: The data to be set
</p>
<p><var>data_size</var>: The size of data to be set
</p>
<p><var>flags</var>: GNUTLS_FSAN_SET to clear previous data or GNUTLS_FSAN_APPEND to append. 
</p>
<p>This function will set the issuer alternative name certificate
extension. It can set the same types as <code>gnutls_x509_crt_set_subject_alt_name()</code> .
</p>
<p>Since version 3.5.7 the <code>GNUTLS_SAN_RFC822NAME</code> , <code>GNUTLS_SAN_DNSNAME</code> , and
<code>GNUTLS_SAN_OTHERNAME_XMPP</code>  are converted to ACE format when necessary.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fset_005fissuer_005falt_005fothername-1"></span><h4 class="subheading">gnutls_x509_crt_set_issuer_alt_othername</h4>
<span id="gnutls_005fx509_005fcrt_005fset_005fissuer_005falt_005fothername"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fset_005fissuer_005falt_005fothername">Function: <em>int</em> <strong>gnutls_x509_crt_set_issuer_alt_othername</strong> <em>(gnutls_x509_crt_t <var>crt</var>, const char * <var>oid</var>, const void * <var>data</var>, unsigned int <var>data_size</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>oid</var>: The other name OID
</p>
<p><var>data</var>: The data to be set
</p>
<p><var>data_size</var>: The size of data to be set
</p>
<p><var>flags</var>: GNUTLS_FSAN_SET to clear previous data or GNUTLS_FSAN_APPEND to append. 
</p>
<p>This function will set an &quot;othername&quot; to the issuer alternative name certificate
extension.
</p>
<p>The values set are set as binary values and are expected to have the proper DER encoding.
For convenience the flags <code>GNUTLS_FSAN_ENCODE_OCTET_STRING</code>  and <code>GNUTLS_FSAN_ENCODE_UTF8_STRING</code> 
can be used to encode the provided data.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.5.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fset_005fissuer_005fdn-1"></span><h4 class="subheading">gnutls_x509_crt_set_issuer_dn</h4>
<span id="gnutls_005fx509_005fcrt_005fset_005fissuer_005fdn"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fset_005fissuer_005fdn">Function: <em>int</em> <strong>gnutls_x509_crt_set_issuer_dn</strong> <em>(gnutls_x509_crt_t <var>crt</var>, const char * <var>dn</var>, const char ** <var>err</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>dn</var>: a comma separated DN string (RFC4514)
</p>
<p><var>err</var>: indicates the error position (if any)
</p>
<p>This function will set the DN on the provided certificate.
The input string should be plain ASCII or UTF-8 encoded. On
DN parsing error <code>GNUTLS_E_PARSING_ERROR</code>  is returned.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fset_005fissuer_005fdn_005fby_005foid-1"></span><h4 class="subheading">gnutls_x509_crt_set_issuer_dn_by_oid</h4>
<span id="gnutls_005fx509_005fcrt_005fset_005fissuer_005fdn_005fby_005foid"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fset_005fissuer_005fdn_005fby_005foid">Function: <em>int</em> <strong>gnutls_x509_crt_set_issuer_dn_by_oid</strong> <em>(gnutls_x509_crt_t <var>crt</var>, const char * <var>oid</var>, unsigned int <var>raw_flag</var>, const void * <var>name</var>, unsigned int <var>sizeof_name</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>oid</var>: holds an Object Identifier in a null terminated string
</p>
<p><var>raw_flag</var>: must be 0, or 1 if the data are DER encoded
</p>
<p><var>name</var>: a pointer to the name
</p>
<p><var>sizeof_name</var>: holds the size of  <code>name</code> 
</p>
<p>This function will set the part of the name of the Certificate
issuer, specified by the given OID.  The input string should be
ASCII or UTF-8 encoded.
</p>
<p>Some helper macros with popular OIDs can be found in gnutls/x509.h
With this function you can only set the known OIDs. You can test
for known OIDs using <code>gnutls_x509_dn_oid_known()</code> . For OIDs that are
not known (by gnutls) you should properly DER encode your data,
and call this function with  <code>raw_flag</code> set.
</p>
<p>Normally you do not need to call this function, since the signing
operation will copy the signer&rsquo;s name as the issuer of the
certificate.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fset_005fissuer_005funique_005fid-1"></span><h4 class="subheading">gnutls_x509_crt_set_issuer_unique_id</h4>
<span id="gnutls_005fx509_005fcrt_005fset_005fissuer_005funique_005fid"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fset_005fissuer_005funique_005fid">Function: <em>int</em> <strong>gnutls_x509_crt_set_issuer_unique_id</strong> <em>(gnutls_x509_crt_t <var>cert</var>, const void * <var>id</var>, size_t <var>id_size</var>)</em></dt>
<dd><p><var>cert</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>id</var>: The unique ID
</p>
<p><var>id_size</var>: Holds the size of the unique ID.
</p>
<p>This function will set the X.509 certificate&rsquo;s issuer unique ID field.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.4.7
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fset_005fkey-1"></span><h4 class="subheading">gnutls_x509_crt_set_key</h4>
<span id="gnutls_005fx509_005fcrt_005fset_005fkey"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fset_005fkey">Function: <em>int</em> <strong>gnutls_x509_crt_set_key</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_x509_privkey_t <var>key</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>key</var>: holds a private key
</p>
<p>This function will set the public parameters from the given
private key to the certificate.
</p>
<p>To export the public key (i.e., the SubjectPublicKeyInfo part), check
<code>gnutls_pubkey_import_x509()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fset_005fkey_005fpurpose_005foid-1"></span><h4 class="subheading">gnutls_x509_crt_set_key_purpose_oid</h4>
<span id="gnutls_005fx509_005fcrt_005fset_005fkey_005fpurpose_005foid"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fset_005fkey_005fpurpose_005foid">Function: <em>int</em> <strong>gnutls_x509_crt_set_key_purpose_oid</strong> <em>(gnutls_x509_crt_t <var>cert</var>, const void * <var>oid</var>, unsigned int <var>critical</var>)</em></dt>
<dd><p><var>cert</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>oid</var>: a pointer to a null terminated string that holds the OID
</p>
<p><var>critical</var>: Whether this extension will be critical or not
</p>
<p>This function will set the key purpose OIDs of the Certificate.
These are stored in the Extended Key Usage extension (2.5.29.37)
See the GNUTLS_KP_* definitions for human readable names.
</p>
<p>Subsequent calls to this function will append OIDs to the OID list.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fset_005fkey_005fusage-1"></span><h4 class="subheading">gnutls_x509_crt_set_key_usage</h4>
<span id="gnutls_005fx509_005fcrt_005fset_005fkey_005fusage"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fset_005fkey_005fusage">Function: <em>int</em> <strong>gnutls_x509_crt_set_key_usage</strong> <em>(gnutls_x509_crt_t <var>crt</var>, unsigned int <var>usage</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>usage</var>: an ORed sequence of the GNUTLS_KEY_* elements.
</p>
<p>This function will set the keyUsage certificate extension.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fset_005fname_005fconstraints-1"></span><h4 class="subheading">gnutls_x509_crt_set_name_constraints</h4>
<span id="gnutls_005fx509_005fcrt_005fset_005fname_005fconstraints"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fset_005fname_005fconstraints">Function: <em>int</em> <strong>gnutls_x509_crt_set_name_constraints</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_x509_name_constraints_t <var>nc</var>, unsigned int <var>critical</var>)</em></dt>
<dd><p><var>crt</var>: The certificate
</p>
<p><var>nc</var>: The nameconstraints structure
</p>
<p><var>critical</var>: whether this extension will be critical
</p>
<p>This function will set the provided name constraints to
the certificate extension list. This extension is always
marked as critical.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fset_005fpin_005ffunction-1"></span><h4 class="subheading">gnutls_x509_crt_set_pin_function</h4>
<span id="gnutls_005fx509_005fcrt_005fset_005fpin_005ffunction"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fset_005fpin_005ffunction">Function: <em>void</em> <strong>gnutls_x509_crt_set_pin_function</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_pin_callback_t <var>fn</var>, void * <var>userdata</var>)</em></dt>
<dd><p><var>crt</var>: The certificate structure
</p>
<p><var>fn</var>: the callback
</p>
<p><var>userdata</var>: data associated with the callback
</p>
<p>This function will set a callback function to be used when
it is required to access a protected object. This function overrides 
the global function set using <code>gnutls_pkcs11_set_pin_function()</code> .
</p>
<p>Note that this callback is currently used only during the import
of a PKCS <code>11</code>  certificate with <code>gnutls_x509_crt_import_url()</code> .
</p>
<p><strong>Since:</strong> 3.1.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fset_005fpolicy-1"></span><h4 class="subheading">gnutls_x509_crt_set_policy</h4>
<span id="gnutls_005fx509_005fcrt_005fset_005fpolicy"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fset_005fpolicy">Function: <em>int</em> <strong>gnutls_x509_crt_set_policy</strong> <em>(gnutls_x509_crt_t <var>crt</var>, const struct gnutls_x509_policy_st * <var>policy</var>, unsigned int <var>critical</var>)</em></dt>
<dd><p><var>crt</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>policy</var>: A pointer to a policy
</p>
<p><var>critical</var>: use non-zero if the extension is marked as critical
</p>
<p>This function will set the certificate policy extension (2.5.29.32).
Multiple calls to this function append a new policy.
</p>
<p>Note the maximum text size for the qualifier <code>GNUTLS_X509_QUALIFIER_NOTICE</code> 
is 200 characters. This function will fail with <code>GNUTLS_E_INVALID_REQUEST</code> 
if this is exceeded.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.1.5
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fset_005fprivate_005fkey_005fusage_005fperiod-1"></span><h4 class="subheading">gnutls_x509_crt_set_private_key_usage_period</h4>
<span id="gnutls_005fx509_005fcrt_005fset_005fprivate_005fkey_005fusage_005fperiod"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fset_005fprivate_005fkey_005fusage_005fperiod">Function: <em>int</em> <strong>gnutls_x509_crt_set_private_key_usage_period</strong> <em>(gnutls_x509_crt_t <var>crt</var>, time_t <var>activation</var>, time_t <var>expiration</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>activation</var>: The activation time
</p>
<p><var>expiration</var>: The expiration time
</p>
<p>This function will set the private key usage period extension (2.5.29.16).
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fset_005fproxy-1"></span><h4 class="subheading">gnutls_x509_crt_set_proxy</h4>
<span id="gnutls_005fx509_005fcrt_005fset_005fproxy"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fset_005fproxy">Function: <em>int</em> <strong>gnutls_x509_crt_set_proxy</strong> <em>(gnutls_x509_crt_t <var>crt</var>, int <var>pathLenConstraint</var>, const char * <var>policyLanguage</var>, const char * <var>policy</var>, size_t <var>sizeof_policy</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>pathLenConstraint</var>: non-negative error codes indicate maximum length of path,
and negative error codes indicate that the pathLenConstraints field should
not be present.
</p>
<p><var>policyLanguage</var>: OID describing the language of  <code>policy</code> .
</p>
<p><var>policy</var>: uint8_t byte array with policy language, can be <code>NULL</code> 
</p>
<p><var>sizeof_policy</var>: size of  <code>policy</code> .
</p>
<p>This function will set the proxyCertInfo extension.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fset_005fproxy_005fdn-1"></span><h4 class="subheading">gnutls_x509_crt_set_proxy_dn</h4>
<span id="gnutls_005fx509_005fcrt_005fset_005fproxy_005fdn"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fset_005fproxy_005fdn">Function: <em>int</em> <strong>gnutls_x509_crt_set_proxy_dn</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_x509_crt_t <var>eecrt</var>, unsigned int <var>raw_flag</var>, const void * <var>name</var>, unsigned int <var>sizeof_name</var>)</em></dt>
<dd><p><var>crt</var>: a gnutls_x509_crt_t type with the new proxy cert
</p>
<p><var>eecrt</var>: the end entity certificate that will be issuing the proxy
</p>
<p><var>raw_flag</var>: must be 0, or 1 if the CN is DER encoded
</p>
<p><var>name</var>: a pointer to the CN name, may be NULL (but MUST then be added later)
</p>
<p><var>sizeof_name</var>: holds the size of  <code>name</code> 
</p>
<p>This function will set the subject in  <code>crt</code> to the end entity&rsquo;s
 <code>eecrt</code> subject name, and add a single Common Name component  <code>name</code> of size  <code>sizeof_name</code> .  This corresponds to the required proxy
certificate naming style.  Note that if  <code>name</code> is <code>NULL</code> , you MUST
set it later by using <code>gnutls_x509_crt_set_dn_by_oid()</code>  or similar.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fset_005fserial-1"></span><h4 class="subheading">gnutls_x509_crt_set_serial</h4>
<span id="gnutls_005fx509_005fcrt_005fset_005fserial"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fset_005fserial">Function: <em>int</em> <strong>gnutls_x509_crt_set_serial</strong> <em>(gnutls_x509_crt_t <var>cert</var>, const void * <var>serial</var>, size_t <var>serial_size</var>)</em></dt>
<dd><p><var>cert</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>serial</var>: The serial number
</p>
<p><var>serial_size</var>: Holds the size of the serial field.
</p>
<p>This function will set the X.509 certificate&rsquo;s serial number.
While the serial number is an integer, it is often handled
as an opaque field by several CAs. For this reason this function
accepts any kind of data as a serial number. To be consistent
with the X.509/PKIX specifications the provided  <code>serial</code> should be 
a big-endian positive number (i.e. it&rsquo;s leftmost bit should be zero).
</p>
<p>The size of the serial is restricted to 20 bytes maximum by RFC5280.
This function allows writing more than 20 bytes but the generated
certificates in that case may be rejected by other implementations.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fset_005fspki-1"></span><h4 class="subheading">gnutls_x509_crt_set_spki</h4>
<span id="gnutls_005fx509_005fcrt_005fset_005fspki"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fset_005fspki">Function: <em>int</em> <strong>gnutls_x509_crt_set_spki</strong> <em>(gnutls_x509_crt_t <var>crt</var>, const gnutls_x509_spki_t <var>spki</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>spki</var>: a SubjectPublicKeyInfo structure of type <code>gnutls_x509_spki_t</code> 
</p>
<p><var>flags</var>: must be zero
</p>
<p>This function will set the certificate&rsquo;s subject public key
information explicitly. This is intended to be used in the cases
where a single public key (e.g., RSA) can be used for multiple
signature algorithms (RSA PKCS1-1.5, and RSA-PSS).
</p>
<p>To export the public key (i.e., the SubjectPublicKeyInfo part), check
<code>gnutls_pubkey_import_x509()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.6.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fset_005fsubject_005falternative_005fname-1"></span><h4 class="subheading">gnutls_x509_crt_set_subject_alternative_name</h4>
<span id="gnutls_005fx509_005fcrt_005fset_005fsubject_005falternative_005fname"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fset_005fsubject_005falternative_005fname">Function: <em>int</em> <strong>gnutls_x509_crt_set_subject_alternative_name</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_x509_subject_alt_name_t           <var>type</var>, const char * <var>data_string</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>type</var>: is one of the gnutls_x509_subject_alt_name_t enumerations
</p>
<p><var>data_string</var>: The data to be set, a (0) terminated string
</p>
<p>This function will set the subject alternative name certificate
extension. This function assumes that data can be expressed as a null
terminated string.
</p>
<p>The name of the function is unfortunate since it is inconsistent with
<code>gnutls_x509_crt_get_subject_alt_name()</code> .
</p>
<p>See <code>gnutls_x509_crt_set_subject_alt_name()</code>  for more information.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fset_005fsubject_005falt_005fname-1"></span><h4 class="subheading">gnutls_x509_crt_set_subject_alt_name</h4>
<span id="gnutls_005fx509_005fcrt_005fset_005fsubject_005falt_005fname"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fset_005fsubject_005falt_005fname">Function: <em>int</em> <strong>gnutls_x509_crt_set_subject_alt_name</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_x509_subject_alt_name_t <var>type</var>, const void * <var>data</var>, unsigned int <var>data_size</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>type</var>: is one of the gnutls_x509_subject_alt_name_t enumerations
</p>
<p><var>data</var>: The data to be set
</p>
<p><var>data_size</var>: The size of data to be set
</p>
<p><var>flags</var>: GNUTLS_FSAN_SET to clear previous data or GNUTLS_FSAN_APPEND to append. 
</p>
<p>This function will set the subject alternative name certificate
extension. It can set the following types: <code>GNUTLS_SAN_DNSNAME</code>  as a text string,
<code>GNUTLS_SAN_RFC822NAME</code>  as a text string, <code>GNUTLS_SAN_URI</code>  as a text string,
<code>GNUTLS_SAN_IPADDRESS</code>  as a binary IP address (4 or 16 bytes),
<code>GNUTLS_SAN_OTHERNAME_XMPP</code>  as a UTF8 string (since 3.5.0).
</p>
<p>Since version 3.5.7 the <code>GNUTLS_SAN_RFC822NAME</code> , <code>GNUTLS_SAN_DNSNAME</code> , and
<code>GNUTLS_SAN_OTHERNAME_XMPP</code>  are converted to ACE format when necessary.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.6.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fset_005fsubject_005falt_005fothername-1"></span><h4 class="subheading">gnutls_x509_crt_set_subject_alt_othername</h4>
<span id="gnutls_005fx509_005fcrt_005fset_005fsubject_005falt_005fothername"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fset_005fsubject_005falt_005fothername">Function: <em>int</em> <strong>gnutls_x509_crt_set_subject_alt_othername</strong> <em>(gnutls_x509_crt_t <var>crt</var>, const char * <var>oid</var>, const void * <var>data</var>, unsigned int <var>data_size</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>oid</var>: The other name OID
</p>
<p><var>data</var>: The data to be set
</p>
<p><var>data_size</var>: The size of data to be set
</p>
<p><var>flags</var>: GNUTLS_FSAN_SET to clear previous data or GNUTLS_FSAN_APPEND to append. 
</p>
<p>This function will set an &quot;othername&quot; to the subject alternative name certificate
extension.
</p>
<p>The values set are set as binary values and are expected to have the proper DER encoding.
For convenience the flags <code>GNUTLS_FSAN_ENCODE_OCTET_STRING</code>  and <code>GNUTLS_FSAN_ENCODE_UTF8_STRING</code> 
can be used to encode the provided data.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.5.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fset_005fsubject_005fkey_005fid-1"></span><h4 class="subheading">gnutls_x509_crt_set_subject_key_id</h4>
<span id="gnutls_005fx509_005fcrt_005fset_005fsubject_005fkey_005fid"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fset_005fsubject_005fkey_005fid">Function: <em>int</em> <strong>gnutls_x509_crt_set_subject_key_id</strong> <em>(gnutls_x509_crt_t <var>cert</var>, const void * <var>id</var>, size_t <var>id_size</var>)</em></dt>
<dd><p><var>cert</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>id</var>: The key ID
</p>
<p><var>id_size</var>: Holds the size of the subject key ID field.
</p>
<p>This function will set the X.509 certificate&rsquo;s subject key ID
extension.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fset_005fsubject_005funique_005fid-1"></span><h4 class="subheading">gnutls_x509_crt_set_subject_unique_id</h4>
<span id="gnutls_005fx509_005fcrt_005fset_005fsubject_005funique_005fid"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fset_005fsubject_005funique_005fid">Function: <em>int</em> <strong>gnutls_x509_crt_set_subject_unique_id</strong> <em>(gnutls_x509_crt_t <var>cert</var>, const void * <var>id</var>, size_t <var>id_size</var>)</em></dt>
<dd><p><var>cert</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>id</var>: The unique ID
</p>
<p><var>id_size</var>: Holds the size of the unique ID.
</p>
<p>This function will set the X.509 certificate&rsquo;s subject unique ID field.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.4.7
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fset_005ftlsfeatures-1"></span><h4 class="subheading">gnutls_x509_crt_set_tlsfeatures</h4>
<span id="gnutls_005fx509_005fcrt_005fset_005ftlsfeatures"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fset_005ftlsfeatures">Function: <em>int</em> <strong>gnutls_x509_crt_set_tlsfeatures</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_x509_tlsfeatures_t <var>features</var>)</em></dt>
<dd><p><var>crt</var>: A X.509 certificate
</p>
<p><var>features</var>: If the function succeeds, the
features will be added to the certificate.
</p>
<p>This function will set the certificates
X.509 TLS extension from the given structure.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.5.1
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fset_005fversion-1"></span><h4 class="subheading">gnutls_x509_crt_set_version</h4>
<span id="gnutls_005fx509_005fcrt_005fset_005fversion"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fset_005fversion">Function: <em>int</em> <strong>gnutls_x509_crt_set_version</strong> <em>(gnutls_x509_crt_t <var>crt</var>, unsigned int <var>version</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>version</var>: holds the version number. For X.509v1 certificates must be 1.
</p>
<p>This function will set the version of the certificate.  This must
be one for X.509 version 1, and so on.  Plain certificates without
extensions must have version set to one.
</p>
<p>To create well-formed certificates, you must specify version 3 if
you use any certificate extensions.  Extensions are created by
functions such as <code>gnutls_x509_crt_set_subject_alt_name()</code> 
or <code>gnutls_x509_crt_set_key_usage()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fsign-1"></span><h4 class="subheading">gnutls_x509_crt_sign</h4>
<span id="gnutls_005fx509_005fcrt_005fsign"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fsign">Function: <em>int</em> <strong>gnutls_x509_crt_sign</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_x509_crt_t <var>issuer</var>, gnutls_x509_privkey_t <var>issuer_key</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>issuer</var>: is the certificate of the certificate issuer
</p>
<p><var>issuer_key</var>: holds the issuer&rsquo;s private key
</p>
<p>This function is the same a <code>gnutls_x509_crt_sign2()</code>  with no flags,
and an appropriate hash algorithm. The hash algorithm used may
vary between versions of GnuTLS, and it is tied to the security
level of the issuer&rsquo;s public key.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fsign2-1"></span><h4 class="subheading">gnutls_x509_crt_sign2</h4>
<span id="gnutls_005fx509_005fcrt_005fsign2"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fsign2">Function: <em>int</em> <strong>gnutls_x509_crt_sign2</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_x509_crt_t <var>issuer</var>, gnutls_x509_privkey_t <var>issuer_key</var>, gnutls_digest_algorithm_t <var>dig</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>issuer</var>: is the certificate of the certificate issuer
</p>
<p><var>issuer_key</var>: holds the issuer&rsquo;s private key
</p>
<p><var>dig</var>: The message digest to use, <code>GNUTLS_DIG_SHA256</code>  is a safe choice
</p>
<p><var>flags</var>: must be 0
</p>
<p>This function will sign the certificate with the issuer&rsquo;s private key, and
will copy the issuer&rsquo;s information into the certificate.
</p>
<p>This must be the last step in a certificate generation since all
the previously set parameters are now signed.
</p>
<p>A known limitation of this function is, that a newly-signed certificate will not
be fully functional (e.g., for signature verification), until it
is exported an re-imported.
</p>
<p>After GnuTLS 3.6.1 the value of  <code>dig</code> may be <code>GNUTLS_DIG_UNKNOWN</code> ,
and in that case, a suitable but reasonable for the key algorithm will be selected.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fverify-1"></span><h4 class="subheading">gnutls_x509_crt_verify</h4>
<span id="gnutls_005fx509_005fcrt_005fverify"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fverify">Function: <em>int</em> <strong>gnutls_x509_crt_verify</strong> <em>(gnutls_x509_crt_t <var>cert</var>, const gnutls_x509_crt_t * <var>CA_list</var>, unsigned <var>CA_list_length</var>, unsigned int <var>flags</var>, unsigned int * <var>verify</var>)</em></dt>
<dd><p><var>cert</var>: is the certificate to be verified
</p>
<p><var>CA_list</var>: is one certificate that is considered to be trusted one
</p>
<p><var>CA_list_length</var>: holds the number of CA certificate in CA_list
</p>
<p><var>flags</var>: Flags that may be used to change the verification algorithm. Use OR of the gnutls_certificate_verify_flags enumerations.
</p>
<p><var>verify</var>: will hold the certificate verification output.
</p>
<p>This function will try to verify the given certificate and return
its status. Note that a verification error does not imply a negative
return status. In that case the  <code>verify</code> status is set.
</p>
<p>The details of the verification are the same
as in <code>gnutls_x509_trust_list_verify_crt2()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fverify_005fdata2-1"></span><h4 class="subheading">gnutls_x509_crt_verify_data2</h4>
<span id="gnutls_005fx509_005fcrt_005fverify_005fdata2"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fverify_005fdata2">Function: <em>int</em> <strong>gnutls_x509_crt_verify_data2</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_sign_algorithm_t <var>algo</var>, unsigned int <var>flags</var>, const gnutls_datum_t * <var>data</var>, const gnutls_datum_t * <var>signature</var>)</em></dt>
<dd><p><var>crt</var>: Holds the certificate to verify with
</p>
<p><var>algo</var>: The signature algorithm used
</p>
<p><var>flags</var>: Zero or an OR list of <code>gnutls_certificate_verify_flags</code> 
</p>
<p><var>data</var>: holds the signed data
</p>
<p><var>signature</var>: contains the signature
</p>
<p>This function will verify the given signed data, using the
parameters from the certificate.
</p>
<p><strong>Returns:</strong> In case of a verification failure <code>GNUTLS_E_PK_SIG_VERIFY_FAILED</code>  
is returned, <code>GNUTLS_E_EXPIRED</code>  or <code>GNUTLS_E_NOT_YET_ACTIVATED</code>  on expired
or not yet activated certificate and zero or positive code on success.
</p>
<p>Note that since GnuTLS 3.5.6 this function introduces checks in the
end certificate ( <code>crt</code> ), including time checks and key usage checks.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fx509_005fdn_005fdeinit-1"></span><h4 class="subheading">gnutls_x509_dn_deinit</h4>
<span id="gnutls_005fx509_005fdn_005fdeinit"></span><dl>
<dt id="index-gnutls_005fx509_005fdn_005fdeinit">Function: <em>void</em> <strong>gnutls_x509_dn_deinit</strong> <em>(gnutls_x509_dn_t <var>dn</var>)</em></dt>
<dd><p><var>dn</var>: a DN uint8_t object pointer.
</p>
<p>This function deallocates the DN object as returned by
<code>gnutls_x509_dn_import()</code> .
</p>
<p><strong>Since:</strong> 2.4.0
</p></dd></dl>

<span id="gnutls_005fx509_005fdn_005fexport-1"></span><h4 class="subheading">gnutls_x509_dn_export</h4>
<span id="gnutls_005fx509_005fdn_005fexport"></span><dl>
<dt id="index-gnutls_005fx509_005fdn_005fexport">Function: <em>int</em> <strong>gnutls_x509_dn_export</strong> <em>(gnutls_x509_dn_t <var>dn</var>, gnutls_x509_crt_fmt_t <var>format</var>, void * <var>output_data</var>, size_t * <var>output_data_size</var>)</em></dt>
<dd><p><var>dn</var>: Holds the uint8_t DN object
</p>
<p><var>format</var>: the format of output params. One of PEM or DER.
</p>
<p><var>output_data</var>: will contain a DN PEM or DER encoded
</p>
<p><var>output_data_size</var>: holds the size of output_data (and will be
replaced by the actual size of parameters)
</p>
<p>This function will export the DN to DER or PEM format.
</p>
<p>If the buffer provided is not long enough to hold the output, then
* <code>output_data_size</code> is updated and <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> 
will be returned.
</p>
<p>If the structure is PEM encoded, it will have a header
of &quot;BEGIN NAME&quot;.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fdn_005fexport2-1"></span><h4 class="subheading">gnutls_x509_dn_export2</h4>
<span id="gnutls_005fx509_005fdn_005fexport2"></span><dl>
<dt id="index-gnutls_005fx509_005fdn_005fexport2">Function: <em>int</em> <strong>gnutls_x509_dn_export2</strong> <em>(gnutls_x509_dn_t <var>dn</var>, gnutls_x509_crt_fmt_t <var>format</var>, gnutls_datum_t * <var>out</var>)</em></dt>
<dd><p><var>dn</var>: Holds the uint8_t DN object
</p>
<p><var>format</var>: the format of output params. One of PEM or DER.
</p>
<p><var>out</var>: will contain a DN PEM or DER encoded
</p>
<p>This function will export the DN to DER or PEM format.
</p>
<p>The output buffer is allocated using <code>gnutls_malloc()</code> .
</p>
<p>If the structure is PEM encoded, it will have a header
of &quot;BEGIN NAME&quot;.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.1.3
</p></dd></dl>

<span id="gnutls_005fx509_005fdn_005fget_005frdn_005fava-1"></span><h4 class="subheading">gnutls_x509_dn_get_rdn_ava</h4>
<span id="gnutls_005fx509_005fdn_005fget_005frdn_005fava"></span><dl>
<dt id="index-gnutls_005fx509_005fdn_005fget_005frdn_005fava-1">Function: <em>int</em> <strong>gnutls_x509_dn_get_rdn_ava</strong> <em>(gnutls_x509_dn_t <var>dn</var>, int <var>irdn</var>, int <var>iava</var>, gnutls_x509_ava_st * <var>ava</var>)</em></dt>
<dd><p><var>dn</var>: a pointer to DN
</p>
<p><var>irdn</var>: index of RDN
</p>
<p><var>iava</var>: index of AVA.
</p>
<p><var>ava</var>: Pointer to structure which will hold output information.
</p>
<p>Get pointers to data within the DN. The format of the  <code>ava</code> structure
is shown below.
</p>
<p>struct gnutls_x509_ava_st {
gnutls_datum_t oid;
gnutls_datum_t value;
unsigned long value_tag;
};
</p>
<p>The X.509 distinguished name is a sequence of sequences of strings
and this is what the  <code>irdn</code> and  <code>iava</code> indexes model.
</p>
<p>Note that  <code>ava</code> will contain pointers into the  <code>dn</code> structure which
in turns points to the original certificate. Thus you should not
modify any data or deallocate any of those.
</p>
<p>This is a low-level function that requires the caller to do the
value conversions when necessary (e.g. from UCS-2).
</p>
<p><strong>Returns:</strong> Returns 0 on success, or an error code.
</p></dd></dl>

<span id="gnutls_005fx509_005fdn_005fget_005fstr-1"></span><h4 class="subheading">gnutls_x509_dn_get_str</h4>
<span id="gnutls_005fx509_005fdn_005fget_005fstr"></span><dl>
<dt id="index-gnutls_005fx509_005fdn_005fget_005fstr">Function: <em>int</em> <strong>gnutls_x509_dn_get_str</strong> <em>(gnutls_x509_dn_t <var>dn</var>, gnutls_datum_t * <var>str</var>)</em></dt>
<dd><p><var>dn</var>: a pointer to DN
</p>
<p><var>str</var>: a datum that will hold the name
</p>
<p>This function will allocate buffer and copy the name in the provided DN.
The name will be in the form &quot;C=xxxx,O=yyyy,CN=zzzz&quot; as
described in RFC4514. The output string will be ASCII or UTF-8
encoded, depending on the certificate data.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.4.2
</p></dd></dl>

<span id="gnutls_005fx509_005fdn_005fget_005fstr2-1"></span><h4 class="subheading">gnutls_x509_dn_get_str2</h4>
<span id="gnutls_005fx509_005fdn_005fget_005fstr2"></span><dl>
<dt id="index-gnutls_005fx509_005fdn_005fget_005fstr2">Function: <em>int</em> <strong>gnutls_x509_dn_get_str2</strong> <em>(gnutls_x509_dn_t <var>dn</var>, gnutls_datum_t * <var>str</var>, unsigned <var>flags</var>)</em></dt>
<dd><p><var>dn</var>: a pointer to DN
</p>
<p><var>str</var>: a datum that will hold the name
</p>
<p><var>flags</var>: zero or <code>GNUTLS_X509_DN_FLAG_COMPAT</code> 
</p>
<p>This function will allocate buffer and copy the name in the provided DN.
The name will be in the form &quot;C=xxxx,O=yyyy,CN=zzzz&quot; as
described in RFC4514. The output string will be ASCII or UTF-8
encoded, depending on the certificate data.
</p>
<p>When the flag <code>GNUTLS_X509_DN_FLAG_COMPAT</code>  is specified, the output
format will match the format output by previous to 3.5.6 versions of GnuTLS
which was not not fully RFC4514-compliant.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.5.7
</p></dd></dl>

<span id="gnutls_005fx509_005fdn_005fimport-1"></span><h4 class="subheading">gnutls_x509_dn_import</h4>
<span id="gnutls_005fx509_005fdn_005fimport"></span><dl>
<dt id="index-gnutls_005fx509_005fdn_005fimport">Function: <em>int</em> <strong>gnutls_x509_dn_import</strong> <em>(gnutls_x509_dn_t <var>dn</var>, const gnutls_datum_t * <var>data</var>)</em></dt>
<dd><p><var>dn</var>: the structure that will hold the imported DN
</p>
<p><var>data</var>: should contain a DER encoded RDN sequence
</p>
<p>This function parses an RDN sequence and stores the result to a
<code>gnutls_x509_dn_t</code>  type. The data must have been initialized
with <code>gnutls_x509_dn_init()</code> . You may use <code>gnutls_x509_dn_get_rdn_ava()</code>  to
decode the DN.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.4.0
</p></dd></dl>

<span id="gnutls_005fx509_005fdn_005finit-1"></span><h4 class="subheading">gnutls_x509_dn_init</h4>
<span id="gnutls_005fx509_005fdn_005finit"></span><dl>
<dt id="index-gnutls_005fx509_005fdn_005finit">Function: <em>int</em> <strong>gnutls_x509_dn_init</strong> <em>(gnutls_x509_dn_t * <var>dn</var>)</em></dt>
<dd><p><var>dn</var>: the object to be initialized
</p>
<p>This function initializes a <code>gnutls_x509_dn_t</code>  type.
</p>
<p>The object returned must be deallocated using
<code>gnutls_x509_dn_deinit()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.4.0
</p></dd></dl>

<span id="gnutls_005fx509_005fdn_005foid_005fknown-1"></span><h4 class="subheading">gnutls_x509_dn_oid_known</h4>
<span id="gnutls_005fx509_005fdn_005foid_005fknown"></span><dl>
<dt id="index-gnutls_005fx509_005fdn_005foid_005fknown">Function: <em>int</em> <strong>gnutls_x509_dn_oid_known</strong> <em>(const char * <var>oid</var>)</em></dt>
<dd><p><var>oid</var>: holds an Object Identifier in a null terminated string
</p>
<p>This function will inform about known DN OIDs. This is useful since
functions like <code>gnutls_x509_crt_set_dn_by_oid()</code>  use the information
on known OIDs to properly encode their input. Object Identifiers
that are not known are not encoded by these functions, and their
input is stored directly into the ASN.1 structure. In that case of
unknown OIDs, you have the responsibility of DER encoding your
data.
</p>
<p><strong>Returns:</strong> 1 on known OIDs and 0 otherwise.
</p></dd></dl>

<span id="gnutls_005fx509_005fdn_005foid_005fname-1"></span><h4 class="subheading">gnutls_x509_dn_oid_name</h4>
<span id="gnutls_005fx509_005fdn_005foid_005fname"></span><dl>
<dt id="index-gnutls_005fx509_005fdn_005foid_005fname">Function: <em>const char *</em> <strong>gnutls_x509_dn_oid_name</strong> <em>(const char * <var>oid</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>oid</var>: holds an Object Identifier in a null terminated string
</p>
<p><var>flags</var>: 0 or GNUTLS_X509_DN_OID_*
</p>
<p>This function will return the name of a known DN OID. If
<code>GNUTLS_X509_DN_OID_RETURN_OID</code>  is specified this function
will return the given OID if no descriptive name has been
found.
</p>
<p><strong>Returns:</strong> A null terminated string or NULL otherwise.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fdn_005fset_005fstr-1"></span><h4 class="subheading">gnutls_x509_dn_set_str</h4>
<span id="gnutls_005fx509_005fdn_005fset_005fstr"></span><dl>
<dt id="index-gnutls_005fx509_005fdn_005fset_005fstr">Function: <em>int</em> <strong>gnutls_x509_dn_set_str</strong> <em>(gnutls_x509_dn_t <var>dn</var>, const char * <var>str</var>, const char ** <var>err</var>)</em></dt>
<dd><p><var>dn</var>: a pointer to DN
</p>
<p><var>str</var>: a comma separated DN string (RFC4514)
</p>
<p><var>err</var>: indicates the error position (if any)
</p>
<p>This function will set the DN on the provided DN structure.
The input string should be plain ASCII or UTF-8 encoded. On
DN parsing error <code>GNUTLS_E_PARSING_ERROR</code>  is returned.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.5.3
</p></dd></dl>

<span id="gnutls_005fx509_005fext_005fdeinit-1"></span><h4 class="subheading">gnutls_x509_ext_deinit</h4>
<span id="gnutls_005fx509_005fext_005fdeinit"></span><dl>
<dt id="index-gnutls_005fx509_005fext_005fdeinit">Function: <em>void</em> <strong>gnutls_x509_ext_deinit</strong> <em>(gnutls_x509_ext_st * <var>ext</var>)</em></dt>
<dd><p><var>ext</var>: The extensions structure
</p>
<p>This function will deinitialize an extensions structure.
</p>
<p><strong>Since:</strong> 3.3.8
</p></dd></dl>

<span id="gnutls_005fx509_005fext_005fexport_005faia-1"></span><h4 class="subheading">gnutls_x509_ext_export_aia</h4>
<span id="gnutls_005fx509_005fext_005fexport_005faia"></span><dl>
<dt id="index-gnutls_005fx509_005fext_005fexport_005faia">Function: <em>int</em> <strong>gnutls_x509_ext_export_aia</strong> <em>(gnutls_x509_aia_t <var>aia</var>, gnutls_datum_t * <var>ext</var>)</em></dt>
<dd><p><var>aia</var>: The authority info access
</p>
<p><var>ext</var>: The DER-encoded extension data; must be freed using <code>gnutls_free()</code> .
</p>
<p>This function will DER encode the Authority Information Access (AIA)
extension; see RFC 5280 section 4.2.2.1 for more information on the
extension.  
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fext_005fexport_005fauthority_005fkey_005fid-1"></span><h4 class="subheading">gnutls_x509_ext_export_authority_key_id</h4>
<span id="gnutls_005fx509_005fext_005fexport_005fauthority_005fkey_005fid"></span><dl>
<dt id="index-gnutls_005fx509_005fext_005fexport_005fauthority_005fkey_005fid">Function: <em>int</em> <strong>gnutls_x509_ext_export_authority_key_id</strong> <em>(gnutls_x509_aki_t <var>aki</var>, gnutls_datum_t * <var>ext</var>)</em></dt>
<dd><p><var>aki</var>: An initialized authority key identifier
</p>
<p><var>ext</var>: The DER-encoded extension data; must be freed using <code>gnutls_free()</code> .
</p>
<p>This function will convert the provided key identifier to a
DER-encoded PKIX AuthorityKeyIdentifier extension. 
The output data in  <code>ext</code> will be allocated using
<code>gnutls_malloc()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fext_005fexport_005fbasic_005fconstraints-1"></span><h4 class="subheading">gnutls_x509_ext_export_basic_constraints</h4>
<span id="gnutls_005fx509_005fext_005fexport_005fbasic_005fconstraints"></span><dl>
<dt id="index-gnutls_005fx509_005fext_005fexport_005fbasic_005fconstraints">Function: <em>int</em> <strong>gnutls_x509_ext_export_basic_constraints</strong> <em>(unsigned int <var>ca</var>, int <var>pathlen</var>, gnutls_datum_t * <var>ext</var>)</em></dt>
<dd><p><var>ca</var>: non-zero for a CA
</p>
<p><var>pathlen</var>: The path length constraint (set to -1 for no constraint)
</p>
<p><var>ext</var>: The DER-encoded extension data; must be freed using <code>gnutls_free()</code> .
</p>
<p>This function will convert the parameters provided to a basic constraints
DER encoded extension (2.5.29.19).
The  <code>ext</code> data will be allocated using
<code>gnutls_malloc()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fext_005fexport_005fcrl_005fdist_005fpoints-1"></span><h4 class="subheading">gnutls_x509_ext_export_crl_dist_points</h4>
<span id="gnutls_005fx509_005fext_005fexport_005fcrl_005fdist_005fpoints"></span><dl>
<dt id="index-gnutls_005fx509_005fext_005fexport_005fcrl_005fdist_005fpoints">Function: <em>int</em> <strong>gnutls_x509_ext_export_crl_dist_points</strong> <em>(gnutls_x509_crl_dist_points_t <var>cdp</var>, gnutls_datum_t * <var>ext</var>)</em></dt>
<dd><p><var>cdp</var>: A pointer to an initialized CRL distribution points.
</p>
<p><var>ext</var>: The DER-encoded extension data; must be freed using <code>gnutls_free()</code> .
</p>
<p>This function will convert the provided policies, to a certificate policy
DER encoded extension (2.5.29.31).
</p>
<p>The  <code>ext</code> data will be allocated using <code>gnutls_malloc()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fext_005fexport_005finhibit_005fanypolicy-1"></span><h4 class="subheading">gnutls_x509_ext_export_inhibit_anypolicy</h4>
<span id="gnutls_005fx509_005fext_005fexport_005finhibit_005fanypolicy"></span><dl>
<dt id="index-gnutls_005fx509_005fext_005fexport_005finhibit_005fanypolicy">Function: <em>int</em> <strong>gnutls_x509_ext_export_inhibit_anypolicy</strong> <em>(unsigned int <var>skipcerts</var>, gnutls_datum_t * <var>ext</var>)</em></dt>
<dd><p><var>skipcerts</var>: number of certificates after which anypolicy is no longer acceptable.
</p>
<p><var>ext</var>: The DER-encoded extension data; must be freed using <code>gnutls_free()</code> .
</p>
<p>This function will convert the  <code>skipcerts</code> value to a DER
encoded Inhibit AnyPolicy PKIX extension. The  <code>ext</code> data will be allocated using
<code>gnutls_malloc()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.6.0
</p></dd></dl>

<span id="gnutls_005fx509_005fext_005fexport_005fkey_005fpurposes-1"></span><h4 class="subheading">gnutls_x509_ext_export_key_purposes</h4>
<span id="gnutls_005fx509_005fext_005fexport_005fkey_005fpurposes"></span><dl>
<dt id="index-gnutls_005fx509_005fext_005fexport_005fkey_005fpurposes">Function: <em>int</em> <strong>gnutls_x509_ext_export_key_purposes</strong> <em>(gnutls_x509_key_purposes_t <var>p</var>, gnutls_datum_t * <var>ext</var>)</em></dt>
<dd><p><var>p</var>: The key purposes
</p>
<p><var>ext</var>: The DER-encoded extension data; must be freed using <code>gnutls_free()</code> .
</p>
<p>This function will convert the key purposes type to a
DER-encoded PKIX ExtKeyUsageSyntax (2.5.29.37) extension. The output data in 
 <code>ext</code> will be allocated using <code>gnutls_malloc()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fext_005fexport_005fkey_005fusage-1"></span><h4 class="subheading">gnutls_x509_ext_export_key_usage</h4>
<span id="gnutls_005fx509_005fext_005fexport_005fkey_005fusage"></span><dl>
<dt id="index-gnutls_005fx509_005fext_005fexport_005fkey_005fusage">Function: <em>int</em> <strong>gnutls_x509_ext_export_key_usage</strong> <em>(unsigned int <var>usage</var>, gnutls_datum_t * <var>ext</var>)</em></dt>
<dd><p><var>usage</var>: an ORed sequence of the GNUTLS_KEY_* elements.
</p>
<p><var>ext</var>: The DER-encoded extension data; must be freed using <code>gnutls_free()</code> .
</p>
<p>This function will convert the keyUsage bit string to a DER
encoded PKIX extension. The  <code>ext</code> data will be allocated using
<code>gnutls_malloc()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fext_005fexport_005fname_005fconstraints-1"></span><h4 class="subheading">gnutls_x509_ext_export_name_constraints</h4>
<span id="gnutls_005fx509_005fext_005fexport_005fname_005fconstraints"></span><dl>
<dt id="index-gnutls_005fx509_005fext_005fexport_005fname_005fconstraints">Function: <em>int</em> <strong>gnutls_x509_ext_export_name_constraints</strong> <em>(gnutls_x509_name_constraints_t <var>nc</var>, gnutls_datum_t * <var>ext</var>)</em></dt>
<dd><p><var>nc</var>: The nameconstraints
</p>
<p><var>ext</var>: The DER-encoded extension data; must be freed using <code>gnutls_free()</code> .
</p>
<p>This function will convert the provided name constraints type to a
DER-encoded PKIX NameConstraints (2.5.29.30) extension. The output data in 
 <code>ext</code> will be allocated using <code>gnutls_malloc()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fext_005fexport_005fpolicies-1"></span><h4 class="subheading">gnutls_x509_ext_export_policies</h4>
<span id="gnutls_005fx509_005fext_005fexport_005fpolicies"></span><dl>
<dt id="index-gnutls_005fx509_005fext_005fexport_005fpolicies">Function: <em>int</em> <strong>gnutls_x509_ext_export_policies</strong> <em>(gnutls_x509_policies_t <var>policies</var>, gnutls_datum_t * <var>ext</var>)</em></dt>
<dd><p><var>policies</var>: A pointer to an initialized policies.
</p>
<p><var>ext</var>: The DER-encoded extension data; must be freed using <code>gnutls_free()</code> .
</p>
<p>This function will convert the provided policies, to a certificate policy
DER encoded extension (2.5.29.32).
</p>
<p>The  <code>ext</code> data will be allocated using <code>gnutls_malloc()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fext_005fexport_005fprivate_005fkey_005fusage_005fperiod-1"></span><h4 class="subheading">gnutls_x509_ext_export_private_key_usage_period</h4>
<span id="gnutls_005fx509_005fext_005fexport_005fprivate_005fkey_005fusage_005fperiod"></span><dl>
<dt id="index-gnutls_005fx509_005fext_005fexport_005fprivate_005fkey_005fusage_005fperiod">Function: <em>int</em> <strong>gnutls_x509_ext_export_private_key_usage_period</strong> <em>(time_t <var>activation</var>, time_t <var>expiration</var>, gnutls_datum_t * <var>ext</var>)</em></dt>
<dd><p><var>activation</var>: The activation time
</p>
<p><var>expiration</var>: The expiration time
</p>
<p><var>ext</var>: The DER-encoded extension data; must be freed using <code>gnutls_free()</code> .
</p>
<p>This function will convert the periods provided to a private key
usage DER encoded extension (2.5.29.16).
The  <code>ext</code> data will be allocated using
<code>gnutls_malloc()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fext_005fexport_005fproxy-1"></span><h4 class="subheading">gnutls_x509_ext_export_proxy</h4>
<span id="gnutls_005fx509_005fext_005fexport_005fproxy"></span><dl>
<dt id="index-gnutls_005fx509_005fext_005fexport_005fproxy">Function: <em>int</em> <strong>gnutls_x509_ext_export_proxy</strong> <em>(int <var>pathLenConstraint</var>, const char * <var>policyLanguage</var>, const char * <var>policy</var>, size_t <var>sizeof_policy</var>, gnutls_datum_t * <var>ext</var>)</em></dt>
<dd><p><var>pathLenConstraint</var>: A negative value will remove the path length constraint,
while non-negative values will be set as the length of the pathLenConstraints field.
</p>
<p><var>policyLanguage</var>: OID describing the language of  <code>policy</code> .
</p>
<p><var>policy</var>: uint8_t byte array with policy language, can be <code>NULL</code> 
</p>
<p><var>sizeof_policy</var>: size of  <code>policy</code> .
</p>
<p><var>ext</var>: The DER-encoded extension data; must be freed using <code>gnutls_free()</code> .
</p>
<p>This function will convert the parameters provided to a proxyCertInfo extension.
</p>
<p>The  <code>ext</code> data will be allocated using <code>gnutls_malloc()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fext_005fexport_005fsubject_005falt_005fnames-1"></span><h4 class="subheading">gnutls_x509_ext_export_subject_alt_names</h4>
<span id="gnutls_005fx509_005fext_005fexport_005fsubject_005falt_005fnames"></span><dl>
<dt id="index-gnutls_005fx509_005fext_005fexport_005fsubject_005falt_005fnames">Function: <em>int</em> <strong>gnutls_x509_ext_export_subject_alt_names</strong> <em>(gnutls_subject_alt_names_t <var>sans</var>, gnutls_datum_t * <var>ext</var>)</em></dt>
<dd><p><var>sans</var>: The alternative names
</p>
<p><var>ext</var>: The DER-encoded extension data; must be freed using <code>gnutls_free()</code> .
</p>
<p>This function will convert the provided alternative names structure to a
DER-encoded SubjectAltName PKIX extension. The output data in  <code>ext</code> will be allocated using
<code>gnutls_malloc()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fext_005fexport_005fsubject_005fkey_005fid-1"></span><h4 class="subheading">gnutls_x509_ext_export_subject_key_id</h4>
<span id="gnutls_005fx509_005fext_005fexport_005fsubject_005fkey_005fid"></span><dl>
<dt id="index-gnutls_005fx509_005fext_005fexport_005fsubject_005fkey_005fid">Function: <em>int</em> <strong>gnutls_x509_ext_export_subject_key_id</strong> <em>(const gnutls_datum_t * <var>id</var>, gnutls_datum_t * <var>ext</var>)</em></dt>
<dd><p><var>id</var>: The key identifier
</p>
<p><var>ext</var>: The DER-encoded extension data; must be freed using <code>gnutls_free()</code> .
</p>
<p>This function will convert the provided key identifier to a
DER-encoded PKIX SubjectKeyIdentifier extension. 
The output data in  <code>ext</code> will be allocated using
<code>gnutls_malloc()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fext_005fexport_005ftlsfeatures-1"></span><h4 class="subheading">gnutls_x509_ext_export_tlsfeatures</h4>
<span id="gnutls_005fx509_005fext_005fexport_005ftlsfeatures"></span><dl>
<dt id="index-gnutls_005fx509_005fext_005fexport_005ftlsfeatures">Function: <em>int</em> <strong>gnutls_x509_ext_export_tlsfeatures</strong> <em>(gnutls_x509_tlsfeatures_t <var>f</var>, gnutls_datum_t * <var>ext</var>)</em></dt>
<dd><p><var>f</var>: The features structure
</p>
<p><var>ext</var>: The DER-encoded extension data; must be freed using <code>gnutls_free()</code> .
</p>
<p>This function will convert the provided TLS features structure structure to a
DER-encoded TLS features PKIX extension. The output data in  <code>ext</code> will be allocated using
<code>gnutls_malloc()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.5.1
</p></dd></dl>

<span id="gnutls_005fx509_005fext_005fimport_005faia-1"></span><h4 class="subheading">gnutls_x509_ext_import_aia</h4>
<span id="gnutls_005fx509_005fext_005fimport_005faia"></span><dl>
<dt id="index-gnutls_005fx509_005fext_005fimport_005faia">Function: <em>int</em> <strong>gnutls_x509_ext_import_aia</strong> <em>(const gnutls_datum_t * <var>ext</var>, gnutls_x509_aia_t <var>aia</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>ext</var>: The DER-encoded extension data
</p>
<p><var>aia</var>: The authority info access
</p>
<p><var>flags</var>: should be zero
</p>
<p>This function extracts the Authority Information Access (AIA)
extension from the provided DER-encoded data; see RFC 5280 section 4.2.2.1 
for more information on the extension.  The
AIA extension holds a sequence of AccessDescription (AD) data.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fext_005fimport_005fauthority_005fkey_005fid-1"></span><h4 class="subheading">gnutls_x509_ext_import_authority_key_id</h4>
<span id="gnutls_005fx509_005fext_005fimport_005fauthority_005fkey_005fid"></span><dl>
<dt id="index-gnutls_005fx509_005fext_005fimport_005fauthority_005fkey_005fid">Function: <em>int</em> <strong>gnutls_x509_ext_import_authority_key_id</strong> <em>(const gnutls_datum_t * <var>ext</var>, gnutls_x509_aki_t <var>aki</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>ext</var>: a DER encoded extension
</p>
<p><var>aki</var>: An initialized authority key identifier type
</p>
<p><var>flags</var>: should be zero
</p>
<p>This function will return the subject key ID stored in the provided
AuthorityKeyIdentifier extension.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
if the extension is not present, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fext_005fimport_005fbasic_005fconstraints-1"></span><h4 class="subheading">gnutls_x509_ext_import_basic_constraints</h4>
<span id="gnutls_005fx509_005fext_005fimport_005fbasic_005fconstraints"></span><dl>
<dt id="index-gnutls_005fx509_005fext_005fimport_005fbasic_005fconstraints">Function: <em>int</em> <strong>gnutls_x509_ext_import_basic_constraints</strong> <em>(const gnutls_datum_t * <var>ext</var>, unsigned int * <var>ca</var>, int * <var>pathlen</var>)</em></dt>
<dd><p><var>ext</var>: the DER encoded extension data
</p>
<p><var>ca</var>: will be non zero if the CA status is true
</p>
<p><var>pathlen</var>: the path length constraint; will be set to -1 for no limit
</p>
<p>This function will return the CA status and path length constraint
as written in the PKIX extension 2.5.29.19.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fext_005fimport_005fcrl_005fdist_005fpoints-1"></span><h4 class="subheading">gnutls_x509_ext_import_crl_dist_points</h4>
<span id="gnutls_005fx509_005fext_005fimport_005fcrl_005fdist_005fpoints"></span><dl>
<dt id="index-gnutls_005fx509_005fext_005fimport_005fcrl_005fdist_005fpoints">Function: <em>int</em> <strong>gnutls_x509_ext_import_crl_dist_points</strong> <em>(const gnutls_datum_t * <var>ext</var>, gnutls_x509_crl_dist_points_t <var>cdp</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>ext</var>: the DER encoded extension data
</p>
<p><var>cdp</var>: A pointer to an initialized CRL distribution points.
</p>
<p><var>flags</var>: should be zero
</p>
<p>This function will extract the CRL distribution points extension (2.5.29.31) 
and store it into the provided type.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fext_005fimport_005finhibit_005fanypolicy-1"></span><h4 class="subheading">gnutls_x509_ext_import_inhibit_anypolicy</h4>
<span id="gnutls_005fx509_005fext_005fimport_005finhibit_005fanypolicy"></span><dl>
<dt id="index-gnutls_005fx509_005fext_005fimport_005finhibit_005fanypolicy">Function: <em>int</em> <strong>gnutls_x509_ext_import_inhibit_anypolicy</strong> <em>(const gnutls_datum_t * <var>ext</var>, unsigned int * <var>skipcerts</var>)</em></dt>
<dd><p><var>ext</var>: the DER encoded extension data
</p>
<p><var>skipcerts</var>: will hold the number of certificates after which anypolicy is no longer acceptable.
</p>
<p>This function will return certificate&rsquo;s value of SkipCerts,
by reading the DER data of the Inhibit anyPolicy X.509 extension (2.5.29.54).
</p>
<p>The  <code>skipcerts</code> value is the number of additional certificates that
may appear in the path before the anyPolicy (<code>GNUTLS_X509_OID_POLICY_ANY</code> )
is no longer acceptable.
</p>
<p><strong>Returns:</strong> zero, or a negative error code in case of
parsing error.  If the certificate does not contain the Inhibit anyPolicy
extension <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  will be
returned.
</p>
<p><strong>Since:</strong> 3.6.0
</p></dd></dl>

<span id="gnutls_005fx509_005fext_005fimport_005fkey_005fpurposes-1"></span><h4 class="subheading">gnutls_x509_ext_import_key_purposes</h4>
<span id="gnutls_005fx509_005fext_005fimport_005fkey_005fpurposes"></span><dl>
<dt id="index-gnutls_005fx509_005fext_005fimport_005fkey_005fpurposes">Function: <em>int</em> <strong>gnutls_x509_ext_import_key_purposes</strong> <em>(const gnutls_datum_t * <var>ext</var>, gnutls_x509_key_purposes_t <var>p</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>ext</var>: The DER-encoded extension data
</p>
<p><var>p</var>: The key purposes
</p>
<p><var>flags</var>: should be zero
</p>
<p>This function will extract the key purposes in the provided DER-encoded
ExtKeyUsageSyntax PKIX extension, to a <code>gnutls_x509_key_purposes_t</code>  type. 
The data must be initialized.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fext_005fimport_005fkey_005fusage-1"></span><h4 class="subheading">gnutls_x509_ext_import_key_usage</h4>
<span id="gnutls_005fx509_005fext_005fimport_005fkey_005fusage"></span><dl>
<dt id="index-gnutls_005fx509_005fext_005fimport_005fkey_005fusage">Function: <em>int</em> <strong>gnutls_x509_ext_import_key_usage</strong> <em>(const gnutls_datum_t * <var>ext</var>, unsigned int * <var>key_usage</var>)</em></dt>
<dd><p><var>ext</var>: the DER encoded extension data
</p>
<p><var>key_usage</var>: where the key usage bits will be stored
</p>
<p>This function will return certificate&rsquo;s key usage, by reading the DER
data of the keyUsage X.509 extension (2.5.29.15). The key usage value will ORed
values of the: <code>GNUTLS_KEY_DIGITAL_SIGNATURE</code> ,
<code>GNUTLS_KEY_NON_REPUDIATION</code> , <code>GNUTLS_KEY_KEY_ENCIPHERMENT</code> ,
<code>GNUTLS_KEY_DATA_ENCIPHERMENT</code> , <code>GNUTLS_KEY_KEY_AGREEMENT</code> ,
<code>GNUTLS_KEY_KEY_CERT_SIGN</code> , <code>GNUTLS_KEY_CRL_SIGN</code> ,
<code>GNUTLS_KEY_ENCIPHER_ONLY</code> , <code>GNUTLS_KEY_DECIPHER_ONLY</code> .
</p>
<p><strong>Returns:</strong> the certificate key usage, or a negative error code in case of
parsing error.  If the certificate does not contain the keyUsage
extension <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  will be
returned.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fext_005fimport_005fname_005fconstraints-1"></span><h4 class="subheading">gnutls_x509_ext_import_name_constraints</h4>
<span id="gnutls_005fx509_005fext_005fimport_005fname_005fconstraints"></span><dl>
<dt id="index-gnutls_005fx509_005fext_005fimport_005fname_005fconstraints">Function: <em>int</em> <strong>gnutls_x509_ext_import_name_constraints</strong> <em>(const gnutls_datum_t * <var>ext</var>, gnutls_x509_name_constraints_t <var>nc</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>ext</var>: a DER encoded extension
</p>
<p><var>nc</var>: The nameconstraints
</p>
<p><var>flags</var>: zero or <code>GNUTLS_NAME_CONSTRAINTS_FLAG_APPEND</code> 
</p>
<p>This function will return an intermediate type containing
the name constraints of the provided NameConstraints extension. That
can be used in combination with <code>gnutls_x509_name_constraints_check()</code> 
to verify whether a server&rsquo;s name is in accordance with the constraints.
</p>
<p>When the  <code>flags</code> is set to <code>GNUTLS_NAME_CONSTRAINTS_FLAG_APPEND</code> , then if 
the  <code>nc</code> type is empty this function will behave identically as if the flag was not set.
Otherwise if there are elements in the  <code>nc</code> structure then the
constraints will be merged with the existing constraints following
RFC5280 p6.1.4 (excluded constraints will be appended, permitted
will be intersected).
</p>
<p>Note that  <code>nc</code> must be initialized prior to calling this function.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
if the extension is not present, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fext_005fimport_005fpolicies-1"></span><h4 class="subheading">gnutls_x509_ext_import_policies</h4>
<span id="gnutls_005fx509_005fext_005fimport_005fpolicies"></span><dl>
<dt id="index-gnutls_005fx509_005fext_005fimport_005fpolicies">Function: <em>int</em> <strong>gnutls_x509_ext_import_policies</strong> <em>(const gnutls_datum_t * <var>ext</var>, gnutls_x509_policies_t <var>policies</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>ext</var>: the DER encoded extension data
</p>
<p><var>policies</var>: A pointer to an initialized policies.
</p>
<p><var>flags</var>: should be zero
</p>
<p>This function will extract the certificate policy extension (2.5.29.32) 
and store it the provided policies.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fext_005fimport_005fprivate_005fkey_005fusage_005fperiod-1"></span><h4 class="subheading">gnutls_x509_ext_import_private_key_usage_period</h4>
<span id="gnutls_005fx509_005fext_005fimport_005fprivate_005fkey_005fusage_005fperiod"></span><dl>
<dt id="index-gnutls_005fx509_005fext_005fimport_005fprivate_005fkey_005fusage_005fperiod">Function: <em>int</em> <strong>gnutls_x509_ext_import_private_key_usage_period</strong> <em>(const gnutls_datum_t * <var>ext</var>, time_t * <var>activation</var>, time_t * <var>expiration</var>)</em></dt>
<dd><p><var>ext</var>: the DER encoded extension data
</p>
<p><var>activation</var>: Will hold the activation time
</p>
<p><var>expiration</var>: Will hold the expiration time
</p>
<p>This function will return the expiration and activation
times of the private key as written in the
PKIX extension 2.5.29.16.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fext_005fimport_005fproxy-1"></span><h4 class="subheading">gnutls_x509_ext_import_proxy</h4>
<span id="gnutls_005fx509_005fext_005fimport_005fproxy"></span><dl>
<dt id="index-gnutls_005fx509_005fext_005fimport_005fproxy">Function: <em>int</em> <strong>gnutls_x509_ext_import_proxy</strong> <em>(const gnutls_datum_t * <var>ext</var>, int * <var>pathlen</var>, char ** <var>policyLanguage</var>, char ** <var>policy</var>, size_t * <var>sizeof_policy</var>)</em></dt>
<dd><p><var>ext</var>: the DER encoded extension data
</p>
<p><var>pathlen</var>: pointer to output integer indicating path length (may be
NULL), non-negative error codes indicate a present pCPathLenConstraint
field and the actual value, -1 indicate that the field is absent.
</p>
<p><var>policyLanguage</var>: output variable with OID of policy language
</p>
<p><var>policy</var>: output variable with policy data
</p>
<p><var>sizeof_policy</var>: output variable with size of policy data
</p>
<p>This function will return the information from a proxy certificate
extension. It reads the ProxyCertInfo X.509 extension (1.3.6.1.5.5.7.1.14).
The  <code>policyLanguage</code> and  <code>policy</code> values must be deinitialized using <code>gnutls_free()</code>  after use.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fext_005fimport_005fsubject_005falt_005fnames-1"></span><h4 class="subheading">gnutls_x509_ext_import_subject_alt_names</h4>
<span id="gnutls_005fx509_005fext_005fimport_005fsubject_005falt_005fnames"></span><dl>
<dt id="index-gnutls_005fx509_005fext_005fimport_005fsubject_005falt_005fnames">Function: <em>int</em> <strong>gnutls_x509_ext_import_subject_alt_names</strong> <em>(const gnutls_datum_t * <var>ext</var>, gnutls_subject_alt_names_t <var>sans</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>ext</var>: The DER-encoded extension data
</p>
<p><var>sans</var>: The alternative names
</p>
<p><var>flags</var>: should be zero
</p>
<p>This function will export the alternative names in the provided DER-encoded
SubjectAltName PKIX extension, to a <code>gnutls_subject_alt_names_t</code>  type.  <code>sans</code> must be initialized.
</p>
<p>This function will succeed even if there no subject alternative names
in the structure.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fext_005fimport_005fsubject_005fkey_005fid-1"></span><h4 class="subheading">gnutls_x509_ext_import_subject_key_id</h4>
<span id="gnutls_005fx509_005fext_005fimport_005fsubject_005fkey_005fid"></span><dl>
<dt id="index-gnutls_005fx509_005fext_005fimport_005fsubject_005fkey_005fid">Function: <em>int</em> <strong>gnutls_x509_ext_import_subject_key_id</strong> <em>(const gnutls_datum_t * <var>ext</var>, gnutls_datum_t * <var>id</var>)</em></dt>
<dd><p><var>ext</var>: a DER encoded extension
</p>
<p><var>id</var>: will contain the subject key ID
</p>
<p>This function will return the subject key ID stored in the provided
SubjectKeyIdentifier extension. The ID will be allocated using
<code>gnutls_malloc()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
if the extension is not present, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fext_005fimport_005ftlsfeatures-1"></span><h4 class="subheading">gnutls_x509_ext_import_tlsfeatures</h4>
<span id="gnutls_005fx509_005fext_005fimport_005ftlsfeatures"></span><dl>
<dt id="index-gnutls_005fx509_005fext_005fimport_005ftlsfeatures">Function: <em>int</em> <strong>gnutls_x509_ext_import_tlsfeatures</strong> <em>(const gnutls_datum_t * <var>ext</var>, gnutls_x509_tlsfeatures_t <var>f</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>ext</var>: The DER-encoded extension data
</p>
<p><var>f</var>: The features structure
</p>
<p><var>flags</var>: zero or <code>GNUTLS_EXT_FLAG_APPEND</code> 
</p>
<p>This function will export the features in the provided DER-encoded
TLS Features PKIX extension, to a <code>gnutls_x509_tlsfeatures_t</code>  type.  <code>f</code> must be initialized.
</p>
<p>When the  <code>flags</code> is set to <code>GNUTLS_EXT_FLAG_APPEND</code> ,
then if the  <code>features</code> structure is empty this function will behave
identically as if the flag was not set. Otherwise if there are elements 
in the  <code>features</code> structure then they will be merged with.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.5.1
</p></dd></dl>

<span id="gnutls_005fx509_005fext_005fprint-1"></span><h4 class="subheading">gnutls_x509_ext_print</h4>
<span id="gnutls_005fx509_005fext_005fprint"></span><dl>
<dt id="index-gnutls_005fx509_005fext_005fprint">Function: <em>int</em> <strong>gnutls_x509_ext_print</strong> <em>(gnutls_x509_ext_st * <var>exts</var>, unsigned int <var>exts_size</var>, gnutls_certificate_print_formats_t <var>format</var>, gnutls_datum_t * <var>out</var>)</em></dt>
<dd><p><var>exts</var>: The data to be printed
</p>
<p><var>exts_size</var>: the number of available structures
</p>
<p><var>format</var>: Indicate the format to use
</p>
<p><var>out</var>: Newly allocated datum with null terminated string.
</p>
<p>This function will pretty print X.509 certificate extensions, 
suitable for display to a human.
</p>
<p>The output  <code>out</code> needs to be deallocated using <code>gnutls_free()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fkey_005fpurpose_005fdeinit-1"></span><h4 class="subheading">gnutls_x509_key_purpose_deinit</h4>
<span id="gnutls_005fx509_005fkey_005fpurpose_005fdeinit"></span><dl>
<dt id="index-gnutls_005fx509_005fkey_005fpurpose_005fdeinit">Function: <em>void</em> <strong>gnutls_x509_key_purpose_deinit</strong> <em>(gnutls_x509_key_purposes_t <var>p</var>)</em></dt>
<dd><p><var>p</var>: The key purposes
</p>
<p>This function will deinitialize a key purposes type.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fkey_005fpurpose_005fget-1"></span><h4 class="subheading">gnutls_x509_key_purpose_get</h4>
<span id="gnutls_005fx509_005fkey_005fpurpose_005fget"></span><dl>
<dt id="index-gnutls_005fx509_005fkey_005fpurpose_005fget">Function: <em>int</em> <strong>gnutls_x509_key_purpose_get</strong> <em>(gnutls_x509_key_purposes_t <var>p</var>, unsigned <var>idx</var>, gnutls_datum_t * <var>oid</var>)</em></dt>
<dd><p><var>p</var>: The key purposes
</p>
<p><var>idx</var>: The index of the key purpose to retrieve
</p>
<p><var>oid</var>: Will hold the object identifier of the key purpose (to be treated as constant)
</p>
<p>This function will retrieve the specified by the index key purpose in the
purposes type. The object identifier will be a null terminated string.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
if the index is out of bounds, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fkey_005fpurpose_005finit-1"></span><h4 class="subheading">gnutls_x509_key_purpose_init</h4>
<span id="gnutls_005fx509_005fkey_005fpurpose_005finit"></span><dl>
<dt id="index-gnutls_005fx509_005fkey_005fpurpose_005finit">Function: <em>int</em> <strong>gnutls_x509_key_purpose_init</strong> <em>(gnutls_x509_key_purposes_t * <var>p</var>)</em></dt>
<dd><p><var>p</var>: The key purposes
</p>
<p>This function will initialize an alternative names type.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fkey_005fpurpose_005fset-1"></span><h4 class="subheading">gnutls_x509_key_purpose_set</h4>
<span id="gnutls_005fx509_005fkey_005fpurpose_005fset"></span><dl>
<dt id="index-gnutls_005fx509_005fkey_005fpurpose_005fset">Function: <em>int</em> <strong>gnutls_x509_key_purpose_set</strong> <em>(gnutls_x509_key_purposes_t <var>p</var>, const char * <var>oid</var>)</em></dt>
<dd><p><var>p</var>: The key purposes
</p>
<p><var>oid</var>: The object identifier of the key purpose
</p>
<p>This function will store the specified key purpose in the
purposes.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0), otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fname_005fconstraints_005fadd_005fexcluded-1"></span><h4 class="subheading">gnutls_x509_name_constraints_add_excluded</h4>
<span id="gnutls_005fx509_005fname_005fconstraints_005fadd_005fexcluded"></span><dl>
<dt id="index-gnutls_005fx509_005fname_005fconstraints_005fadd_005fexcluded">Function: <em>int</em> <strong>gnutls_x509_name_constraints_add_excluded</strong> <em>(gnutls_x509_name_constraints_t <var>nc</var>, gnutls_x509_subject_alt_name_t <var>type</var>, const gnutls_datum_t * <var>name</var>)</em></dt>
<dd><p><var>nc</var>: The nameconstraints
</p>
<p><var>type</var>: The type of the constraints
</p>
<p><var>name</var>: The data of the constraints
</p>
<p>This function will add a name constraint to the list of excluded
constraints. The constraints  <code>type</code> can be any of the following types:
<code>GNUTLS_SAN_DNSNAME</code> , <code>GNUTLS_SAN_RFC822NAME</code> , <code>GNUTLS_SAN_DN</code> ,
<code>GNUTLS_SAN_URI</code> , <code>GNUTLS_SAN_IPADDRESS</code> . For the latter, an IP address
in network byte order is expected, followed by its network mask (which is
4 bytes in IPv4 or 16-bytes in IPv6).
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fname_005fconstraints_005fadd_005fpermitted-1"></span><h4 class="subheading">gnutls_x509_name_constraints_add_permitted</h4>
<span id="gnutls_005fx509_005fname_005fconstraints_005fadd_005fpermitted"></span><dl>
<dt id="index-gnutls_005fx509_005fname_005fconstraints_005fadd_005fpermitted">Function: <em>int</em> <strong>gnutls_x509_name_constraints_add_permitted</strong> <em>(gnutls_x509_name_constraints_t <var>nc</var>, gnutls_x509_subject_alt_name_t <var>type</var>, const gnutls_datum_t * <var>name</var>)</em></dt>
<dd><p><var>nc</var>: The nameconstraints
</p>
<p><var>type</var>: The type of the constraints
</p>
<p><var>name</var>: The data of the constraints
</p>
<p>This function will add a name constraint to the list of permitted
constraints. The constraints  <code>type</code> can be any of the following types:
<code>GNUTLS_SAN_DNSNAME</code> , <code>GNUTLS_SAN_RFC822NAME</code> , <code>GNUTLS_SAN_DN</code> ,
<code>GNUTLS_SAN_URI</code> , <code>GNUTLS_SAN_IPADDRESS</code> . For the latter, an IP address
in network byte order is expected, followed by its network mask.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fname_005fconstraints_005fcheck-1"></span><h4 class="subheading">gnutls_x509_name_constraints_check</h4>
<span id="gnutls_005fx509_005fname_005fconstraints_005fcheck"></span><dl>
<dt id="index-gnutls_005fx509_005fname_005fconstraints_005fcheck">Function: <em>unsigned</em> <strong>gnutls_x509_name_constraints_check</strong> <em>(gnutls_x509_name_constraints_t <var>nc</var>, gnutls_x509_subject_alt_name_t <var>type</var>, const gnutls_datum_t * <var>name</var>)</em></dt>
<dd><p><var>nc</var>: the extracted name constraints
</p>
<p><var>type</var>: the type of the constraint to check (of type gnutls_x509_subject_alt_name_t)
</p>
<p><var>name</var>: the name to be checked
</p>
<p>This function will check the provided name against the constraints in
 <code>nc</code> using the RFC5280 rules. Currently this function is limited to DNS
names, emails and IP addresses (of type <code>GNUTLS_SAN_DNSNAME</code> ,
<code>GNUTLS_SAN_RFC822NAME</code>  and <code>GNUTLS_SAN_IPADDRESS</code> ).
</p>
<p><strong>Returns:</strong> zero if the provided name is not acceptable, and non-zero otherwise.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fname_005fconstraints_005fcheck_005fcrt-1"></span><h4 class="subheading">gnutls_x509_name_constraints_check_crt</h4>
<span id="gnutls_005fx509_005fname_005fconstraints_005fcheck_005fcrt"></span><dl>
<dt id="index-gnutls_005fx509_005fname_005fconstraints_005fcheck_005fcrt">Function: <em>unsigned</em> <strong>gnutls_x509_name_constraints_check_crt</strong> <em>(gnutls_x509_name_constraints_t <var>nc</var>, gnutls_x509_subject_alt_name_t <var>type</var>, gnutls_x509_crt_t <var>cert</var>)</em></dt>
<dd><p><var>nc</var>: the extracted name constraints
</p>
<p><var>type</var>: the type of the constraint to check (of type gnutls_x509_subject_alt_name_t)
</p>
<p><var>cert</var>: the certificate to be checked
</p>
<p>This function will check the provided certificate names against the constraints in
 <code>nc</code> using the RFC5280 rules. It will traverse all the certificate&rsquo;s names and
alternative names.
</p>
<p>Currently this function is limited to DNS
names and emails (of type <code>GNUTLS_SAN_DNSNAME</code>  and <code>GNUTLS_SAN_RFC822NAME</code> ).
</p>
<p><strong>Returns:</strong> zero if the provided name is not acceptable, and non-zero otherwise.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fname_005fconstraints_005fdeinit-1"></span><h4 class="subheading">gnutls_x509_name_constraints_deinit</h4>
<span id="gnutls_005fx509_005fname_005fconstraints_005fdeinit"></span><dl>
<dt id="index-gnutls_005fx509_005fname_005fconstraints_005fdeinit">Function: <em>void</em> <strong>gnutls_x509_name_constraints_deinit</strong> <em>(gnutls_x509_name_constraints_t <var>nc</var>)</em></dt>
<dd><p><var>nc</var>: The nameconstraints
</p>
<p>This function will deinitialize a name constraints type.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fname_005fconstraints_005fget_005fexcluded-1"></span><h4 class="subheading">gnutls_x509_name_constraints_get_excluded</h4>
<span id="gnutls_005fx509_005fname_005fconstraints_005fget_005fexcluded"></span><dl>
<dt id="index-gnutls_005fx509_005fname_005fconstraints_005fget_005fexcluded">Function: <em>int</em> <strong>gnutls_x509_name_constraints_get_excluded</strong> <em>(gnutls_x509_name_constraints_t <var>nc</var>, unsigned <var>idx</var>, unsigned * <var>type</var>, gnutls_datum_t * <var>name</var>)</em></dt>
<dd><p><var>nc</var>: the extracted name constraints
</p>
<p><var>idx</var>: the index of the constraint
</p>
<p><var>type</var>: the type of the constraint (of type gnutls_x509_subject_alt_name_t)
</p>
<p><var>name</var>: the name in the constraint (of the specific type)
</p>
<p>This function will return an intermediate type containing
the name constraints of the provided CA certificate. That
structure can be used in combination with <code>gnutls_x509_name_constraints_check()</code> 
to verify whether a server&rsquo;s name is in accordance with the constraints.
</p>
<p>The name should be treated as constant and valid for the lifetime of  <code>nc</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
if the extension is not present, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fname_005fconstraints_005fget_005fpermitted-1"></span><h4 class="subheading">gnutls_x509_name_constraints_get_permitted</h4>
<span id="gnutls_005fx509_005fname_005fconstraints_005fget_005fpermitted"></span><dl>
<dt id="index-gnutls_005fx509_005fname_005fconstraints_005fget_005fpermitted">Function: <em>int</em> <strong>gnutls_x509_name_constraints_get_permitted</strong> <em>(gnutls_x509_name_constraints_t <var>nc</var>, unsigned <var>idx</var>, unsigned * <var>type</var>, gnutls_datum_t * <var>name</var>)</em></dt>
<dd><p><var>nc</var>: the extracted name constraints
</p>
<p><var>idx</var>: the index of the constraint
</p>
<p><var>type</var>: the type of the constraint (of type gnutls_x509_subject_alt_name_t)
</p>
<p><var>name</var>: the name in the constraint (of the specific type)
</p>
<p>This function will return an intermediate type containing
the name constraints of the provided CA certificate. That
structure can be used in combination with <code>gnutls_x509_name_constraints_check()</code> 
to verify whether a server&rsquo;s name is in accordance with the constraints.
</p>
<p>The name should be treated as constant and valid for the lifetime of  <code>nc</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
if the extension is not present, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fname_005fconstraints_005finit-1"></span><h4 class="subheading">gnutls_x509_name_constraints_init</h4>
<span id="gnutls_005fx509_005fname_005fconstraints_005finit"></span><dl>
<dt id="index-gnutls_005fx509_005fname_005fconstraints_005finit">Function: <em>int</em> <strong>gnutls_x509_name_constraints_init</strong> <em>(gnutls_x509_name_constraints_t * <var>nc</var>)</em></dt>
<dd><p><var>nc</var>: The nameconstraints
</p>
<p>This function will initialize a name constraints type.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fothername_005fto_005fvirtual-1"></span><h4 class="subheading">gnutls_x509_othername_to_virtual</h4>
<span id="gnutls_005fx509_005fothername_005fto_005fvirtual"></span><dl>
<dt id="index-gnutls_005fx509_005fothername_005fto_005fvirtual">Function: <em>int</em> <strong>gnutls_x509_othername_to_virtual</strong> <em>(const char * <var>oid</var>, const gnutls_datum_t * <var>othername</var>, unsigned int * <var>virt_type</var>, gnutls_datum_t * <var>virt</var>)</em></dt>
<dd><p><var>oid</var>: The othername object identifier
</p>
<p><var>othername</var>: The othername data
</p>
<p><var>virt_type</var>: GNUTLS_SAN_OTHERNAME_XXX
</p>
<p><var>virt</var>: allocated printable data
</p>
<p>This function will parse and convert the othername data to a virtual
type supported by gnutls.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.8
</p></dd></dl>

<span id="gnutls_005fx509_005fpolicies_005fdeinit-1"></span><h4 class="subheading">gnutls_x509_policies_deinit</h4>
<span id="gnutls_005fx509_005fpolicies_005fdeinit"></span><dl>
<dt id="index-gnutls_005fx509_005fpolicies_005fdeinit">Function: <em>void</em> <strong>gnutls_x509_policies_deinit</strong> <em>(gnutls_x509_policies_t <var>policies</var>)</em></dt>
<dd><p><var>policies</var>: The authority key identifier
</p>
<p>This function will deinitialize an authority key identifier type.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fpolicies_005fget-1"></span><h4 class="subheading">gnutls_x509_policies_get</h4>
<span id="gnutls_005fx509_005fpolicies_005fget"></span><dl>
<dt id="index-gnutls_005fx509_005fpolicies_005fget">Function: <em>int</em> <strong>gnutls_x509_policies_get</strong> <em>(gnutls_x509_policies_t <var>policies</var>, unsigned int <var>seq</var>, struct gnutls_x509_policy_st * <var>policy</var>)</em></dt>
<dd><p><var>policies</var>: The policies
</p>
<p><var>seq</var>: The index of the name to get
</p>
<p><var>policy</var>: Will hold the policy
</p>
<p>This function will return a specific policy as stored in
the  <code>policies</code> type. The returned values should be treated as constant
and valid for the lifetime of  <code>policies</code> .
</p>
<p>The any policy OID is available as the <code>GNUTLS_X509_OID_POLICY_ANY</code>  macro.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
if the index is out of bounds, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fpolicies_005finit-1"></span><h4 class="subheading">gnutls_x509_policies_init</h4>
<span id="gnutls_005fx509_005fpolicies_005finit"></span><dl>
<dt id="index-gnutls_005fx509_005fpolicies_005finit">Function: <em>int</em> <strong>gnutls_x509_policies_init</strong> <em>(gnutls_x509_policies_t * <var>policies</var>)</em></dt>
<dd><p><var>policies</var>: The authority key ID
</p>
<p>This function will initialize an authority key ID type.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fpolicies_005fset-1"></span><h4 class="subheading">gnutls_x509_policies_set</h4>
<span id="gnutls_005fx509_005fpolicies_005fset"></span><dl>
<dt id="index-gnutls_005fx509_005fpolicies_005fset">Function: <em>int</em> <strong>gnutls_x509_policies_set</strong> <em>(gnutls_x509_policies_t <var>policies</var>, const struct gnutls_x509_policy_st * <var>policy</var>)</em></dt>
<dd><p><var>policies</var>: An initialized policies
</p>
<p><var>policy</var>: Contains the policy to set
</p>
<p>This function will store the specified policy in
the provided  <code>policies</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0), otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fpolicy_005frelease-1"></span><h4 class="subheading">gnutls_x509_policy_release</h4>
<span id="gnutls_005fx509_005fpolicy_005frelease"></span><dl>
<dt id="index-gnutls_005fx509_005fpolicy_005frelease">Function: <em>void</em> <strong>gnutls_x509_policy_release</strong> <em>(struct gnutls_x509_policy_st * <var>policy</var>)</em></dt>
<dd><p><var>policy</var>: a certificate policy
</p>
<p>This function will deinitialize all memory associated with the provided
 <code>policy</code> . The policy is allocated using <code>gnutls_x509_crt_get_policy()</code> .
</p>
<p><strong>Since:</strong> 3.1.5
</p></dd></dl>

<span id="gnutls_005fx509_005fprivkey_005fcpy-1"></span><h4 class="subheading">gnutls_x509_privkey_cpy</h4>
<span id="gnutls_005fx509_005fprivkey_005fcpy"></span><dl>
<dt id="index-gnutls_005fx509_005fprivkey_005fcpy">Function: <em>int</em> <strong>gnutls_x509_privkey_cpy</strong> <em>(gnutls_x509_privkey_t <var>dst</var>, gnutls_x509_privkey_t <var>src</var>)</em></dt>
<dd><p><var>dst</var>: The destination key, which should be initialized.
</p>
<p><var>src</var>: The source key
</p>
<p>This function will copy a private key from source to destination
key. Destination has to be initialized.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fprivkey_005fdeinit-1"></span><h4 class="subheading">gnutls_x509_privkey_deinit</h4>
<span id="gnutls_005fx509_005fprivkey_005fdeinit"></span><dl>
<dt id="index-gnutls_005fx509_005fprivkey_005fdeinit">Function: <em>void</em> <strong>gnutls_x509_privkey_deinit</strong> <em>(gnutls_x509_privkey_t <var>key</var>)</em></dt>
<dd><p><var>key</var>: The key to be deinitialized
</p>
<p>This function will deinitialize a private key structure.
</p></dd></dl>

<span id="gnutls_005fx509_005fprivkey_005fexport-1"></span><h4 class="subheading">gnutls_x509_privkey_export</h4>
<span id="gnutls_005fx509_005fprivkey_005fexport"></span><dl>
<dt id="index-gnutls_005fx509_005fprivkey_005fexport">Function: <em>int</em> <strong>gnutls_x509_privkey_export</strong> <em>(gnutls_x509_privkey_t <var>key</var>, gnutls_x509_crt_fmt_t <var>format</var>, void * <var>output_data</var>, size_t * <var>output_data_size</var>)</em></dt>
<dd><p><var>key</var>: Holds the key
</p>
<p><var>format</var>: the format of output params. One of PEM or DER.
</p>
<p><var>output_data</var>: will contain a private key PEM or DER encoded
</p>
<p><var>output_data_size</var>: holds the size of output_data (and will be
replaced by the actual size of parameters)
</p>
<p>This function will export the private key to a PKCS<code>1</code>  structure for
RSA or RSA-PSS keys, and integer sequence for DSA keys. Other keys types
will be exported in PKCS<code>8</code>  form.
</p>
<p>If the structure is PEM encoded, it will have a header
of &quot;BEGIN RSA PRIVATE KEY&quot;.
</p>
<p>It is recommended to use <code>gnutls_x509_privkey_export_pkcs8()</code>  instead
of this function, when a consistent output format is required.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fprivkey_005fexport2-1"></span><h4 class="subheading">gnutls_x509_privkey_export2</h4>
<span id="gnutls_005fx509_005fprivkey_005fexport2"></span><dl>
<dt id="index-gnutls_005fx509_005fprivkey_005fexport2">Function: <em>int</em> <strong>gnutls_x509_privkey_export2</strong> <em>(gnutls_x509_privkey_t <var>key</var>, gnutls_x509_crt_fmt_t <var>format</var>, gnutls_datum_t * <var>out</var>)</em></dt>
<dd><p><var>key</var>: Holds the key
</p>
<p><var>format</var>: the format of output params. One of PEM or DER.
</p>
<p><var>out</var>: will contain a private key PEM or DER encoded
</p>
<p>This function will export the private key to a PKCS<code>1</code>  structure for
RSA or RSA-PSS keys, and integer sequence for DSA keys. Other keys types
will be exported in PKCS<code>8</code>  form.
</p>
<p>The output buffer is allocated using <code>gnutls_malloc()</code> .
</p>
<p>It is recommended to use <code>gnutls_x509_privkey_export2_pkcs8()</code>  instead
of this function, when a consistent output format is required.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p>Since 3.1.3
</p></dd></dl>

<span id="gnutls_005fx509_005fprivkey_005fexport2_005fpkcs8-1"></span><h4 class="subheading">gnutls_x509_privkey_export2_pkcs8</h4>
<span id="gnutls_005fx509_005fprivkey_005fexport2_005fpkcs8"></span><dl>
<dt id="index-gnutls_005fx509_005fprivkey_005fexport2_005fpkcs8">Function: <em>int</em> <strong>gnutls_x509_privkey_export2_pkcs8</strong> <em>(gnutls_x509_privkey_t <var>key</var>, gnutls_x509_crt_fmt_t <var>format</var>, const char * <var>password</var>, unsigned int <var>flags</var>, gnutls_datum_t * <var>out</var>)</em></dt>
<dd><p><var>key</var>: Holds the key
</p>
<p><var>format</var>: the format of output params. One of PEM or DER.
</p>
<p><var>password</var>: the password that will be used to encrypt the key.
</p>
<p><var>flags</var>: an ORed sequence of gnutls_pkcs_encrypt_flags_t
</p>
<p><var>out</var>: will contain a private key PEM or DER encoded
</p>
<p>This function will export the private key to a PKCS8 structure.
Both RSA and DSA keys can be exported. For DSA keys we use
PKCS <code>11</code>  definitions. If the flags do not specify the encryption
cipher, then the default 3DES (PBES2) will be used.
</p>
<p>The  <code>password</code> can be either ASCII or UTF-8 in the default PBES2
encryption schemas, or ASCII for the PKCS12 schemas.
</p>
<p>The output buffer is allocated using <code>gnutls_malloc()</code> .
</p>
<p>If the structure is PEM encoded, it will have a header
of &quot;BEGIN ENCRYPTED PRIVATE KEY&quot; or &quot;BEGIN PRIVATE KEY&quot; if
encryption is not used.
</p>
<p><strong>Returns:</strong> In case of failure a negative error code will be
returned, and 0 on success.
</p>
<p>Since 3.1.3
</p></dd></dl>

<span id="gnutls_005fx509_005fprivkey_005fexport_005fdsa_005fraw-1"></span><h4 class="subheading">gnutls_x509_privkey_export_dsa_raw</h4>
<span id="gnutls_005fx509_005fprivkey_005fexport_005fdsa_005fraw"></span><dl>
<dt id="index-gnutls_005fx509_005fprivkey_005fexport_005fdsa_005fraw">Function: <em>int</em> <strong>gnutls_x509_privkey_export_dsa_raw</strong> <em>(gnutls_x509_privkey_t <var>key</var>, gnutls_datum_t * <var>p</var>, gnutls_datum_t * <var>q</var>, gnutls_datum_t * <var>g</var>, gnutls_datum_t * <var>y</var>, gnutls_datum_t * <var>x</var>)</em></dt>
<dd><p><var>key</var>: a key
</p>
<p><var>p</var>: will hold the p
</p>
<p><var>q</var>: will hold the q
</p>
<p><var>g</var>: will hold the g
</p>
<p><var>y</var>: will hold the y
</p>
<p><var>x</var>: will hold the x
</p>
<p>This function will export the DSA private key&rsquo;s parameters found
in the given structure. The new parameters will be allocated using
<code>gnutls_malloc()</code>  and will be stored in the appropriate datum.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fprivkey_005fexport_005fecc_005fraw-1"></span><h4 class="subheading">gnutls_x509_privkey_export_ecc_raw</h4>
<span id="gnutls_005fx509_005fprivkey_005fexport_005fecc_005fraw"></span><dl>
<dt id="index-gnutls_005fx509_005fprivkey_005fexport_005fecc_005fraw">Function: <em>int</em> <strong>gnutls_x509_privkey_export_ecc_raw</strong> <em>(gnutls_x509_privkey_t <var>key</var>, gnutls_ecc_curve_t * <var>curve</var>, gnutls_datum_t * <var>x</var>, gnutls_datum_t * <var>y</var>, gnutls_datum_t * <var>k</var>)</em></dt>
<dd><p><var>key</var>: a key
</p>
<p><var>curve</var>: will hold the curve
</p>
<p><var>x</var>: will hold the x-coordinate
</p>
<p><var>y</var>: will hold the y-coordinate
</p>
<p><var>k</var>: will hold the private key
</p>
<p>This function will export the ECC private key&rsquo;s parameters found
in the given structure. The new parameters will be allocated using
<code>gnutls_malloc()</code>  and will be stored in the appropriate datum.
</p>
<p>In EdDSA curves the  <code>y</code> parameter will be <code>NULL</code>  and the other parameters
will be in the native format for the curve.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fprivkey_005fexport_005fgost_005fraw-1"></span><h4 class="subheading">gnutls_x509_privkey_export_gost_raw</h4>
<span id="gnutls_005fx509_005fprivkey_005fexport_005fgost_005fraw"></span><dl>
<dt id="index-gnutls_005fx509_005fprivkey_005fexport_005fgost_005fraw">Function: <em>int</em> <strong>gnutls_x509_privkey_export_gost_raw</strong> <em>(gnutls_x509_privkey_t <var>key</var>, gnutls_ecc_curve_t * <var>curve</var>, gnutls_digest_algorithm_t * <var>digest</var>, gnutls_gost_paramset_t * <var>paramset</var>, gnutls_datum_t * <var>x</var>, gnutls_datum_t * <var>y</var>, gnutls_datum_t * <var>k</var>)</em></dt>
<dd><p><var>key</var>: a key
</p>
<p><var>curve</var>: will hold the curve
</p>
<p><var>digest</var>: will hold the digest
</p>
<p><var>paramset</var>: will hold the GOST parameter set ID
</p>
<p><var>x</var>: will hold the x-coordinate
</p>
<p><var>y</var>: will hold the y-coordinate
</p>
<p><var>k</var>: will hold the private key
</p>
<p>This function will export the GOST private key&rsquo;s parameters found
in the given structure. The new parameters will be allocated using
<code>gnutls_malloc()</code>  and will be stored in the appropriate datum.
</p>
<p><strong>Note:</strong> parameters will be stored with least significant byte first. On
version 3.6.3 this was incorrectly returned in big-endian format.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.6.3
</p></dd></dl>

<span id="gnutls_005fx509_005fprivkey_005fexport_005fpkcs8-1"></span><h4 class="subheading">gnutls_x509_privkey_export_pkcs8</h4>
<span id="gnutls_005fx509_005fprivkey_005fexport_005fpkcs8"></span><dl>
<dt id="index-gnutls_005fx509_005fprivkey_005fexport_005fpkcs8">Function: <em>int</em> <strong>gnutls_x509_privkey_export_pkcs8</strong> <em>(gnutls_x509_privkey_t <var>key</var>, gnutls_x509_crt_fmt_t <var>format</var>, const char * <var>password</var>, unsigned int <var>flags</var>, void * <var>output_data</var>, size_t * <var>output_data_size</var>)</em></dt>
<dd><p><var>key</var>: Holds the key
</p>
<p><var>format</var>: the format of output params. One of PEM or DER.
</p>
<p><var>password</var>: the password that will be used to encrypt the key.
</p>
<p><var>flags</var>: an ORed sequence of gnutls_pkcs_encrypt_flags_t
</p>
<p><var>output_data</var>: will contain a private key PEM or DER encoded
</p>
<p><var>output_data_size</var>: holds the size of output_data (and will be
replaced by the actual size of parameters)
</p>
<p>This function will export the private key to a PKCS8 structure.
Both RSA and DSA keys can be exported. For DSA keys we use
PKCS <code>11</code>  definitions. If the flags do not specify the encryption
cipher, then the default 3DES (PBES2) will be used.
</p>
<p>The  <code>password</code> can be either ASCII or UTF-8 in the default PBES2
encryption schemas, or ASCII for the PKCS12 schemas.
</p>
<p>If the buffer provided is not long enough to hold the output, then
*output_data_size is updated and GNUTLS_E_SHORT_MEMORY_BUFFER will
be returned.
</p>
<p>If the structure is PEM encoded, it will have a header
of &quot;BEGIN ENCRYPTED PRIVATE KEY&quot; or &quot;BEGIN PRIVATE KEY&quot; if
encryption is not used.
</p>
<p><strong>Returns:</strong> In case of failure a negative error code will be
returned, and 0 on success.
</p></dd></dl>

<span id="gnutls_005fx509_005fprivkey_005fexport_005frsa_005fraw-1"></span><h4 class="subheading">gnutls_x509_privkey_export_rsa_raw</h4>
<span id="gnutls_005fx509_005fprivkey_005fexport_005frsa_005fraw"></span><dl>
<dt id="index-gnutls_005fx509_005fprivkey_005fexport_005frsa_005fraw">Function: <em>int</em> <strong>gnutls_x509_privkey_export_rsa_raw</strong> <em>(gnutls_x509_privkey_t <var>key</var>, gnutls_datum_t * <var>m</var>, gnutls_datum_t * <var>e</var>, gnutls_datum_t * <var>d</var>, gnutls_datum_t * <var>p</var>, gnutls_datum_t * <var>q</var>, gnutls_datum_t * <var>u</var>)</em></dt>
<dd><p><var>key</var>: a key
</p>
<p><var>m</var>: will hold the modulus
</p>
<p><var>e</var>: will hold the public exponent
</p>
<p><var>d</var>: will hold the private exponent
</p>
<p><var>p</var>: will hold the first prime (p)
</p>
<p><var>q</var>: will hold the second prime (q)
</p>
<p><var>u</var>: will hold the coefficient
</p>
<p>This function will export the RSA private key&rsquo;s parameters found
in the given structure. The new parameters will be allocated using
<code>gnutls_malloc()</code>  and will be stored in the appropriate datum.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fprivkey_005fexport_005frsa_005fraw2-1"></span><h4 class="subheading">gnutls_x509_privkey_export_rsa_raw2</h4>
<span id="gnutls_005fx509_005fprivkey_005fexport_005frsa_005fraw2"></span><dl>
<dt id="index-gnutls_005fx509_005fprivkey_005fexport_005frsa_005fraw2">Function: <em>int</em> <strong>gnutls_x509_privkey_export_rsa_raw2</strong> <em>(gnutls_x509_privkey_t <var>key</var>, gnutls_datum_t * <var>m</var>, gnutls_datum_t * <var>e</var>, gnutls_datum_t * <var>d</var>, gnutls_datum_t * <var>p</var>, gnutls_datum_t * <var>q</var>, gnutls_datum_t * <var>u</var>, gnutls_datum_t * <var>e1</var>, gnutls_datum_t * <var>e2</var>)</em></dt>
<dd><p><var>key</var>: a key
</p>
<p><var>m</var>: will hold the modulus
</p>
<p><var>e</var>: will hold the public exponent
</p>
<p><var>d</var>: will hold the private exponent
</p>
<p><var>p</var>: will hold the first prime (p)
</p>
<p><var>q</var>: will hold the second prime (q)
</p>
<p><var>u</var>: will hold the coefficient
</p>
<p><var>e1</var>: will hold e1 = d mod (p-1)
</p>
<p><var>e2</var>: will hold e2 = d mod (q-1)
</p>
<p>This function will export the RSA private key&rsquo;s parameters found
in the given structure. The new parameters will be allocated using
<code>gnutls_malloc()</code>  and will be stored in the appropriate datum.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fx509_005fprivkey_005ffix-1"></span><h4 class="subheading">gnutls_x509_privkey_fix</h4>
<span id="gnutls_005fx509_005fprivkey_005ffix"></span><dl>
<dt id="index-gnutls_005fx509_005fprivkey_005ffix">Function: <em>int</em> <strong>gnutls_x509_privkey_fix</strong> <em>(gnutls_x509_privkey_t <var>key</var>)</em></dt>
<dd><p><var>key</var>: a key
</p>
<p>This function will recalculate the secondary parameters in a key.
In RSA keys, this can be the coefficient and exponent1,2.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fprivkey_005fgenerate-1"></span><h4 class="subheading">gnutls_x509_privkey_generate</h4>
<span id="gnutls_005fx509_005fprivkey_005fgenerate"></span><dl>
<dt id="index-gnutls_005fx509_005fprivkey_005fgenerate">Function: <em>int</em> <strong>gnutls_x509_privkey_generate</strong> <em>(gnutls_x509_privkey_t <var>key</var>, gnutls_pk_algorithm_t <var>algo</var>, unsigned int <var>bits</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>key</var>: an initialized key
</p>
<p><var>algo</var>: is one of the algorithms in <code>gnutls_pk_algorithm_t</code> .
</p>
<p><var>bits</var>: the size of the parameters to generate
</p>
<p><var>flags</var>: Must be zero or flags from <code>gnutls_privkey_flags_t</code> .
</p>
<p>This function will generate a random private key. Note that this
function must be called on an initialized private key.
</p>
<p>The flag <code>GNUTLS_PRIVKEY_FLAG_PROVABLE</code> 
instructs the key generation process to use algorithms like Shawe-Taylor
(from FIPS PUB186-4) which generate provable parameters out of a seed
for RSA and DSA keys. See <code>gnutls_x509_privkey_generate2()</code>  for more
information.
</p>
<p>Note that when generating an elliptic curve key, the curve
can be substituted in the place of the bits parameter using the
<code>GNUTLS_CURVE_TO_BITS()</code>  macro. The input to the macro is any curve from
<code>gnutls_ecc_curve_t</code> .
</p>
<p>For DSA keys, if the subgroup size needs to be specified check
the <code>GNUTLS_SUBGROUP_TO_BITS()</code>  macro.
</p>
<p>It is recommended to do not set the number of  <code>bits</code> directly, use <code>gnutls_sec_param_to_pk_bits()</code>  instead .
</p>
<p>See also <code>gnutls_privkey_generate()</code> , <code>gnutls_x509_privkey_generate2()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fprivkey_005fgenerate2-1"></span><h4 class="subheading">gnutls_x509_privkey_generate2</h4>
<span id="gnutls_005fx509_005fprivkey_005fgenerate2"></span><dl>
<dt id="index-gnutls_005fx509_005fprivkey_005fgenerate2">Function: <em>int</em> <strong>gnutls_x509_privkey_generate2</strong> <em>(gnutls_x509_privkey_t <var>key</var>, gnutls_pk_algorithm_t <var>algo</var>, unsigned int <var>bits</var>, unsigned int <var>flags</var>, const gnutls_keygen_data_st * <var>data</var>, unsigned <var>data_size</var>)</em></dt>
<dd><p><var>key</var>: a key
</p>
<p><var>algo</var>: is one of the algorithms in <code>gnutls_pk_algorithm_t</code> .
</p>
<p><var>bits</var>: the size of the modulus
</p>
<p><var>flags</var>: Must be zero or flags from <code>gnutls_privkey_flags_t</code> .
</p>
<p><var>data</var>: Allow specifying <code>gnutls_keygen_data_st</code>  types such as the seed to be used.
</p>
<p><var>data_size</var>: The number of  <code>data</code> available.
</p>
<p>This function will generate a random private key. Note that this
function must be called on an initialized private key.
</p>
<p>The flag <code>GNUTLS_PRIVKEY_FLAG_PROVABLE</code> 
instructs the key generation process to use algorithms like Shawe-Taylor
(from FIPS PUB186-4) which generate provable parameters out of a seed
for RSA and DSA keys. On DSA keys the PQG parameters are generated using the
seed, while on RSA the two primes. To specify an explicit seed
(by default a random seed is used), use the  <code>data</code> with a <code>GNUTLS_KEYGEN_SEED</code> 
type.
</p>
<p>Note that when generating an elliptic curve key, the curve
can be substituted in the place of the bits parameter using the
<code>GNUTLS_CURVE_TO_BITS()</code>  macro.
</p>
<p>To export the generated keys in memory or in files it is recommended to use the
PKCS<code>8</code>  form as it can handle all key types, and can store additional parameters
such as the seed, in case of provable RSA or DSA keys.
Generated keys can be exported in memory using <code>gnutls_privkey_export_x509()</code> ,
and then with <code>gnutls_x509_privkey_export2_pkcs8()</code> .
</p>
<p>If key generation is part of your application, avoid setting the number
of bits directly, and instead use <code>gnutls_sec_param_to_pk_bits()</code> .
That way the generated keys will adapt to the security levels
of the underlying GnuTLS library.
</p>
<p>See also <code>gnutls_privkey_generate2()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fprivkey_005fget_005fkey_005fid-1"></span><h4 class="subheading">gnutls_x509_privkey_get_key_id</h4>
<span id="gnutls_005fx509_005fprivkey_005fget_005fkey_005fid"></span><dl>
<dt id="index-gnutls_005fx509_005fprivkey_005fget_005fkey_005fid">Function: <em>int</em> <strong>gnutls_x509_privkey_get_key_id</strong> <em>(gnutls_x509_privkey_t <var>key</var>, unsigned int <var>flags</var>, unsigned char * <var>output_data</var>, size_t * <var>output_data_size</var>)</em></dt>
<dd><p><var>key</var>: a key
</p>
<p><var>flags</var>: should be one of the flags from <code>gnutls_keyid_flags_t</code> 
</p>
<p><var>output_data</var>: will contain the key ID
</p>
<p><var>output_data_size</var>: holds the size of output_data (and will be
replaced by the actual size of parameters)
</p>
<p>This function will return a unique ID that depends on the public key
parameters. This ID can be used in checking whether a certificate
corresponds to the given key.
</p>
<p>If the buffer provided is not long enough to hold the output, then
* <code>output_data_size</code> is updated and <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  will
be returned.  The output will normally be a SHA-1 hash output,
which is 20 bytes.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fprivkey_005fget_005fpk_005falgorithm-1"></span><h4 class="subheading">gnutls_x509_privkey_get_pk_algorithm</h4>
<span id="gnutls_005fx509_005fprivkey_005fget_005fpk_005falgorithm"></span><dl>
<dt id="index-gnutls_005fx509_005fprivkey_005fget_005fpk_005falgorithm">Function: <em>int</em> <strong>gnutls_x509_privkey_get_pk_algorithm</strong> <em>(gnutls_x509_privkey_t <var>key</var>)</em></dt>
<dd><p><var>key</var>: should contain a <code>gnutls_x509_privkey_t</code>  type
</p>
<p>This function will return the public key algorithm of a private
key.
</p>
<p><strong>Returns:</strong> a member of the <code>gnutls_pk_algorithm_t</code>  enumeration on
success, or a negative error code on error.
</p></dd></dl>

<span id="gnutls_005fx509_005fprivkey_005fget_005fpk_005falgorithm2-1"></span><h4 class="subheading">gnutls_x509_privkey_get_pk_algorithm2</h4>
<span id="gnutls_005fx509_005fprivkey_005fget_005fpk_005falgorithm2"></span><dl>
<dt id="index-gnutls_005fx509_005fprivkey_005fget_005fpk_005falgorithm2">Function: <em>int</em> <strong>gnutls_x509_privkey_get_pk_algorithm2</strong> <em>(gnutls_x509_privkey_t <var>key</var>, unsigned int * <var>bits</var>)</em></dt>
<dd><p><var>key</var>: should contain a <code>gnutls_x509_privkey_t</code>  type
</p>
<p><var>bits</var>: The number of bits in the public key algorithm
</p>
<p>This function will return the public key algorithm of a private
key.
</p>
<p><strong>Returns:</strong> a member of the <code>gnutls_pk_algorithm_t</code>  enumeration on
success, or a negative error code on error.
</p></dd></dl>

<span id="gnutls_005fx509_005fprivkey_005fget_005fseed-1"></span><h4 class="subheading">gnutls_x509_privkey_get_seed</h4>
<span id="gnutls_005fx509_005fprivkey_005fget_005fseed"></span><dl>
<dt id="index-gnutls_005fx509_005fprivkey_005fget_005fseed">Function: <em>int</em> <strong>gnutls_x509_privkey_get_seed</strong> <em>(gnutls_x509_privkey_t <var>key</var>, gnutls_digest_algorithm_t * <var>digest</var>, void * <var>seed</var>, size_t * <var>seed_size</var>)</em></dt>
<dd><p><var>key</var>: should contain a <code>gnutls_x509_privkey_t</code>  type
</p>
<p><var>digest</var>: if non-NULL it will contain the digest algorithm used for key generation (if applicable)
</p>
<p><var>seed</var>: where seed will be copied to
</p>
<p><var>seed_size</var>: originally holds the size of  <code>seed</code> , will be updated with actual size
</p>
<p>This function will return the seed that was used to generate the
given private key. That function will succeed only if the key was generated
as a provable key.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.5.0
</p></dd></dl>

<span id="gnutls_005fx509_005fprivkey_005fget_005fspki-1"></span><h4 class="subheading">gnutls_x509_privkey_get_spki</h4>
<span id="gnutls_005fx509_005fprivkey_005fget_005fspki"></span><dl>
<dt id="index-gnutls_005fx509_005fprivkey_005fget_005fspki">Function: <em>int</em> <strong>gnutls_x509_privkey_get_spki</strong> <em>(gnutls_x509_privkey_t <var>key</var>, gnutls_x509_spki_t <var>spki</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>key</var>: should contain a <code>gnutls_x509_privkey_t</code>  type
</p>
<p><var>spki</var>: a SubjectPublicKeyInfo structure of type <code>gnutls_x509_spki_t</code> 
</p>
<p><var>flags</var>: must be zero
</p>
<p>This function will return the public key information of a private
key. The provided  <code>spki</code> must be initialized.
</p>
<p><strong>Returns:</strong> Zero on success, or a negative error code on error.
</p></dd></dl>

<span id="gnutls_005fx509_005fprivkey_005fimport-1"></span><h4 class="subheading">gnutls_x509_privkey_import</h4>
<span id="gnutls_005fx509_005fprivkey_005fimport"></span><dl>
<dt id="index-gnutls_005fx509_005fprivkey_005fimport">Function: <em>int</em> <strong>gnutls_x509_privkey_import</strong> <em>(gnutls_x509_privkey_t <var>key</var>, const gnutls_datum_t * <var>data</var>, gnutls_x509_crt_fmt_t <var>format</var>)</em></dt>
<dd><p><var>key</var>: The data to store the parsed key
</p>
<p><var>data</var>: The DER or PEM encoded certificate.
</p>
<p><var>format</var>: One of DER or PEM
</p>
<p>This function will convert the given DER or PEM encoded key to the
native <code>gnutls_x509_privkey_t</code>  format. The output will be stored in
 <code>key</code> .
</p>
<p>If the key is PEM encoded it should have a header that contains &quot;PRIVATE
KEY&quot;. Note that this function falls back to PKCS <code>8</code>  decoding without
password, if the default format fails to import.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fprivkey_005fimport2-1"></span><h4 class="subheading">gnutls_x509_privkey_import2</h4>
<span id="gnutls_005fx509_005fprivkey_005fimport2"></span><dl>
<dt id="index-gnutls_005fx509_005fprivkey_005fimport2-1">Function: <em>int</em> <strong>gnutls_x509_privkey_import2</strong> <em>(gnutls_x509_privkey_t <var>key</var>, const gnutls_datum_t * <var>data</var>, gnutls_x509_crt_fmt_t <var>format</var>, const char * <var>password</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>key</var>: The data to store the parsed key
</p>
<p><var>data</var>: The DER or PEM encoded key.
</p>
<p><var>format</var>: One of DER or PEM
</p>
<p><var>password</var>: A password (optional)
</p>
<p><var>flags</var>: an ORed sequence of gnutls_pkcs_encrypt_flags_t
</p>
<p>This function will import the given DER or PEM encoded key, to 
the native <code>gnutls_x509_privkey_t</code>  format, irrespective of the
input format. The input format is auto-detected.
</p>
<p>The supported formats are basic unencrypted key, PKCS8, PKCS12,
and the openssl format.
</p>
<p>If the provided key is encrypted but no password was given, then
<code>GNUTLS_E_DECRYPTION_FAILED</code>  is returned. Since GnuTLS 3.4.0 this
function will utilize the PIN callbacks if any.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fprivkey_005fimport_005fdsa_005fraw-1"></span><h4 class="subheading">gnutls_x509_privkey_import_dsa_raw</h4>
<span id="gnutls_005fx509_005fprivkey_005fimport_005fdsa_005fraw"></span><dl>
<dt id="index-gnutls_005fx509_005fprivkey_005fimport_005fdsa_005fraw">Function: <em>int</em> <strong>gnutls_x509_privkey_import_dsa_raw</strong> <em>(gnutls_x509_privkey_t <var>key</var>, const gnutls_datum_t * <var>p</var>, const gnutls_datum_t * <var>q</var>, const gnutls_datum_t * <var>g</var>, const gnutls_datum_t * <var>y</var>, const gnutls_datum_t * <var>x</var>)</em></dt>
<dd><p><var>key</var>: The data to store the parsed key
</p>
<p><var>p</var>: holds the p
</p>
<p><var>q</var>: holds the q
</p>
<p><var>g</var>: holds the g
</p>
<p><var>y</var>: holds the y
</p>
<p><var>x</var>: holds the x
</p>
<p>This function will convert the given DSA raw parameters to the
native <code>gnutls_x509_privkey_t</code>  format.  The output will be stored
in  <code>key</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fprivkey_005fimport_005fecc_005fraw-1"></span><h4 class="subheading">gnutls_x509_privkey_import_ecc_raw</h4>
<span id="gnutls_005fx509_005fprivkey_005fimport_005fecc_005fraw"></span><dl>
<dt id="index-gnutls_005fx509_005fprivkey_005fimport_005fecc_005fraw">Function: <em>int</em> <strong>gnutls_x509_privkey_import_ecc_raw</strong> <em>(gnutls_x509_privkey_t <var>key</var>, gnutls_ecc_curve_t <var>curve</var>, const gnutls_datum_t * <var>x</var>, const gnutls_datum_t * <var>y</var>, const gnutls_datum_t * <var>k</var>)</em></dt>
<dd><p><var>key</var>: The data to store the parsed key
</p>
<p><var>curve</var>: holds the curve
</p>
<p><var>x</var>: holds the x-coordinate
</p>
<p><var>y</var>: holds the y-coordinate
</p>
<p><var>k</var>: holds the k
</p>
<p>This function will convert the given elliptic curve parameters to the
native <code>gnutls_x509_privkey_t</code>  format.  The output will be stored
in  <code>key</code> . For EdDSA keys, the  <code>x</code> and  <code>k</code> values must be in the
native to curve format.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fprivkey_005fimport_005fgost_005fraw-1"></span><h4 class="subheading">gnutls_x509_privkey_import_gost_raw</h4>
<span id="gnutls_005fx509_005fprivkey_005fimport_005fgost_005fraw"></span><dl>
<dt id="index-gnutls_005fx509_005fprivkey_005fimport_005fgost_005fraw">Function: <em>int</em> <strong>gnutls_x509_privkey_import_gost_raw</strong> <em>(gnutls_x509_privkey_t <var>key</var>, gnutls_ecc_curve_t <var>curve</var>, gnutls_digest_algorithm_t <var>digest</var>, gnutls_gost_paramset_t <var>paramset</var>, const gnutls_datum_t * <var>x</var>, const gnutls_datum_t * <var>y</var>, const gnutls_datum_t * <var>k</var>)</em></dt>
<dd><p><var>key</var>: The data to store the parsed key
</p>
<p><var>curve</var>: holds the curve
</p>
<p><var>digest</var>: will hold the digest
</p>
<p><var>paramset</var>: will hold the GOST parameter set ID
</p>
<p><var>x</var>: holds the x-coordinate
</p>
<p><var>y</var>: holds the y-coordinate
</p>
<p><var>k</var>: holds the k (private key)
</p>
<p>This function will convert the given GOST private key&rsquo;s parameters to the
native <code>gnutls_x509_privkey_t</code>  format.  The output will be stored
in  <code>key</code> .   <code>digest</code> should be one of GNUTLS_DIG_GOSR_94,
GNUTLS_DIG_STREEBOG_256 or GNUTLS_DIG_STREEBOG_512.  If  <code>paramset</code> is set to
GNUTLS_GOST_PARAMSET_UNKNOWN default one will be selected depending on
 <code>digest</code> .
</p>
<p><strong>Note:</strong> parameters should be stored with least significant byte first. On
version 3.6.3 big-endian format was used incorrectly.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.6.3
</p></dd></dl>

<span id="gnutls_005fx509_005fprivkey_005fimport_005fopenssl-1"></span><h4 class="subheading">gnutls_x509_privkey_import_openssl</h4>
<span id="gnutls_005fx509_005fprivkey_005fimport_005fopenssl"></span><dl>
<dt id="index-gnutls_005fx509_005fprivkey_005fimport_005fopenssl-1">Function: <em>int</em> <strong>gnutls_x509_privkey_import_openssl</strong> <em>(gnutls_x509_privkey_t <var>key</var>, const gnutls_datum_t * <var>data</var>, const char * <var>password</var>)</em></dt>
<dd><p><var>key</var>: The data to store the parsed key
</p>
<p><var>data</var>: The DER or PEM encoded key.
</p>
<p><var>password</var>: the password to decrypt the key (if it is encrypted).
</p>
<p>This function will convert the given PEM encrypted to 
the native gnutls_x509_privkey_t format. The
output will be stored in  <code>key</code> .  
</p>
<p>The  <code>password</code> should be in ASCII. If the password is not provided
or wrong then <code>GNUTLS_E_DECRYPTION_FAILED</code>  will be returned.
</p>
<p>If the Certificate is PEM encoded it should have a header of
&quot;PRIVATE KEY&quot; and the &quot;DEK-Info&quot; header. 
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fprivkey_005fimport_005fpkcs8-1"></span><h4 class="subheading">gnutls_x509_privkey_import_pkcs8</h4>
<span id="gnutls_005fx509_005fprivkey_005fimport_005fpkcs8"></span><dl>
<dt id="index-gnutls_005fx509_005fprivkey_005fimport_005fpkcs8">Function: <em>int</em> <strong>gnutls_x509_privkey_import_pkcs8</strong> <em>(gnutls_x509_privkey_t <var>key</var>, const gnutls_datum_t * <var>data</var>, gnutls_x509_crt_fmt_t <var>format</var>, const char * <var>password</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>key</var>: The data to store the parsed key
</p>
<p><var>data</var>: The DER or PEM encoded key.
</p>
<p><var>format</var>: One of DER or PEM
</p>
<p><var>password</var>: the password to decrypt the key (if it is encrypted).
</p>
<p><var>flags</var>: 0 if encrypted or GNUTLS_PKCS_PLAIN if not encrypted.
</p>
<p>This function will convert the given DER or PEM encoded PKCS8 2.0
encrypted key to the native gnutls_x509_privkey_t format. The
output will be stored in  <code>key</code> .  Both RSA and DSA keys can be
imported, and flags can only be used to indicate an unencrypted
key.
</p>
<p>The  <code>password</code> can be either ASCII or UTF-8 in the default PBES2
encryption schemas, or ASCII for the PKCS12 schemas.
</p>
<p>If the Certificate is PEM encoded it should have a header of
&quot;ENCRYPTED PRIVATE KEY&quot;, or &quot;PRIVATE KEY&quot;. You only need to
specify the flags if the key is DER encoded, since in that case
the encryption status cannot be auto-detected.
</p>
<p>If the <code>GNUTLS_PKCS_PLAIN</code>  flag is specified and the supplied data
are encrypted then <code>GNUTLS_E_DECRYPTION_FAILED</code>  is returned.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fprivkey_005fimport_005frsa_005fraw-1"></span><h4 class="subheading">gnutls_x509_privkey_import_rsa_raw</h4>
<span id="gnutls_005fx509_005fprivkey_005fimport_005frsa_005fraw"></span><dl>
<dt id="index-gnutls_005fx509_005fprivkey_005fimport_005frsa_005fraw">Function: <em>int</em> <strong>gnutls_x509_privkey_import_rsa_raw</strong> <em>(gnutls_x509_privkey_t <var>key</var>, const gnutls_datum_t * <var>m</var>, const gnutls_datum_t * <var>e</var>, const gnutls_datum_t * <var>d</var>, const gnutls_datum_t * <var>p</var>, const gnutls_datum_t * <var>q</var>, const gnutls_datum_t * <var>u</var>)</em></dt>
<dd><p><var>key</var>: The data to store the parsed key
</p>
<p><var>m</var>: holds the modulus
</p>
<p><var>e</var>: holds the public exponent
</p>
<p><var>d</var>: holds the private exponent
</p>
<p><var>p</var>: holds the first prime (p)
</p>
<p><var>q</var>: holds the second prime (q)
</p>
<p><var>u</var>: holds the coefficient
</p>
<p>This function will convert the given RSA raw parameters to the
native <code>gnutls_x509_privkey_t</code>  format.  The output will be stored in
 <code>key</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fprivkey_005fimport_005frsa_005fraw2-1"></span><h4 class="subheading">gnutls_x509_privkey_import_rsa_raw2</h4>
<span id="gnutls_005fx509_005fprivkey_005fimport_005frsa_005fraw2"></span><dl>
<dt id="index-gnutls_005fx509_005fprivkey_005fimport_005frsa_005fraw2">Function: <em>int</em> <strong>gnutls_x509_privkey_import_rsa_raw2</strong> <em>(gnutls_x509_privkey_t <var>key</var>, const gnutls_datum_t * <var>m</var>, const gnutls_datum_t * <var>e</var>, const gnutls_datum_t * <var>d</var>, const gnutls_datum_t * <var>p</var>, const gnutls_datum_t * <var>q</var>, const gnutls_datum_t * <var>u</var>, const gnutls_datum_t * <var>e1</var>, const gnutls_datum_t * <var>e2</var>)</em></dt>
<dd><p><var>key</var>: The data to store the parsed key
</p>
<p><var>m</var>: holds the modulus
</p>
<p><var>e</var>: holds the public exponent
</p>
<p><var>d</var>: holds the private exponent
</p>
<p><var>p</var>: holds the first prime (p)
</p>
<p><var>q</var>: holds the second prime (q)
</p>
<p><var>u</var>: holds the coefficient (optional)
</p>
<p><var>e1</var>: holds e1 = d mod (p-1) (optional)
</p>
<p><var>e2</var>: holds e2 = d mod (q-1) (optional)
</p>
<p>This function will convert the given RSA raw parameters to the
native <code>gnutls_x509_privkey_t</code>  format.  The output will be stored in
 <code>key</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fprivkey_005finit-1"></span><h4 class="subheading">gnutls_x509_privkey_init</h4>
<span id="gnutls_005fx509_005fprivkey_005finit"></span><dl>
<dt id="index-gnutls_005fx509_005fprivkey_005finit">Function: <em>int</em> <strong>gnutls_x509_privkey_init</strong> <em>(gnutls_x509_privkey_t * <var>key</var>)</em></dt>
<dd><p><var>key</var>: A pointer to the type to be initialized
</p>
<p>This function will initialize a private key type.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fprivkey_005fsec_005fparam-1"></span><h4 class="subheading">gnutls_x509_privkey_sec_param</h4>
<span id="gnutls_005fx509_005fprivkey_005fsec_005fparam"></span><dl>
<dt id="index-gnutls_005fx509_005fprivkey_005fsec_005fparam">Function: <em>gnutls_sec_param_t</em> <strong>gnutls_x509_privkey_sec_param</strong> <em>(gnutls_x509_privkey_t <var>key</var>)</em></dt>
<dd><p><var>key</var>: a key
</p>
<p>This function will return the security parameter appropriate with
this private key.
</p>
<p><strong>Returns:</strong> On success, a valid security parameter is returned otherwise
<code>GNUTLS_SEC_PARAM_UNKNOWN</code>  is returned.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fx509_005fprivkey_005fset_005fflags-1"></span><h4 class="subheading">gnutls_x509_privkey_set_flags</h4>
<span id="gnutls_005fx509_005fprivkey_005fset_005fflags"></span><dl>
<dt id="index-gnutls_005fx509_005fprivkey_005fset_005fflags">Function: <em>void</em> <strong>gnutls_x509_privkey_set_flags</strong> <em>(gnutls_x509_privkey_t <var>key</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>key</var>: A key of type <code>gnutls_x509_privkey_t</code> 
</p>
<p><var>flags</var>: flags from the <code>gnutls_privkey_flags</code> 
</p>
<p>This function will set flags for the specified private key, after
it is generated. Currently this is useful for the <code>GNUTLS_PRIVKEY_FLAG_EXPORT_COMPAT</code> 
to allow exporting a &quot;provable&quot; private key in backwards compatible way.
</p>
<p><strong>Since:</strong> 3.5.0
</p></dd></dl>

<span id="gnutls_005fx509_005fprivkey_005fset_005fpin_005ffunction-1"></span><h4 class="subheading">gnutls_x509_privkey_set_pin_function</h4>
<span id="gnutls_005fx509_005fprivkey_005fset_005fpin_005ffunction"></span><dl>
<dt id="index-gnutls_005fx509_005fprivkey_005fset_005fpin_005ffunction">Function: <em>void</em> <strong>gnutls_x509_privkey_set_pin_function</strong> <em>(gnutls_x509_privkey_t <var>privkey</var>, gnutls_pin_callback_t <var>fn</var>, void * <var>userdata</var>)</em></dt>
<dd><p><var>privkey</var>: The certificate structure
</p>
<p><var>fn</var>: the callback
</p>
<p><var>userdata</var>: data associated with the callback
</p>
<p>This function will set a callback function to be used when
it is required to access a protected object. This function overrides 
the global function set using <code>gnutls_pkcs11_set_pin_function()</code> .
</p>
<p>Note that this callback is used when decrypting a key.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fx509_005fprivkey_005fset_005fspki-1"></span><h4 class="subheading">gnutls_x509_privkey_set_spki</h4>
<span id="gnutls_005fx509_005fprivkey_005fset_005fspki"></span><dl>
<dt id="index-gnutls_005fx509_005fprivkey_005fset_005fspki">Function: <em>int</em> <strong>gnutls_x509_privkey_set_spki</strong> <em>(gnutls_x509_privkey_t <var>key</var>, const gnutls_x509_spki_t <var>spki</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>key</var>: should contain a <code>gnutls_x509_privkey_t</code>  type
</p>
<p><var>spki</var>: a SubjectPublicKeyInfo structure of type <code>gnutls_x509_spki_t</code> 
</p>
<p><var>flags</var>: must be zero
</p>
<p>This function will return the public key information of a private
key. The provided  <code>spki</code> must be initialized.
</p>
<p><strong>Returns:</strong> Zero on success, or a negative error code on error.
</p></dd></dl>

<span id="gnutls_005fx509_005fprivkey_005fsign_005fdata-1"></span><h4 class="subheading">gnutls_x509_privkey_sign_data</h4>
<span id="gnutls_005fx509_005fprivkey_005fsign_005fdata"></span><dl>
<dt id="index-gnutls_005fx509_005fprivkey_005fsign_005fdata">Function: <em>int</em> <strong>gnutls_x509_privkey_sign_data</strong> <em>(gnutls_x509_privkey_t <var>key</var>, gnutls_digest_algorithm_t <var>digest</var>, unsigned int <var>flags</var>, const gnutls_datum_t * <var>data</var>, void * <var>signature</var>, size_t * <var>signature_size</var>)</em></dt>
<dd><p><var>key</var>: a key
</p>
<p><var>digest</var>: should be a digest algorithm
</p>
<p><var>flags</var>: should be 0 for now
</p>
<p><var>data</var>: holds the data to be signed
</p>
<p><var>signature</var>: will contain the signature
</p>
<p><var>signature_size</var>: holds the size of signature (and will be replaced
by the new size)
</p>
<p>This function will sign the given data using a signature algorithm
supported by the private key. Signature algorithms are always used
together with a hash functions.  Different hash functions may be
used for the RSA algorithm, but only SHA-1 for the DSA keys.
</p>
<p>If the buffer provided is not long enough to hold the output, then
* <code>signature_size</code> is updated and <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  will
be returned.
</p>
<p>Use <code>gnutls_x509_crt_get_preferred_hash_algorithm()</code>  to determine
the hash algorithm.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fprivkey_005fverify_005fparams-1"></span><h4 class="subheading">gnutls_x509_privkey_verify_params</h4>
<span id="gnutls_005fx509_005fprivkey_005fverify_005fparams"></span><dl>
<dt id="index-gnutls_005fx509_005fprivkey_005fverify_005fparams">Function: <em>int</em> <strong>gnutls_x509_privkey_verify_params</strong> <em>(gnutls_x509_privkey_t <var>key</var>)</em></dt>
<dd><p><var>key</var>: a key
</p>
<p>This function will verify the private key parameters.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fprivkey_005fverify_005fseed-1"></span><h4 class="subheading">gnutls_x509_privkey_verify_seed</h4>
<span id="gnutls_005fx509_005fprivkey_005fverify_005fseed"></span><dl>
<dt id="index-gnutls_005fx509_005fprivkey_005fverify_005fseed">Function: <em>int</em> <strong>gnutls_x509_privkey_verify_seed</strong> <em>(gnutls_x509_privkey_t <var>key</var>, gnutls_digest_algorithm_t <var>digest</var>, const void * <var>seed</var>, size_t <var>seed_size</var>)</em></dt>
<dd><p><var>key</var>: should contain a <code>gnutls_x509_privkey_t</code>  type
</p>
<p><var>digest</var>: it contains the digest algorithm used for key generation (if applicable)
</p>
<p><var>seed</var>: the seed of the key to be checked with
</p>
<p><var>seed_size</var>: holds the size of  <code>seed</code> 
</p>
<p>This function will verify that the given private key was generated from
the provided seed. If  <code>seed</code> is <code>NULL</code>  then the seed stored in the  <code>key</code> &rsquo;s structure
will be used for verification.
</p>
<p><strong>Returns:</strong> In case of a verification failure <code>GNUTLS_E_PRIVKEY_VERIFICATION_ERROR</code> 
is returned, and zero or positive code on success.
</p>
<p><strong>Since:</strong> 3.5.0
</p></dd></dl>

<span id="gnutls_005fx509_005frdn_005fget-1"></span><h4 class="subheading">gnutls_x509_rdn_get</h4>
<span id="gnutls_005fx509_005frdn_005fget"></span><dl>
<dt id="index-gnutls_005fx509_005frdn_005fget">Function: <em>int</em> <strong>gnutls_x509_rdn_get</strong> <em>(const gnutls_datum_t * <var>idn</var>, char * <var>buf</var>, size_t * <var>buf_size</var>)</em></dt>
<dd><p><var>idn</var>: should contain a DER encoded RDN sequence
</p>
<p><var>buf</var>: a pointer to a structure to hold the peer&rsquo;s name
</p>
<p><var>buf_size</var>: holds the size of  <code>buf</code> 
</p>
<p>This function will return the name of the given RDN sequence.  The
name will be in the form &quot;C=xxxx,O=yyyy,CN=zzzz&quot; as described in
RFC4514.
</p>
<p>This function does not output a fully RFC4514 compliant string, if
that is required see <code>gnutls_x509_rdn_get2()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, or
<code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  is returned and * <code>buf_size</code> is
updated if the provided buffer is not long enough, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005frdn_005fget2-1"></span><h4 class="subheading">gnutls_x509_rdn_get2</h4>
<span id="gnutls_005fx509_005frdn_005fget2"></span><dl>
<dt id="index-gnutls_005fx509_005frdn_005fget2">Function: <em>int</em> <strong>gnutls_x509_rdn_get2</strong> <em>(const gnutls_datum_t * <var>idn</var>, gnutls_datum_t * <var>str</var>, unsigned <var>flags</var>)</em></dt>
<dd><p><var>idn</var>: should contain a DER encoded RDN sequence
</p>
<p><var>str</var>: a datum that will hold the name
</p>
<p><var>flags</var>: zero of <code>GNUTLS_X509_DN_FLAG_COMPAT</code> 
</p>
<p>This function will return the name of the given RDN sequence.  The
name will be in the form &quot;C=xxxx,O=yyyy,CN=zzzz&quot; as described in
RFC4514.
</p>
<p>When the flag <code>GNUTLS_X509_DN_FLAG_COMPAT</code>  is specified, the output
format will match the format output by previous to 3.5.6 versions of GnuTLS
which was not not fully RFC4514-compliant.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, or
<code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  is returned and * <code>buf_size</code> is
updated if the provided buffer is not long enough, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005frdn_005fget_005fby_005foid-1"></span><h4 class="subheading">gnutls_x509_rdn_get_by_oid</h4>
<span id="gnutls_005fx509_005frdn_005fget_005fby_005foid"></span><dl>
<dt id="index-gnutls_005fx509_005frdn_005fget_005fby_005foid">Function: <em>int</em> <strong>gnutls_x509_rdn_get_by_oid</strong> <em>(const gnutls_datum_t * <var>idn</var>, const char * <var>oid</var>, unsigned <var>indx</var>, unsigned int <var>raw_flag</var>, void * <var>buf</var>, size_t * <var>buf_size</var>)</em></dt>
<dd><p><var>idn</var>: should contain a DER encoded RDN sequence
</p>
<p><var>oid</var>: an Object Identifier
</p>
<p><var>indx</var>: In case multiple same OIDs exist in the RDN indicates which
to send. Use 0 for the first one.
</p>
<p><var>raw_flag</var>: If non-zero then the raw DER data are returned.
</p>
<p><var>buf</var>: a pointer to a structure to hold the peer&rsquo;s name
</p>
<p><var>buf_size</var>: holds the size of  <code>buf</code> 
</p>
<p>This function will return the name of the given Object identifier,
of the RDN sequence.  The name will be encoded using the rules
from RFC4514.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, or
<code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  is returned and * <code>buf_size</code> is
updated if the provided buffer is not long enough, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005frdn_005fget_005foid-1"></span><h4 class="subheading">gnutls_x509_rdn_get_oid</h4>
<span id="gnutls_005fx509_005frdn_005fget_005foid"></span><dl>
<dt id="index-gnutls_005fx509_005frdn_005fget_005foid">Function: <em>int</em> <strong>gnutls_x509_rdn_get_oid</strong> <em>(const gnutls_datum_t * <var>idn</var>, unsigned <var>indx</var>, void * <var>buf</var>, size_t * <var>buf_size</var>)</em></dt>
<dd><p><var>idn</var>: should contain a DER encoded RDN sequence
</p>
<p><var>indx</var>: Indicates which OID to return. Use 0 for the first one.
</p>
<p><var>buf</var>: a pointer to a structure to hold the peer&rsquo;s name OID
</p>
<p><var>buf_size</var>: holds the size of  <code>buf</code> 
</p>
<p>This function will return the specified Object identifier, of the
RDN sequence.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, or
<code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  is returned and * <code>buf_size</code> is
updated if the provided buffer is not long enough, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.4.0
</p></dd></dl>

<span id="gnutls_005fx509_005fspki_005fdeinit-1"></span><h4 class="subheading">gnutls_x509_spki_deinit</h4>
<span id="gnutls_005fx509_005fspki_005fdeinit"></span><dl>
<dt id="index-gnutls_005fx509_005fspki_005fdeinit">Function: <em>void</em> <strong>gnutls_x509_spki_deinit</strong> <em>(gnutls_x509_spki_t <var>spki</var>)</em></dt>
<dd><p><var>spki</var>: the SubjectPublicKeyInfo structure
</p>
<p>This function will deinitialize a SubjectPublicKeyInfo structure.
</p>
<p><strong>Since:</strong> 3.6.0
</p></dd></dl>

<span id="gnutls_005fx509_005fspki_005fget_005frsa_005fpss_005fparams-1"></span><h4 class="subheading">gnutls_x509_spki_get_rsa_pss_params</h4>
<span id="gnutls_005fx509_005fspki_005fget_005frsa_005fpss_005fparams"></span><dl>
<dt id="index-gnutls_005fx509_005fspki_005fget_005frsa_005fpss_005fparams">Function: <em>int</em> <strong>gnutls_x509_spki_get_rsa_pss_params</strong> <em>(gnutls_x509_spki_t <var>spki</var>, gnutls_digest_algorithm_t * <var>dig</var>, unsigned int * <var>salt_size</var>)</em></dt>
<dd><p><var>spki</var>: the SubjectPublicKeyInfo structure
</p>
<p><var>dig</var>: if non-NULL, it will hold the digest algorithm
</p>
<p><var>salt_size</var>: if non-NULL, it will hold the salt size
</p>
<p>This function will get the public key algorithm parameters
of RSA-PSS type.
</p>
<p><strong>Returns:</strong> zero if the parameters are present or a negative
value on error.
</p>
<p><strong>Since:</strong> 3.6.0
</p></dd></dl>

<span id="gnutls_005fx509_005fspki_005finit-1"></span><h4 class="subheading">gnutls_x509_spki_init</h4>
<span id="gnutls_005fx509_005fspki_005finit"></span><dl>
<dt id="index-gnutls_005fx509_005fspki_005finit">Function: <em>int</em> <strong>gnutls_x509_spki_init</strong> <em>(gnutls_x509_spki_t * <var>spki</var>)</em></dt>
<dd><p><var>spki</var>: A pointer to the type to be initialized
</p>
<p>This function will initialize a SubjectPublicKeyInfo structure used
in PKIX. The structure is used to set additional parameters
in the public key information field of a certificate.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.6.0
</p></dd></dl>

<span id="gnutls_005fx509_005fspki_005fset_005frsa_005fpss_005fparams-1"></span><h4 class="subheading">gnutls_x509_spki_set_rsa_pss_params</h4>
<span id="gnutls_005fx509_005fspki_005fset_005frsa_005fpss_005fparams"></span><dl>
<dt id="index-gnutls_005fx509_005fspki_005fset_005frsa_005fpss_005fparams">Function: <em>void</em> <strong>gnutls_x509_spki_set_rsa_pss_params</strong> <em>(gnutls_x509_spki_t <var>spki</var>, gnutls_digest_algorithm_t <var>dig</var>, unsigned int <var>salt_size</var>)</em></dt>
<dd><p><var>spki</var>: the SubjectPublicKeyInfo structure
</p>
<p><var>dig</var>: a digest algorithm of type <code>gnutls_digest_algorithm_t</code> 
</p>
<p><var>salt_size</var>: the size of salt string
</p>
<p>This function will set the public key parameters for
an RSA-PSS algorithm, in the SubjectPublicKeyInfo structure.
</p>
<p><strong>Since:</strong> 3.6.0
</p></dd></dl>

<span id="gnutls_005fx509_005ftlsfeatures_005fadd-1"></span><h4 class="subheading">gnutls_x509_tlsfeatures_add</h4>
<span id="gnutls_005fx509_005ftlsfeatures_005fadd"></span><dl>
<dt id="index-gnutls_005fx509_005ftlsfeatures_005fadd">Function: <em>int</em> <strong>gnutls_x509_tlsfeatures_add</strong> <em>(gnutls_x509_tlsfeatures_t <var>f</var>, unsigned int <var>feature</var>)</em></dt>
<dd><p><var>f</var>: The TLS features
</p>
<p><var>feature</var>: The feature to add
</p>
<p>This function will append a feature to the X.509 TLS features
extension structure.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.5.1
</p></dd></dl>

<span id="gnutls_005fx509_005ftlsfeatures_005fcheck_005fcrt-1"></span><h4 class="subheading">gnutls_x509_tlsfeatures_check_crt</h4>
<span id="gnutls_005fx509_005ftlsfeatures_005fcheck_005fcrt"></span><dl>
<dt id="index-gnutls_005fx509_005ftlsfeatures_005fcheck_005fcrt">Function: <em>unsigned</em> <strong>gnutls_x509_tlsfeatures_check_crt</strong> <em>(gnutls_x509_tlsfeatures_t <var>feat</var>, gnutls_x509_crt_t <var>cert</var>)</em></dt>
<dd><p><var>feat</var>: a set of TLSFeatures
</p>
<p><var>cert</var>: the certificate to be checked
</p>
<p>This function will check the provided certificate against the TLSFeatures
set in  <code>feat</code> using the RFC7633 p.4.2.2 rules. It will check whether the certificate
contains the features in  <code>feat</code> or a superset.
</p>
<p><strong>Returns:</strong> non-zero if the provided certificate complies, and zero otherwise.
</p>
<p><strong>Since:</strong> 3.5.1
</p></dd></dl>

<span id="gnutls_005fx509_005ftlsfeatures_005fdeinit-1"></span><h4 class="subheading">gnutls_x509_tlsfeatures_deinit</h4>
<span id="gnutls_005fx509_005ftlsfeatures_005fdeinit"></span><dl>
<dt id="index-gnutls_005fx509_005ftlsfeatures_005fdeinit">Function: <em>void</em> <strong>gnutls_x509_tlsfeatures_deinit</strong> <em>(gnutls_x509_tlsfeatures_t <var>f</var>)</em></dt>
<dd><p><var>f</var>: The TLS features
</p>
<p>This function will deinitialize a X.509 TLS features extension structure
</p>
<p><strong>Since:</strong> 3.5.1
</p></dd></dl>

<span id="gnutls_005fx509_005ftlsfeatures_005fget-1"></span><h4 class="subheading">gnutls_x509_tlsfeatures_get</h4>
<span id="gnutls_005fx509_005ftlsfeatures_005fget"></span><dl>
<dt id="index-gnutls_005fx509_005ftlsfeatures_005fget">Function: <em>int</em> <strong>gnutls_x509_tlsfeatures_get</strong> <em>(gnutls_x509_tlsfeatures_t <var>f</var>, unsigned <var>idx</var>, unsigned int * <var>feature</var>)</em></dt>
<dd><p><var>f</var>: The TLS features
</p>
<p><var>idx</var>: The index of the feature to get
</p>
<p><var>feature</var>: If the function succeeds, the feature will be stored in this variable
</p>
<p>This function will get a feature from the X.509 TLS features
extension structure.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.5.1
</p></dd></dl>

<span id="gnutls_005fx509_005ftlsfeatures_005finit-1"></span><h4 class="subheading">gnutls_x509_tlsfeatures_init</h4>
<span id="gnutls_005fx509_005ftlsfeatures_005finit"></span><dl>
<dt id="index-gnutls_005fx509_005ftlsfeatures_005finit">Function: <em>int</em> <strong>gnutls_x509_tlsfeatures_init</strong> <em>(gnutls_x509_tlsfeatures_t * <var>f</var>)</em></dt>
<dd><p><var>f</var>: The TLS features
</p>
<p>This function will initialize a X.509 TLS features extension structure
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error value.
</p>
<p><strong>Since:</strong> 3.5.1
</p></dd></dl>

<span id="gnutls_005fx509_005ftrust_005flist_005fadd_005fcas-1"></span><h4 class="subheading">gnutls_x509_trust_list_add_cas</h4>
<span id="gnutls_005fx509_005ftrust_005flist_005fadd_005fcas"></span><dl>
<dt id="index-gnutls_005fx509_005ftrust_005flist_005fadd_005fcas-1">Function: <em>int</em> <strong>gnutls_x509_trust_list_add_cas</strong> <em>(gnutls_x509_trust_list_t <var>list</var>, const gnutls_x509_crt_t * <var>clist</var>, unsigned <var>clist_size</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>list</var>: The list
</p>
<p><var>clist</var>: A list of CAs
</p>
<p><var>clist_size</var>: The length of the CA list
</p>
<p><var>flags</var>: flags from <code>gnutls_trust_list_flags_t</code> 
</p>
<p>This function will add the given certificate authorities
to the trusted list. The CAs in  <code>clist</code> must not be deinitialized
during the lifetime of  <code>list</code> .
</p>
<p>If the flag <code>GNUTLS_TL_NO_DUPLICATES</code>  is specified, then
this function will ensure that no duplicates will be
present in the final trust list.
</p>
<p>If the flag <code>GNUTLS_TL_NO_DUPLICATE_KEY</code>  is specified, then
this function will ensure that no certificates with the
same key are present in the final trust list.
</p>
<p>If either <code>GNUTLS_TL_NO_DUPLICATE_KEY</code>  or <code>GNUTLS_TL_NO_DUPLICATES</code> 
are given, <code>gnutls_x509_trust_list_deinit()</code>  must be called with parameter
 <code>all</code> being 1.
</p>
<p><strong>Returns:</strong> The number of added elements is returned; that includes
duplicate entries.
</p>
<p><strong>Since:</strong> 3.0.0
</p></dd></dl>

<span id="gnutls_005fx509_005ftrust_005flist_005fadd_005fcrls-1"></span><h4 class="subheading">gnutls_x509_trust_list_add_crls</h4>
<span id="gnutls_005fx509_005ftrust_005flist_005fadd_005fcrls"></span><dl>
<dt id="index-gnutls_005fx509_005ftrust_005flist_005fadd_005fcrls-1">Function: <em>int</em> <strong>gnutls_x509_trust_list_add_crls</strong> <em>(gnutls_x509_trust_list_t <var>list</var>, const gnutls_x509_crl_t * <var>crl_list</var>, unsigned <var>crl_size</var>, unsigned int <var>flags</var>, unsigned int <var>verification_flags</var>)</em></dt>
<dd><p><var>list</var>: The list
</p>
<p><var>crl_list</var>: A list of CRLs
</p>
<p><var>crl_size</var>: The length of the CRL list
</p>
<p><var>flags</var>: flags from <code>gnutls_trust_list_flags_t</code> 
</p>
<p><var>verification_flags</var>: gnutls_certificate_verify_flags if flags specifies GNUTLS_TL_VERIFY_CRL
</p>
<p>This function will add the given certificate revocation lists
to the trusted list. The CRLs in  <code>crl_list</code> must not be deinitialized
during the lifetime of  <code>list</code> .
</p>
<p>This function must be called after <code>gnutls_x509_trust_list_add_cas()</code> 
to allow verifying the CRLs for validity. If the flag <code>GNUTLS_TL_NO_DUPLICATES</code> 
is given, then the final CRL list will not contain duplicate entries.
</p>
<p>If the flag <code>GNUTLS_TL_NO_DUPLICATES</code>  is given, <code>gnutls_x509_trust_list_deinit()</code>  must be
called with parameter  <code>all</code> being 1.
</p>
<p>If flag <code>GNUTLS_TL_VERIFY_CRL</code>  is given the CRLs will be verified before being added,
and if verification fails, they will be skipped.
</p>
<p><strong>Returns:</strong> The number of added elements is returned; that includes
duplicate entries.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fx509_005ftrust_005flist_005fadd_005fnamed_005fcrt-1"></span><h4 class="subheading">gnutls_x509_trust_list_add_named_crt</h4>
<span id="gnutls_005fx509_005ftrust_005flist_005fadd_005fnamed_005fcrt"></span><dl>
<dt id="index-gnutls_005fx509_005ftrust_005flist_005fadd_005fnamed_005fcrt-1">Function: <em>int</em> <strong>gnutls_x509_trust_list_add_named_crt</strong> <em>(gnutls_x509_trust_list_t <var>list</var>, gnutls_x509_crt_t <var>cert</var>, const void * <var>name</var>, size_t <var>name_size</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>list</var>: The list
</p>
<p><var>cert</var>: A certificate
</p>
<p><var>name</var>: An identifier for the certificate
</p>
<p><var>name_size</var>: The size of the identifier
</p>
<p><var>flags</var>: should be 0.
</p>
<p>This function will add the given certificate to the trusted
list and associate it with a name. The certificate will not be
be used for verification with <code>gnutls_x509_trust_list_verify_crt()</code> 
but with <code>gnutls_x509_trust_list_verify_named_crt()</code>  or
<code>gnutls_x509_trust_list_verify_crt2()</code>  - the latter only since
GnuTLS 3.4.0 and if a hostname is provided.
</p>
<p>In principle this function can be used to set individual &quot;server&quot;
certificates that are trusted by the user for that specific server
but for no other purposes.
</p>
<p>The certificate  <code>cert</code> must not be deinitialized during the lifetime
of the  <code>list</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.0.0
</p></dd></dl>

<span id="gnutls_005fx509_005ftrust_005flist_005fadd_005fsystem_005ftrust-1"></span><h4 class="subheading">gnutls_x509_trust_list_add_system_trust</h4>
<span id="gnutls_005fx509_005ftrust_005flist_005fadd_005fsystem_005ftrust"></span><dl>
<dt id="index-gnutls_005fx509_005ftrust_005flist_005fadd_005fsystem_005ftrust-1">Function: <em>int</em> <strong>gnutls_x509_trust_list_add_system_trust</strong> <em>(gnutls_x509_trust_list_t <var>list</var>, unsigned int <var>tl_flags</var>, unsigned int <var>tl_vflags</var>)</em></dt>
<dd><p><var>list</var>: The structure of the list
</p>
<p><var>tl_flags</var>: GNUTLS_TL_*
</p>
<p><var>tl_vflags</var>: gnutls_certificate_verify_flags if flags specifies GNUTLS_TL_VERIFY_CRL
</p>
<p>This function adds the system&rsquo;s default trusted certificate
authorities to the trusted list. Note that on unsupported systems
this function returns <code>GNUTLS_E_UNIMPLEMENTED_FEATURE</code> .
</p>
<p>This function implies the flag <code>GNUTLS_TL_NO_DUPLICATES</code> .
</p>
<p><strong>Returns:</strong> The number of added elements or a negative error code on error.
</p>
<p><strong>Since:</strong> 3.1
</p></dd></dl>

<span id="gnutls_005fx509_005ftrust_005flist_005fadd_005ftrust_005fdir-1"></span><h4 class="subheading">gnutls_x509_trust_list_add_trust_dir</h4>
<span id="gnutls_005fx509_005ftrust_005flist_005fadd_005ftrust_005fdir"></span><dl>
<dt id="index-gnutls_005fx509_005ftrust_005flist_005fadd_005ftrust_005fdir">Function: <em>int</em> <strong>gnutls_x509_trust_list_add_trust_dir</strong> <em>(gnutls_x509_trust_list_t <var>list</var>, const char * <var>ca_dir</var>, const char * <var>crl_dir</var>, gnutls_x509_crt_fmt_t <var>type</var>, unsigned int <var>tl_flags</var>, unsigned int <var>tl_vflags</var>)</em></dt>
<dd><p><var>list</var>: The list
</p>
<p><var>ca_dir</var>: A directory containing the CAs (optional)
</p>
<p><var>crl_dir</var>: A directory containing a list of CRLs (optional)
</p>
<p><var>type</var>: The format of the certificates
</p>
<p><var>tl_flags</var>: flags from <code>gnutls_trust_list_flags_t</code> 
</p>
<p><var>tl_vflags</var>: gnutls_certificate_verify_flags if flags specifies GNUTLS_TL_VERIFY_CRL
</p>
<p>This function will add the given certificate authorities
to the trusted list. Only directories are accepted by
this function.
</p>
<p><strong>Returns:</strong> The number of added elements is returned.
</p>
<p><strong>Since:</strong> 3.3.6
</p></dd></dl>

<span id="gnutls_005fx509_005ftrust_005flist_005fadd_005ftrust_005ffile-1"></span><h4 class="subheading">gnutls_x509_trust_list_add_trust_file</h4>
<span id="gnutls_005fx509_005ftrust_005flist_005fadd_005ftrust_005ffile"></span><dl>
<dt id="index-gnutls_005fx509_005ftrust_005flist_005fadd_005ftrust_005ffile-1">Function: <em>int</em> <strong>gnutls_x509_trust_list_add_trust_file</strong> <em>(gnutls_x509_trust_list_t <var>list</var>, const char * <var>ca_file</var>, const char * <var>crl_file</var>, gnutls_x509_crt_fmt_t <var>type</var>, unsigned int <var>tl_flags</var>, unsigned int <var>tl_vflags</var>)</em></dt>
<dd><p><var>list</var>: The list
</p>
<p><var>ca_file</var>: A file containing a list of CAs (optional)
</p>
<p><var>crl_file</var>: A file containing a list of CRLs (optional)
</p>
<p><var>type</var>: The format of the certificates
</p>
<p><var>tl_flags</var>: flags from <code>gnutls_trust_list_flags_t</code> 
</p>
<p><var>tl_vflags</var>: gnutls_certificate_verify_flags if flags specifies GNUTLS_TL_VERIFY_CRL
</p>
<p>This function will add the given certificate authorities
to the trusted list. PKCS <code>11</code>  URLs are also accepted, instead
of files, by this function. A PKCS <code>11</code>  URL implies a trust
database (a specially marked module in p11-kit); the URL &quot;pkcs11:&quot;
implies all trust databases in the system. Only a single URL specifying
trust databases can be set; they cannot be stacked with multiple calls.
</p>
<p><strong>Returns:</strong> The number of added elements is returned.
</p>
<p><strong>Since:</strong> 3.1
</p></dd></dl>

<span id="gnutls_005fx509_005ftrust_005flist_005fadd_005ftrust_005fmem-1"></span><h4 class="subheading">gnutls_x509_trust_list_add_trust_mem</h4>
<span id="gnutls_005fx509_005ftrust_005flist_005fadd_005ftrust_005fmem"></span><dl>
<dt id="index-gnutls_005fx509_005ftrust_005flist_005fadd_005ftrust_005fmem-1">Function: <em>int</em> <strong>gnutls_x509_trust_list_add_trust_mem</strong> <em>(gnutls_x509_trust_list_t <var>list</var>, const gnutls_datum_t * <var>cas</var>, const gnutls_datum_t * <var>crls</var>, gnutls_x509_crt_fmt_t <var>type</var>, unsigned int <var>tl_flags</var>, unsigned int <var>tl_vflags</var>)</em></dt>
<dd><p><var>list</var>: The list
</p>
<p><var>cas</var>: A buffer containing a list of CAs (optional)
</p>
<p><var>crls</var>: A buffer containing a list of CRLs (optional)
</p>
<p><var>type</var>: The format of the certificates
</p>
<p><var>tl_flags</var>: flags from <code>gnutls_trust_list_flags_t</code> 
</p>
<p><var>tl_vflags</var>: gnutls_certificate_verify_flags if flags specifies GNUTLS_TL_VERIFY_CRL
</p>
<p>This function will add the given certificate authorities
to the trusted list. 
</p>
<p>If this function is used <code>gnutls_x509_trust_list_deinit()</code>  must be called
with parameter  <code>all</code> being 1.
</p>
<p><strong>Returns:</strong> The number of added elements is returned.
</p>
<p><strong>Since:</strong> 3.1
</p></dd></dl>

<span id="gnutls_005fx509_005ftrust_005flist_005fdeinit-1"></span><h4 class="subheading">gnutls_x509_trust_list_deinit</h4>
<span id="gnutls_005fx509_005ftrust_005flist_005fdeinit"></span><dl>
<dt id="index-gnutls_005fx509_005ftrust_005flist_005fdeinit">Function: <em>void</em> <strong>gnutls_x509_trust_list_deinit</strong> <em>(gnutls_x509_trust_list_t <var>list</var>, unsigned int <var>all</var>)</em></dt>
<dd><p><var>list</var>: The list to be deinitialized
</p>
<p><var>all</var>: if non-zero it will deinitialize all the certificates and CRLs contained in the structure.
</p>
<p>This function will deinitialize a trust list. Note that the
 <code>all</code> flag should be typically non-zero unless you have specified
your certificates using <code>gnutls_x509_trust_list_add_cas()</code>  and you
want to prevent them from being deinitialized by this function.
</p>
<p><strong>Since:</strong> 3.0.0
</p></dd></dl>

<span id="gnutls_005fx509_005ftrust_005flist_005fget_005fissuer-1"></span><h4 class="subheading">gnutls_x509_trust_list_get_issuer</h4>
<span id="gnutls_005fx509_005ftrust_005flist_005fget_005fissuer"></span><dl>
<dt id="index-gnutls_005fx509_005ftrust_005flist_005fget_005fissuer">Function: <em>int</em> <strong>gnutls_x509_trust_list_get_issuer</strong> <em>(gnutls_x509_trust_list_t <var>list</var>, gnutls_x509_crt_t <var>cert</var>, gnutls_x509_crt_t * <var>issuer</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>list</var>: The list
</p>
<p><var>cert</var>: is the certificate to find issuer for
</p>
<p><var>issuer</var>: Will hold the issuer if any. Should be treated as constant.
</p>
<p><var>flags</var>: flags from <code>gnutls_trust_list_flags_t</code>  (<code>GNUTLS_TL_GET_COPY</code>  is applicable)
</p>
<p>This function will find the issuer of the given certificate.
If the flag <code>GNUTLS_TL_GET_COPY</code>  is specified a copy of the issuer
will be returned which must be freed using <code>gnutls_x509_crt_deinit()</code> .
In that case the provided  <code>issuer</code> must not be initialized.
</p>
<p>Note that the flag <code>GNUTLS_TL_GET_COPY</code>  is required for this function
to work with PKCS<code>11</code>  trust lists in a thread-safe way.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fx509_005ftrust_005flist_005fget_005fissuer_005fby_005fdn-1"></span><h4 class="subheading">gnutls_x509_trust_list_get_issuer_by_dn</h4>
<span id="gnutls_005fx509_005ftrust_005flist_005fget_005fissuer_005fby_005fdn"></span><dl>
<dt id="index-gnutls_005fx509_005ftrust_005flist_005fget_005fissuer_005fby_005fdn">Function: <em>int</em> <strong>gnutls_x509_trust_list_get_issuer_by_dn</strong> <em>(gnutls_x509_trust_list_t <var>list</var>, const gnutls_datum_t * <var>dn</var>, gnutls_x509_crt_t * <var>issuer</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>list</var>: The list
</p>
<p><var>dn</var>: is the issuer&rsquo;s DN
</p>
<p><var>issuer</var>: Will hold the issuer if any. Should be deallocated after use.
</p>
<p><var>flags</var>: Use zero
</p>
<p>This function will find the issuer with the given name, and
return a copy of the issuer, which must be freed using <code>gnutls_x509_crt_deinit()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fx509_005ftrust_005flist_005fget_005fissuer_005fby_005fsubject_005fkey_005fid-1"></span><h4 class="subheading">gnutls_x509_trust_list_get_issuer_by_subject_key_id</h4>
<span id="gnutls_005fx509_005ftrust_005flist_005fget_005fissuer_005fby_005fsubject_005fkey_005fid"></span><dl>
<dt id="index-gnutls_005fx509_005ftrust_005flist_005fget_005fissuer_005fby_005fsubject_005fkey_005fid">Function: <em>int</em> <strong>gnutls_x509_trust_list_get_issuer_by_subject_key_id</strong> <em>(gnutls_x509_trust_list_t <var>list</var>, const gnutls_datum_t * <var>dn</var>, const gnutls_datum_t * <var>spki</var>, gnutls_x509_crt_t * <var>issuer</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>list</var>: The list
</p>
<p><var>dn</var>: is the issuer&rsquo;s DN (may be <code>NULL</code> )
</p>
<p><var>spki</var>: is the subject key ID
</p>
<p><var>issuer</var>: Will hold the issuer if any. Should be deallocated after use.
</p>
<p><var>flags</var>: Use zero
</p>
<p>This function will find the issuer with the given name and subject key ID, and
return a copy of the issuer, which must be freed using <code>gnutls_x509_crt_deinit()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.4.2
</p></dd></dl>

<span id="gnutls_005fx509_005ftrust_005flist_005finit-1"></span><h4 class="subheading">gnutls_x509_trust_list_init</h4>
<span id="gnutls_005fx509_005ftrust_005flist_005finit"></span><dl>
<dt id="index-gnutls_005fx509_005ftrust_005flist_005finit">Function: <em>int</em> <strong>gnutls_x509_trust_list_init</strong> <em>(gnutls_x509_trust_list_t * <var>list</var>, unsigned int <var>size</var>)</em></dt>
<dd><p><var>list</var>: A pointer to the type to be initialized
</p>
<p><var>size</var>: The size of the internal hash table. Use (0) for default size.
</p>
<p>This function will initialize an X.509 trust list structure.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.0.0
</p></dd></dl>

<span id="gnutls_005fx509_005ftrust_005flist_005fiter_005fdeinit-1"></span><h4 class="subheading">gnutls_x509_trust_list_iter_deinit</h4>
<span id="gnutls_005fx509_005ftrust_005flist_005fiter_005fdeinit"></span><dl>
<dt id="index-gnutls_005fx509_005ftrust_005flist_005fiter_005fdeinit">Function: <em>void</em> <strong>gnutls_x509_trust_list_iter_deinit</strong> <em>(gnutls_x509_trust_list_iter_t <var>iter</var>)</em></dt>
<dd><p><var>iter</var>: The iterator structure to be deinitialized
</p>
<p>This function will deinitialize an iterator structure.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fx509_005ftrust_005flist_005fiter_005fget_005fca-1"></span><h4 class="subheading">gnutls_x509_trust_list_iter_get_ca</h4>
<span id="gnutls_005fx509_005ftrust_005flist_005fiter_005fget_005fca"></span><dl>
<dt id="index-gnutls_005fx509_005ftrust_005flist_005fiter_005fget_005fca">Function: <em>int</em> <strong>gnutls_x509_trust_list_iter_get_ca</strong> <em>(gnutls_x509_trust_list_t <var>list</var>, gnutls_x509_trust_list_iter_t * <var>iter</var>, gnutls_x509_crt_t * <var>crt</var>)</em></dt>
<dd><p><var>list</var>: The list
</p>
<p><var>iter</var>: A pointer to an iterator (initially the iterator should be <code>NULL</code> )
</p>
<p><var>crt</var>: where the certificate will be copied
</p>
<p>This function obtains a certificate in the trust list and advances the
iterator to the next certificate. The certificate returned in  <code>crt</code> must be
deallocated with <code>gnutls_x509_crt_deinit()</code> .
</p>
<p>When past the last element is accessed <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
is returned and the iterator is reset.
</p>
<p>The iterator is deinitialized and reset to <code>NULL</code>  automatically by this
function after iterating through all elements until
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  is returned. If the iteration is
aborted early, it must be manually deinitialized using
<code>gnutls_x509_trust_list_iter_deinit()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fx509_005ftrust_005flist_005fremove_005fcas-1"></span><h4 class="subheading">gnutls_x509_trust_list_remove_cas</h4>
<span id="gnutls_005fx509_005ftrust_005flist_005fremove_005fcas"></span><dl>
<dt id="index-gnutls_005fx509_005ftrust_005flist_005fremove_005fcas">Function: <em>int</em> <strong>gnutls_x509_trust_list_remove_cas</strong> <em>(gnutls_x509_trust_list_t <var>list</var>, const gnutls_x509_crt_t * <var>clist</var>, unsigned <var>clist_size</var>)</em></dt>
<dd><p><var>list</var>: The list
</p>
<p><var>clist</var>: A list of CAs
</p>
<p><var>clist_size</var>: The length of the CA list
</p>
<p>This function will remove the given certificate authorities
from the trusted list.
</p>
<p>Note that this function can accept certificates and authorities
not yet known. In that case they will be kept in a separate
black list that will be used during certificate verification.
Unlike <code>gnutls_x509_trust_list_add_cas()</code>  there is no deinitialization
restriction for  certificate list provided in this function.
</p>
<p><strong>Returns:</strong> The number of removed elements is returned.
</p>
<p><strong>Since:</strong> 3.1.10
</p></dd></dl>

<span id="gnutls_005fx509_005ftrust_005flist_005fremove_005ftrust_005ffile-1"></span><h4 class="subheading">gnutls_x509_trust_list_remove_trust_file</h4>
<span id="gnutls_005fx509_005ftrust_005flist_005fremove_005ftrust_005ffile"></span><dl>
<dt id="index-gnutls_005fx509_005ftrust_005flist_005fremove_005ftrust_005ffile">Function: <em>int</em> <strong>gnutls_x509_trust_list_remove_trust_file</strong> <em>(gnutls_x509_trust_list_t <var>list</var>, const char * <var>ca_file</var>, gnutls_x509_crt_fmt_t <var>type</var>)</em></dt>
<dd><p><var>list</var>: The list
</p>
<p><var>ca_file</var>: A file containing a list of CAs
</p>
<p><var>type</var>: The format of the certificates
</p>
<p>This function will remove the given certificate authorities
from the trusted list, and add them into a black list when needed. 
PKCS 11 URLs are also accepted, instead
of files, by this function.
</p>
<p>See also <code>gnutls_x509_trust_list_remove_cas()</code> .
</p>
<p><strong>Returns:</strong> The number of added elements is returned.
</p>
<p><strong>Since:</strong> 3.1.10
</p></dd></dl>

<span id="gnutls_005fx509_005ftrust_005flist_005fremove_005ftrust_005fmem-1"></span><h4 class="subheading">gnutls_x509_trust_list_remove_trust_mem</h4>
<span id="gnutls_005fx509_005ftrust_005flist_005fremove_005ftrust_005fmem"></span><dl>
<dt id="index-gnutls_005fx509_005ftrust_005flist_005fremove_005ftrust_005fmem">Function: <em>int</em> <strong>gnutls_x509_trust_list_remove_trust_mem</strong> <em>(gnutls_x509_trust_list_t <var>list</var>, const gnutls_datum_t * <var>cas</var>, gnutls_x509_crt_fmt_t <var>type</var>)</em></dt>
<dd><p><var>list</var>: The list
</p>
<p><var>cas</var>: A buffer containing a list of CAs (optional)
</p>
<p><var>type</var>: The format of the certificates
</p>
<p>This function will remove the provided certificate authorities
from the trusted list, and add them into a black list when needed. 
</p>
<p>See also <code>gnutls_x509_trust_list_remove_cas()</code> .
</p>
<p><strong>Returns:</strong> The number of removed elements is returned.
</p>
<p><strong>Since:</strong> 3.1.10
</p></dd></dl>

<span id="gnutls_005fx509_005ftrust_005flist_005fverify_005fcrt-1"></span><h4 class="subheading">gnutls_x509_trust_list_verify_crt</h4>
<span id="gnutls_005fx509_005ftrust_005flist_005fverify_005fcrt"></span><dl>
<dt id="index-gnutls_005fx509_005ftrust_005flist_005fverify_005fcrt-1">Function: <em>int</em> <strong>gnutls_x509_trust_list_verify_crt</strong> <em>(gnutls_x509_trust_list_t <var>list</var>, gnutls_x509_crt_t * <var>cert_list</var>, unsigned int <var>cert_list_size</var>, unsigned int <var>flags</var>, unsigned int * <var>voutput</var>, gnutls_verify_output_function <var>func</var>)</em></dt>
<dd><p><var>list</var>: The list
</p>
<p><var>cert_list</var>: is the certificate list to be verified
</p>
<p><var>cert_list_size</var>: is the certificate list size
</p>
<p><var>flags</var>: Flags that may be used to change the verification algorithm. Use OR of the gnutls_certificate_verify_flags enumerations.
</p>
<p><var>voutput</var>: will hold the certificate verification output.
</p>
<p><var>func</var>: If non-null will be called on each chain element verification with the output.
</p>
<p>This function will try to verify the given certificate and return
its status. The  <code>voutput</code> parameter will hold an OR&rsquo;ed sequence of
<code>gnutls_certificate_status_t</code>  flags.
</p>
<p>The details of the verification are the same as in <code>gnutls_x509_trust_list_verify_crt2()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fx509_005ftrust_005flist_005fverify_005fcrt2-1"></span><h4 class="subheading">gnutls_x509_trust_list_verify_crt2</h4>
<span id="gnutls_005fx509_005ftrust_005flist_005fverify_005fcrt2"></span><dl>
<dt id="index-gnutls_005fx509_005ftrust_005flist_005fverify_005fcrt2-1">Function: <em>int</em> <strong>gnutls_x509_trust_list_verify_crt2</strong> <em>(gnutls_x509_trust_list_t <var>list</var>, gnutls_x509_crt_t * <var>cert_list</var>, unsigned int <var>cert_list_size</var>, gnutls_typed_vdata_st * <var>data</var>, unsigned int <var>elements</var>, unsigned int <var>flags</var>, unsigned int * <var>voutput</var>, gnutls_verify_output_function <var>func</var>)</em></dt>
<dd><p><var>list</var>: The list
</p>
<p><var>cert_list</var>: is the certificate list to be verified
</p>
<p><var>cert_list_size</var>: is the certificate list size
</p>
<p><var>data</var>: an array of typed data
</p>
<p><var>elements</var>: the number of data elements
</p>
<p><var>flags</var>: Flags that may be used to change the verification algorithm. Use OR of the gnutls_certificate_verify_flags enumerations.
</p>
<p><var>voutput</var>: will hold the certificate verification output.
</p>
<p><var>func</var>: If non-null will be called on each chain element verification with the output.
</p>
<p>This function will attempt to verify the given certificate chain and return
its status. The  <code>voutput</code> parameter will hold an OR&rsquo;ed sequence of
<code>gnutls_certificate_status_t</code>  flags.
</p>
<p>When a certificate chain of  <code>cert_list_size</code> with more than one certificates is
provided, the verification status will apply to the first certificate in the chain
that failed verification. The verification process starts from the end of the chain
(from CA to end certificate). The first certificate in the chain must be the end-certificate
while the rest of the members may be sorted or not.
</p>
<p>Additionally a certificate verification profile can be specified
from the ones in <code>gnutls_certificate_verification_profiles_t</code>  by
ORing the result of <code>GNUTLS_PROFILE_TO_VFLAGS()</code>  to the verification
flags.
</p>
<p>Additional verification parameters are possible via the  <code>data</code> types; the
acceptable types are <code>GNUTLS_DT_DNS_HOSTNAME</code> , <code>GNUTLS_DT_IP_ADDRESS</code>  and <code>GNUTLS_DT_KEY_PURPOSE_OID</code> .
The former accepts as data a null-terminated hostname, and the latter a null-terminated
object identifier (e.g., <code>GNUTLS_KP_TLS_WWW_SERVER</code> ).
If a DNS hostname is provided then this function will compare
the hostname in the end certificate against the given. If names do not match the
<code>GNUTLS_CERT_UNEXPECTED_OWNER</code>  status flag will be set. In addition it
will consider certificates provided with <code>gnutls_x509_trust_list_add_named_crt()</code> .
</p>
<p>If a key purpose OID is provided and the end-certificate contains the extended key
usage PKIX extension, it will be required to match the provided OID
or be marked for any purpose, otherwise verification will fail with 
<code>GNUTLS_CERT_PURPOSE_MISMATCH</code>  status.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value. Note that verification failure will not result to an
error code, only  <code>voutput</code> will be updated.
</p>
<p><strong>Since:</strong> 3.3.8
</p></dd></dl>

<span id="gnutls_005fx509_005ftrust_005flist_005fverify_005fnamed_005fcrt-1"></span><h4 class="subheading">gnutls_x509_trust_list_verify_named_crt</h4>
<span id="gnutls_005fx509_005ftrust_005flist_005fverify_005fnamed_005fcrt"></span><dl>
<dt id="index-gnutls_005fx509_005ftrust_005flist_005fverify_005fnamed_005fcrt-1">Function: <em>int</em> <strong>gnutls_x509_trust_list_verify_named_crt</strong> <em>(gnutls_x509_trust_list_t <var>list</var>, gnutls_x509_crt_t <var>cert</var>, const void * <var>name</var>, size_t <var>name_size</var>, unsigned int <var>flags</var>, unsigned int * <var>voutput</var>, gnutls_verify_output_function <var>func</var>)</em></dt>
<dd><p><var>list</var>: The list
</p>
<p><var>cert</var>: is the certificate to be verified
</p>
<p><var>name</var>: is the certificate&rsquo;s name
</p>
<p><var>name_size</var>: is the certificate&rsquo;s name size
</p>
<p><var>flags</var>: Flags that may be used to change the verification algorithm. Use OR of the gnutls_certificate_verify_flags enumerations.
</p>
<p><var>voutput</var>: will hold the certificate verification output.
</p>
<p><var>func</var>: If non-null will be called on each chain element verification with the output.
</p>
<p>This function will try to find a certificate that is associated with the provided
name &ndash;see <code>gnutls_x509_trust_list_add_named_crt()</code> . If a match is found the
certificate is considered valid. In addition to that this function will also 
check CRLs. The  <code>voutput</code> parameter will hold an OR&rsquo;ed sequence of 
<code>gnutls_certificate_status_t</code>  flags.
</p>
<p>Additionally a certificate verification profile can be specified
from the ones in <code>gnutls_certificate_verification_profiles_t</code>  by
ORing the result of <code>GNUTLS_PROFILE_TO_VFLAGS()</code>  to the verification
flags.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.0.0
</p></dd></dl>


<hr>
<span id="PKCS-7-API"></span><div class="header">
<p>
Next: <a href="#OCSP-API" accesskey="n" rel="next">OCSP API</a>, Previous: <a href="#X509-certificate-API" accesskey="p" rel="prev">X509 certificate API</a>, Up: <a href="#API-reference" accesskey="u" rel="up">API reference</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="PKCS-7-API-1"></span><h3 class="section">E.4 <acronym>PKCS</acronym> 7 API</h3>

<p>The following functions are to be used for PKCS 7 structures handling.
Their prototypes lie in <samp>gnutls/pkcs7.h</samp>.
</p>

<span id="gnutls_005fpkcs7_005fadd_005fattr-1"></span><h4 class="subheading">gnutls_pkcs7_add_attr</h4>
<span id="gnutls_005fpkcs7_005fadd_005fattr"></span><dl>
<dt id="index-gnutls_005fpkcs7_005fadd_005fattr">Function: <em>int</em> <strong>gnutls_pkcs7_add_attr</strong> <em>(gnutls_pkcs7_attrs_t * <var>list</var>, const char * <var>oid</var>, gnutls_datum_t * <var>data</var>, unsigned <var>flags</var>)</em></dt>
<dd><p><var>list</var>: A list of existing attributes or pointer to <code>NULL</code>  for the first one
</p>
<p><var>oid</var>: the OID of the attribute to be set
</p>
<p><var>data</var>: the raw (DER-encoded) data of the attribute to be set
</p>
<p><var>flags</var>: zero or <code>GNUTLS_PKCS7_ATTR_ENCODE_OCTET_STRING</code> 
</p>
<p>This function will set a PKCS <code>7</code>  attribute in the provided list.
If this function fails, the previous list would be deallocated.
</p>
<p>Note that any attributes set with this function must either be
DER or BER encoded, unless a special flag is present.
</p>
<p><strong>Returns:</strong> On success, the new list head, otherwise <code>NULL</code> .
</p>
<p><strong>Since:</strong> 3.4.2
</p></dd></dl>

<span id="gnutls_005fpkcs7_005fattrs_005fdeinit-1"></span><h4 class="subheading">gnutls_pkcs7_attrs_deinit</h4>
<span id="gnutls_005fpkcs7_005fattrs_005fdeinit"></span><dl>
<dt id="index-gnutls_005fpkcs7_005fattrs_005fdeinit">Function: <em>void</em> <strong>gnutls_pkcs7_attrs_deinit</strong> <em>(gnutls_pkcs7_attrs_t <var>list</var>)</em></dt>
<dd><p><var>list</var>: A list of existing attributes
</p>
<p>This function will clear a PKCS <code>7</code>  attribute list.
</p>
<p><strong>Since:</strong> 3.4.2
</p></dd></dl>

<span id="gnutls_005fpkcs7_005fdeinit-1"></span><h4 class="subheading">gnutls_pkcs7_deinit</h4>
<span id="gnutls_005fpkcs7_005fdeinit"></span><dl>
<dt id="index-gnutls_005fpkcs7_005fdeinit">Function: <em>void</em> <strong>gnutls_pkcs7_deinit</strong> <em>(gnutls_pkcs7_t <var>pkcs7</var>)</em></dt>
<dd><p><var>pkcs7</var>: the type to be deinitialized
</p>
<p>This function will deinitialize a PKCS7 type.
</p></dd></dl>

<span id="gnutls_005fpkcs7_005fdelete_005fcrl-1"></span><h4 class="subheading">gnutls_pkcs7_delete_crl</h4>
<span id="gnutls_005fpkcs7_005fdelete_005fcrl"></span><dl>
<dt id="index-gnutls_005fpkcs7_005fdelete_005fcrl">Function: <em>int</em> <strong>gnutls_pkcs7_delete_crl</strong> <em>(gnutls_pkcs7_t <var>pkcs7</var>, int <var>indx</var>)</em></dt>
<dd><p><var>pkcs7</var>: The pkcs7 type
</p>
<p><var>indx</var>: the index of the crl to delete
</p>
<p>This function will delete a crl from a PKCS7 or RFC2630 crl set.
Index starts from 0. Returns 0 on success.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fpkcs7_005fdelete_005fcrt-1"></span><h4 class="subheading">gnutls_pkcs7_delete_crt</h4>
<span id="gnutls_005fpkcs7_005fdelete_005fcrt"></span><dl>
<dt id="index-gnutls_005fpkcs7_005fdelete_005fcrt">Function: <em>int</em> <strong>gnutls_pkcs7_delete_crt</strong> <em>(gnutls_pkcs7_t <var>pkcs7</var>, int <var>indx</var>)</em></dt>
<dd><p><var>pkcs7</var>: The pkcs7 type
</p>
<p><var>indx</var>: the index of the certificate to delete
</p>
<p>This function will delete a certificate from a PKCS7 or RFC2630
certificate set.  Index starts from 0. Returns 0 on success.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fpkcs7_005fexport-1"></span><h4 class="subheading">gnutls_pkcs7_export</h4>
<span id="gnutls_005fpkcs7_005fexport"></span><dl>
<dt id="index-gnutls_005fpkcs7_005fexport">Function: <em>int</em> <strong>gnutls_pkcs7_export</strong> <em>(gnutls_pkcs7_t <var>pkcs7</var>, gnutls_x509_crt_fmt_t <var>format</var>, void * <var>output_data</var>, size_t * <var>output_data_size</var>)</em></dt>
<dd><p><var>pkcs7</var>: The pkcs7 type
</p>
<p><var>format</var>: the format of output params. One of PEM or DER.
</p>
<p><var>output_data</var>: will contain a structure PEM or DER encoded
</p>
<p><var>output_data_size</var>: holds the size of output_data (and will be
replaced by the actual size of parameters)
</p>
<p>This function will export the pkcs7 structure to DER or PEM format.
</p>
<p>If the buffer provided is not long enough to hold the output, then
* <code>output_data_size</code> is updated and <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> 
will be returned.
</p>
<p>If the structure is PEM encoded, it will have a header
of &quot;BEGIN PKCS7&quot;.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fpkcs7_005fexport2-1"></span><h4 class="subheading">gnutls_pkcs7_export2</h4>
<span id="gnutls_005fpkcs7_005fexport2"></span><dl>
<dt id="index-gnutls_005fpkcs7_005fexport2">Function: <em>int</em> <strong>gnutls_pkcs7_export2</strong> <em>(gnutls_pkcs7_t <var>pkcs7</var>, gnutls_x509_crt_fmt_t <var>format</var>, gnutls_datum_t * <var>out</var>)</em></dt>
<dd><p><var>pkcs7</var>: The pkcs7 type
</p>
<p><var>format</var>: the format of output params. One of PEM or DER.
</p>
<p><var>out</var>: will contain a structure PEM or DER encoded
</p>
<p>This function will export the pkcs7 structure to DER or PEM format.
</p>
<p>The output buffer is allocated using <code>gnutls_malloc()</code> .
</p>
<p>If the structure is PEM encoded, it will have a header
of &quot;BEGIN PKCS7&quot;.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.1.3
</p></dd></dl>

<span id="gnutls_005fpkcs7_005fget_005fattr-1"></span><h4 class="subheading">gnutls_pkcs7_get_attr</h4>
<span id="gnutls_005fpkcs7_005fget_005fattr"></span><dl>
<dt id="index-gnutls_005fpkcs7_005fget_005fattr">Function: <em>int</em> <strong>gnutls_pkcs7_get_attr</strong> <em>(gnutls_pkcs7_attrs_t <var>list</var>, unsigned <var>idx</var>, char ** <var>oid</var>, gnutls_datum_t * <var>data</var>, unsigned <var>flags</var>)</em></dt>
<dd><p><var>list</var>: A list of existing attributes or <code>NULL</code>  for the first one
</p>
<p><var>idx</var>: the index of the attribute to get
</p>
<p><var>oid</var>: the OID of the attribute (read-only)
</p>
<p><var>data</var>: the raw data of the attribute
</p>
<p><var>flags</var>: zero or <code>GNUTLS_PKCS7_ATTR_ENCODE_OCTET_STRING</code> 
</p>
<p>This function will get a PKCS <code>7</code>  attribute from the provided list.
The OID is a constant string, but data will be allocated and must be
deinitialized by the caller.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value. <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  is returned
if there are no data in the current index.
</p>
<p><strong>Since:</strong> 3.4.2
</p></dd></dl>

<span id="gnutls_005fpkcs7_005fget_005fcrl_005fcount-1"></span><h4 class="subheading">gnutls_pkcs7_get_crl_count</h4>
<span id="gnutls_005fpkcs7_005fget_005fcrl_005fcount"></span><dl>
<dt id="index-gnutls_005fpkcs7_005fget_005fcrl_005fcount">Function: <em>int</em> <strong>gnutls_pkcs7_get_crl_count</strong> <em>(gnutls_pkcs7_t <var>pkcs7</var>)</em></dt>
<dd><p><var>pkcs7</var>: The pkcs7 type
</p>
<p>This function will return the number of certificates in the PKCS7
or RFC2630 crl set.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fpkcs7_005fget_005fcrl_005fraw-1"></span><h4 class="subheading">gnutls_pkcs7_get_crl_raw</h4>
<span id="gnutls_005fpkcs7_005fget_005fcrl_005fraw"></span><dl>
<dt id="index-gnutls_005fpkcs7_005fget_005fcrl_005fraw">Function: <em>int</em> <strong>gnutls_pkcs7_get_crl_raw</strong> <em>(gnutls_pkcs7_t <var>pkcs7</var>, unsigned <var>indx</var>, void * <var>crl</var>, size_t * <var>crl_size</var>)</em></dt>
<dd><p><var>pkcs7</var>: The pkcs7 type
</p>
<p><var>indx</var>: contains the index of the crl to extract
</p>
<p><var>crl</var>: the contents of the crl will be copied there (may be null)
</p>
<p><var>crl_size</var>: should hold the size of the crl
</p>
<p>This function will return a crl of the PKCS7 or RFC2630 crl set.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.  If the provided buffer is not long enough,
then  <code>crl_size</code> is updated and <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  is
returned.  After the last crl has been read
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  will be returned.
</p></dd></dl>

<span id="gnutls_005fpkcs7_005fget_005fcrl_005fraw2-1"></span><h4 class="subheading">gnutls_pkcs7_get_crl_raw2</h4>
<span id="gnutls_005fpkcs7_005fget_005fcrl_005fraw2"></span><dl>
<dt id="index-gnutls_005fpkcs7_005fget_005fcrl_005fraw2">Function: <em>int</em> <strong>gnutls_pkcs7_get_crl_raw2</strong> <em>(gnutls_pkcs7_t <var>pkcs7</var>, unsigned <var>indx</var>, gnutls_datum_t * <var>crl</var>)</em></dt>
<dd><p><var>pkcs7</var>: The pkcs7 type
</p>
<p><var>indx</var>: contains the index of the crl to extract
</p>
<p><var>crl</var>: will contain the contents of the CRL in an allocated buffer
</p>
<p>This function will return a DER encoded CRL of the PKCS7 or RFC2630 crl set.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.  After the last crl has been read
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  will be returned.
</p>
<p><strong>Since:</strong> 3.4.2
</p></dd></dl>

<span id="gnutls_005fpkcs7_005fget_005fcrt_005fcount-1"></span><h4 class="subheading">gnutls_pkcs7_get_crt_count</h4>
<span id="gnutls_005fpkcs7_005fget_005fcrt_005fcount"></span><dl>
<dt id="index-gnutls_005fpkcs7_005fget_005fcrt_005fcount">Function: <em>int</em> <strong>gnutls_pkcs7_get_crt_count</strong> <em>(gnutls_pkcs7_t <var>pkcs7</var>)</em></dt>
<dd><p><var>pkcs7</var>: should contain a <code>gnutls_pkcs7_t</code>  type
</p>
<p>This function will return the number of certificates in the PKCS7
or RFC2630 certificate set.
</p>
<p><strong>Returns:</strong> On success, a positive number is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fpkcs7_005fget_005fcrt_005fraw-1"></span><h4 class="subheading">gnutls_pkcs7_get_crt_raw</h4>
<span id="gnutls_005fpkcs7_005fget_005fcrt_005fraw"></span><dl>
<dt id="index-gnutls_005fpkcs7_005fget_005fcrt_005fraw">Function: <em>int</em> <strong>gnutls_pkcs7_get_crt_raw</strong> <em>(gnutls_pkcs7_t <var>pkcs7</var>, unsigned <var>indx</var>, void * <var>certificate</var>, size_t * <var>certificate_size</var>)</em></dt>
<dd><p><var>pkcs7</var>: should contain a gnutls_pkcs7_t type
</p>
<p><var>indx</var>: contains the index of the certificate to extract
</p>
<p><var>certificate</var>: the contents of the certificate will be copied
there (may be null)
</p>
<p><var>certificate_size</var>: should hold the size of the certificate
</p>
<p>This function will return a certificate of the PKCS7 or RFC2630
certificate set.
</p>
<p>After the last certificate has been read
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  will be returned.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.  If the provided buffer is not long enough,
then  <code>certificate_size</code> is updated and
<code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  is returned.
</p></dd></dl>

<span id="gnutls_005fpkcs7_005fget_005fcrt_005fraw2-1"></span><h4 class="subheading">gnutls_pkcs7_get_crt_raw2</h4>
<span id="gnutls_005fpkcs7_005fget_005fcrt_005fraw2"></span><dl>
<dt id="index-gnutls_005fpkcs7_005fget_005fcrt_005fraw2">Function: <em>int</em> <strong>gnutls_pkcs7_get_crt_raw2</strong> <em>(gnutls_pkcs7_t <var>pkcs7</var>, unsigned <var>indx</var>, gnutls_datum_t * <var>cert</var>)</em></dt>
<dd><p><var>pkcs7</var>: should contain a gnutls_pkcs7_t type
</p>
<p><var>indx</var>: contains the index of the certificate to extract
</p>
<p><var>cert</var>: will hold the contents of the certificate; must be deallocated with <code>gnutls_free()</code> 
</p>
<p>This function will return a certificate of the PKCS7 or RFC2630
certificate set.
</p>
<p>After the last certificate has been read
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  will be returned.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.  If the provided buffer is not long enough,
then  <code>certificate_size</code> is updated and
<code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  is returned.
</p>
<p><strong>Since:</strong> 3.4.2
</p></dd></dl>

<span id="gnutls_005fpkcs7_005fget_005fembedded_005fdata-1"></span><h4 class="subheading">gnutls_pkcs7_get_embedded_data</h4>
<span id="gnutls_005fpkcs7_005fget_005fembedded_005fdata"></span><dl>
<dt id="index-gnutls_005fpkcs7_005fget_005fembedded_005fdata">Function: <em>int</em> <strong>gnutls_pkcs7_get_embedded_data</strong> <em>(gnutls_pkcs7_t <var>pkcs7</var>, unsigned <var>flags</var>, gnutls_datum_t * <var>data</var>)</em></dt>
<dd><p><var>pkcs7</var>: should contain a gnutls_pkcs7_t type
</p>
<p><var>flags</var>: must be zero or <code>GNUTLS_PKCS7_EDATA_GET_RAW</code> 
</p>
<p><var>data</var>: will hold the embedded data in the provided structure
</p>
<p>This function will return the data embedded in the signature of
the PKCS7 structure. If no data are available then
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  will be returned.
</p>
<p>The returned data must be de-allocated using <code>gnutls_free()</code> .
</p>
<p>Note, that this function returns the exact same data that are
authenticated. If the <code>GNUTLS_PKCS7_EDATA_GET_RAW</code>  flag is provided,
the returned data will be including the wrapping tag/value as
they are encoded in the structure.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.4.8
</p></dd></dl>

<span id="gnutls_005fpkcs7_005fget_005fembedded_005fdata_005foid-1"></span><h4 class="subheading">gnutls_pkcs7_get_embedded_data_oid</h4>
<span id="gnutls_005fpkcs7_005fget_005fembedded_005fdata_005foid"></span><dl>
<dt id="index-gnutls_005fpkcs7_005fget_005fembedded_005fdata_005foid">Function: <em>const char *</em> <strong>gnutls_pkcs7_get_embedded_data_oid</strong> <em>(gnutls_pkcs7_t <var>pkcs7</var>)</em></dt>
<dd><p><var>pkcs7</var>: should contain a gnutls_pkcs7_t type
</p>
<p>This function will return the OID of the data embedded in the signature of
the PKCS7 structure. If no data are available then <code>NULL</code>  will be
returned. The returned value will be valid during the lifetime
of the  <code>pkcs7</code> structure.
</p>
<p><strong>Returns:</strong> On success, a pointer to an OID string, <code>NULL</code>  on error.
</p>
<p><strong>Since:</strong> 3.5.5
</p></dd></dl>

<span id="gnutls_005fpkcs7_005fget_005fsignature_005fcount-1"></span><h4 class="subheading">gnutls_pkcs7_get_signature_count</h4>
<span id="gnutls_005fpkcs7_005fget_005fsignature_005fcount"></span><dl>
<dt id="index-gnutls_005fpkcs7_005fget_005fsignature_005fcount">Function: <em>int</em> <strong>gnutls_pkcs7_get_signature_count</strong> <em>(gnutls_pkcs7_t <var>pkcs7</var>)</em></dt>
<dd><p><var>pkcs7</var>: should contain a <code>gnutls_pkcs7_t</code>  type
</p>
<p>This function will return the number of signatures in the PKCS7
structure.
</p>
<p><strong>Returns:</strong> On success, a positive number is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.4.3
</p></dd></dl>

<span id="gnutls_005fpkcs7_005fget_005fsignature_005finfo-1"></span><h4 class="subheading">gnutls_pkcs7_get_signature_info</h4>
<span id="gnutls_005fpkcs7_005fget_005fsignature_005finfo"></span><dl>
<dt id="index-gnutls_005fpkcs7_005fget_005fsignature_005finfo">Function: <em>int</em> <strong>gnutls_pkcs7_get_signature_info</strong> <em>(gnutls_pkcs7_t <var>pkcs7</var>, unsigned <var>idx</var>, gnutls_pkcs7_signature_info_st * <var>info</var>)</em></dt>
<dd><p><var>pkcs7</var>: should contain a <code>gnutls_pkcs7_t</code>  type
</p>
<p><var>idx</var>: the index of the signature info to check
</p>
<p><var>info</var>: will contain the output signature
</p>
<p>This function will return information about the signature identified
by idx in the provided PKCS <code>7</code>  structure. The information should be
deinitialized using <code>gnutls_pkcs7_signature_info_deinit()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.4.2
</p></dd></dl>

<span id="gnutls_005fpkcs7_005fimport-1"></span><h4 class="subheading">gnutls_pkcs7_import</h4>
<span id="gnutls_005fpkcs7_005fimport"></span><dl>
<dt id="index-gnutls_005fpkcs7_005fimport">Function: <em>int</em> <strong>gnutls_pkcs7_import</strong> <em>(gnutls_pkcs7_t <var>pkcs7</var>, const gnutls_datum_t * <var>data</var>, gnutls_x509_crt_fmt_t <var>format</var>)</em></dt>
<dd><p><var>pkcs7</var>: The data to store the parsed PKCS7.
</p>
<p><var>data</var>: The DER or PEM encoded PKCS7.
</p>
<p><var>format</var>: One of DER or PEM
</p>
<p>This function will convert the given DER or PEM encoded PKCS7 to
the native <code>gnutls_pkcs7_t</code>  format.  The output will be stored in
 <code>pkcs7</code> .
</p>
<p>If the PKCS7 is PEM encoded it should have a header of &quot;PKCS7&quot;.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fpkcs7_005finit-1"></span><h4 class="subheading">gnutls_pkcs7_init</h4>
<span id="gnutls_005fpkcs7_005finit"></span><dl>
<dt id="index-gnutls_005fpkcs7_005finit">Function: <em>int</em> <strong>gnutls_pkcs7_init</strong> <em>(gnutls_pkcs7_t * <var>pkcs7</var>)</em></dt>
<dd><p><var>pkcs7</var>: A pointer to the type to be initialized
</p>
<p>This function will initialize a PKCS7 structure. PKCS7 structures
usually contain lists of X.509 Certificates and X.509 Certificate
revocation lists.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fpkcs7_005fprint-1"></span><h4 class="subheading">gnutls_pkcs7_print</h4>
<span id="gnutls_005fpkcs7_005fprint"></span><dl>
<dt id="index-gnutls_005fpkcs7_005fprint">Function: <em>int</em> <strong>gnutls_pkcs7_print</strong> <em>(gnutls_pkcs7_t <var>pkcs7</var>, gnutls_certificate_print_formats_t <var>format</var>, gnutls_datum_t * <var>out</var>)</em></dt>
<dd><p><var>pkcs7</var>: The PKCS7 struct to be printed
</p>
<p><var>format</var>: Indicate the format to use
</p>
<p><var>out</var>: Newly allocated datum with null terminated string.
</p>
<p>This function will pretty print a signed PKCS <code>7</code>  structure, suitable for
display to a human.
</p>
<p>Currently the supported formats are <code>GNUTLS_CRT_PRINT_FULL</code>  and
<code>GNUTLS_CRT_PRINT_COMPACT</code> .
</p>
<p>The output  <code>out</code> needs to be deallocated using <code>gnutls_free()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fpkcs7_005fset_005fcrl-1"></span><h4 class="subheading">gnutls_pkcs7_set_crl</h4>
<span id="gnutls_005fpkcs7_005fset_005fcrl"></span><dl>
<dt id="index-gnutls_005fpkcs7_005fset_005fcrl">Function: <em>int</em> <strong>gnutls_pkcs7_set_crl</strong> <em>(gnutls_pkcs7_t <var>pkcs7</var>, gnutls_x509_crl_t <var>crl</var>)</em></dt>
<dd><p><var>pkcs7</var>: The pkcs7 type
</p>
<p><var>crl</var>: the DER encoded crl to be added
</p>
<p>This function will add a parsed CRL to the PKCS7 or RFC2630 crl
set.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fpkcs7_005fset_005fcrl_005fraw-1"></span><h4 class="subheading">gnutls_pkcs7_set_crl_raw</h4>
<span id="gnutls_005fpkcs7_005fset_005fcrl_005fraw"></span><dl>
<dt id="index-gnutls_005fpkcs7_005fset_005fcrl_005fraw">Function: <em>int</em> <strong>gnutls_pkcs7_set_crl_raw</strong> <em>(gnutls_pkcs7_t <var>pkcs7</var>, const gnutls_datum_t * <var>crl</var>)</em></dt>
<dd><p><var>pkcs7</var>: The pkcs7 type
</p>
<p><var>crl</var>: the DER encoded crl to be added
</p>
<p>This function will add a crl to the PKCS7 or RFC2630 crl set.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fpkcs7_005fset_005fcrt-1"></span><h4 class="subheading">gnutls_pkcs7_set_crt</h4>
<span id="gnutls_005fpkcs7_005fset_005fcrt"></span><dl>
<dt id="index-gnutls_005fpkcs7_005fset_005fcrt">Function: <em>int</em> <strong>gnutls_pkcs7_set_crt</strong> <em>(gnutls_pkcs7_t <var>pkcs7</var>, gnutls_x509_crt_t <var>crt</var>)</em></dt>
<dd><p><var>pkcs7</var>: The pkcs7 type
</p>
<p><var>crt</var>: the certificate to be copied.
</p>
<p>This function will add a parsed certificate to the PKCS7 or
RFC2630 certificate set.  This is a wrapper function over
<code>gnutls_pkcs7_set_crt_raw()</code>  .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fpkcs7_005fset_005fcrt_005fraw-1"></span><h4 class="subheading">gnutls_pkcs7_set_crt_raw</h4>
<span id="gnutls_005fpkcs7_005fset_005fcrt_005fraw"></span><dl>
<dt id="index-gnutls_005fpkcs7_005fset_005fcrt_005fraw">Function: <em>int</em> <strong>gnutls_pkcs7_set_crt_raw</strong> <em>(gnutls_pkcs7_t <var>pkcs7</var>, const gnutls_datum_t * <var>crt</var>)</em></dt>
<dd><p><var>pkcs7</var>: The pkcs7 type
</p>
<p><var>crt</var>: the DER encoded certificate to be added
</p>
<p>This function will add a certificate to the PKCS7 or RFC2630
certificate set.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fpkcs7_005fsign-1"></span><h4 class="subheading">gnutls_pkcs7_sign</h4>
<span id="gnutls_005fpkcs7_005fsign"></span><dl>
<dt id="index-gnutls_005fpkcs7_005fsign-1">Function: <em>int</em> <strong>gnutls_pkcs7_sign</strong> <em>(gnutls_pkcs7_t <var>pkcs7</var>, gnutls_x509_crt_t <var>signer</var>, gnutls_privkey_t <var>signer_key</var>, const gnutls_datum_t * <var>data</var>, gnutls_pkcs7_attrs_t <var>signed_attrs</var>, gnutls_pkcs7_attrs_t <var>unsigned_attrs</var>, gnutls_digest_algorithm_t <var>dig</var>, unsigned <var>flags</var>)</em></dt>
<dd><p><var>pkcs7</var>: should contain a <code>gnutls_pkcs7_t</code>  type
</p>
<p><var>signer</var>: the certificate to sign the structure
</p>
<p><var>signer_key</var>: the key to sign the structure
</p>
<p><var>data</var>: The data to be signed or <code>NULL</code>  if the data are already embedded
</p>
<p><var>signed_attrs</var>: Any additional attributes to be included in the signed ones (or <code>NULL</code> )
</p>
<p><var>unsigned_attrs</var>: Any additional attributes to be included in the unsigned ones (or <code>NULL</code> )
</p>
<p><var>dig</var>: The digest algorithm to use for signing
</p>
<p><var>flags</var>: Should be zero or one of <code>GNUTLS_PKCS7</code>  flags
</p>
<p>This function will add a signature in the provided PKCS <code>7</code>  structure
for the provided data. Multiple signatures can be made with different
signers.
</p>
<p>The available flags are:
<code>GNUTLS_PKCS7_EMBED_DATA</code> , <code>GNUTLS_PKCS7_INCLUDE_TIME</code> , <code>GNUTLS_PKCS7_INCLUDE_CERT</code> ,
and <code>GNUTLS_PKCS7_WRITE_SPKI</code> . They are explained in the <code>gnutls_pkcs7_sign_flags</code> 
definition.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.4.2
</p></dd></dl>

<span id="gnutls_005fpkcs7_005fsignature_005finfo_005fdeinit-1"></span><h4 class="subheading">gnutls_pkcs7_signature_info_deinit</h4>
<span id="gnutls_005fpkcs7_005fsignature_005finfo_005fdeinit"></span><dl>
<dt id="index-gnutls_005fpkcs7_005fsignature_005finfo_005fdeinit">Function: <em>void</em> <strong>gnutls_pkcs7_signature_info_deinit</strong> <em>(gnutls_pkcs7_signature_info_st * <var>info</var>)</em></dt>
<dd><p><var>info</var>: should point to a <code>gnutls_pkcs7_signature_info_st</code>  structure
</p>
<p>This function will deinitialize any allocated value in the
provided <code>gnutls_pkcs7_signature_info_st</code> .
</p>
<p><strong>Since:</strong> 3.4.2
</p></dd></dl>

<span id="gnutls_005fpkcs7_005fverify-1"></span><h4 class="subheading">gnutls_pkcs7_verify</h4>
<span id="gnutls_005fpkcs7_005fverify"></span><dl>
<dt id="index-gnutls_005fpkcs7_005fverify">Function: <em>int</em> <strong>gnutls_pkcs7_verify</strong> <em>(gnutls_pkcs7_t <var>pkcs7</var>, gnutls_x509_trust_list_t <var>tl</var>, gnutls_typed_vdata_st * <var>vdata</var>, unsigned int <var>vdata_size</var>, unsigned <var>idx</var>, const gnutls_datum_t * <var>data</var>, unsigned <var>flags</var>)</em></dt>
<dd><p><var>pkcs7</var>: should contain a <code>gnutls_pkcs7_t</code>  type
</p>
<p><var>tl</var>: A list of trusted certificates
</p>
<p><var>vdata</var>: an array of typed data
</p>
<p><var>vdata_size</var>: the number of data elements
</p>
<p><var>idx</var>: the index of the signature info to check
</p>
<p><var>data</var>: The data to be verified or <code>NULL</code> 
</p>
<p><var>flags</var>: Zero or an OR list of <code>gnutls_certificate_verify_flags</code> 
</p>
<p>This function will verify the provided data against the signature
present in the SignedData of the PKCS <code>7</code>  structure. If the data
provided are NULL then the data in the encapsulatedContent field
will be used instead.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value. A verification error results to a
<code>GNUTLS_E_PK_SIG_VERIFY_FAILED</code>  and the lack of encapsulated data
to verify to a <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> .
</p>
<p><strong>Since:</strong> 3.4.2
</p></dd></dl>

<span id="gnutls_005fpkcs7_005fverify_005fdirect-1"></span><h4 class="subheading">gnutls_pkcs7_verify_direct</h4>
<span id="gnutls_005fpkcs7_005fverify_005fdirect"></span><dl>
<dt id="index-gnutls_005fpkcs7_005fverify_005fdirect">Function: <em>int</em> <strong>gnutls_pkcs7_verify_direct</strong> <em>(gnutls_pkcs7_t <var>pkcs7</var>, gnutls_x509_crt_t <var>signer</var>, unsigned <var>idx</var>, const gnutls_datum_t * <var>data</var>, unsigned <var>flags</var>)</em></dt>
<dd><p><var>pkcs7</var>: should contain a <code>gnutls_pkcs7_t</code>  type
</p>
<p><var>signer</var>: the certificate believed to have signed the structure
</p>
<p><var>idx</var>: the index of the signature info to check
</p>
<p><var>data</var>: The data to be verified or <code>NULL</code> 
</p>
<p><var>flags</var>: Zero or an OR list of <code>gnutls_certificate_verify_flags</code> 
</p>
<p>This function will verify the provided data against the signature
present in the SignedData of the PKCS <code>7</code>  structure. If the data
provided are NULL then the data in the encapsulatedContent field
will be used instead.
</p>
<p>Note that, unlike <code>gnutls_pkcs7_verify()</code>  this function does not
verify the key purpose of the signer. It is expected for the caller
to verify the intended purpose of the <code>signer</code>  -e.g., via <code>gnutls_x509_crt_get_key_purpose_oid()</code> ,
or <code>gnutls_x509_crt_check_key_purpose()</code> .
</p>
<p>Note also, that since GnuTLS 3.5.6 this function introduces checks in the
end certificate ( <code>signer</code> ), including time checks and key usage checks.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value. A verification error results to a
<code>GNUTLS_E_PK_SIG_VERIFY_FAILED</code>  and the lack of encapsulated data
to verify to a <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> .
</p>
<p><strong>Since:</strong> 3.4.2
</p></dd></dl>


<hr>
<span id="OCSP-API"></span><div class="header">
<p>
Next: <a href="#PKCS-12-API" accesskey="n" rel="next">PKCS 12 API</a>, Previous: <a href="#PKCS-7-API" accesskey="p" rel="prev">PKCS 7 API</a>, Up: <a href="#API-reference" accesskey="u" rel="up">API reference</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="OCSP-API-1"></span><h3 class="section">E.5 <acronym>OCSP</acronym> API</h3>
<span id="index-OCSP-Functions"></span>

<p>The following functions are for <acronym>OCSP</acronym> certificate status
checking.  Their prototypes lie in <samp>gnutls/ocsp.h</samp>.
</p>

<span id="gnutls_005focsp_005freq_005fadd_005fcert-1"></span><h4 class="subheading">gnutls_ocsp_req_add_cert</h4>
<span id="gnutls_005focsp_005freq_005fadd_005fcert"></span><dl>
<dt id="index-gnutls_005focsp_005freq_005fadd_005fcert">Function: <em>int</em> <strong>gnutls_ocsp_req_add_cert</strong> <em>(gnutls_ocsp_req_t <var>req</var>, gnutls_digest_algorithm_t <var>digest</var>, gnutls_x509_crt_t <var>issuer</var>, gnutls_x509_crt_t <var>cert</var>)</em></dt>
<dd><p><var>req</var>: should contain a <code>gnutls_ocsp_req_t</code>  type
</p>
<p><var>digest</var>: hash algorithm, a <code>gnutls_digest_algorithm_t</code>  value
</p>
<p><var>issuer</var>: issuer of  <code>subject</code> certificate
</p>
<p><var>cert</var>: certificate to request status for
</p>
<p>This function will add another request to the OCSP request for a
particular certificate.  The issuer name hash, issuer key hash, and
serial number fields is populated as follows.  The issuer name and
the serial number is taken from  <code>cert</code> .  The issuer key is taken
from  <code>issuer</code> .  The hashed values will be hashed using the  <code>digest</code> algorithm, normally <code>GNUTLS_DIG_SHA1</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error code is returned.
</p></dd></dl>

<span id="gnutls_005focsp_005freq_005fadd_005fcert_005fid-1"></span><h4 class="subheading">gnutls_ocsp_req_add_cert_id</h4>
<span id="gnutls_005focsp_005freq_005fadd_005fcert_005fid"></span><dl>
<dt id="index-gnutls_005focsp_005freq_005fadd_005fcert_005fid">Function: <em>int</em> <strong>gnutls_ocsp_req_add_cert_id</strong> <em>(gnutls_ocsp_req_t <var>req</var>, gnutls_digest_algorithm_t <var>digest</var>, const gnutls_datum_t * <var>issuer_name_hash</var>, const gnutls_datum_t * <var>issuer_key_hash</var>, const gnutls_datum_t * <var>serial_number</var>)</em></dt>
<dd><p><var>req</var>: should contain a <code>gnutls_ocsp_req_t</code>  type
</p>
<p><var>digest</var>: hash algorithm, a <code>gnutls_digest_algorithm_t</code>  value
</p>
<p><var>issuer_name_hash</var>: hash of issuer&rsquo;s DN
</p>
<p><var>issuer_key_hash</var>: hash of issuer&rsquo;s public key
</p>
<p><var>serial_number</var>: serial number of certificate to check
</p>
<p>This function will add another request to the OCSP request for a
particular certificate having the issuer name hash of
 <code>issuer_name_hash</code> and issuer key hash of  <code>issuer_key_hash</code> (both
hashed using  <code>digest</code> ) and serial number  <code>serial_number</code> .
</p>
<p>The information needed corresponds to the CertID structure:
</p>
<p>&lt;informalexample&gt;&lt;programlisting&gt;
CertID	  ::=     SEQUENCE {
hashAlgorithm       AlgorithmIdentifier,
issuerNameHash      OCTET STRING, &ndash; Hash of Issuer&rsquo;s DN
issuerKeyHash       OCTET STRING, &ndash; Hash of Issuers public key
serialNumber	CertificateSerialNumber }
&lt;/programlisting&gt;&lt;/informalexample&gt;
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error code is returned.
</p></dd></dl>

<span id="gnutls_005focsp_005freq_005fdeinit-1"></span><h4 class="subheading">gnutls_ocsp_req_deinit</h4>
<span id="gnutls_005focsp_005freq_005fdeinit"></span><dl>
<dt id="index-gnutls_005focsp_005freq_005fdeinit">Function: <em>void</em> <strong>gnutls_ocsp_req_deinit</strong> <em>(gnutls_ocsp_req_t <var>req</var>)</em></dt>
<dd><p><var>req</var>: The data to be deinitialized
</p>
<p>This function will deinitialize a OCSP request structure.
</p></dd></dl>

<span id="gnutls_005focsp_005freq_005fexport-1"></span><h4 class="subheading">gnutls_ocsp_req_export</h4>
<span id="gnutls_005focsp_005freq_005fexport"></span><dl>
<dt id="index-gnutls_005focsp_005freq_005fexport">Function: <em>int</em> <strong>gnutls_ocsp_req_export</strong> <em>(gnutls_ocsp_req_t <var>req</var>, gnutls_datum_t * <var>data</var>)</em></dt>
<dd><p><var>req</var>: Holds the OCSP request
</p>
<p><var>data</var>: newly allocate buffer holding DER encoded OCSP request
</p>
<p>This function will export the OCSP request to DER format.
</p>
<p><strong>Returns:</strong> In case of failure a negative error code will be
returned, and 0 on success.
</p></dd></dl>

<span id="gnutls_005focsp_005freq_005fget_005fcert_005fid-1"></span><h4 class="subheading">gnutls_ocsp_req_get_cert_id</h4>
<span id="gnutls_005focsp_005freq_005fget_005fcert_005fid"></span><dl>
<dt id="index-gnutls_005focsp_005freq_005fget_005fcert_005fid">Function: <em>int</em> <strong>gnutls_ocsp_req_get_cert_id</strong> <em>(gnutls_ocsp_req_t <var>req</var>, unsigned <var>indx</var>, gnutls_digest_algorithm_t * <var>digest</var>, gnutls_datum_t * <var>issuer_name_hash</var>, gnutls_datum_t * <var>issuer_key_hash</var>, gnutls_datum_t * <var>serial_number</var>)</em></dt>
<dd><p><var>req</var>: should contain a <code>gnutls_ocsp_req_t</code>  type
</p>
<p><var>indx</var>: Specifies which extension OID to get. Use (0) to get the first one.
</p>
<p><var>digest</var>: output variable with <code>gnutls_digest_algorithm_t</code>  hash algorithm
</p>
<p><var>issuer_name_hash</var>: output buffer with hash of issuer&rsquo;s DN
</p>
<p><var>issuer_key_hash</var>: output buffer with hash of issuer&rsquo;s public key
</p>
<p><var>serial_number</var>: output buffer with serial number of certificate to check
</p>
<p>This function will return the certificate information of the
 <code>indx</code> &rsquo;ed request in the OCSP request.  The information returned
corresponds to the CertID structure:
</p>
<p>&lt;informalexample&gt;&lt;programlisting&gt;
CertID	  ::=     SEQUENCE {
hashAlgorithm       AlgorithmIdentifier,
issuerNameHash      OCTET STRING, &ndash; Hash of Issuer&rsquo;s DN
issuerKeyHash       OCTET STRING, &ndash; Hash of Issuers public key
serialNumber	CertificateSerialNumber }
&lt;/programlisting&gt;&lt;/informalexample&gt;
</p>
<p>Each of the pointers to output variables may be NULL to indicate
that the caller is not interested in that value.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error code is returned.  If you have reached the last
CertID available <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  will be
returned.
</p></dd></dl>

<span id="gnutls_005focsp_005freq_005fget_005fextension-1"></span><h4 class="subheading">gnutls_ocsp_req_get_extension</h4>
<span id="gnutls_005focsp_005freq_005fget_005fextension"></span><dl>
<dt id="index-gnutls_005focsp_005freq_005fget_005fextension">Function: <em>int</em> <strong>gnutls_ocsp_req_get_extension</strong> <em>(gnutls_ocsp_req_t <var>req</var>, unsigned <var>indx</var>, gnutls_datum_t * <var>oid</var>, unsigned int * <var>critical</var>, gnutls_datum_t * <var>data</var>)</em></dt>
<dd><p><var>req</var>: should contain a <code>gnutls_ocsp_req_t</code>  type
</p>
<p><var>indx</var>: Specifies which extension OID to get. Use (0) to get the first one.
</p>
<p><var>oid</var>: will hold newly allocated buffer with OID of extension, may be NULL
</p>
<p><var>critical</var>: output variable with critical flag, may be NULL.
</p>
<p><var>data</var>: will hold newly allocated buffer with extension data, may be NULL
</p>
<p>This function will return all information about the requested
extension in the OCSP request.  The information returned is the
OID, the critical flag, and the data itself.  The extension OID
will be stored as a string.  Any of  <code>oid</code> ,  <code>critical</code> , and  <code>data</code> may
be NULL which means that the caller is not interested in getting
that information back.
</p>
<p>The caller needs to deallocate memory by calling <code>gnutls_free()</code>  on
 <code>oid</code> -&gt;data and  <code>data</code> -&gt;data.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error code is returned.  If you have reached the last
extension available <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  will
be returned.
</p></dd></dl>

<span id="gnutls_005focsp_005freq_005fget_005fnonce-1"></span><h4 class="subheading">gnutls_ocsp_req_get_nonce</h4>
<span id="gnutls_005focsp_005freq_005fget_005fnonce"></span><dl>
<dt id="index-gnutls_005focsp_005freq_005fget_005fnonce">Function: <em>int</em> <strong>gnutls_ocsp_req_get_nonce</strong> <em>(gnutls_ocsp_req_t <var>req</var>, unsigned int * <var>critical</var>, gnutls_datum_t * <var>nonce</var>)</em></dt>
<dd><p><var>req</var>: should contain a <code>gnutls_ocsp_req_t</code>  type
</p>
<p><var>critical</var>: whether nonce extension is marked critical, or NULL
</p>
<p><var>nonce</var>: will hold newly allocated buffer with nonce data
</p>
<p>This function will return the OCSP request nonce extension data.
</p>
<p>The caller needs to deallocate memory by calling <code>gnutls_free()</code>  on
 <code>nonce</code> -&gt;data.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error code is returned.
</p></dd></dl>

<span id="gnutls_005focsp_005freq_005fget_005fversion-1"></span><h4 class="subheading">gnutls_ocsp_req_get_version</h4>
<span id="gnutls_005focsp_005freq_005fget_005fversion"></span><dl>
<dt id="index-gnutls_005focsp_005freq_005fget_005fversion">Function: <em>int</em> <strong>gnutls_ocsp_req_get_version</strong> <em>(gnutls_ocsp_req_t <var>req</var>)</em></dt>
<dd><p><var>req</var>: should contain a <code>gnutls_ocsp_req_t</code>  type
</p>
<p>This function will return the version of the OCSP request.
Typically this is always 1 indicating version 1.
</p>
<p><strong>Returns:</strong> version of OCSP request, or a negative error code on error.
</p></dd></dl>

<span id="gnutls_005focsp_005freq_005fimport-1"></span><h4 class="subheading">gnutls_ocsp_req_import</h4>
<span id="gnutls_005focsp_005freq_005fimport"></span><dl>
<dt id="index-gnutls_005focsp_005freq_005fimport">Function: <em>int</em> <strong>gnutls_ocsp_req_import</strong> <em>(gnutls_ocsp_req_t <var>req</var>, const gnutls_datum_t * <var>data</var>)</em></dt>
<dd><p><var>req</var>: The data to store the parsed request.
</p>
<p><var>data</var>: DER encoded OCSP request.
</p>
<p>This function will convert the given DER encoded OCSP request to
the native <code>gnutls_ocsp_req_t</code>  format. The output will be stored in
 <code>req</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005focsp_005freq_005finit-1"></span><h4 class="subheading">gnutls_ocsp_req_init</h4>
<span id="gnutls_005focsp_005freq_005finit"></span><dl>
<dt id="index-gnutls_005focsp_005freq_005finit">Function: <em>int</em> <strong>gnutls_ocsp_req_init</strong> <em>(gnutls_ocsp_req_t * <var>req</var>)</em></dt>
<dd><p><var>req</var>: A pointer to the type to be initialized
</p>
<p>This function will initialize an OCSP request structure.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005focsp_005freq_005fprint-1"></span><h4 class="subheading">gnutls_ocsp_req_print</h4>
<span id="gnutls_005focsp_005freq_005fprint"></span><dl>
<dt id="index-gnutls_005focsp_005freq_005fprint">Function: <em>int</em> <strong>gnutls_ocsp_req_print</strong> <em>(gnutls_ocsp_req_t <var>req</var>, gnutls_ocsp_print_formats_t <var>format</var>, gnutls_datum_t * <var>out</var>)</em></dt>
<dd><p><var>req</var>: The data to be printed
</p>
<p><var>format</var>: Indicate the format to use
</p>
<p><var>out</var>: Newly allocated datum with (0) terminated string.
</p>
<p>This function will pretty print a OCSP request, suitable for
display to a human.
</p>
<p>If the format is <code>GNUTLS_OCSP_PRINT_FULL</code>  then all fields of the
request will be output, on multiple lines.
</p>
<p>The output  <code>out</code> -&gt;data needs to be deallocate using <code>gnutls_free()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005focsp_005freq_005frandomize_005fnonce-1"></span><h4 class="subheading">gnutls_ocsp_req_randomize_nonce</h4>
<span id="gnutls_005focsp_005freq_005frandomize_005fnonce"></span><dl>
<dt id="index-gnutls_005focsp_005freq_005frandomize_005fnonce">Function: <em>int</em> <strong>gnutls_ocsp_req_randomize_nonce</strong> <em>(gnutls_ocsp_req_t <var>req</var>)</em></dt>
<dd><p><var>req</var>: should contain a <code>gnutls_ocsp_req_t</code>  type
</p>
<p>This function will add or update an nonce extension to the OCSP
request with a newly generated random value.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error code is returned.
</p></dd></dl>

<span id="gnutls_005focsp_005freq_005fset_005fextension-1"></span><h4 class="subheading">gnutls_ocsp_req_set_extension</h4>
<span id="gnutls_005focsp_005freq_005fset_005fextension"></span><dl>
<dt id="index-gnutls_005focsp_005freq_005fset_005fextension">Function: <em>int</em> <strong>gnutls_ocsp_req_set_extension</strong> <em>(gnutls_ocsp_req_t <var>req</var>, const char * <var>oid</var>, unsigned int <var>critical</var>, const gnutls_datum_t * <var>data</var>)</em></dt>
<dd><p><var>req</var>: should contain a <code>gnutls_ocsp_req_t</code>  type
</p>
<p><var>oid</var>: buffer with OID of extension as a string.
</p>
<p><var>critical</var>: critical flag, normally false.
</p>
<p><var>data</var>: the extension data
</p>
<p>This function will add an extension to the OCSP request.  Calling
this function multiple times for the same OID will overwrite values
from earlier calls.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error code is returned.
</p></dd></dl>

<span id="gnutls_005focsp_005freq_005fset_005fnonce-1"></span><h4 class="subheading">gnutls_ocsp_req_set_nonce</h4>
<span id="gnutls_005focsp_005freq_005fset_005fnonce"></span><dl>
<dt id="index-gnutls_005focsp_005freq_005fset_005fnonce">Function: <em>int</em> <strong>gnutls_ocsp_req_set_nonce</strong> <em>(gnutls_ocsp_req_t <var>req</var>, unsigned int <var>critical</var>, const gnutls_datum_t * <var>nonce</var>)</em></dt>
<dd><p><var>req</var>: should contain a <code>gnutls_ocsp_req_t</code>  type
</p>
<p><var>critical</var>: critical flag, normally false.
</p>
<p><var>nonce</var>: the nonce data
</p>
<p>This function will add an nonce extension to the OCSP request.
Calling this function multiple times will overwrite values from
earlier calls.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error code is returned.
</p></dd></dl>

<span id="gnutls_005focsp_005fresp_005fcheck_005fcrt-1"></span><h4 class="subheading">gnutls_ocsp_resp_check_crt</h4>
<span id="gnutls_005focsp_005fresp_005fcheck_005fcrt"></span><dl>
<dt id="index-gnutls_005focsp_005fresp_005fcheck_005fcrt">Function: <em>int</em> <strong>gnutls_ocsp_resp_check_crt</strong> <em>(gnutls_ocsp_resp_t <var>resp</var>, unsigned int <var>indx</var>, gnutls_x509_crt_t <var>crt</var>)</em></dt>
<dd><p><var>resp</var>: should contain a <code>gnutls_ocsp_resp_t</code>  type
</p>
<p><var>indx</var>: Specifies response number to get. Use (0) to get the first one.
</p>
<p><var>crt</var>: The certificate to check
</p>
<p>This function will check whether the OCSP response
is about the provided certificate.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error code is returned.  
</p>
<p><strong>Since:</strong> 3.1.3
</p></dd></dl>

<span id="gnutls_005focsp_005fresp_005fdeinit-1"></span><h4 class="subheading">gnutls_ocsp_resp_deinit</h4>
<span id="gnutls_005focsp_005fresp_005fdeinit"></span><dl>
<dt id="index-gnutls_005focsp_005fresp_005fdeinit">Function: <em>void</em> <strong>gnutls_ocsp_resp_deinit</strong> <em>(gnutls_ocsp_resp_t <var>resp</var>)</em></dt>
<dd><p><var>resp</var>: The data to be deinitialized
</p>
<p>This function will deinitialize a OCSP response structure.
</p></dd></dl>

<span id="gnutls_005focsp_005fresp_005fexport-1"></span><h4 class="subheading">gnutls_ocsp_resp_export</h4>
<span id="gnutls_005focsp_005fresp_005fexport"></span><dl>
<dt id="index-gnutls_005focsp_005fresp_005fexport">Function: <em>int</em> <strong>gnutls_ocsp_resp_export</strong> <em>(gnutls_ocsp_resp_t <var>resp</var>, gnutls_datum_t * <var>data</var>)</em></dt>
<dd><p><var>resp</var>: Holds the OCSP response
</p>
<p><var>data</var>: newly allocate buffer holding DER encoded OCSP response
</p>
<p>This function will export the OCSP response to DER format.
</p>
<p><strong>Returns:</strong> In case of failure a negative error code will be
returned, and 0 on success.
</p></dd></dl>

<span id="gnutls_005focsp_005fresp_005fexport2-1"></span><h4 class="subheading">gnutls_ocsp_resp_export2</h4>
<span id="gnutls_005focsp_005fresp_005fexport2"></span><dl>
<dt id="index-gnutls_005focsp_005fresp_005fexport2">Function: <em>int</em> <strong>gnutls_ocsp_resp_export2</strong> <em>(gnutls_ocsp_resp_t <var>resp</var>, gnutls_datum_t * <var>data</var>, gnutls_x509_crt_fmt_t <var>fmt</var>)</em></dt>
<dd><p><var>resp</var>: Holds the OCSP response
</p>
<p><var>data</var>: newly allocate buffer holding DER or PEM encoded OCSP response
</p>
<p><var>fmt</var>: DER or PEM
</p>
<p>This function will export the OCSP response to DER or PEM format.
</p>
<p><strong>Returns:</strong> In case of failure a negative error code will be
returned, and 0 on success.
</p>
<p><strong>Since:</strong> 3.6.3
</p></dd></dl>

<span id="gnutls_005focsp_005fresp_005fget_005fcerts-1"></span><h4 class="subheading">gnutls_ocsp_resp_get_certs</h4>
<span id="gnutls_005focsp_005fresp_005fget_005fcerts"></span><dl>
<dt id="index-gnutls_005focsp_005fresp_005fget_005fcerts">Function: <em>int</em> <strong>gnutls_ocsp_resp_get_certs</strong> <em>(gnutls_ocsp_resp_t <var>resp</var>, gnutls_x509_crt_t ** <var>certs</var>, size_t * <var>ncerts</var>)</em></dt>
<dd><p><var>resp</var>: should contain a <code>gnutls_ocsp_resp_t</code>  type
</p>
<p><var>certs</var>: newly allocated array with <code>gnutls_x509_crt_t</code>  certificates
</p>
<p><var>ncerts</var>: output variable with number of allocated certs.
</p>
<p>This function will extract the X.509 certificates found in the
Basic OCSP Response.  The  <code>certs</code> output variable will hold a newly
allocated zero-terminated array with X.509 certificates.
</p>
<p>Every certificate in the array needs to be de-allocated with
<code>gnutls_x509_crt_deinit()</code>  and the array itself must be freed using
<code>gnutls_free()</code> .
</p>
<p>Both the  <code>certs</code> and  <code>ncerts</code> variables may be NULL.  Then the
function will work as normal but will not return the NULL:d
information.  This can be used to get the number of certificates
only, or to just get the certificate array without its size.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005focsp_005fresp_005fget_005fextension-1"></span><h4 class="subheading">gnutls_ocsp_resp_get_extension</h4>
<span id="gnutls_005focsp_005fresp_005fget_005fextension"></span><dl>
<dt id="index-gnutls_005focsp_005fresp_005fget_005fextension">Function: <em>int</em> <strong>gnutls_ocsp_resp_get_extension</strong> <em>(gnutls_ocsp_resp_t <var>resp</var>, unsigned <var>indx</var>, gnutls_datum_t * <var>oid</var>, unsigned int * <var>critical</var>, gnutls_datum_t * <var>data</var>)</em></dt>
<dd><p><var>resp</var>: should contain a <code>gnutls_ocsp_resp_t</code>  type
</p>
<p><var>indx</var>: Specifies which extension OID to get. Use (0) to get the first one.
</p>
<p><var>oid</var>: will hold newly allocated buffer with OID of extension, may be NULL
</p>
<p><var>critical</var>: output variable with critical flag, may be NULL.
</p>
<p><var>data</var>: will hold newly allocated buffer with extension data, may be NULL
</p>
<p>This function will return all information about the requested
extension in the OCSP response.  The information returned is the
OID, the critical flag, and the data itself.  The extension OID
will be stored as a string.  Any of  <code>oid</code> ,  <code>critical</code> , and  <code>data</code> may
be NULL which means that the caller is not interested in getting
that information back.
</p>
<p>The caller needs to deallocate memory by calling <code>gnutls_free()</code>  on
 <code>oid</code> -&gt;data and  <code>data</code> -&gt;data.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error code is returned.  If you have reached the last
extension available <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  will
be returned.
</p></dd></dl>

<span id="gnutls_005focsp_005fresp_005fget_005fnonce-1"></span><h4 class="subheading">gnutls_ocsp_resp_get_nonce</h4>
<span id="gnutls_005focsp_005fresp_005fget_005fnonce"></span><dl>
<dt id="index-gnutls_005focsp_005fresp_005fget_005fnonce">Function: <em>int</em> <strong>gnutls_ocsp_resp_get_nonce</strong> <em>(gnutls_ocsp_resp_t <var>resp</var>, unsigned int * <var>critical</var>, gnutls_datum_t * <var>nonce</var>)</em></dt>
<dd><p><var>resp</var>: should contain a <code>gnutls_ocsp_resp_t</code>  type
</p>
<p><var>critical</var>: whether nonce extension is marked critical
</p>
<p><var>nonce</var>: will hold newly allocated buffer with nonce data
</p>
<p>This function will return the Basic OCSP Response nonce extension
data.
</p>
<p>The caller needs to deallocate memory by calling <code>gnutls_free()</code>  on
 <code>nonce</code> -&gt;data.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error code is returned.
</p></dd></dl>

<span id="gnutls_005focsp_005fresp_005fget_005fproduced-1"></span><h4 class="subheading">gnutls_ocsp_resp_get_produced</h4>
<span id="gnutls_005focsp_005fresp_005fget_005fproduced"></span><dl>
<dt id="index-gnutls_005focsp_005fresp_005fget_005fproduced">Function: <em>time_t</em> <strong>gnutls_ocsp_resp_get_produced</strong> <em>(gnutls_ocsp_resp_t <var>resp</var>)</em></dt>
<dd><p><var>resp</var>: should contain a <code>gnutls_ocsp_resp_t</code>  type
</p>
<p>This function will return the time when the OCSP response was
signed.
</p>
<p><strong>Returns:</strong> signing time, or (time_t)-1 on error.
</p></dd></dl>

<span id="gnutls_005focsp_005fresp_005fget_005fresponder-1"></span><h4 class="subheading">gnutls_ocsp_resp_get_responder</h4>
<span id="gnutls_005focsp_005fresp_005fget_005fresponder"></span><dl>
<dt id="index-gnutls_005focsp_005fresp_005fget_005fresponder">Function: <em>int</em> <strong>gnutls_ocsp_resp_get_responder</strong> <em>(gnutls_ocsp_resp_t <var>resp</var>, gnutls_datum_t * <var>dn</var>)</em></dt>
<dd><p><var>resp</var>: should contain a <code>gnutls_ocsp_resp_t</code>  type
</p>
<p><var>dn</var>: newly allocated buffer with name
</p>
<p>This function will extract the name of the Basic OCSP Response in
the provided buffer. The name will be in the form
&quot;C=xxxx,O=yyyy,CN=zzzz&quot; as described in RFC2253. The output string
will be ASCII or UTF-8 encoded, depending on the certificate data.
</p>
<p>If the responder ID is not a name but a hash, this function
will return zero and the  <code>dn</code> elements will be set to <code>NULL</code> .
</p>
<p>The caller needs to deallocate memory by calling <code>gnutls_free()</code>  on
 <code>dn</code> -&gt;data.
</p>
<p>This function does not output a fully RFC4514 compliant string, if
that is required see <code>gnutls_ocsp_resp_get_responder2()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error code is returned. When no data exist it will
return success and set  <code>dn</code> elements to zero.
</p></dd></dl>

<span id="gnutls_005focsp_005fresp_005fget_005fresponder2-1"></span><h4 class="subheading">gnutls_ocsp_resp_get_responder2</h4>
<span id="gnutls_005focsp_005fresp_005fget_005fresponder2"></span><dl>
<dt id="index-gnutls_005focsp_005fresp_005fget_005fresponder2">Function: <em>int</em> <strong>gnutls_ocsp_resp_get_responder2</strong> <em>(gnutls_ocsp_resp_t <var>resp</var>, gnutls_datum_t * <var>dn</var>, unsigned <var>flags</var>)</em></dt>
<dd><p><var>resp</var>: should contain a <code>gnutls_ocsp_resp_t</code>  type
</p>
<p><var>dn</var>: newly allocated buffer with name
</p>
<p><var>flags</var>: zero or <code>GNUTLS_X509_DN_FLAG_COMPAT</code> 
</p>
<p>This function will extract the name of the Basic OCSP Response in
the provided buffer. The name will be in the form
&quot;C=xxxx,O=yyyy,CN=zzzz&quot; as described in RFC2253. The output string
will be ASCII or UTF-8 encoded, depending on the certificate data.
</p>
<p>If the responder ID is not a name but a hash, this function
will return zero and the  <code>dn</code> elements will be set to <code>NULL</code> .
</p>
<p>The caller needs to deallocate memory by calling <code>gnutls_free()</code>  on
 <code>dn</code> -&gt;data.
</p>
<p>When the flag <code>GNUTLS_X509_DN_FLAG_COMPAT</code>  is specified, the output
format will match the format output by previous to 3.5.6 versions of GnuTLS
which was not not fully RFC4514-compliant.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error code is returned. When no data exist it will return
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> .
</p></dd></dl>

<span id="gnutls_005focsp_005fresp_005fget_005fresponder_005fraw_005fid-1"></span><h4 class="subheading">gnutls_ocsp_resp_get_responder_raw_id</h4>
<span id="gnutls_005focsp_005fresp_005fget_005fresponder_005fraw_005fid"></span><dl>
<dt id="index-gnutls_005focsp_005fresp_005fget_005fresponder_005fraw_005fid">Function: <em>int</em> <strong>gnutls_ocsp_resp_get_responder_raw_id</strong> <em>(gnutls_ocsp_resp_t <var>resp</var>, unsigned <var>type</var>, gnutls_datum_t * <var>raw</var>)</em></dt>
<dd><p><var>resp</var>: should contain a <code>gnutls_ocsp_resp_t</code>  type
</p>
<p><var>type</var>: should be <code>GNUTLS_OCSP_RESP_ID_KEY</code>  or <code>GNUTLS_OCSP_RESP_ID_DN</code> 
</p>
<p><var>raw</var>: newly allocated buffer with the raw ID
</p>
<p>This function will extract the raw key (or DN) ID of the Basic OCSP Response in
the provided buffer. If the responder ID is not a key ID then
this function will return <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> .
</p>
<p>The caller needs to deallocate memory by calling <code>gnutls_free()</code>  on
 <code>dn</code> -&gt;data.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error code is returned.
</p></dd></dl>

<span id="gnutls_005focsp_005fresp_005fget_005fresponse-1"></span><h4 class="subheading">gnutls_ocsp_resp_get_response</h4>
<span id="gnutls_005focsp_005fresp_005fget_005fresponse"></span><dl>
<dt id="index-gnutls_005focsp_005fresp_005fget_005fresponse">Function: <em>int</em> <strong>gnutls_ocsp_resp_get_response</strong> <em>(gnutls_ocsp_resp_t <var>resp</var>, gnutls_datum_t * <var>response_type_oid</var>, gnutls_datum_t * <var>response</var>)</em></dt>
<dd><p><var>resp</var>: should contain a <code>gnutls_ocsp_resp_t</code>  type
</p>
<p><var>response_type_oid</var>: newly allocated output buffer with response type OID
</p>
<p><var>response</var>: newly allocated output buffer with DER encoded response
</p>
<p>This function will extract the response type OID in and the
response data from an OCSP response.  Normally the
 <code>response_type_oid</code> is always &quot;1.3.6.1.5.5.7.48.1.1&quot; which means the
 <code>response</code> should be decoded as a Basic OCSP Response, but
technically other response types could be used.
</p>
<p>This function is typically only useful when you want to extract the
response type OID of an response for diagnostic purposes.
Otherwise <code>gnutls_ocsp_resp_import()</code>  will decode the basic OCSP
response part and the caller need not worry about that aspect.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005focsp_005fresp_005fget_005fsignature-1"></span><h4 class="subheading">gnutls_ocsp_resp_get_signature</h4>
<span id="gnutls_005focsp_005fresp_005fget_005fsignature"></span><dl>
<dt id="index-gnutls_005focsp_005fresp_005fget_005fsignature">Function: <em>int</em> <strong>gnutls_ocsp_resp_get_signature</strong> <em>(gnutls_ocsp_resp_t <var>resp</var>, gnutls_datum_t * <var>sig</var>)</em></dt>
<dd><p><var>resp</var>: should contain a <code>gnutls_ocsp_resp_t</code>  type
</p>
<p><var>sig</var>: newly allocated output buffer with signature data
</p>
<p>This function will extract the signature field of a OCSP response.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005focsp_005fresp_005fget_005fsignature_005falgorithm-1"></span><h4 class="subheading">gnutls_ocsp_resp_get_signature_algorithm</h4>
<span id="gnutls_005focsp_005fresp_005fget_005fsignature_005falgorithm"></span><dl>
<dt id="index-gnutls_005focsp_005fresp_005fget_005fsignature_005falgorithm">Function: <em>int</em> <strong>gnutls_ocsp_resp_get_signature_algorithm</strong> <em>(gnutls_ocsp_resp_t <var>resp</var>)</em></dt>
<dd><p><var>resp</var>: should contain a <code>gnutls_ocsp_resp_t</code>  type
</p>
<p>This function will return a value of the <code>gnutls_sign_algorithm_t</code> 
enumeration that is the signature algorithm that has been used to
sign the OCSP response.
</p>
<p><strong>Returns:</strong> a <code>gnutls_sign_algorithm_t</code>  value, or a negative error code
on error.
</p></dd></dl>

<span id="gnutls_005focsp_005fresp_005fget_005fsingle-1"></span><h4 class="subheading">gnutls_ocsp_resp_get_single</h4>
<span id="gnutls_005focsp_005fresp_005fget_005fsingle"></span><dl>
<dt id="index-gnutls_005focsp_005fresp_005fget_005fsingle-1">Function: <em>int</em> <strong>gnutls_ocsp_resp_get_single</strong> <em>(gnutls_ocsp_resp_t <var>resp</var>, unsigned <var>indx</var>, gnutls_digest_algorithm_t * <var>digest</var>, gnutls_datum_t * <var>issuer_name_hash</var>, gnutls_datum_t * <var>issuer_key_hash</var>, gnutls_datum_t * <var>serial_number</var>, unsigned int * <var>cert_status</var>, time_t * <var>this_update</var>, time_t * <var>next_update</var>, time_t * <var>revocation_time</var>, unsigned int * <var>revocation_reason</var>)</em></dt>
<dd><p><var>resp</var>: should contain a <code>gnutls_ocsp_resp_t</code>  type
</p>
<p><var>indx</var>: Specifies response number to get. Use (0) to get the first one.
</p>
<p><var>digest</var>: output variable with <code>gnutls_digest_algorithm_t</code>  hash algorithm
</p>
<p><var>issuer_name_hash</var>: output buffer with hash of issuer&rsquo;s DN
</p>
<p><var>issuer_key_hash</var>: output buffer with hash of issuer&rsquo;s public key
</p>
<p><var>serial_number</var>: output buffer with serial number of certificate to check
</p>
<p><var>cert_status</var>: a certificate status, a <code>gnutls_ocsp_cert_status_t</code>  enum.
</p>
<p><var>this_update</var>: time at which the status is known to be correct.
</p>
<p><var>next_update</var>: when newer information will be available, or (time_t)-1 if unspecified
</p>
<p><var>revocation_time</var>: when  <code>cert_status</code> is <code>GNUTLS_OCSP_CERT_REVOKED</code> , holds time of revocation.
</p>
<p><var>revocation_reason</var>: revocation reason, a <code>gnutls_x509_crl_reason_t</code>  enum.
</p>
<p>This function will return the certificate information of the
 <code>indx</code> &rsquo;ed response in the Basic OCSP Response  <code>resp</code> .  The
information returned corresponds to the OCSP SingleResponse structure
except the final singleExtensions.
</p>
<p>Each of the pointers to output variables may be NULL to indicate
that the caller is not interested in that value.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error code is returned.  If you have reached the last
CertID available <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  will be
returned.
</p></dd></dl>

<span id="gnutls_005focsp_005fresp_005fget_005fstatus-1"></span><h4 class="subheading">gnutls_ocsp_resp_get_status</h4>
<span id="gnutls_005focsp_005fresp_005fget_005fstatus"></span><dl>
<dt id="index-gnutls_005focsp_005fresp_005fget_005fstatus">Function: <em>int</em> <strong>gnutls_ocsp_resp_get_status</strong> <em>(gnutls_ocsp_resp_t <var>resp</var>)</em></dt>
<dd><p><var>resp</var>: should contain a <code>gnutls_ocsp_resp_t</code>  type
</p>
<p>This function will return the status of a OCSP response, an
<code>gnutls_ocsp_resp_status_t</code>  enumeration.
</p>
<p><strong>Returns:</strong> status of OCSP request as a <code>gnutls_ocsp_resp_status_t</code> , or
a negative error code on error.
</p></dd></dl>

<span id="gnutls_005focsp_005fresp_005fget_005fversion-1"></span><h4 class="subheading">gnutls_ocsp_resp_get_version</h4>
<span id="gnutls_005focsp_005fresp_005fget_005fversion"></span><dl>
<dt id="index-gnutls_005focsp_005fresp_005fget_005fversion">Function: <em>int</em> <strong>gnutls_ocsp_resp_get_version</strong> <em>(gnutls_ocsp_resp_t <var>resp</var>)</em></dt>
<dd><p><var>resp</var>: should contain a <code>gnutls_ocsp_resp_t</code>  type
</p>
<p>This function will return the version of the Basic OCSP Response.
Typically this is always 1 indicating version 1.
</p>
<p><strong>Returns:</strong> version of Basic OCSP response, or a negative error code
on error.
</p></dd></dl>

<span id="gnutls_005focsp_005fresp_005fimport-1"></span><h4 class="subheading">gnutls_ocsp_resp_import</h4>
<span id="gnutls_005focsp_005fresp_005fimport"></span><dl>
<dt id="index-gnutls_005focsp_005fresp_005fimport">Function: <em>int</em> <strong>gnutls_ocsp_resp_import</strong> <em>(gnutls_ocsp_resp_t <var>resp</var>, const gnutls_datum_t * <var>data</var>)</em></dt>
<dd><p><var>resp</var>: The data to store the parsed response.
</p>
<p><var>data</var>: DER encoded OCSP response.
</p>
<p>This function will convert the given DER encoded OCSP response to
the native <code>gnutls_ocsp_resp_t</code>  format.  It also decodes the Basic
OCSP Response part, if any.  The output will be stored in  <code>resp</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005focsp_005fresp_005fimport2-1"></span><h4 class="subheading">gnutls_ocsp_resp_import2</h4>
<span id="gnutls_005focsp_005fresp_005fimport2"></span><dl>
<dt id="index-gnutls_005focsp_005fresp_005fimport2">Function: <em>int</em> <strong>gnutls_ocsp_resp_import2</strong> <em>(gnutls_ocsp_resp_t <var>resp</var>, const gnutls_datum_t * <var>data</var>, gnutls_x509_crt_fmt_t <var>fmt</var>)</em></dt>
<dd><p><var>resp</var>: The data to store the parsed response.
</p>
<p><var>data</var>: DER or PEM encoded OCSP response.
</p>
<p><var>fmt</var>: DER or PEM
</p>
<p>This function will convert the given OCSP response to
the native <code>gnutls_ocsp_resp_t</code>  format.  It also decodes the Basic
OCSP Response part, if any.  The output will be stored in  <code>resp</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.6.3
</p></dd></dl>

<span id="gnutls_005focsp_005fresp_005finit-1"></span><h4 class="subheading">gnutls_ocsp_resp_init</h4>
<span id="gnutls_005focsp_005fresp_005finit"></span><dl>
<dt id="index-gnutls_005focsp_005fresp_005finit">Function: <em>int</em> <strong>gnutls_ocsp_resp_init</strong> <em>(gnutls_ocsp_resp_t * <var>resp</var>)</em></dt>
<dd><p><var>resp</var>: A pointer to the type to be initialized
</p>
<p>This function will initialize an OCSP response structure.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005focsp_005fresp_005flist_005fimport2-1"></span><h4 class="subheading">gnutls_ocsp_resp_list_import2</h4>
<span id="gnutls_005focsp_005fresp_005flist_005fimport2"></span><dl>
<dt id="index-gnutls_005focsp_005fresp_005flist_005fimport2">Function: <em>int</em> <strong>gnutls_ocsp_resp_list_import2</strong> <em>(gnutls_ocsp_resp_t ** <var>ocsps</var>, unsigned int * <var>size</var>, const gnutls_datum_t * <var>resp_data</var>, gnutls_x509_crt_fmt_t <var>format</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>ocsps</var>: Will hold the parsed OCSP response list.
</p>
<p><var>size</var>: It will contain the size of the list.
</p>
<p><var>resp_data</var>: The PEM encoded OCSP list.
</p>
<p><var>format</var>: One of <code>GNUTLS_X509_FMT_PEM</code>  or <code>GNUTLS_X509_FMT_DER</code> 
</p>
<p><var>flags</var>: must be (0) or an OR&rsquo;d sequence of gnutls_certificate_import_flags.
</p>
<p>This function will convert the given PEM encoded OCSP response list
to the native gnutls_ocsp_resp_t format. The output will be stored
in  <code>ocsps</code> which will be allocated and initialized.
</p>
<p>The OCSP responses should have a header of &quot;OCSP RESPONSE&quot;.
</p>
<p>To deinitialize responses, you need to deinitialize each <code>gnutls_ocsp_resp_t</code> 
structure independently, and use <code>gnutls_free()</code>  at  <code>ocsps</code> .
</p>
<p>In PEM files, when no OCSP responses are detected
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  will be returned.
</p>
<p><strong>Returns:</strong> the number of responses read or a negative error value.
</p>
<p><strong>Since:</strong> 3.6.3
</p></dd></dl>

<span id="gnutls_005focsp_005fresp_005fprint-1"></span><h4 class="subheading">gnutls_ocsp_resp_print</h4>
<span id="gnutls_005focsp_005fresp_005fprint"></span><dl>
<dt id="index-gnutls_005focsp_005fresp_005fprint">Function: <em>int</em> <strong>gnutls_ocsp_resp_print</strong> <em>(gnutls_ocsp_resp_t <var>resp</var>, gnutls_ocsp_print_formats_t <var>format</var>, gnutls_datum_t * <var>out</var>)</em></dt>
<dd><p><var>resp</var>: The data to be printed
</p>
<p><var>format</var>: Indicate the format to use
</p>
<p><var>out</var>: Newly allocated datum with (0) terminated string.
</p>
<p>This function will pretty print a OCSP response, suitable for
display to a human.
</p>
<p>If the format is <code>GNUTLS_OCSP_PRINT_FULL</code>  then all fields of the
response will be output, on multiple lines.
</p>
<p>The output  <code>out</code> -&gt;data needs to be deallocate using <code>gnutls_free()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005focsp_005fresp_005fverify-1"></span><h4 class="subheading">gnutls_ocsp_resp_verify</h4>
<span id="gnutls_005focsp_005fresp_005fverify"></span><dl>
<dt id="index-gnutls_005focsp_005fresp_005fverify">Function: <em>int</em> <strong>gnutls_ocsp_resp_verify</strong> <em>(gnutls_ocsp_resp_t <var>resp</var>, gnutls_x509_trust_list_t <var>trustlist</var>, unsigned int * <var>verify</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>resp</var>: should contain a <code>gnutls_ocsp_resp_t</code>  type
</p>
<p><var>trustlist</var>: trust anchors as a <code>gnutls_x509_trust_list_t</code>  type
</p>
<p><var>verify</var>: output variable with verification status, an <code>gnutls_ocsp_verify_reason_t</code> 
</p>
<p><var>flags</var>: verification flags from <code>gnutls_certificate_verify_flags</code> 
</p>
<p>Verify signature of the Basic OCSP Response against the public key
in the certificate of a trusted signer.  The  <code>trustlist</code> should be
populated with trust anchors.  The function will extract the signer
certificate from the Basic OCSP Response and will verify it against
the  <code>trustlist</code> .  A trusted signer is a certificate that is either
in  <code>trustlist</code> , or it is signed directly by a certificate in
 <code>trustlist</code> and has the id-ad-ocspSigning Extended Key Usage bit
set.
</p>
<p>The output  <code>verify</code> variable will hold verification status codes
(e.g., <code>GNUTLS_OCSP_VERIFY_SIGNER_NOT_FOUND</code> ,
<code>GNUTLS_OCSP_VERIFY_INSECURE_ALGORITHM</code> ) which are only valid if the
function returned <code>GNUTLS_E_SUCCESS</code> .
</p>
<p>Note that the function returns <code>GNUTLS_E_SUCCESS</code>  even when
verification failed.  The caller must always inspect the  <code>verify</code> variable to find out the verification status.
</p>
<p>The  <code>flags</code> variable should be 0 for now.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005focsp_005fresp_005fverify_005fdirect-1"></span><h4 class="subheading">gnutls_ocsp_resp_verify_direct</h4>
<span id="gnutls_005focsp_005fresp_005fverify_005fdirect"></span><dl>
<dt id="index-gnutls_005focsp_005fresp_005fverify_005fdirect">Function: <em>int</em> <strong>gnutls_ocsp_resp_verify_direct</strong> <em>(gnutls_ocsp_resp_t <var>resp</var>, gnutls_x509_crt_t <var>issuer</var>, unsigned int * <var>verify</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>resp</var>: should contain a <code>gnutls_ocsp_resp_t</code>  type
</p>
<p><var>issuer</var>: certificate believed to have signed the response
</p>
<p><var>verify</var>: output variable with verification status, an <code>gnutls_ocsp_verify_reason_t</code> 
</p>
<p><var>flags</var>: verification flags from <code>gnutls_certificate_verify_flags</code> 
</p>
<p>Verify signature of the Basic OCSP Response against the public key
in the  <code>issuer</code> certificate.
</p>
<p>The output  <code>verify</code> variable will hold verification status codes
(e.g., <code>GNUTLS_OCSP_VERIFY_SIGNER_NOT_FOUND</code> ,
<code>GNUTLS_OCSP_VERIFY_INSECURE_ALGORITHM</code> ) which are only valid if the
function returned <code>GNUTLS_E_SUCCESS</code> .
</p>
<p>Note that the function returns <code>GNUTLS_E_SUCCESS</code>  even when
verification failed.  The caller must always inspect the  <code>verify</code> variable to find out the verification status.
</p>
<p>The  <code>flags</code> variable should be 0 for now.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>


<hr>
<span id="PKCS-12-API"></span><div class="header">
<p>
Next: <a href="#PKCS-11-API" accesskey="n" rel="next">PKCS 11 API</a>, Previous: <a href="#OCSP-API" accesskey="p" rel="prev">OCSP API</a>, Up: <a href="#API-reference" accesskey="u" rel="up">API reference</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="PKCS-12-API-1"></span><h3 class="section">E.6 PKCS 12 API</h3>

<p>The following functions are to be used for PKCS 12 handling.
Their prototypes lie in <samp>gnutls/pkcs12.h</samp>.
</p>

<span id="gnutls_005fpkcs12_005fbag_005fdecrypt-1"></span><h4 class="subheading">gnutls_pkcs12_bag_decrypt</h4>
<span id="gnutls_005fpkcs12_005fbag_005fdecrypt"></span><dl>
<dt id="index-gnutls_005fpkcs12_005fbag_005fdecrypt">Function: <em>int</em> <strong>gnutls_pkcs12_bag_decrypt</strong> <em>(gnutls_pkcs12_bag_t <var>bag</var>, const char * <var>pass</var>)</em></dt>
<dd><p><var>bag</var>: The bag
</p>
<p><var>pass</var>: The password used for encryption, must be ASCII.
</p>
<p>This function will decrypt the given encrypted bag and return 0 on
success.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p></dd></dl>

<span id="gnutls_005fpkcs12_005fbag_005fdeinit-1"></span><h4 class="subheading">gnutls_pkcs12_bag_deinit</h4>
<span id="gnutls_005fpkcs12_005fbag_005fdeinit"></span><dl>
<dt id="index-gnutls_005fpkcs12_005fbag_005fdeinit">Function: <em>void</em> <strong>gnutls_pkcs12_bag_deinit</strong> <em>(gnutls_pkcs12_bag_t <var>bag</var>)</em></dt>
<dd><p><var>bag</var>: A pointer to the type to be initialized
</p>
<p>This function will deinitialize a PKCS12 Bag structure.
</p></dd></dl>

<span id="gnutls_005fpkcs12_005fbag_005fenc_005finfo-1"></span><h4 class="subheading">gnutls_pkcs12_bag_enc_info</h4>
<span id="gnutls_005fpkcs12_005fbag_005fenc_005finfo"></span><dl>
<dt id="index-gnutls_005fpkcs12_005fbag_005fenc_005finfo">Function: <em>int</em> <strong>gnutls_pkcs12_bag_enc_info</strong> <em>(gnutls_pkcs12_bag_t <var>bag</var>, unsigned int * <var>schema</var>, unsigned int * <var>cipher</var>, void * <var>salt</var>, unsigned int * <var>salt_size</var>, unsigned int * <var>iter_count</var>, char ** <var>oid</var>)</em></dt>
<dd><p><var>bag</var>: The bag
</p>
<p><var>schema</var>: indicate the schema as one of <code>gnutls_pkcs_encrypt_flags_t</code> 
</p>
<p><var>cipher</var>: the cipher used as <code>gnutls_cipher_algorithm_t</code> 
</p>
<p><var>salt</var>: PBKDF2 salt (if non-NULL then  <code>salt_size</code> initially holds its size)
</p>
<p><var>salt_size</var>: PBKDF2 salt size
</p>
<p><var>iter_count</var>: PBKDF2 iteration count
</p>
<p><var>oid</var>: if non-NULL it will contain an allocated null-terminated variable with the OID
</p>
<p>This function will provide information on the encryption algorithms used
in an encrypted bag. If the structure algorithms
are unknown the code <code>GNUTLS_E_UNKNOWN_CIPHER_TYPE</code>  will be returned,
and only  <code>oid</code> , will be set. That is,  <code>oid</code> will be set on encrypted bags
whether supported or not. It must be deinitialized using <code>gnutls_free()</code> .
The other variables are only set on supported structures.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_INVALID_REQUEST</code>  if the provided bag isn&rsquo;t encrypted,
<code>GNUTLS_E_UNKNOWN_CIPHER_TYPE</code>  if the structure&rsquo;s encryption isn&rsquo;t supported, or
another negative error code in case of a failure. Zero on success.
</p></dd></dl>

<span id="gnutls_005fpkcs12_005fbag_005fencrypt-1"></span><h4 class="subheading">gnutls_pkcs12_bag_encrypt</h4>
<span id="gnutls_005fpkcs12_005fbag_005fencrypt"></span><dl>
<dt id="index-gnutls_005fpkcs12_005fbag_005fencrypt">Function: <em>int</em> <strong>gnutls_pkcs12_bag_encrypt</strong> <em>(gnutls_pkcs12_bag_t <var>bag</var>, const char * <var>pass</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>bag</var>: The bag
</p>
<p><var>pass</var>: The password used for encryption, must be ASCII
</p>
<p><var>flags</var>: should be one of <code>gnutls_pkcs_encrypt_flags_t</code>  elements bitwise or&rsquo;d
</p>
<p>This function will encrypt the given bag.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
otherwise a negative error code is returned.
</p></dd></dl>

<span id="gnutls_005fpkcs12_005fbag_005fget_005fcount-1"></span><h4 class="subheading">gnutls_pkcs12_bag_get_count</h4>
<span id="gnutls_005fpkcs12_005fbag_005fget_005fcount"></span><dl>
<dt id="index-gnutls_005fpkcs12_005fbag_005fget_005fcount">Function: <em>int</em> <strong>gnutls_pkcs12_bag_get_count</strong> <em>(gnutls_pkcs12_bag_t <var>bag</var>)</em></dt>
<dd><p><var>bag</var>: The bag
</p>
<p>This function will return the number of the elements within the bag.
</p>
<p><strong>Returns:</strong> Number of elements in bag, or an negative error code on
error.
</p></dd></dl>

<span id="gnutls_005fpkcs12_005fbag_005fget_005fdata-1"></span><h4 class="subheading">gnutls_pkcs12_bag_get_data</h4>
<span id="gnutls_005fpkcs12_005fbag_005fget_005fdata"></span><dl>
<dt id="index-gnutls_005fpkcs12_005fbag_005fget_005fdata">Function: <em>int</em> <strong>gnutls_pkcs12_bag_get_data</strong> <em>(gnutls_pkcs12_bag_t <var>bag</var>, unsigned <var>indx</var>, gnutls_datum_t * <var>data</var>)</em></dt>
<dd><p><var>bag</var>: The bag
</p>
<p><var>indx</var>: The element of the bag to get the data from
</p>
<p><var>data</var>: where the bag&rsquo;s data will be. Should be treated as constant.
</p>
<p>This function will return the bag&rsquo;s data. The data is a constant
that is stored into the bag.  Should not be accessed after the bag
is deleted.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fpkcs12_005fbag_005fget_005ffriendly_005fname-1"></span><h4 class="subheading">gnutls_pkcs12_bag_get_friendly_name</h4>
<span id="gnutls_005fpkcs12_005fbag_005fget_005ffriendly_005fname"></span><dl>
<dt id="index-gnutls_005fpkcs12_005fbag_005fget_005ffriendly_005fname">Function: <em>int</em> <strong>gnutls_pkcs12_bag_get_friendly_name</strong> <em>(gnutls_pkcs12_bag_t <var>bag</var>, unsigned <var>indx</var>, char ** <var>name</var>)</em></dt>
<dd><p><var>bag</var>: The bag
</p>
<p><var>indx</var>: The bag&rsquo;s element to add the id
</p>
<p><var>name</var>: will hold a pointer to the name (to be treated as const)
</p>
<p>This function will return the friendly name, of the specified bag
element.  The key ID is usually used to distinguish the local
private key and the certificate pair.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value. or a negative error code on error.
</p></dd></dl>

<span id="gnutls_005fpkcs12_005fbag_005fget_005fkey_005fid-1"></span><h4 class="subheading">gnutls_pkcs12_bag_get_key_id</h4>
<span id="gnutls_005fpkcs12_005fbag_005fget_005fkey_005fid"></span><dl>
<dt id="index-gnutls_005fpkcs12_005fbag_005fget_005fkey_005fid">Function: <em>int</em> <strong>gnutls_pkcs12_bag_get_key_id</strong> <em>(gnutls_pkcs12_bag_t <var>bag</var>, unsigned <var>indx</var>, gnutls_datum_t * <var>id</var>)</em></dt>
<dd><p><var>bag</var>: The bag
</p>
<p><var>indx</var>: The bag&rsquo;s element to add the id
</p>
<p><var>id</var>: where the ID will be copied (to be treated as const)
</p>
<p>This function will return the key ID, of the specified bag element.
The key ID is usually used to distinguish the local private key and
the certificate pair.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value. or a negative error code on error.
</p></dd></dl>

<span id="gnutls_005fpkcs12_005fbag_005fget_005ftype-1"></span><h4 class="subheading">gnutls_pkcs12_bag_get_type</h4>
<span id="gnutls_005fpkcs12_005fbag_005fget_005ftype"></span><dl>
<dt id="index-gnutls_005fpkcs12_005fbag_005fget_005ftype">Function: <em>int</em> <strong>gnutls_pkcs12_bag_get_type</strong> <em>(gnutls_pkcs12_bag_t <var>bag</var>, unsigned <var>indx</var>)</em></dt>
<dd><p><var>bag</var>: The bag
</p>
<p><var>indx</var>: The element of the bag to get the type
</p>
<p>This function will return the bag&rsquo;s type.
</p>
<p><strong>Returns:</strong> On error a negative error value or one of the <code>gnutls_pkcs12_bag_type_t</code>  enumerations.
</p></dd></dl>

<span id="gnutls_005fpkcs12_005fbag_005finit-1"></span><h4 class="subheading">gnutls_pkcs12_bag_init</h4>
<span id="gnutls_005fpkcs12_005fbag_005finit"></span><dl>
<dt id="index-gnutls_005fpkcs12_005fbag_005finit">Function: <em>int</em> <strong>gnutls_pkcs12_bag_init</strong> <em>(gnutls_pkcs12_bag_t * <var>bag</var>)</em></dt>
<dd><p><var>bag</var>: A pointer to the type to be initialized
</p>
<p>This function will initialize a PKCS12 bag structure. PKCS12 Bags
usually contain private keys, lists of X.509 Certificates and X.509
Certificate revocation lists.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fpkcs12_005fbag_005fset_005fcrl-1"></span><h4 class="subheading">gnutls_pkcs12_bag_set_crl</h4>
<span id="gnutls_005fpkcs12_005fbag_005fset_005fcrl"></span><dl>
<dt id="index-gnutls_005fpkcs12_005fbag_005fset_005fcrl">Function: <em>int</em> <strong>gnutls_pkcs12_bag_set_crl</strong> <em>(gnutls_pkcs12_bag_t <var>bag</var>, gnutls_x509_crl_t <var>crl</var>)</em></dt>
<dd><p><var>bag</var>: The bag
</p>
<p><var>crl</var>: the CRL to be copied.
</p>
<p>This function will insert the given CRL into the
bag. This is just a wrapper over <code>gnutls_pkcs12_bag_set_data()</code> .
</p>
<p><strong>Returns:</strong> the index of the added bag on success, or a negative error code
on failure.
</p></dd></dl>

<span id="gnutls_005fpkcs12_005fbag_005fset_005fcrt-1"></span><h4 class="subheading">gnutls_pkcs12_bag_set_crt</h4>
<span id="gnutls_005fpkcs12_005fbag_005fset_005fcrt"></span><dl>
<dt id="index-gnutls_005fpkcs12_005fbag_005fset_005fcrt">Function: <em>int</em> <strong>gnutls_pkcs12_bag_set_crt</strong> <em>(gnutls_pkcs12_bag_t <var>bag</var>, gnutls_x509_crt_t <var>crt</var>)</em></dt>
<dd><p><var>bag</var>: The bag
</p>
<p><var>crt</var>: the certificate to be copied.
</p>
<p>This function will insert the given certificate into the
bag. This is just a wrapper over <code>gnutls_pkcs12_bag_set_data()</code> .
</p>
<p><strong>Returns:</strong> the index of the added bag on success, or a negative
value on failure.
</p></dd></dl>

<span id="gnutls_005fpkcs12_005fbag_005fset_005fdata-1"></span><h4 class="subheading">gnutls_pkcs12_bag_set_data</h4>
<span id="gnutls_005fpkcs12_005fbag_005fset_005fdata"></span><dl>
<dt id="index-gnutls_005fpkcs12_005fbag_005fset_005fdata">Function: <em>int</em> <strong>gnutls_pkcs12_bag_set_data</strong> <em>(gnutls_pkcs12_bag_t <var>bag</var>, gnutls_pkcs12_bag_type_t <var>type</var>, const gnutls_datum_t * <var>data</var>)</em></dt>
<dd><p><var>bag</var>: The bag
</p>
<p><var>type</var>: The data&rsquo;s type
</p>
<p><var>data</var>: the data to be copied.
</p>
<p>This function will insert the given data of the given type into
the bag.
</p>
<p><strong>Returns:</strong> the index of the added bag on success, or a negative
value on error.
</p></dd></dl>

<span id="gnutls_005fpkcs12_005fbag_005fset_005ffriendly_005fname-1"></span><h4 class="subheading">gnutls_pkcs12_bag_set_friendly_name</h4>
<span id="gnutls_005fpkcs12_005fbag_005fset_005ffriendly_005fname"></span><dl>
<dt id="index-gnutls_005fpkcs12_005fbag_005fset_005ffriendly_005fname">Function: <em>int</em> <strong>gnutls_pkcs12_bag_set_friendly_name</strong> <em>(gnutls_pkcs12_bag_t <var>bag</var>, unsigned <var>indx</var>, const char * <var>name</var>)</em></dt>
<dd><p><var>bag</var>: The bag
</p>
<p><var>indx</var>: The bag&rsquo;s element to add the id
</p>
<p><var>name</var>: the name
</p>
<p>This function will add the given key friendly name, to the
specified, by the index, bag element. The name will be encoded as
a &rsquo;Friendly name&rsquo; bag attribute, which is usually used to set a
user name to the local private key and the certificate pair.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value. or a negative error code on error.
</p></dd></dl>

<span id="gnutls_005fpkcs12_005fbag_005fset_005fkey_005fid-1"></span><h4 class="subheading">gnutls_pkcs12_bag_set_key_id</h4>
<span id="gnutls_005fpkcs12_005fbag_005fset_005fkey_005fid"></span><dl>
<dt id="index-gnutls_005fpkcs12_005fbag_005fset_005fkey_005fid">Function: <em>int</em> <strong>gnutls_pkcs12_bag_set_key_id</strong> <em>(gnutls_pkcs12_bag_t <var>bag</var>, unsigned <var>indx</var>, const gnutls_datum_t * <var>id</var>)</em></dt>
<dd><p><var>bag</var>: The bag
</p>
<p><var>indx</var>: The bag&rsquo;s element to add the id
</p>
<p><var>id</var>: the ID
</p>
<p>This function will add the given key ID, to the specified, by the
index, bag element. The key ID will be encoded as a &rsquo;Local key
identifier&rsquo; bag attribute, which is usually used to distinguish
the local private key and the certificate pair.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value. or a negative error code on error.
</p></dd></dl>

<span id="gnutls_005fpkcs12_005fbag_005fset_005fprivkey-1"></span><h4 class="subheading">gnutls_pkcs12_bag_set_privkey</h4>
<span id="gnutls_005fpkcs12_005fbag_005fset_005fprivkey"></span><dl>
<dt id="index-gnutls_005fpkcs12_005fbag_005fset_005fprivkey">Function: <em>int</em> <strong>gnutls_pkcs12_bag_set_privkey</strong> <em>(gnutls_pkcs12_bag_t <var>bag</var>, gnutls_x509_privkey_t <var>privkey</var>, const char * <var>password</var>, unsigned <var>flags</var>)</em></dt>
<dd><p><var>bag</var>: The bag
</p>
<p><var>privkey</var>: the private key to be copied.
</p>
<p><var>password</var>: the password to protect the key with (may be <code>NULL</code> )
</p>
<p><var>flags</var>: should be one of <code>gnutls_pkcs_encrypt_flags_t</code>  elements bitwise or&rsquo;d
</p>
<p>This function will insert the given private key into the
bag. This is just a wrapper over <code>gnutls_pkcs12_bag_set_data()</code> .
</p>
<p><strong>Returns:</strong> the index of the added bag on success, or a negative
value on failure.
</p></dd></dl>

<span id="gnutls_005fpkcs12_005fdeinit-1"></span><h4 class="subheading">gnutls_pkcs12_deinit</h4>
<span id="gnutls_005fpkcs12_005fdeinit"></span><dl>
<dt id="index-gnutls_005fpkcs12_005fdeinit">Function: <em>void</em> <strong>gnutls_pkcs12_deinit</strong> <em>(gnutls_pkcs12_t <var>pkcs12</var>)</em></dt>
<dd><p><var>pkcs12</var>: The type to be initialized
</p>
<p>This function will deinitialize a PKCS12 type.
</p></dd></dl>

<span id="gnutls_005fpkcs12_005fexport-1"></span><h4 class="subheading">gnutls_pkcs12_export</h4>
<span id="gnutls_005fpkcs12_005fexport"></span><dl>
<dt id="index-gnutls_005fpkcs12_005fexport">Function: <em>int</em> <strong>gnutls_pkcs12_export</strong> <em>(gnutls_pkcs12_t <var>pkcs12</var>, gnutls_x509_crt_fmt_t <var>format</var>, void * <var>output_data</var>, size_t * <var>output_data_size</var>)</em></dt>
<dd><p><var>pkcs12</var>: A pkcs12 type
</p>
<p><var>format</var>: the format of output params. One of PEM or DER.
</p>
<p><var>output_data</var>: will contain a structure PEM or DER encoded
</p>
<p><var>output_data_size</var>: holds the size of output_data (and will be
replaced by the actual size of parameters)
</p>
<p>This function will export the pkcs12 structure to DER or PEM format.
</p>
<p>If the buffer provided is not long enough to hold the output, then
*output_data_size will be updated and GNUTLS_E_SHORT_MEMORY_BUFFER
will be returned.
</p>
<p>If the structure is PEM encoded, it will have a header
of &quot;BEGIN PKCS12&quot;.
</p>
<p><strong>Returns:</strong> In case of failure a negative error code will be
returned, and 0 on success.
</p></dd></dl>

<span id="gnutls_005fpkcs12_005fexport2-1"></span><h4 class="subheading">gnutls_pkcs12_export2</h4>
<span id="gnutls_005fpkcs12_005fexport2"></span><dl>
<dt id="index-gnutls_005fpkcs12_005fexport2">Function: <em>int</em> <strong>gnutls_pkcs12_export2</strong> <em>(gnutls_pkcs12_t <var>pkcs12</var>, gnutls_x509_crt_fmt_t <var>format</var>, gnutls_datum_t * <var>out</var>)</em></dt>
<dd><p><var>pkcs12</var>: A pkcs12 type
</p>
<p><var>format</var>: the format of output params. One of PEM or DER.
</p>
<p><var>out</var>: will contain a structure PEM or DER encoded
</p>
<p>This function will export the pkcs12 structure to DER or PEM format.
</p>
<p>The output buffer is allocated using <code>gnutls_malloc()</code> .
</p>
<p>If the structure is PEM encoded, it will have a header
of &quot;BEGIN PKCS12&quot;.
</p>
<p><strong>Returns:</strong> In case of failure a negative error code will be
returned, and 0 on success.
</p>
<p><strong>Since:</strong> 3.1.3
</p></dd></dl>

<span id="gnutls_005fpkcs12_005fgenerate_005fmac-1"></span><h4 class="subheading">gnutls_pkcs12_generate_mac</h4>
<span id="gnutls_005fpkcs12_005fgenerate_005fmac"></span><dl>
<dt id="index-gnutls_005fpkcs12_005fgenerate_005fmac">Function: <em>int</em> <strong>gnutls_pkcs12_generate_mac</strong> <em>(gnutls_pkcs12_t <var>pkcs12</var>, const char * <var>pass</var>)</em></dt>
<dd><p><var>pkcs12</var>: A pkcs12 type
</p>
<p><var>pass</var>: The password for the MAC
</p>
<p>This function will generate a MAC for the PKCS12 structure.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fpkcs12_005fgenerate_005fmac2-1"></span><h4 class="subheading">gnutls_pkcs12_generate_mac2</h4>
<span id="gnutls_005fpkcs12_005fgenerate_005fmac2"></span><dl>
<dt id="index-gnutls_005fpkcs12_005fgenerate_005fmac2">Function: <em>int</em> <strong>gnutls_pkcs12_generate_mac2</strong> <em>(gnutls_pkcs12_t <var>pkcs12</var>, gnutls_mac_algorithm_t <var>mac</var>, const char * <var>pass</var>)</em></dt>
<dd><p><var>pkcs12</var>: A pkcs12 type
</p>
<p><var>mac</var>: the MAC algorithm to use
</p>
<p><var>pass</var>: The password for the MAC
</p>
<p>This function will generate a MAC for the PKCS12 structure.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fpkcs12_005fget_005fbag-1"></span><h4 class="subheading">gnutls_pkcs12_get_bag</h4>
<span id="gnutls_005fpkcs12_005fget_005fbag"></span><dl>
<dt id="index-gnutls_005fpkcs12_005fget_005fbag">Function: <em>int</em> <strong>gnutls_pkcs12_get_bag</strong> <em>(gnutls_pkcs12_t <var>pkcs12</var>, int <var>indx</var>, gnutls_pkcs12_bag_t <var>bag</var>)</em></dt>
<dd><p><var>pkcs12</var>: A pkcs12 type
</p>
<p><var>indx</var>: contains the index of the bag to extract
</p>
<p><var>bag</var>: An initialized bag, where the contents of the bag will be copied
</p>
<p>This function will return a Bag from the PKCS12 structure.
</p>
<p>After the last Bag has been read
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  will be returned.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fpkcs12_005fimport-1"></span><h4 class="subheading">gnutls_pkcs12_import</h4>
<span id="gnutls_005fpkcs12_005fimport"></span><dl>
<dt id="index-gnutls_005fpkcs12_005fimport">Function: <em>int</em> <strong>gnutls_pkcs12_import</strong> <em>(gnutls_pkcs12_t <var>pkcs12</var>, const gnutls_datum_t * <var>data</var>, gnutls_x509_crt_fmt_t <var>format</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>pkcs12</var>: The data to store the parsed PKCS12.
</p>
<p><var>data</var>: The DER or PEM encoded PKCS12.
</p>
<p><var>format</var>: One of DER or PEM
</p>
<p><var>flags</var>: an ORed sequence of gnutls_privkey_pkcs8_flags
</p>
<p>This function will convert the given DER or PEM encoded PKCS12
to the native gnutls_pkcs12_t format. The output will be stored in &rsquo;pkcs12&rsquo;.
</p>
<p>If the PKCS12 is PEM encoded it should have a header of &quot;PKCS12&quot;.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fpkcs12_005finit-1"></span><h4 class="subheading">gnutls_pkcs12_init</h4>
<span id="gnutls_005fpkcs12_005finit"></span><dl>
<dt id="index-gnutls_005fpkcs12_005finit">Function: <em>int</em> <strong>gnutls_pkcs12_init</strong> <em>(gnutls_pkcs12_t * <var>pkcs12</var>)</em></dt>
<dd><p><var>pkcs12</var>: A pointer to the type to be initialized
</p>
<p>This function will initialize a PKCS12 type. PKCS12 structures
usually contain lists of X.509 Certificates and X.509 Certificate
revocation lists.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fpkcs12_005fmac_005finfo-1"></span><h4 class="subheading">gnutls_pkcs12_mac_info</h4>
<span id="gnutls_005fpkcs12_005fmac_005finfo"></span><dl>
<dt id="index-gnutls_005fpkcs12_005fmac_005finfo">Function: <em>int</em> <strong>gnutls_pkcs12_mac_info</strong> <em>(gnutls_pkcs12_t <var>pkcs12</var>, unsigned int * <var>mac</var>, void * <var>salt</var>, unsigned int * <var>salt_size</var>, unsigned int * <var>iter_count</var>, char ** <var>oid</var>)</em></dt>
<dd><p><var>pkcs12</var>: A pkcs12 type
</p>
<p><var>mac</var>: the MAC algorithm used as <code>gnutls_mac_algorithm_t</code> 
</p>
<p><var>salt</var>: the salt used for string to key (if non-NULL then  <code>salt_size</code> initially holds its size)
</p>
<p><var>salt_size</var>: string to key salt size
</p>
<p><var>iter_count</var>: string to key iteration count
</p>
<p><var>oid</var>: if non-NULL it will contain an allocated null-terminated variable with the OID
</p>
<p>This function will provide information on the MAC algorithm used
in a PKCS <code>12</code>  structure. If the structure algorithms
are unknown the code <code>GNUTLS_E_UNKNOWN_HASH_ALGORITHM</code>  will be returned,
and only  <code>oid</code> , will be set. That is,  <code>oid</code> will be set on structures
with a MAC whether supported or not. It must be deinitialized using <code>gnutls_free()</code> .
The other variables are only set on supported structures.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_INVALID_REQUEST</code>  if the provided structure doesn&rsquo;t contain a MAC,
<code>GNUTLS_E_UNKNOWN_HASH_ALGORITHM</code>  if the structure&rsquo;s MAC isn&rsquo;t supported, or
another negative error code in case of a failure. Zero on success.
</p></dd></dl>

<span id="gnutls_005fpkcs12_005fset_005fbag-1"></span><h4 class="subheading">gnutls_pkcs12_set_bag</h4>
<span id="gnutls_005fpkcs12_005fset_005fbag"></span><dl>
<dt id="index-gnutls_005fpkcs12_005fset_005fbag">Function: <em>int</em> <strong>gnutls_pkcs12_set_bag</strong> <em>(gnutls_pkcs12_t <var>pkcs12</var>, gnutls_pkcs12_bag_t <var>bag</var>)</em></dt>
<dd><p><var>pkcs12</var>: should contain a gnutls_pkcs12_t type
</p>
<p><var>bag</var>: An initialized bag
</p>
<p>This function will insert a Bag into the PKCS12 structure.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fpkcs12_005fsimple_005fparse-1"></span><h4 class="subheading">gnutls_pkcs12_simple_parse</h4>
<span id="gnutls_005fpkcs12_005fsimple_005fparse"></span><dl>
<dt id="index-gnutls_005fpkcs12_005fsimple_005fparse-1">Function: <em>int</em> <strong>gnutls_pkcs12_simple_parse</strong> <em>(gnutls_pkcs12_t <var>p12</var>, const char * <var>password</var>, gnutls_x509_privkey_t * <var>key</var>, gnutls_x509_crt_t ** <var>chain</var>, unsigned int * <var>chain_len</var>, gnutls_x509_crt_t ** <var>extra_certs</var>, unsigned int * <var>extra_certs_len</var>, gnutls_x509_crl_t * <var>crl</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>p12</var>: A pkcs12 type
</p>
<p><var>password</var>: optional password used to decrypt the structure, bags and keys.
</p>
<p><var>key</var>: a structure to store the parsed private key.
</p>
<p><var>chain</var>: the corresponding to key certificate chain (may be <code>NULL</code> )
</p>
<p><var>chain_len</var>: will be updated with the number of additional (may be <code>NULL</code> )
</p>
<p><var>extra_certs</var>: optional pointer to receive an array of additional
certificates found in the PKCS12 structure (may be <code>NULL</code> ).
</p>
<p><var>extra_certs_len</var>: will be updated with the number of additional
certs (may be <code>NULL</code> ).
</p>
<p><var>crl</var>: an optional structure to store the parsed CRL (may be <code>NULL</code> ).
</p>
<p><var>flags</var>: should be zero or one of GNUTLS_PKCS12_SP_*
</p>
<p>This function parses a PKCS12 structure in  <code>pkcs12</code> and extracts the
private key, the corresponding certificate chain, any additional
certificates and a CRL. The structures in  <code>key</code> ,  <code>chain</code>  <code>crl</code> , and  <code>extra_certs</code> must not be initialized.
</p>
<p>The  <code>extra_certs</code> and  <code>extra_certs_len</code> parameters are optional
and both may be set to <code>NULL</code> . If either is non-<code>NULL</code> , then both must
be set. The value for  <code>extra_certs</code> is allocated
using <code>gnutls_malloc()</code> .
</p>
<p>Encrypted PKCS12 bags and PKCS8 private keys are supported, but
only with password based security and the same password for all
operations.
</p>
<p>Note that a PKCS12 structure may contain many keys and/or certificates,
and there is no way to identify which key/certificate pair you want.
For this reason this function is useful for PKCS12 files that contain 
only one key/certificate pair and/or one CRL.
</p>
<p>If the provided structure has encrypted fields but no password
is provided then this function returns <code>GNUTLS_E_DECRYPTION_FAILED</code> .
</p>
<p>Note that normally the chain constructed does not include self signed
certificates, to comply with TLS&rsquo; requirements. If, however, the flag 
<code>GNUTLS_PKCS12_SP_INCLUDE_SELF_SIGNED</code>  is specified then
self signed certificates will be included in the chain.
</p>
<p>Prior to using this function the PKCS <code>12</code>  structure integrity must
be verified using <code>gnutls_pkcs12_verify_mac()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.1.0
</p></dd></dl>

<span id="gnutls_005fpkcs12_005fverify_005fmac-1"></span><h4 class="subheading">gnutls_pkcs12_verify_mac</h4>
<span id="gnutls_005fpkcs12_005fverify_005fmac"></span><dl>
<dt id="index-gnutls_005fpkcs12_005fverify_005fmac">Function: <em>int</em> <strong>gnutls_pkcs12_verify_mac</strong> <em>(gnutls_pkcs12_t <var>pkcs12</var>, const char * <var>pass</var>)</em></dt>
<dd><p><var>pkcs12</var>: should contain a gnutls_pkcs12_t type
</p>
<p><var>pass</var>: The password for the MAC
</p>
<p>This function will verify the MAC for the PKCS12 structure.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>


<hr>
<span id="PKCS-11-API"></span><div class="header">
<p>
Next: <a href="#TPM-API" accesskey="n" rel="next">TPM API</a>, Previous: <a href="#PKCS-12-API" accesskey="p" rel="prev">PKCS 12 API</a>, Up: <a href="#API-reference" accesskey="u" rel="up">API reference</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Hardware-token-via-PKCS-11-API"></span><h3 class="section">E.7 Hardware token via PKCS 11 API</h3>

<p>The following functions are to be used for PKCS 11 handling.
Their prototypes lie in <samp>gnutls/pkcs11.h</samp>.
</p>

<span id="gnutls_005fpkcs11_005fadd_005fprovider-1"></span><h4 class="subheading">gnutls_pkcs11_add_provider</h4>
<span id="gnutls_005fpkcs11_005fadd_005fprovider"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fadd_005fprovider-1">Function: <em>int</em> <strong>gnutls_pkcs11_add_provider</strong> <em>(const char * <var>name</var>, const char * <var>params</var>)</em></dt>
<dd><p><var>name</var>: The filename of the module
</p>
<p><var>params</var>: should be NULL or a known string (see description)
</p>
<p>This function will load and add a PKCS 11 module to the module
list used in gnutls. After this function is called the module will
be used for PKCS 11 operations.
</p>
<p>When loading a module to be used for certificate verification,
use the string &rsquo;trusted&rsquo; as  <code>params</code> .
</p>
<p>Note that this function is not thread safe.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fpkcs11_005fcopy_005fattached_005fextension-1"></span><h4 class="subheading">gnutls_pkcs11_copy_attached_extension</h4>
<span id="gnutls_005fpkcs11_005fcopy_005fattached_005fextension"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fcopy_005fattached_005fextension">Function: <em>int</em> <strong>gnutls_pkcs11_copy_attached_extension</strong> <em>(const char * <var>token_url</var>, gnutls_x509_crt_t <var>crt</var>, gnutls_datum_t * <var>data</var>, const char * <var>label</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>token_url</var>: A PKCS <code>11</code>  URL specifying a token
</p>
<p><var>crt</var>: An X.509 certificate object
</p>
<p><var>data</var>: the attached extension
</p>
<p><var>label</var>: A name to be used for the attached extension (may be <code>NULL</code> )
</p>
<p><var>flags</var>: One of GNUTLS_PKCS11_OBJ_FLAG_*
</p>
<p>This function will copy an the attached extension in  <code>data</code> for
the certificate provided in  <code>crt</code> in the PKCS <code>11</code>  token specified
by the URL (typically a trust module). The extension must be in
RFC5280 Extension format.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.3.8
</p></dd></dl>

<span id="gnutls_005fpkcs11_005fcopy_005fpubkey-1"></span><h4 class="subheading">gnutls_pkcs11_copy_pubkey</h4>
<span id="gnutls_005fpkcs11_005fcopy_005fpubkey"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fcopy_005fpubkey">Function: <em>int</em> <strong>gnutls_pkcs11_copy_pubkey</strong> <em>(const char * <var>token_url</var>, gnutls_pubkey_t <var>pubkey</var>, const char * <var>label</var>, const gnutls_datum_t * <var>cid</var>, unsigned int <var>key_usage</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>token_url</var>: A PKCS <code>11</code>  URL specifying a token
</p>
<p><var>pubkey</var>: The public key to copy
</p>
<p><var>label</var>: The name to be used for the stored data
</p>
<p><var>cid</var>: The CKA_ID to set for the object -if NULL, the ID will be derived from the public key
</p>
<p><var>key_usage</var>: One of GNUTLS_KEY_*
</p>
<p><var>flags</var>: One of GNUTLS_PKCS11_OBJ_FLAG_*
</p>
<p>This function will copy a public key object into a PKCS <code>11</code>  token specified by
a URL. Valid flags to mark the key: <code>GNUTLS_PKCS11_OBJ_FLAG_MARK_TRUSTED</code> ,
<code>GNUTLS_PKCS11_OBJ_FLAG_MARK_PRIVATE</code> , <code>GNUTLS_PKCS11_OBJ_FLAG_MARK_CA</code> ,
<code>GNUTLS_PKCS11_OBJ_FLAG_MARK_ALWAYS_AUTH</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.4.6
</p></dd></dl>

<span id="gnutls_005fpkcs11_005fcopy_005fsecret_005fkey-1"></span><h4 class="subheading">gnutls_pkcs11_copy_secret_key</h4>
<span id="gnutls_005fpkcs11_005fcopy_005fsecret_005fkey"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fcopy_005fsecret_005fkey">Function: <em>int</em> <strong>gnutls_pkcs11_copy_secret_key</strong> <em>(const char * <var>token_url</var>, gnutls_datum_t * <var>key</var>, const char * <var>label</var>, unsigned int <var>key_usage</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>token_url</var>: A PKCS <code>11</code>  URL specifying a token
</p>
<p><var>key</var>: The raw key
</p>
<p><var>label</var>: A name to be used for the stored data
</p>
<p><var>key_usage</var>: One of GNUTLS_KEY_*
</p>
<p><var>flags</var>: One of GNUTLS_PKCS11_OBJ_FLAG_*
</p>
<p>This function will copy a raw secret (symmetric) key into a PKCS <code>11</code>  
token specified by a URL. The key can be marked as sensitive or not.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fpkcs11_005fcopy_005fx509_005fcrt-1"></span><h4 class="subheading">gnutls_pkcs11_copy_x509_crt</h4>
<span id="gnutls_005fpkcs11_005fcopy_005fx509_005fcrt"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fcopy_005fx509_005fcrt">Function: <em>int</em> <strong>gnutls_pkcs11_copy_x509_crt</strong> <em>(const char * <var>token_url</var>, gnutls_x509_crt_t <var>crt</var>, const char * <var>label</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>token_url</var>: A PKCS <code>11</code>  URL specifying a token
</p>
<p><var>crt</var>: A certificate
</p>
<p><var>label</var>: A name to be used for the stored data
</p>
<p><var>flags</var>: One of GNUTLS_PKCS11_OBJ_FLAG_*
</p>
<p>This function will copy a certificate into a PKCS <code>11</code>  token specified by
a URL. The certificate can be marked as trusted or not.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fpkcs11_005fcopy_005fx509_005fcrt2-1"></span><h4 class="subheading">gnutls_pkcs11_copy_x509_crt2</h4>
<span id="gnutls_005fpkcs11_005fcopy_005fx509_005fcrt2"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fcopy_005fx509_005fcrt2-1">Function: <em>int</em> <strong>gnutls_pkcs11_copy_x509_crt2</strong> <em>(const char * <var>token_url</var>, gnutls_x509_crt_t <var>crt</var>, const char * <var>label</var>, const gnutls_datum_t * <var>cid</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>token_url</var>: A PKCS <code>11</code>  URL specifying a token
</p>
<p><var>crt</var>: The certificate to copy
</p>
<p><var>label</var>: The name to be used for the stored data
</p>
<p><var>cid</var>: The CKA_ID to set for the object -if NULL, the ID will be derived from the public key
</p>
<p><var>flags</var>: One of GNUTLS_PKCS11_OBJ_FLAG_*
</p>
<p>This function will copy a certificate into a PKCS <code>11</code>  token specified by
a URL. Valid flags to mark the certificate: <code>GNUTLS_PKCS11_OBJ_FLAG_MARK_TRUSTED</code> ,
<code>GNUTLS_PKCS11_OBJ_FLAG_MARK_PRIVATE</code> , <code>GNUTLS_PKCS11_OBJ_FLAG_MARK_CA</code> ,
<code>GNUTLS_PKCS11_OBJ_FLAG_MARK_ALWAYS_AUTH</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fpkcs11_005fcopy_005fx509_005fprivkey-1"></span><h4 class="subheading">gnutls_pkcs11_copy_x509_privkey</h4>
<span id="gnutls_005fpkcs11_005fcopy_005fx509_005fprivkey"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fcopy_005fx509_005fprivkey">Function: <em>int</em> <strong>gnutls_pkcs11_copy_x509_privkey</strong> <em>(const char * <var>token_url</var>, gnutls_x509_privkey_t <var>key</var>, const char * <var>label</var>, unsigned int <var>key_usage</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>token_url</var>: A PKCS <code>11</code>  URL specifying a token
</p>
<p><var>key</var>: A private key
</p>
<p><var>label</var>: A name to be used for the stored data
</p>
<p><var>key_usage</var>: One of GNUTLS_KEY_*
</p>
<p><var>flags</var>: One of GNUTLS_PKCS11_OBJ_* flags
</p>
<p>This function will copy a private key into a PKCS <code>11</code>  token specified by
a URL.
</p>
<p>Since 3.6.3 the objects are marked as sensitive by default unless
<code>GNUTLS_PKCS11_OBJ_FLAG_MARK_NOT_SENSITIVE</code>  is specified.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fpkcs11_005fcopy_005fx509_005fprivkey2-1"></span><h4 class="subheading">gnutls_pkcs11_copy_x509_privkey2</h4>
<span id="gnutls_005fpkcs11_005fcopy_005fx509_005fprivkey2"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fcopy_005fx509_005fprivkey2-1">Function: <em>int</em> <strong>gnutls_pkcs11_copy_x509_privkey2</strong> <em>(const char * <var>token_url</var>, gnutls_x509_privkey_t <var>key</var>, const char * <var>label</var>, const gnutls_datum_t * <var>cid</var>, unsigned int <var>key_usage</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>token_url</var>: A PKCS <code>11</code>  URL specifying a token
</p>
<p><var>key</var>: A private key
</p>
<p><var>label</var>: A name to be used for the stored data
</p>
<p><var>cid</var>: The CKA_ID to set for the object -if NULL, the ID will be derived from the public key
</p>
<p><var>key_usage</var>: One of GNUTLS_KEY_*
</p>
<p><var>flags</var>: One of GNUTLS_PKCS11_OBJ_* flags
</p>
<p>This function will copy a private key into a PKCS <code>11</code>  token specified by
a URL.
</p>
<p>Since 3.6.3 the objects are marked as sensitive by default unless
<code>GNUTLS_PKCS11_OBJ_FLAG_MARK_NOT_SENSITIVE</code>  is specified.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fpkcs11_005fcrt_005fis_005fknown-1"></span><h4 class="subheading">gnutls_pkcs11_crt_is_known</h4>
<span id="gnutls_005fpkcs11_005fcrt_005fis_005fknown"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fcrt_005fis_005fknown">Function: <em>unsigned</em> <strong>gnutls_pkcs11_crt_is_known</strong> <em>(const char * <var>url</var>, gnutls_x509_crt_t <var>cert</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>url</var>: A PKCS 11 url identifying a token
</p>
<p><var>cert</var>: is the certificate to find issuer for
</p>
<p><var>flags</var>: Use zero or flags from <code>GNUTLS_PKCS11_OBJ_FLAG</code> .
</p>
<p>This function will check whether the provided certificate is stored
in the specified token. This is useful in combination with 
<code>GNUTLS_PKCS11_OBJ_FLAG_RETRIEVE_TRUSTED</code>  or
<code>GNUTLS_PKCS11_OBJ_FLAG_RETRIEVE_DISTRUSTED</code> ,
to check whether a CA is present or a certificate is blacklisted in
a trust PKCS <code>11</code>  module.
</p>
<p>This function can be used with a  <code>url</code> of &quot;pkcs11:&quot;, and in that case all modules
will be searched. To restrict the modules to the marked as trusted in p11-kit
use the <code>GNUTLS_PKCS11_OBJ_FLAG_PRESENT_IN_TRUSTED_MODULE</code>  flag.
</p>
<p>Note that the flag <code>GNUTLS_PKCS11_OBJ_FLAG_RETRIEVE_DISTRUSTED</code>  is
specific to p11-kit trust modules.
</p>
<p><strong>Returns:</strong> If the certificate exists non-zero is returned, otherwise zero.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fpkcs11_005fdeinit-1"></span><h4 class="subheading">gnutls_pkcs11_deinit</h4>
<span id="gnutls_005fpkcs11_005fdeinit"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fdeinit">Function: <em>void</em> <strong>gnutls_pkcs11_deinit</strong> <em>( <var>void</var>)</em></dt>
<dd>
<p>This function will deinitialize the PKCS 11 subsystem in gnutls.
This function is only needed if you need to deinitialize the
subsystem without calling <code>gnutls_global_deinit()</code> .
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fpkcs11_005fdelete_005furl-1"></span><h4 class="subheading">gnutls_pkcs11_delete_url</h4>
<span id="gnutls_005fpkcs11_005fdelete_005furl"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fdelete_005furl-1">Function: <em>int</em> <strong>gnutls_pkcs11_delete_url</strong> <em>(const char * <var>object_url</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>object_url</var>: The URL of the object to delete.
</p>
<p><var>flags</var>: One of GNUTLS_PKCS11_OBJ_* flags
</p>
<p>This function will delete objects matching the given URL.
Note that not all tokens support the delete operation.
</p>
<p><strong>Returns:</strong> On success, the number of objects deleted is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fpkcs11_005fget_005fpin_005ffunction-1"></span><h4 class="subheading">gnutls_pkcs11_get_pin_function</h4>
<span id="gnutls_005fpkcs11_005fget_005fpin_005ffunction"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fget_005fpin_005ffunction">Function: <em>gnutls_pin_callback_t</em> <strong>gnutls_pkcs11_get_pin_function</strong> <em>(void ** <var>userdata</var>)</em></dt>
<dd><p><var>userdata</var>: data to be supplied to callback
</p>
<p>This function will return the callback function set using
<code>gnutls_pkcs11_set_pin_function()</code> .
</p>
<p><strong>Returns:</strong> The function set or NULL otherwise.
</p>
<p><strong>Since:</strong> 3.1.0
</p></dd></dl>

<span id="gnutls_005fpkcs11_005fget_005fraw_005fissuer-1"></span><h4 class="subheading">gnutls_pkcs11_get_raw_issuer</h4>
<span id="gnutls_005fpkcs11_005fget_005fraw_005fissuer"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fget_005fraw_005fissuer">Function: <em>int</em> <strong>gnutls_pkcs11_get_raw_issuer</strong> <em>(const char * <var>url</var>, gnutls_x509_crt_t <var>cert</var>, gnutls_datum_t * <var>issuer</var>, gnutls_x509_crt_fmt_t <var>fmt</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>url</var>: A PKCS 11 url identifying a token
</p>
<p><var>cert</var>: is the certificate to find issuer for
</p>
<p><var>issuer</var>: Will hold the issuer if any in an allocated buffer.
</p>
<p><var>fmt</var>: The format of the exported issuer.
</p>
<p><var>flags</var>: Use zero or flags from <code>GNUTLS_PKCS11_OBJ_FLAG</code> .
</p>
<p>This function will return the issuer of a given certificate, if it
is stored in the token. By default only marked as trusted issuers
are returned. If any issuer should be returned specify
<code>GNUTLS_PKCS11_OBJ_FLAG_RETRIEVE_ANY</code>  in  <code>flags</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.2.7
</p></dd></dl>

<span id="gnutls_005fpkcs11_005fget_005fraw_005fissuer_005fby_005fdn-1"></span><h4 class="subheading">gnutls_pkcs11_get_raw_issuer_by_dn</h4>
<span id="gnutls_005fpkcs11_005fget_005fraw_005fissuer_005fby_005fdn"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fget_005fraw_005fissuer_005fby_005fdn">Function: <em>int</em> <strong>gnutls_pkcs11_get_raw_issuer_by_dn</strong> <em>(const char * <var>url</var>, const gnutls_datum_t * <var>dn</var>, gnutls_datum_t * <var>issuer</var>, gnutls_x509_crt_fmt_t <var>fmt</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>url</var>: A PKCS 11 url identifying a token
</p>
<p><var>dn</var>: is the DN to search for
</p>
<p><var>issuer</var>: Will hold the issuer if any in an allocated buffer.
</p>
<p><var>fmt</var>: The format of the exported issuer.
</p>
<p><var>flags</var>: Use zero or flags from <code>GNUTLS_PKCS11_OBJ_FLAG</code> .
</p>
<p>This function will return the certificate with the given DN, if it
is stored in the token. By default only marked as trusted issuers
are returned. If any issuer should be returned specify
<code>GNUTLS_PKCS11_OBJ_FLAG_RETRIEVE_ANY</code>  in  <code>flags</code> .
</p>
<p>The name of the function includes issuer because it can
be used to discover issuers of certificates.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fpkcs11_005fget_005fraw_005fissuer_005fby_005fsubject_005fkey_005fid-1"></span><h4 class="subheading">gnutls_pkcs11_get_raw_issuer_by_subject_key_id</h4>
<span id="gnutls_005fpkcs11_005fget_005fraw_005fissuer_005fby_005fsubject_005fkey_005fid"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fget_005fraw_005fissuer_005fby_005fsubject_005fkey_005fid">Function: <em>int</em> <strong>gnutls_pkcs11_get_raw_issuer_by_subject_key_id</strong> <em>(const char * <var>url</var>, const gnutls_datum_t * <var>dn</var>, const gnutls_datum_t * <var>spki</var>, gnutls_datum_t * <var>issuer</var>, gnutls_x509_crt_fmt_t <var>fmt</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>url</var>: A PKCS 11 url identifying a token
</p>
<p><var>dn</var>: is the DN to search for (may be <code>NULL</code> )
</p>
<p><var>spki</var>: is the subject key ID to search for
</p>
<p><var>issuer</var>: Will hold the issuer if any in an allocated buffer.
</p>
<p><var>fmt</var>: The format of the exported issuer.
</p>
<p><var>flags</var>: Use zero or flags from <code>GNUTLS_PKCS11_OBJ_FLAG</code> .
</p>
<p>This function will return the certificate with the given DN and  <code>spki</code> , if it
is stored in the token. By default only marked as trusted issuers
are returned. If any issuer should be returned specify
<code>GNUTLS_PKCS11_OBJ_FLAG_RETRIEVE_ANY</code>  in  <code>flags</code> .
</p>
<p>The name of the function includes issuer because it can
be used to discover issuers of certificates.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.4.2
</p></dd></dl>

<span id="gnutls_005fpkcs11_005finit-1"></span><h4 class="subheading">gnutls_pkcs11_init</h4>
<span id="gnutls_005fpkcs11_005finit"></span><dl>
<dt id="index-gnutls_005fpkcs11_005finit-1">Function: <em>int</em> <strong>gnutls_pkcs11_init</strong> <em>(unsigned int <var>flags</var>, const char * <var>deprecated_config_file</var>)</em></dt>
<dd><p><var>flags</var>: An ORed sequence of <code>GNUTLS_PKCS11_FLAG_</code> *
</p>
<p><var>deprecated_config_file</var>: either NULL or the location of a deprecated
configuration file
</p>
<p>This function will initialize the PKCS 11 subsystem in gnutls. It will
read configuration files if <code>GNUTLS_PKCS11_FLAG_AUTO</code>  is used or allow
you to independently load PKCS 11 modules using <code>gnutls_pkcs11_add_provider()</code> 
if <code>GNUTLS_PKCS11_FLAG_MANUAL</code>  is specified.
</p>
<p>You don&rsquo;t need to call this function since GnuTLS 3.3.0 because it is being called
during the first request PKCS 11 operation. That call will assume the <code>GNUTLS_PKCS11_FLAG_AUTO</code> 
flag. If another flags are required then it must be called independently
prior to any PKCS 11 operation.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fpkcs11_005fobj_005fdeinit-1"></span><h4 class="subheading">gnutls_pkcs11_obj_deinit</h4>
<span id="gnutls_005fpkcs11_005fobj_005fdeinit"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fobj_005fdeinit">Function: <em>void</em> <strong>gnutls_pkcs11_obj_deinit</strong> <em>(gnutls_pkcs11_obj_t <var>obj</var>)</em></dt>
<dd><p><var>obj</var>: The type to be deinitialized
</p>
<p>This function will deinitialize a certificate structure.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fpkcs11_005fobj_005fexport-1"></span><h4 class="subheading">gnutls_pkcs11_obj_export</h4>
<span id="gnutls_005fpkcs11_005fobj_005fexport"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fobj_005fexport">Function: <em>int</em> <strong>gnutls_pkcs11_obj_export</strong> <em>(gnutls_pkcs11_obj_t <var>obj</var>, void * <var>output_data</var>, size_t * <var>output_data_size</var>)</em></dt>
<dd><p><var>obj</var>: Holds the object
</p>
<p><var>output_data</var>: will contain the object data
</p>
<p><var>output_data_size</var>: holds the size of output_data (and will be
replaced by the actual size of parameters)
</p>
<p>This function will export the PKCS11 object data.  It is normal for
data to be inaccessible and in that case <code>GNUTLS_E_INVALID_REQUEST</code> 
will be returned.
</p>
<p>If the buffer provided is not long enough to hold the output, then
*output_data_size is updated and GNUTLS_E_SHORT_MEMORY_BUFFER will
be returned.
</p>
<p><strong>Returns:</strong> In case of failure a negative error code will be
returned, and <code>GNUTLS_E_SUCCESS</code>  (0) on success.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fpkcs11_005fobj_005fexport2-1"></span><h4 class="subheading">gnutls_pkcs11_obj_export2</h4>
<span id="gnutls_005fpkcs11_005fobj_005fexport2"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fobj_005fexport2">Function: <em>int</em> <strong>gnutls_pkcs11_obj_export2</strong> <em>(gnutls_pkcs11_obj_t <var>obj</var>, gnutls_datum_t * <var>out</var>)</em></dt>
<dd><p><var>obj</var>: Holds the object
</p>
<p><var>out</var>: will contain the object data
</p>
<p>This function will export the PKCS11 object data.  It is normal for
data to be inaccessible and in that case <code>GNUTLS_E_INVALID_REQUEST</code> 
will be returned.
</p>
<p>The output buffer is allocated using <code>gnutls_malloc()</code> .
</p>
<p><strong>Returns:</strong> In case of failure a negative error code will be
returned, and <code>GNUTLS_E_SUCCESS</code>  (0) on success.
</p>
<p><strong>Since:</strong> 3.1.3
</p></dd></dl>

<span id="gnutls_005fpkcs11_005fobj_005fexport3-1"></span><h4 class="subheading">gnutls_pkcs11_obj_export3</h4>
<span id="gnutls_005fpkcs11_005fobj_005fexport3"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fobj_005fexport3">Function: <em>int</em> <strong>gnutls_pkcs11_obj_export3</strong> <em>(gnutls_pkcs11_obj_t <var>obj</var>, gnutls_x509_crt_fmt_t <var>fmt</var>, gnutls_datum_t * <var>out</var>)</em></dt>
<dd><p><var>obj</var>: Holds the object
</p>
<p><var>fmt</var>: The format of the exported data
</p>
<p><var>out</var>: will contain the object data
</p>
<p>This function will export the PKCS11 object data.  It is normal for
data to be inaccessible and in that case <code>GNUTLS_E_INVALID_REQUEST</code> 
will be returned.
</p>
<p>The output buffer is allocated using <code>gnutls_malloc()</code> .
</p>
<p><strong>Returns:</strong> In case of failure a negative error code will be
returned, and <code>GNUTLS_E_SUCCESS</code>  (0) on success.
</p>
<p><strong>Since:</strong> 3.2.7
</p></dd></dl>

<span id="gnutls_005fpkcs11_005fobj_005fexport_005furl-1"></span><h4 class="subheading">gnutls_pkcs11_obj_export_url</h4>
<span id="gnutls_005fpkcs11_005fobj_005fexport_005furl"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fobj_005fexport_005furl">Function: <em>int</em> <strong>gnutls_pkcs11_obj_export_url</strong> <em>(gnutls_pkcs11_obj_t <var>obj</var>, gnutls_pkcs11_url_type_t <var>detailed</var>, char ** <var>url</var>)</em></dt>
<dd><p><var>obj</var>: Holds the PKCS 11 certificate
</p>
<p><var>detailed</var>: non zero if a detailed URL is required
</p>
<p><var>url</var>: will contain an allocated url
</p>
<p>This function will export a URL identifying the given object.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fpkcs11_005fobj_005fflags_005fget_005fstr-1"></span><h4 class="subheading">gnutls_pkcs11_obj_flags_get_str</h4>
<span id="gnutls_005fpkcs11_005fobj_005fflags_005fget_005fstr"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fobj_005fflags_005fget_005fstr">Function: <em>char *</em> <strong>gnutls_pkcs11_obj_flags_get_str</strong> <em>(unsigned int <var>flags</var>)</em></dt>
<dd><p><var>flags</var>: holds the flags
</p>
<p>This function given an or-sequence of <code>GNUTLS_PKCS11_OBJ_FLAG_MARK</code> ,
will return an allocated string with its description. The string
needs to be deallocated using <code>gnutls_free()</code> .
</p>
<p><strong>Returns:</strong> If flags is zero <code>NULL</code>  is returned, otherwise an allocated string.
</p>
<p><strong>Since:</strong> 3.3.7
</p></dd></dl>

<span id="gnutls_005fpkcs11_005fobj_005fget_005fexts-1"></span><h4 class="subheading">gnutls_pkcs11_obj_get_exts</h4>
<span id="gnutls_005fpkcs11_005fobj_005fget_005fexts"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fobj_005fget_005fexts">Function: <em>int</em> <strong>gnutls_pkcs11_obj_get_exts</strong> <em>(gnutls_pkcs11_obj_t <var>obj</var>, gnutls_x509_ext_st ** <var>exts</var>, unsigned int * <var>exts_size</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>obj</var>: should contain a <code>gnutls_pkcs11_obj_t</code>  type
</p>
<p><var>exts</var>: a pointer to a <code>gnutls_x509_ext_st</code>  pointer
</p>
<p><var>exts_size</var>: will be updated with the number of  <code>exts</code> 
</p>
<p><var>flags</var>: Or sequence of <code>GNUTLS_PKCS11_OBJ_</code> * flags 
</p>
<p>This function will return information about attached extensions
that associate to the provided object (which should be a certificate).
The extensions are the attached p11-kit trust module extensions.
</p>
<p>Each element of  <code>exts</code> must be deinitialized using <code>gnutls_x509_ext_deinit()</code> 
while  <code>exts</code> should be deallocated using <code>gnutls_free()</code> .
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  (0) on success or a negative error code on error.
</p>
<p><strong>Since:</strong> 3.3.8
</p></dd></dl>

<span id="gnutls_005fpkcs11_005fobj_005fget_005fflags-1"></span><h4 class="subheading">gnutls_pkcs11_obj_get_flags</h4>
<span id="gnutls_005fpkcs11_005fobj_005fget_005fflags"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fobj_005fget_005fflags">Function: <em>int</em> <strong>gnutls_pkcs11_obj_get_flags</strong> <em>(gnutls_pkcs11_obj_t <var>obj</var>, unsigned int * <var>oflags</var>)</em></dt>
<dd><p><var>obj</var>: The pkcs11 object
</p>
<p><var>oflags</var>: Will hold the output flags
</p>
<p>This function will return the flags of the object.
The  <code>oflags</code> will be flags from <code>gnutls_pkcs11_obj_flags</code> . That is,
the <code>GNUTLS_PKCS11_OBJ_FLAG_MARK_</code> * flags.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.3.7
</p></dd></dl>

<span id="gnutls_005fpkcs11_005fobj_005fget_005finfo-1"></span><h4 class="subheading">gnutls_pkcs11_obj_get_info</h4>
<span id="gnutls_005fpkcs11_005fobj_005fget_005finfo"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fobj_005fget_005finfo-1">Function: <em>int</em> <strong>gnutls_pkcs11_obj_get_info</strong> <em>(gnutls_pkcs11_obj_t <var>obj</var>, gnutls_pkcs11_obj_info_t <var>itype</var>, void * <var>output</var>, size_t * <var>output_size</var>)</em></dt>
<dd><p><var>obj</var>: should contain a <code>gnutls_pkcs11_obj_t</code>  type
</p>
<p><var>itype</var>: Denotes the type of information requested
</p>
<p><var>output</var>: where output will be stored
</p>
<p><var>output_size</var>: contains the maximum size of the output buffer and will be
overwritten with the actual size.
</p>
<p>This function will return information about the PKCS11 certificate
such as the label, id as well as token information where the key is
stored.
</p>
<p>When output is text, a null terminated string is written to  <code>output</code> and its
string length is written to  <code>output_size</code> (without null terminator). If the
buffer is too small,  <code>output_size</code> will contain the expected buffer size
(with null terminator for text) and return <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> .
</p>
<p>In versions previously to 3.6.0 this function included the null terminator
to  <code>output_size</code> . After 3.6.0 the output size doesn&rsquo;t include the terminator character.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  (0) on success or a negative error code on error.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fpkcs11_005fobj_005fget_005fptr-1"></span><h4 class="subheading">gnutls_pkcs11_obj_get_ptr</h4>
<span id="gnutls_005fpkcs11_005fobj_005fget_005fptr"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fobj_005fget_005fptr-1">Function: <em>int</em> <strong>gnutls_pkcs11_obj_get_ptr</strong> <em>(gnutls_pkcs11_obj_t <var>obj</var>, void ** <var>ptr</var>, void ** <var>session</var>, void ** <var>ohandle</var>, unsigned long * <var>slot_id</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>obj</var>: should contain a <code>gnutls_pkcs11_obj_t</code>  type
</p>
<p><var>ptr</var>: will contain the CK_FUNCTION_LIST_PTR pointer (may be <code>NULL</code> )
</p>
<p><var>session</var>: will contain the CK_SESSION_HANDLE of the object
</p>
<p><var>ohandle</var>: will contain the CK_OBJECT_HANDLE of the object
</p>
<p><var>slot_id</var>: the identifier of the slot (may be <code>NULL</code> )
</p>
<p><var>flags</var>: Or sequence of GNUTLS_PKCS11_OBJ_* flags
</p>
<p>Obtains the PKCS<code>11</code>  session handles of an object.  <code>session</code> and  <code>ohandle</code> must be deinitialized by the caller. The returned pointers are
independent of the  <code>obj</code> lifetime.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  (0) on success or a negative error code
on error.
</p>
<p><strong>Since:</strong> 3.6.3
</p></dd></dl>

<span id="gnutls_005fpkcs11_005fobj_005fget_005ftype-1"></span><h4 class="subheading">gnutls_pkcs11_obj_get_type</h4>
<span id="gnutls_005fpkcs11_005fobj_005fget_005ftype"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fobj_005fget_005ftype">Function: <em>gnutls_pkcs11_obj_type_t</em> <strong>gnutls_pkcs11_obj_get_type</strong> <em>(gnutls_pkcs11_obj_t <var>obj</var>)</em></dt>
<dd><p><var>obj</var>: Holds the PKCS 11 object
</p>
<p>This function will return the type of the object being
stored in the structure.
</p>
<p><strong>Returns:</strong> The type of the object
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fpkcs11_005fobj_005fimport_005furl-1"></span><h4 class="subheading">gnutls_pkcs11_obj_import_url</h4>
<span id="gnutls_005fpkcs11_005fobj_005fimport_005furl"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fobj_005fimport_005furl">Function: <em>int</em> <strong>gnutls_pkcs11_obj_import_url</strong> <em>(gnutls_pkcs11_obj_t <var>obj</var>, const char * <var>url</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>obj</var>: The structure to store the object
</p>
<p><var>url</var>: a PKCS 11 url identifying the key
</p>
<p><var>flags</var>: Or sequence of GNUTLS_PKCS11_OBJ_* flags
</p>
<p>This function will &quot;import&quot; a PKCS 11 URL identifying an object (e.g. certificate)
to the <code>gnutls_pkcs11_obj_t</code>  type. This does not involve any
parsing (such as X.509 or OpenPGP) since the <code>gnutls_pkcs11_obj_t</code>  is
format agnostic. Only data are transferred.
</p>
<p>If the flag <code>GNUTLS_PKCS11_OBJ_FLAG_OVERWRITE_TRUSTMOD_EXT</code>  is specified
any certificate read, will have its extensions overwritten by any
stapled extensions in the trust module.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fpkcs11_005fobj_005finit-1"></span><h4 class="subheading">gnutls_pkcs11_obj_init</h4>
<span id="gnutls_005fpkcs11_005fobj_005finit"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fobj_005finit">Function: <em>int</em> <strong>gnutls_pkcs11_obj_init</strong> <em>(gnutls_pkcs11_obj_t * <var>obj</var>)</em></dt>
<dd><p><var>obj</var>: A pointer to the type to be initialized
</p>
<p>This function will initialize a pkcs11 certificate structure.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fpkcs11_005fobj_005flist_005fimport_005furl3-1"></span><h4 class="subheading">gnutls_pkcs11_obj_list_import_url3</h4>
<span id="gnutls_005fpkcs11_005fobj_005flist_005fimport_005furl3"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fobj_005flist_005fimport_005furl3">Function: <em>int</em> <strong>gnutls_pkcs11_obj_list_import_url3</strong> <em>(gnutls_pkcs11_obj_t * <var>p_list</var>, unsigned int * <var>n_list</var>, const char * <var>url</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>p_list</var>: An uninitialized object list (may be <code>NULL</code> )
</p>
<p><var>n_list</var>: Initially should hold the maximum size of the list. Will contain the actual size.
</p>
<p><var>url</var>: A PKCS 11 url identifying a set of objects
</p>
<p><var>flags</var>: Or sequence of GNUTLS_PKCS11_OBJ_* flags
</p>
<p>This function will initialize and set values to an object list
by using all objects identified by a PKCS 11 URL.
</p>
<p>This function will enumerate all the objects specified by the PKCS<code>11</code>  URL
provided. It expects an already allocated  <code>p_list</code> which has * <code>n_list</code> elements,
and that value will be updated to the actual number of present objects. The
 <code>p_list</code> objects will be initialized and set by this function.
To obtain a list of all available objects use a  <code>url</code> of &rsquo;pkcs11:&rsquo;.
</p>
<p>All returned objects must be deinitialized using <code>gnutls_pkcs11_obj_deinit()</code> .
</p>
<p>The supported in this function  <code>flags</code> are <code>GNUTLS_PKCS11_OBJ_FLAG_LOGIN</code> ,
<code>GNUTLS_PKCS11_OBJ_FLAG_LOGIN_SO</code> , <code>GNUTLS_PKCS11_OBJ_FLAG_PRESENT_IN_TRUSTED_MODULE</code> ,
<code>GNUTLS_PKCS11_OBJ_FLAG_CRT</code> , <code>GNUTLS_PKCS11_OBJ_FLAG_PUBKEY</code> , <code>GNUTLS_PKCS11_OBJ_FLAG_PRIVKEY</code> ,
<code>GNUTLS_PKCS11_OBJ_FLAG_WITH_PRIVKEY</code> , <code>GNUTLS_PKCS11_OBJ_FLAG_MARK_CA</code> ,
<code>GNUTLS_PKCS11_OBJ_FLAG_MARK_TRUSTED</code> , and since 3.5.1 the <code>GNUTLS_PKCS11_OBJ_FLAG_OVERWRITE_TRUSTMOD_EXT</code> .
</p>
<p>On versions of GnuTLS prior to 3.4.0 the equivalent function was
<code>gnutls_pkcs11_obj_list_import_url()</code> . That is also available on this version
as a macro which maps to this function.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fpkcs11_005fobj_005flist_005fimport_005furl4-1"></span><h4 class="subheading">gnutls_pkcs11_obj_list_import_url4</h4>
<span id="gnutls_005fpkcs11_005fobj_005flist_005fimport_005furl4"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fobj_005flist_005fimport_005furl4">Function: <em>int</em> <strong>gnutls_pkcs11_obj_list_import_url4</strong> <em>(gnutls_pkcs11_obj_t ** <var>p_list</var>, unsigned int * <var>n_list</var>, const char * <var>url</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>p_list</var>: An uninitialized object list (may be NULL)
</p>
<p><var>n_list</var>: It will contain the size of the list.
</p>
<p><var>url</var>: A PKCS 11 url identifying a set of objects
</p>
<p><var>flags</var>: Or sequence of GNUTLS_PKCS11_OBJ_* flags
</p>
<p>This function will enumerate all the objects specified by the PKCS<code>11</code>  URL
provided. It will initialize and set values to the object pointer list ( <code>p_list</code> )
provided. To obtain a list of all available objects use a  <code>url</code> of &rsquo;pkcs11:&rsquo;.
</p>
<p>All returned objects must be deinitialized using <code>gnutls_pkcs11_obj_deinit()</code> ,
and  <code>p_list</code> must be deinitialized using <code>gnutls_free()</code> .
</p>
<p>The supported in this function  <code>flags</code> are <code>GNUTLS_PKCS11_OBJ_FLAG_LOGIN</code> ,
<code>GNUTLS_PKCS11_OBJ_FLAG_LOGIN_SO</code> , <code>GNUTLS_PKCS11_OBJ_FLAG_PRESENT_IN_TRUSTED_MODULE</code> ,
<code>GNUTLS_PKCS11_OBJ_FLAG_CRT</code> , <code>GNUTLS_PKCS11_OBJ_FLAG_PUBKEY</code> , <code>GNUTLS_PKCS11_OBJ_FLAG_PRIVKEY</code> ,
<code>GNUTLS_PKCS11_OBJ_FLAG_WITH_PRIVKEY</code> , <code>GNUTLS_PKCS11_OBJ_FLAG_MARK_CA</code> ,
<code>GNUTLS_PKCS11_OBJ_FLAG_MARK_TRUSTED</code> , and since 3.5.1 the <code>GNUTLS_PKCS11_OBJ_FLAG_OVERWRITE_TRUSTMOD_EXT</code> .
</p>
<p>On versions of GnuTLS prior to 3.4.0 the equivalent function was
<code>gnutls_pkcs11_obj_list_import_url2()</code> . That is also available on this version
as a macro which maps to this function.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fpkcs11_005fobj_005fset_005finfo-1"></span><h4 class="subheading">gnutls_pkcs11_obj_set_info</h4>
<span id="gnutls_005fpkcs11_005fobj_005fset_005finfo"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fobj_005fset_005finfo">Function: <em>int</em> <strong>gnutls_pkcs11_obj_set_info</strong> <em>(gnutls_pkcs11_obj_t <var>obj</var>, gnutls_pkcs11_obj_info_t <var>itype</var>, const void * <var>data</var>, size_t <var>data_size</var>, unsigned <var>flags</var>)</em></dt>
<dd><p><var>obj</var>: should contain a <code>gnutls_pkcs11_obj_t</code>  type
</p>
<p><var>itype</var>: Denotes the type of information to be set
</p>
<p><var>data</var>: the data to set
</p>
<p><var>data_size</var>: the size of data
</p>
<p><var>flags</var>: Or sequence of GNUTLS_PKCS11_OBJ_* flags
</p>
<p>This function will set attributes on the provided object.
Available options for  <code>itype</code> are <code>GNUTLS_PKCS11_OBJ_LABEL</code> ,
<code>GNUTLS_PKCS11_OBJ_ID_HEX</code> , and <code>GNUTLS_PKCS11_OBJ_ID</code> .
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  (0) on success or a negative error code on error.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fpkcs11_005fobj_005fset_005fpin_005ffunction-1"></span><h4 class="subheading">gnutls_pkcs11_obj_set_pin_function</h4>
<span id="gnutls_005fpkcs11_005fobj_005fset_005fpin_005ffunction"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fobj_005fset_005fpin_005ffunction">Function: <em>void</em> <strong>gnutls_pkcs11_obj_set_pin_function</strong> <em>(gnutls_pkcs11_obj_t <var>obj</var>, gnutls_pin_callback_t <var>fn</var>, void * <var>userdata</var>)</em></dt>
<dd><p><var>obj</var>: The object structure
</p>
<p><var>fn</var>: the callback
</p>
<p><var>userdata</var>: data associated with the callback
</p>
<p>This function will set a callback function to be used when
required to access the object. This function overrides the global
set using <code>gnutls_pkcs11_set_pin_function()</code> .
</p>
<p><strong>Since:</strong> 3.1.0
</p></dd></dl>

<span id="gnutls_005fpkcs11_005fprivkey_005fcpy-1"></span><h4 class="subheading">gnutls_pkcs11_privkey_cpy</h4>
<span id="gnutls_005fpkcs11_005fprivkey_005fcpy"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fprivkey_005fcpy">Function: <em>int</em> <strong>gnutls_pkcs11_privkey_cpy</strong> <em>(gnutls_pkcs11_privkey_t <var>dst</var>, gnutls_pkcs11_privkey_t <var>src</var>)</em></dt>
<dd><p><var>dst</var>: The destination key, which should be initialized.
</p>
<p><var>src</var>: The source key
</p>
<p>This function will copy a private key from source to destination
key. Destination has to be initialized.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fpkcs11_005fprivkey_005fdeinit-1"></span><h4 class="subheading">gnutls_pkcs11_privkey_deinit</h4>
<span id="gnutls_005fpkcs11_005fprivkey_005fdeinit"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fprivkey_005fdeinit">Function: <em>void</em> <strong>gnutls_pkcs11_privkey_deinit</strong> <em>(gnutls_pkcs11_privkey_t <var>key</var>)</em></dt>
<dd><p><var>key</var>: the key to be deinitialized
</p>
<p>This function will deinitialize a private key structure.
</p></dd></dl>

<span id="gnutls_005fpkcs11_005fprivkey_005fexport_005fpubkey-1"></span><h4 class="subheading">gnutls_pkcs11_privkey_export_pubkey</h4>
<span id="gnutls_005fpkcs11_005fprivkey_005fexport_005fpubkey"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fprivkey_005fexport_005fpubkey">Function: <em>int</em> <strong>gnutls_pkcs11_privkey_export_pubkey</strong> <em>(gnutls_pkcs11_privkey_t <var>pkey</var>, gnutls_x509_crt_fmt_t <var>fmt</var>, gnutls_datum_t * <var>data</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>pkey</var>: The private key
</p>
<p><var>fmt</var>: the format of output params. PEM or DER.
</p>
<p><var>data</var>: will hold the public key
</p>
<p><var>flags</var>: should be zero
</p>
<p>This function will extract the public key (modulus and public
exponent) from the private key specified by the  <code>url</code> private key.
This public key will be stored in  <code>pubkey</code> in the format specified
by  <code>fmt</code> .  <code>pubkey</code> should be deinitialized using <code>gnutls_free()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.3.7
</p></dd></dl>

<span id="gnutls_005fpkcs11_005fprivkey_005fexport_005furl-1"></span><h4 class="subheading">gnutls_pkcs11_privkey_export_url</h4>
<span id="gnutls_005fpkcs11_005fprivkey_005fexport_005furl"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fprivkey_005fexport_005furl">Function: <em>int</em> <strong>gnutls_pkcs11_privkey_export_url</strong> <em>(gnutls_pkcs11_privkey_t <var>key</var>, gnutls_pkcs11_url_type_t <var>detailed</var>, char ** <var>url</var>)</em></dt>
<dd><p><var>key</var>: Holds the PKCS 11 key
</p>
<p><var>detailed</var>: non zero if a detailed URL is required
</p>
<p><var>url</var>: will contain an allocated url
</p>
<p>This function will export a URL identifying the given key.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fpkcs11_005fprivkey_005fgenerate-1"></span><h4 class="subheading">gnutls_pkcs11_privkey_generate</h4>
<span id="gnutls_005fpkcs11_005fprivkey_005fgenerate"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fprivkey_005fgenerate">Function: <em>int</em> <strong>gnutls_pkcs11_privkey_generate</strong> <em>(const char * <var>url</var>, gnutls_pk_algorithm_t <var>pk</var>, unsigned int <var>bits</var>, const char * <var>label</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>url</var>: a token URL
</p>
<p><var>pk</var>: the public key algorithm
</p>
<p><var>bits</var>: the security bits
</p>
<p><var>label</var>: a label
</p>
<p><var>flags</var>: should be zero
</p>
<p>This function will generate a private key in the specified
by the  <code>url</code> token. The private key will be generate within
the token and will not be exportable.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fpkcs11_005fprivkey_005fgenerate2-1"></span><h4 class="subheading">gnutls_pkcs11_privkey_generate2</h4>
<span id="gnutls_005fpkcs11_005fprivkey_005fgenerate2"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fprivkey_005fgenerate2">Function: <em>int</em> <strong>gnutls_pkcs11_privkey_generate2</strong> <em>(const char * <var>url</var>, gnutls_pk_algorithm_t <var>pk</var>, unsigned int <var>bits</var>, const char * <var>label</var>, gnutls_x509_crt_fmt_t <var>fmt</var>, gnutls_datum_t * <var>pubkey</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>url</var>: a token URL
</p>
<p><var>pk</var>: the public key algorithm
</p>
<p><var>bits</var>: the security bits
</p>
<p><var>label</var>: a label
</p>
<p><var>fmt</var>: the format of output params. PEM or DER
</p>
<p><var>pubkey</var>: will hold the public key (may be <code>NULL</code> )
</p>
<p><var>flags</var>: zero or an OR&rsquo;ed sequence of <code>GNUTLS_PKCS11_OBJ_FLAGs</code> 
</p>
<p>This function will generate a private key in the specified
by the  <code>url</code> token. The private key will be generate within
the token and will not be exportable. This function will
store the DER-encoded public key in the SubjectPublicKeyInfo format
in  <code>pubkey</code> . The  <code>pubkey</code> should be deinitialized using <code>gnutls_free()</code> .
</p>
<p>Note that when generating an elliptic curve key, the curve
can be substituted in the place of the bits parameter using the
<code>GNUTLS_CURVE_TO_BITS()</code>  macro.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.1.5
</p></dd></dl>

<span id="gnutls_005fpkcs11_005fprivkey_005fgenerate3-1"></span><h4 class="subheading">gnutls_pkcs11_privkey_generate3</h4>
<span id="gnutls_005fpkcs11_005fprivkey_005fgenerate3"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fprivkey_005fgenerate3">Function: <em>int</em> <strong>gnutls_pkcs11_privkey_generate3</strong> <em>(const char * <var>url</var>, gnutls_pk_algorithm_t <var>pk</var>, unsigned int <var>bits</var>, const char * <var>label</var>, const gnutls_datum_t * <var>cid</var>, gnutls_x509_crt_fmt_t <var>fmt</var>, gnutls_datum_t * <var>pubkey</var>, unsigned int <var>key_usage</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>url</var>: a token URL
</p>
<p><var>pk</var>: the public key algorithm
</p>
<p><var>bits</var>: the security bits
</p>
<p><var>label</var>: a label
</p>
<p><var>cid</var>: The CKA_ID to use for the new object
</p>
<p><var>fmt</var>: the format of output params. PEM or DER
</p>
<p><var>pubkey</var>: will hold the public key (may be <code>NULL</code> )
</p>
<p><var>key_usage</var>: One of GNUTLS_KEY_*
</p>
<p><var>flags</var>: zero or an OR&rsquo;ed sequence of <code>GNUTLS_PKCS11_OBJ_FLAGs</code> 
</p>
<p>This function will generate a private key in the specified
by the  <code>url</code> token. The private key will be generate within
the token and will not be exportable. This function will
store the DER-encoded public key in the SubjectPublicKeyInfo format 
in  <code>pubkey</code> . The  <code>pubkey</code> should be deinitialized using <code>gnutls_free()</code> .
</p>
<p>Note that when generating an elliptic curve key, the curve
can be substituted in the place of the bits parameter using the
<code>GNUTLS_CURVE_TO_BITS()</code>  macro.
</p>
<p>Since 3.6.3 the objects are marked as sensitive by default unless
<code>GNUTLS_PKCS11_OBJ_FLAG_MARK_NOT_SENSITIVE</code>  is specified.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fpkcs11_005fprivkey_005fget_005finfo-1"></span><h4 class="subheading">gnutls_pkcs11_privkey_get_info</h4>
<span id="gnutls_005fpkcs11_005fprivkey_005fget_005finfo"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fprivkey_005fget_005finfo">Function: <em>int</em> <strong>gnutls_pkcs11_privkey_get_info</strong> <em>(gnutls_pkcs11_privkey_t <var>pkey</var>, gnutls_pkcs11_obj_info_t <var>itype</var>, void * <var>output</var>, size_t * <var>output_size</var>)</em></dt>
<dd><p><var>pkey</var>: should contain a <code>gnutls_pkcs11_privkey_t</code>  type
</p>
<p><var>itype</var>: Denotes the type of information requested
</p>
<p><var>output</var>: where output will be stored
</p>
<p><var>output_size</var>: contains the maximum size of the output and will be overwritten with actual
</p>
<p>This function will return information about the PKCS 11 private key such
as the label, id as well as token information where the key is stored. When
output is text it returns null terminated string although <code>output_size</code>  contains
the size of the actual data only.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  (0) on success or a negative error code on error.
</p></dd></dl>

<span id="gnutls_005fpkcs11_005fprivkey_005fget_005fpk_005falgorithm-1"></span><h4 class="subheading">gnutls_pkcs11_privkey_get_pk_algorithm</h4>
<span id="gnutls_005fpkcs11_005fprivkey_005fget_005fpk_005falgorithm"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fprivkey_005fget_005fpk_005falgorithm">Function: <em>int</em> <strong>gnutls_pkcs11_privkey_get_pk_algorithm</strong> <em>(gnutls_pkcs11_privkey_t <var>key</var>, unsigned int * <var>bits</var>)</em></dt>
<dd><p><var>key</var>: should contain a <code>gnutls_pkcs11_privkey_t</code>  type
</p>
<p><var>bits</var>: if bits is non null it will hold the size of the parameters&rsquo; in bits
</p>
<p>This function will return the public key algorithm of a private
key.
</p>
<p><strong>Returns:</strong> a member of the <code>gnutls_pk_algorithm_t</code>  enumeration on
success, or a negative error code on error.
</p></dd></dl>

<span id="gnutls_005fpkcs11_005fprivkey_005fimport_005furl-1"></span><h4 class="subheading">gnutls_pkcs11_privkey_import_url</h4>
<span id="gnutls_005fpkcs11_005fprivkey_005fimport_005furl"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fprivkey_005fimport_005furl">Function: <em>int</em> <strong>gnutls_pkcs11_privkey_import_url</strong> <em>(gnutls_pkcs11_privkey_t <var>pkey</var>, const char * <var>url</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>pkey</var>: The private key
</p>
<p><var>url</var>: a PKCS 11 url identifying the key
</p>
<p><var>flags</var>: Or sequence of GNUTLS_PKCS11_OBJ_* flags
</p>
<p>This function will &quot;import&quot; a PKCS 11 URL identifying a private
key to the <code>gnutls_pkcs11_privkey_t</code>  type. In reality since
in most cases keys cannot be exported, the private key structure
is being associated with the available operations on the token.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fpkcs11_005fprivkey_005finit-1"></span><h4 class="subheading">gnutls_pkcs11_privkey_init</h4>
<span id="gnutls_005fpkcs11_005fprivkey_005finit"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fprivkey_005finit">Function: <em>int</em> <strong>gnutls_pkcs11_privkey_init</strong> <em>(gnutls_pkcs11_privkey_t * <var>key</var>)</em></dt>
<dd><p><var>key</var>: A pointer to the type to be initialized
</p>
<p>This function will initialize an private key structure. This
structure can be used for accessing an underlying PKCS<code>11</code>  object.
</p>
<p>In versions of GnuTLS later than 3.5.11 the object is protected
using locks and a single <code>gnutls_pkcs11_privkey_t</code>  can be re-used
by many threads. However, for performance it is recommended to utilize
one object per key per thread.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fpkcs11_005fprivkey_005fset_005fpin_005ffunction-1"></span><h4 class="subheading">gnutls_pkcs11_privkey_set_pin_function</h4>
<span id="gnutls_005fpkcs11_005fprivkey_005fset_005fpin_005ffunction"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fprivkey_005fset_005fpin_005ffunction">Function: <em>void</em> <strong>gnutls_pkcs11_privkey_set_pin_function</strong> <em>(gnutls_pkcs11_privkey_t <var>key</var>, gnutls_pin_callback_t <var>fn</var>, void * <var>userdata</var>)</em></dt>
<dd><p><var>key</var>: The private key
</p>
<p><var>fn</var>: the callback
</p>
<p><var>userdata</var>: data associated with the callback
</p>
<p>This function will set a callback function to be used when
required to access the object. This function overrides the global
set using <code>gnutls_pkcs11_set_pin_function()</code> .
</p>
<p><strong>Since:</strong> 3.1.0
</p></dd></dl>

<span id="gnutls_005fpkcs11_005fprivkey_005fstatus-1"></span><h4 class="subheading">gnutls_pkcs11_privkey_status</h4>
<span id="gnutls_005fpkcs11_005fprivkey_005fstatus"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fprivkey_005fstatus">Function: <em>unsigned</em> <strong>gnutls_pkcs11_privkey_status</strong> <em>(gnutls_pkcs11_privkey_t <var>key</var>)</em></dt>
<dd><p><var>key</var>: Holds the key
</p>
<p>Checks the status of the private key token.
</p>
<p><strong>Returns:</strong> this function will return non-zero if the token
holding the private key is still available (inserted), and zero otherwise.
</p>
<p><strong>Since:</strong> 3.1.9
</p></dd></dl>

<span id="gnutls_005fpkcs11_005freinit-1"></span><h4 class="subheading">gnutls_pkcs11_reinit</h4>
<span id="gnutls_005fpkcs11_005freinit"></span><dl>
<dt id="index-gnutls_005fpkcs11_005freinit">Function: <em>int</em> <strong>gnutls_pkcs11_reinit</strong> <em>( <var>void</var>)</em></dt>
<dd>
<p>This function will reinitialize the PKCS 11 subsystem in gnutls. 
This is required by PKCS 11 when an application uses <code>fork()</code> . The
reinitialization function must be called on the child.
</p>
<p>Note that since GnuTLS 3.3.0, the reinitialization of the PKCS <code>11</code> 
subsystem occurs automatically after fork.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fpkcs11_005fset_005fpin_005ffunction-1"></span><h4 class="subheading">gnutls_pkcs11_set_pin_function</h4>
<span id="gnutls_005fpkcs11_005fset_005fpin_005ffunction"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fset_005fpin_005ffunction">Function: <em>void</em> <strong>gnutls_pkcs11_set_pin_function</strong> <em>(gnutls_pin_callback_t <var>fn</var>, void * <var>userdata</var>)</em></dt>
<dd><p><var>fn</var>: The PIN callback, a <code>gnutls_pin_callback_t()</code>  function.
</p>
<p><var>userdata</var>: data to be supplied to callback
</p>
<p>This function will set a callback function to be used when a PIN is
required for PKCS 11 operations.  See
<code>gnutls_pin_callback_t()</code>  on how the callback should behave.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fpkcs11_005fset_005ftoken_005ffunction-1"></span><h4 class="subheading">gnutls_pkcs11_set_token_function</h4>
<span id="gnutls_005fpkcs11_005fset_005ftoken_005ffunction"></span><dl>
<dt id="index-gnutls_005fpkcs11_005fset_005ftoken_005ffunction">Function: <em>void</em> <strong>gnutls_pkcs11_set_token_function</strong> <em>(gnutls_pkcs11_token_callback_t <var>fn</var>, void * <var>userdata</var>)</em></dt>
<dd><p><var>fn</var>: The token callback
</p>
<p><var>userdata</var>: data to be supplied to callback
</p>
<p>This function will set a callback function to be used when a token
needs to be inserted to continue PKCS 11 operations.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fpkcs11_005ftoken_005fcheck_005fmechanism-1"></span><h4 class="subheading">gnutls_pkcs11_token_check_mechanism</h4>
<span id="gnutls_005fpkcs11_005ftoken_005fcheck_005fmechanism"></span><dl>
<dt id="index-gnutls_005fpkcs11_005ftoken_005fcheck_005fmechanism">Function: <em>unsigned</em> <strong>gnutls_pkcs11_token_check_mechanism</strong> <em>(const char * <var>url</var>, unsigned long <var>mechanism</var>, void * <var>ptr</var>, unsigned <var>psize</var>, unsigned <var>flags</var>)</em></dt>
<dd><p><var>url</var>: should contain a PKCS 11 URL
</p>
<p><var>mechanism</var>: The PKCS <code>11</code>  mechanism ID
</p>
<p><var>ptr</var>: if set it should point to a CK_MECHANISM_INFO struct
</p>
<p><var>psize</var>: the size of CK_MECHANISM_INFO struct (for safety)
</p>
<p><var>flags</var>: must be zero
</p>
<p>This function will return whether a mechanism is supported
by the given token. If the mechanism is supported and
 <code>ptr</code> is set, it will be updated with the token information.
</p>
<p><strong>Returns:</strong> Non-zero if the mechanism is supported or zero otherwise.
</p>
<p><strong>Since:</strong> 3.6.0
</p></dd></dl>

<span id="gnutls_005fpkcs11_005ftoken_005fget_005fflags-1"></span><h4 class="subheading">gnutls_pkcs11_token_get_flags</h4>
<span id="gnutls_005fpkcs11_005ftoken_005fget_005fflags"></span><dl>
<dt id="index-gnutls_005fpkcs11_005ftoken_005fget_005fflags">Function: <em>int</em> <strong>gnutls_pkcs11_token_get_flags</strong> <em>(const char * <var>url</var>, unsigned int * <var>flags</var>)</em></dt>
<dd><p><var>url</var>: should contain a PKCS 11 URL
</p>
<p><var>flags</var>: The output flags (GNUTLS_PKCS11_TOKEN_*)
</p>
<p>This function will return information about the PKCS 11 token flags.
</p>
<p>The supported flags are: <code>GNUTLS_PKCS11_TOKEN_HW</code>  and <code>GNUTLS_PKCS11_TOKEN_TRUSTED</code> .
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  (0) on success or a negative error code on error.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fpkcs11_005ftoken_005fget_005finfo-1"></span><h4 class="subheading">gnutls_pkcs11_token_get_info</h4>
<span id="gnutls_005fpkcs11_005ftoken_005fget_005finfo"></span><dl>
<dt id="index-gnutls_005fpkcs11_005ftoken_005fget_005finfo">Function: <em>int</em> <strong>gnutls_pkcs11_token_get_info</strong> <em>(const char * <var>url</var>, gnutls_pkcs11_token_info_t <var>ttype</var>, void * <var>output</var>, size_t * <var>output_size</var>)</em></dt>
<dd><p><var>url</var>: should contain a PKCS 11 URL
</p>
<p><var>ttype</var>: Denotes the type of information requested
</p>
<p><var>output</var>: where output will be stored
</p>
<p><var>output_size</var>: contains the maximum size of the output buffer and will be
overwritten with the actual size.
</p>
<p>This function will return information about the PKCS 11 token such
as the label, id, etc.
</p>
<p>When output is text, a null terminated string is written to  <code>output</code> and its
string length is written to  <code>output_size</code> (without null terminator). If the
buffer is too small,  <code>output_size</code> will contain the expected buffer size
(with null terminator for text) and return <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> .
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  (0) on success or a negative error code
on error.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fpkcs11_005ftoken_005fget_005fmechanism-1"></span><h4 class="subheading">gnutls_pkcs11_token_get_mechanism</h4>
<span id="gnutls_005fpkcs11_005ftoken_005fget_005fmechanism"></span><dl>
<dt id="index-gnutls_005fpkcs11_005ftoken_005fget_005fmechanism">Function: <em>int</em> <strong>gnutls_pkcs11_token_get_mechanism</strong> <em>(const char * <var>url</var>, unsigned int <var>idx</var>, unsigned long * <var>mechanism</var>)</em></dt>
<dd><p><var>url</var>: should contain a PKCS 11 URL
</p>
<p><var>idx</var>: The index of the mechanism
</p>
<p><var>mechanism</var>: The PKCS <code>11</code>  mechanism ID
</p>
<p>This function will return the names of the supported mechanisms
by the token. It should be called with an increasing index until
it return GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  (0) on success or a negative error code on error.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fpkcs11_005ftoken_005fget_005fptr-1"></span><h4 class="subheading">gnutls_pkcs11_token_get_ptr</h4>
<span id="gnutls_005fpkcs11_005ftoken_005fget_005fptr"></span><dl>
<dt id="index-gnutls_005fpkcs11_005ftoken_005fget_005fptr-1">Function: <em>int</em> <strong>gnutls_pkcs11_token_get_ptr</strong> <em>(const char * <var>url</var>, void ** <var>ptr</var>, unsigned long * <var>slot_id</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>url</var>: should contain a PKCS<code>11</code>  URL identifying a token
</p>
<p><var>ptr</var>: will contain the CK_FUNCTION_LIST_PTR pointer
</p>
<p><var>slot_id</var>: will contain the slot_id (may be <code>NULL</code> )
</p>
<p><var>flags</var>: should be zero
</p>
<p>This function will return the function pointer of the specified
token by the URL. The returned pointers are valid until
gnutls is deinitialized, c.f. <code>_global_deinit()</code> .
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  (0) on success or a negative error code
on error.
</p>
<p><strong>Since:</strong> 3.6.3
</p></dd></dl>

<span id="gnutls_005fpkcs11_005ftoken_005fget_005frandom-1"></span><h4 class="subheading">gnutls_pkcs11_token_get_random</h4>
<span id="gnutls_005fpkcs11_005ftoken_005fget_005frandom"></span><dl>
<dt id="index-gnutls_005fpkcs11_005ftoken_005fget_005frandom">Function: <em>int</em> <strong>gnutls_pkcs11_token_get_random</strong> <em>(const char * <var>token_url</var>, void * <var>rnddata</var>, size_t <var>len</var>)</em></dt>
<dd><p><var>token_url</var>: A PKCS <code>11</code>  URL specifying a token
</p>
<p><var>rnddata</var>: A pointer to the memory area to be filled with random data
</p>
<p><var>len</var>: The number of bytes of randomness to request
</p>
<p>This function will get random data from the given token.
It will store rnddata and fill the memory pointed to by rnddata with
len random bytes from the token.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fpkcs11_005ftoken_005fget_005furl-1"></span><h4 class="subheading">gnutls_pkcs11_token_get_url</h4>
<span id="gnutls_005fpkcs11_005ftoken_005fget_005furl"></span><dl>
<dt id="index-gnutls_005fpkcs11_005ftoken_005fget_005furl">Function: <em>int</em> <strong>gnutls_pkcs11_token_get_url</strong> <em>(unsigned int <var>seq</var>, gnutls_pkcs11_url_type_t <var>detailed</var>, char ** <var>url</var>)</em></dt>
<dd><p><var>seq</var>: sequence number starting from 0
</p>
<p><var>detailed</var>: non zero if a detailed URL is required
</p>
<p><var>url</var>: will contain an allocated url
</p>
<p>This function will return the URL for each token available
in system. The url has to be released using <code>gnutls_free()</code> 
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned,
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>  if the sequence number
exceeds the available tokens, otherwise a negative error value.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fpkcs11_005ftoken_005finit-1"></span><h4 class="subheading">gnutls_pkcs11_token_init</h4>
<span id="gnutls_005fpkcs11_005ftoken_005finit"></span><dl>
<dt id="index-gnutls_005fpkcs11_005ftoken_005finit">Function: <em>int</em> <strong>gnutls_pkcs11_token_init</strong> <em>(const char * <var>token_url</var>, const char * <var>so_pin</var>, const char * <var>label</var>)</em></dt>
<dd><p><var>token_url</var>: A PKCS <code>11</code>  URL specifying a token
</p>
<p><var>so_pin</var>: Security Officer&rsquo;s PIN
</p>
<p><var>label</var>: A name to be used for the token
</p>
<p>This function will initialize (format) a token. If the token is
at a factory defaults state the security officer&rsquo;s PIN given will be
set to be the default. Otherwise it should match the officer&rsquo;s PIN.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fpkcs11_005ftoken_005fset_005fpin-1"></span><h4 class="subheading">gnutls_pkcs11_token_set_pin</h4>
<span id="gnutls_005fpkcs11_005ftoken_005fset_005fpin"></span><dl>
<dt id="index-gnutls_005fpkcs11_005ftoken_005fset_005fpin">Function: <em>int</em> <strong>gnutls_pkcs11_token_set_pin</strong> <em>(const char * <var>token_url</var>, const char * <var>oldpin</var>, const char * <var>newpin</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>token_url</var>: A PKCS <code>11</code>  URL specifying a token
</p>
<p><var>oldpin</var>: old user&rsquo;s PIN
</p>
<p><var>newpin</var>: new user&rsquo;s PIN
</p>
<p><var>flags</var>: one of <code>gnutls_pin_flag_t</code> .
</p>
<p>This function will modify or set a user or administrator&rsquo;s PIN for
the given token.  If it is called to set a PIN for first time
the oldpin must be <code>NULL</code> . When setting the admin&rsquo;s PIN with the
<code>GNUTLS_PIN_SO</code>  flag, the  <code>oldpin</code> value must be provided (this requirement
is relaxed after GnuTLS 3.6.5 since which the PIN will be requested if missing).
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fpkcs11_005ftype_005fget_005fname-1"></span><h4 class="subheading">gnutls_pkcs11_type_get_name</h4>
<span id="gnutls_005fpkcs11_005ftype_005fget_005fname"></span><dl>
<dt id="index-gnutls_005fpkcs11_005ftype_005fget_005fname">Function: <em>const char *</em> <strong>gnutls_pkcs11_type_get_name</strong> <em>(gnutls_pkcs11_obj_type_t <var>type</var>)</em></dt>
<dd><p><var>type</var>: Holds the PKCS 11 object type, a <code>gnutls_pkcs11_obj_type_t</code> .
</p>
<p>This function will return a human readable description of the
PKCS11 object type  <code>obj</code> .  It will return &quot;Unknown&quot; for unknown
types.
</p>
<p><strong>Returns:</strong> human readable string labeling the PKCS11 object type
 <code>type</code> .
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fimport_005fpkcs11-1"></span><h4 class="subheading">gnutls_x509_crt_import_pkcs11</h4>
<span id="gnutls_005fx509_005fcrt_005fimport_005fpkcs11"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fimport_005fpkcs11">Function: <em>int</em> <strong>gnutls_x509_crt_import_pkcs11</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_pkcs11_obj_t <var>pkcs11_crt</var>)</em></dt>
<dd><p><var>crt</var>: A certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>pkcs11_crt</var>: A PKCS 11 object that contains a certificate
</p>
<p>This function will import a PKCS 11 certificate to a <code>gnutls_x509_crt_t</code> 
structure.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005flist_005fimport_005fpkcs11-1"></span><h4 class="subheading">gnutls_x509_crt_list_import_pkcs11</h4>
<span id="gnutls_005fx509_005fcrt_005flist_005fimport_005fpkcs11"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005flist_005fimport_005fpkcs11">Function: <em>int</em> <strong>gnutls_x509_crt_list_import_pkcs11</strong> <em>(gnutls_x509_crt_t * <var>certs</var>, unsigned int <var>cert_max</var>, gnutls_pkcs11_obj_t * const <var>objs</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>certs</var>: A list of certificates of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>cert_max</var>: The maximum size of the list
</p>
<p><var>objs</var>: A list of PKCS 11 objects
</p>
<p><var>flags</var>: 0 for now
</p>
<p>This function will import a PKCS 11 certificate list to a list of 
<code>gnutls_x509_crt_t</code>  type. These must not be initialized.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>


<hr>
<span id="TPM-API"></span><div class="header">
<p>
Next: <a href="#Abstract-key-API" accesskey="n" rel="next">Abstract key API</a>, Previous: <a href="#PKCS-11-API" accesskey="p" rel="prev">PKCS 11 API</a>, Up: <a href="#API-reference" accesskey="u" rel="up">API reference</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="TPM-API-1"></span><h3 class="section">E.8 TPM API</h3>

<p>The following functions are to be used for TPM handling.
Their prototypes lie in <samp>gnutls/tpm.h</samp>.
</p>

<span id="gnutls_005ftpm_005fget_005fregistered-1"></span><h4 class="subheading">gnutls_tpm_get_registered</h4>
<span id="gnutls_005ftpm_005fget_005fregistered"></span><dl>
<dt id="index-gnutls_005ftpm_005fget_005fregistered">Function: <em>int</em> <strong>gnutls_tpm_get_registered</strong> <em>(gnutls_tpm_key_list_t * <var>list</var>)</em></dt>
<dd><p><var>list</var>: a list to store the keys
</p>
<p>This function will get a list of stored keys in the TPM. The uuid
of those keys
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.1.0
</p></dd></dl>

<span id="gnutls_005ftpm_005fkey_005flist_005fdeinit-1"></span><h4 class="subheading">gnutls_tpm_key_list_deinit</h4>
<span id="gnutls_005ftpm_005fkey_005flist_005fdeinit"></span><dl>
<dt id="index-gnutls_005ftpm_005fkey_005flist_005fdeinit">Function: <em>void</em> <strong>gnutls_tpm_key_list_deinit</strong> <em>(gnutls_tpm_key_list_t <var>list</var>)</em></dt>
<dd><p><var>list</var>: a list of the keys
</p>
<p>This function will deinitialize the list of stored keys in the TPM.
</p>
<p><strong>Since:</strong> 3.1.0
</p></dd></dl>

<span id="gnutls_005ftpm_005fkey_005flist_005fget_005furl-1"></span><h4 class="subheading">gnutls_tpm_key_list_get_url</h4>
<span id="gnutls_005ftpm_005fkey_005flist_005fget_005furl"></span><dl>
<dt id="index-gnutls_005ftpm_005fkey_005flist_005fget_005furl">Function: <em>int</em> <strong>gnutls_tpm_key_list_get_url</strong> <em>(gnutls_tpm_key_list_t <var>list</var>, unsigned int <var>idx</var>, char ** <var>url</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>list</var>: a list of the keys
</p>
<p><var>idx</var>: The index of the key (starting from zero)
</p>
<p><var>url</var>: The URL to be returned
</p>
<p><var>flags</var>: should be zero
</p>
<p>This function will return for each given index a URL of
the corresponding key.
If the provided index is out of bounds then <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
is returned.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.1.0
</p></dd></dl>

<span id="gnutls_005ftpm_005fprivkey_005fdelete-1"></span><h4 class="subheading">gnutls_tpm_privkey_delete</h4>
<span id="gnutls_005ftpm_005fprivkey_005fdelete"></span><dl>
<dt id="index-gnutls_005ftpm_005fprivkey_005fdelete-2">Function: <em>int</em> <strong>gnutls_tpm_privkey_delete</strong> <em>(const char * <var>url</var>, const char * <var>srk_password</var>)</em></dt>
<dd><p><var>url</var>: the URL describing the key
</p>
<p><var>srk_password</var>: a password for the SRK key
</p>
<p>This function will unregister the private key from the TPM
chip. 
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.1.0
</p></dd></dl>

<span id="gnutls_005ftpm_005fprivkey_005fgenerate-1"></span><h4 class="subheading">gnutls_tpm_privkey_generate</h4>
<span id="gnutls_005ftpm_005fprivkey_005fgenerate"></span><dl>
<dt id="index-gnutls_005ftpm_005fprivkey_005fgenerate-1">Function: <em>int</em> <strong>gnutls_tpm_privkey_generate</strong> <em>(gnutls_pk_algorithm_t <var>pk</var>, unsigned int <var>bits</var>, const char * <var>srk_password</var>, const char * <var>key_password</var>, gnutls_tpmkey_fmt_t <var>format</var>, gnutls_x509_crt_fmt_t <var>pub_format</var>, gnutls_datum_t * <var>privkey</var>, gnutls_datum_t * <var>pubkey</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>pk</var>: the public key algorithm
</p>
<p><var>bits</var>: the security bits
</p>
<p><var>srk_password</var>: a password to protect the exported key (optional)
</p>
<p><var>key_password</var>: the password for the TPM (optional)
</p>
<p><var>format</var>: the format of the private key
</p>
<p><var>pub_format</var>: the format of the public key
</p>
<p><var>privkey</var>: the generated key
</p>
<p><var>pubkey</var>: the corresponding public key (may be null)
</p>
<p><var>flags</var>: should be a list of GNUTLS_TPM_* flags
</p>
<p>This function will generate a private key in the TPM
chip. The private key will be generated within the chip
and will be exported in a wrapped with TPM&rsquo;s master key
form. Furthermore the wrapped key can be protected with
the provided  <code>password</code> .
</p>
<p>Note that bits in TPM is quantized value. If the input value
is not one of the allowed values, then it will be quantized to
one of 512, 1024, 2048, 4096, 8192 and 16384.
</p>
<p>Allowed flags are:
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.1.0
</p></dd></dl>


<hr>
<span id="Abstract-key-API"></span><div class="header">
<p>
Next: <a href="#Socket-specific-API" accesskey="n" rel="next">Socket specific API</a>, Previous: <a href="#TPM-API" accesskey="p" rel="prev">TPM API</a>, Up: <a href="#API-reference" accesskey="u" rel="up">API reference</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Abstract-key-API-1"></span><h3 class="section">E.9 Abstract key API</h3>

<p>The following functions are to be used for abstract key handling.
Their prototypes lie in <samp>gnutls/abstract.h</samp>.
</p>

<span id="gnutls_005fcertificate_005fset_005fkey-1"></span><h4 class="subheading">gnutls_certificate_set_key</h4>
<span id="gnutls_005fcertificate_005fset_005fkey"></span><dl>
<dt id="index-gnutls_005fcertificate_005fset_005fkey-1">Function: <em>int</em> <strong>gnutls_certificate_set_key</strong> <em>(gnutls_certificate_credentials_t <var>res</var>, const char ** <var>names</var>, int <var>names_size</var>, gnutls_pcert_st * <var>pcert_list</var>, int <var>pcert_list_size</var>, gnutls_privkey_t <var>key</var>)</em></dt>
<dd><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>names</var>: is an array of DNS names belonging to the public-key (NULL if none)
</p>
<p><var>names_size</var>: holds the size of the names list
</p>
<p><var>pcert_list</var>: contains a certificate list (chain) or raw public-key
</p>
<p><var>pcert_list_size</var>: holds the size of the certificate list
</p>
<p><var>key</var>: is a <code>gnutls_privkey_t</code>  key corresponding to the first public-key in pcert_list
</p>
<p>This function sets a public/private key pair in the
gnutls_certificate_credentials_t type. The given public key may be encapsulated
in a certificate or can be given as a raw key. This function may be
called more than once, in case multiple key pairs exist for
the server. For clients that want to send more than their own end-
entity certificate (e.g., also an intermediate CA cert), the full
certificate chain must be provided in  <code>pcert_list</code> .
</p>
<p>Note that the  <code>key</code> will become part of the credentials structure and must
not be deallocated. It will be automatically deallocated when the  <code>res</code> structure
is deinitialized.
</p>
<p>If this function fails, the  <code>res</code> structure is at an undefined state and it must
not be reused to load other keys or certificates.
</p>
<p>Note that, this function by default returns zero on success and a negative value on error.
Since 3.5.6, when the flag <code>GNUTLS_CERTIFICATE_API_V2</code>  is set using <code>gnutls_certificate_set_flags()</code> 
it returns an index (greater or equal to zero). That index can be used for other functions to refer to the added key-pair.
</p>
<p>Since GnuTLS 3.6.6 this function also handles raw public keys.
</p>
<p><strong>Returns:</strong> On success this functions returns zero, and otherwise a negative value on error (see above for modifying that behavior).
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fcertificate_005fset_005fretrieve_005ffunction2-1"></span><h4 class="subheading">gnutls_certificate_set_retrieve_function2</h4>
<span id="gnutls_005fcertificate_005fset_005fretrieve_005ffunction2"></span><dl>
<dt id="index-gnutls_005fcertificate_005fset_005fretrieve_005ffunction2">Function: <em>void</em> <strong>gnutls_certificate_set_retrieve_function2</strong> <em>(gnutls_certificate_credentials_t <var>cred</var>, gnutls_certificate_retrieve_function2 * <var>func</var>)</em></dt>
<dd><p><var>cred</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>func</var>: is the callback function
</p>
<p>This function sets a callback to be called in order to retrieve the
certificate to be used in the handshake. The callback will take control
only if a certificate is requested by the peer.
</p>
<p>The callback&rsquo;s function prototype is:
int (*callback)(gnutls_session_t, const gnutls_datum_t* req_ca_dn, int nreqs,
const gnutls_pk_algorithm_t* pk_algos, int pk_algos_length, gnutls_pcert_st** pcert,
unsigned int *pcert_length, gnutls_privkey_t * pkey);
</p>
<p><code>req_ca_dn</code> is only used in X.509 certificates.
Contains a list with the CA names that the server considers trusted.
This is a hint and typically the client should send a certificate that is signed
by one of these CAs. These names, when available, are DER encoded. To get a more
meaningful value use the function <code>gnutls_x509_rdn_get()</code> .
</p>
<p><code>pk_algos</code> contains a list with server&rsquo;s acceptable public key algorithms.
The certificate returned should support the server&rsquo;s given algorithms.
</p>
<p><code>pcert</code> should contain a single certificate and public key or a list of them.
</p>
<p><code>pcert_length</code> is the size of the previous list.
</p>
<p><code>pkey</code> is the private key.
</p>
<p>If the callback function is provided then gnutls will call it, in the
handshake, after the certificate request message has been received.
All the provided by the callback values will not be released or
modified by gnutls.
</p>
<p>In server side pk_algos and req_ca_dn are NULL.
</p>
<p>The callback function should set the certificate list to be sent,
and return 0 on success. If no certificate was selected then the
number of certificates should be set to zero. The value (-1)
indicates error and the handshake will be terminated. If both certificates
are set in the credentials and a callback is available, the callback
takes predence.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fcertificate_005fset_005fretrieve_005ffunction3-1"></span><h4 class="subheading">gnutls_certificate_set_retrieve_function3</h4>
<span id="gnutls_005fcertificate_005fset_005fretrieve_005ffunction3"></span><dl>
<dt id="index-gnutls_005fcertificate_005fset_005fretrieve_005ffunction3">Function: <em>void</em> <strong>gnutls_certificate_set_retrieve_function3</strong> <em>(gnutls_certificate_credentials_t <var>cred</var>, gnutls_certificate_retrieve_function3 * <var>func</var>)</em></dt>
<dd><p><var>cred</var>: is a <code>gnutls_certificate_credentials_t</code>  type.
</p>
<p><var>func</var>: is the callback function
</p>
<p>This function sets a callback to be called in order to retrieve the
certificate and OCSP responses to be used in the handshake.  <code>func</code> will
be called only if the peer requests a certificate either during handshake
or during post-handshake authentication.
</p>
<p>The callback&rsquo;s function prototype is defined in &lsquo;abstract.h&rsquo;:
</p>
<p>int gnutls_certificate_retrieve_function3(
gnutls_session_t,
const struct gnutls_cert_retr_st *info,
gnutls_pcert_st **certs,
unsigned int *pcert_length,
gnutls_ocsp_data_st **ocsp,
unsigned int *ocsp_length,
gnutls_privkey_t *privkey,
unsigned int *flags);
</p>
<p>The info field of the callback contains:
 <code>req_ca_dn</code> which is a list with the CA names that the server considers trusted.
This is a hint and typically the client should send a certificate that is signed
by one of these CAs. These names, when available, are DER encoded. To get a more
meaningful value use the function <code>gnutls_x509_rdn_get()</code> .
 <code>pk_algos</code> contains a list with server&rsquo;s acceptable public key algorithms.
The certificate returned should support the server&rsquo;s given algorithms.
</p>
<p>The callback should fill-in the following values.
</p>
<p><code>pcert</code> should contain an allocated list of certificates and public keys.
 <code>pcert_length</code> is the size of the previous list.
 <code>ocsp</code> should contain an allocated list of OCSP responses.
 <code>ocsp_length</code> is the size of the previous list.
 <code>pkey</code> is the private key.
</p>
<p>If flags in the callback are set to <code>GNUTLS_CERT_RETR_DEINIT_ALL</code>  then
all provided values must be allocated using <code>gnutls_malloc()</code> , and will
be released by gnutls; otherwise they will not be touched by gnutls.
</p>
<p>The callback function should set the certificate and OCSP response
list to be sent, and return 0 on success. If no certificates are available,
the  <code>pcert_length</code> and  <code>ocsp_length</code> should be set to zero. The return
value (-1) indicates error and the handshake will be terminated. If both
certificates are set in the credentials and a callback is available, the
callback takes predence.
</p>
<p><strong>Since:</strong> 3.6.3
</p></dd></dl>

<span id="gnutls_005fpcert_005fdeinit-1"></span><h4 class="subheading">gnutls_pcert_deinit</h4>
<span id="gnutls_005fpcert_005fdeinit"></span><dl>
<dt id="index-gnutls_005fpcert_005fdeinit">Function: <em>void</em> <strong>gnutls_pcert_deinit</strong> <em>(gnutls_pcert_st * <var>pcert</var>)</em></dt>
<dd><p><var>pcert</var>: The structure to be deinitialized
</p>
<p>This function will deinitialize a pcert structure.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fpcert_005fexport_005fopenpgp-1"></span><h4 class="subheading">gnutls_pcert_export_openpgp</h4>
<span id="gnutls_005fpcert_005fexport_005fopenpgp"></span><dl>
<dt id="index-gnutls_005fpcert_005fexport_005fopenpgp">Function: <em>int</em> <strong>gnutls_pcert_export_openpgp</strong> <em>(gnutls_pcert_st * <var>pcert</var>, gnutls_openpgp_crt_t * <var>crt</var>)</em></dt>
<dd><p><var>pcert</var>: The pcert structure.
</p>
<p><var>crt</var>: An initialized <code>gnutls_openpgp_crt_t</code> .
</p>
<p>This function is no-op.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_UNIMPLEMENTED_FEATURE</code> .
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fpcert_005fexport_005fx509-1"></span><h4 class="subheading">gnutls_pcert_export_x509</h4>
<span id="gnutls_005fpcert_005fexport_005fx509"></span><dl>
<dt id="index-gnutls_005fpcert_005fexport_005fx509">Function: <em>int</em> <strong>gnutls_pcert_export_x509</strong> <em>(gnutls_pcert_st * <var>pcert</var>, gnutls_x509_crt_t * <var>crt</var>)</em></dt>
<dd><p><var>pcert</var>: The pcert structure.
</p>
<p><var>crt</var>: An initialized <code>gnutls_x509_crt_t</code> .
</p>
<p>Converts the given <code>gnutls_pcert_t</code>  type into a <code>gnutls_x509_crt_t</code> .
This function only works if the type of  <code>pcert</code> is <code>GNUTLS_CRT_X509</code> .
When successful, the value written to  <code>crt</code> must be freed with
<code>gnutls_x509_crt_deinit()</code>  when no longer needed.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fpcert_005fimport_005fopenpgp-1"></span><h4 class="subheading">gnutls_pcert_import_openpgp</h4>
<span id="gnutls_005fpcert_005fimport_005fopenpgp"></span><dl>
<dt id="index-gnutls_005fpcert_005fimport_005fopenpgp">Function: <em>int</em> <strong>gnutls_pcert_import_openpgp</strong> <em>(gnutls_pcert_st * <var>pcert</var>, gnutls_openpgp_crt_t <var>crt</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>pcert</var>: The pcert structure
</p>
<p><var>crt</var>: The raw certificate to be imported
</p>
<p><var>flags</var>: zero for now
</p>
<p>This function is no-op.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_UNIMPLEMENTED_FEATURE</code> .
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fpcert_005fimport_005fopenpgp_005fraw-1"></span><h4 class="subheading">gnutls_pcert_import_openpgp_raw</h4>
<span id="gnutls_005fpcert_005fimport_005fopenpgp_005fraw"></span><dl>
<dt id="index-gnutls_005fpcert_005fimport_005fopenpgp_005fraw">Function: <em>int</em> <strong>gnutls_pcert_import_openpgp_raw</strong> <em>(gnutls_pcert_st * <var>pcert</var>, const gnutls_datum_t * <var>cert</var>, gnutls_openpgp_crt_fmt_t         <var>format</var>, gnutls_openpgp_keyid_t <var>keyid</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>pcert</var>: The pcert structure
</p>
<p><var>cert</var>: The raw certificate to be imported
</p>
<p><var>format</var>: The format of the certificate
</p>
<p><var>keyid</var>: The key ID to use (NULL for the master key)
</p>
<p><var>flags</var>: zero for now
</p>
<p>This function is no-op.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_UNIMPLEMENTED_FEATURE</code> .
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fpcert_005fimport_005frawpk-1"></span><h4 class="subheading">gnutls_pcert_import_rawpk</h4>
<span id="gnutls_005fpcert_005fimport_005frawpk"></span><dl>
<dt id="index-gnutls_005fpcert_005fimport_005frawpk">Function: <em>int</em> <strong>gnutls_pcert_import_rawpk</strong> <em>(gnutls_pcert_st* <var>pcert</var>, gnutls_pubkey_t <var>pubkey</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>pcert</var>: The pcert structure to import the data into.
</p>
<p><var>pubkey</var>: The raw public-key in <code>gnutls_pubkey_t</code>  format to be imported
</p>
<p><var>flags</var>: zero for now
</p>
<p>This convenience function will import (i.e. convert) the given raw
public key  <code>pubkey</code> into a <code>gnutls_pcert_st</code>  structure. The structure
must be deinitialized afterwards using <code>gnutls_pcert_deinit()</code> . The
given  <code>pubkey</code> must not be deinitialized because it will be associated
with the given  <code>pcert</code> structure and will be deinitialized with it.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.6.6
</p></dd></dl>

<span id="gnutls_005fpcert_005fimport_005frawpk_005fraw-1"></span><h4 class="subheading">gnutls_pcert_import_rawpk_raw</h4>
<span id="gnutls_005fpcert_005fimport_005frawpk_005fraw"></span><dl>
<dt id="index-gnutls_005fpcert_005fimport_005frawpk_005fraw">Function: <em>int</em> <strong>gnutls_pcert_import_rawpk_raw</strong> <em>(gnutls_pcert_st* <var>pcert</var>, const gnutls_datum_t* <var>rawpubkey</var>, gnutls_x509_crt_fmt_t <var>format</var>, unsigned int <var>key_usage</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>pcert</var>: The pcert structure to import the data into.
</p>
<p><var>rawpubkey</var>: The raw public-key in <code>gnutls_datum_t</code>  format to be imported.
</p>
<p><var>format</var>: The format of the raw public-key. DER or PEM.
</p>
<p><var>key_usage</var>: An ORed sequence of <code>GNUTLS_KEY_</code> * flags.
</p>
<p><var>flags</var>: zero for now
</p>
<p>This convenience function will import (i.e. convert) the given raw
public key  <code>rawpubkey</code> into a <code>gnutls_pcert_st</code>  structure. The structure
must be deinitialized afterwards using <code>gnutls_pcert_deinit()</code> .
Note that the caller is responsible for freeing  <code>rawpubkey</code> . All necessary
values will be copied into  <code>pcert</code> .
</p>
<p>Key usage (as defined by X.509 extension (2.5.29.15)) can be explicitly
set because there is no certificate structure around the key to define
this value. See for more info <code>gnutls_x509_crt_get_key_usage()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.6.6
</p></dd></dl>

<span id="gnutls_005fpcert_005fimport_005fx509-1"></span><h4 class="subheading">gnutls_pcert_import_x509</h4>
<span id="gnutls_005fpcert_005fimport_005fx509"></span><dl>
<dt id="index-gnutls_005fpcert_005fimport_005fx509">Function: <em>int</em> <strong>gnutls_pcert_import_x509</strong> <em>(gnutls_pcert_st * <var>pcert</var>, gnutls_x509_crt_t <var>crt</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>pcert</var>: The pcert structure
</p>
<p><var>crt</var>: The certificate to be imported
</p>
<p><var>flags</var>: zero for now
</p>
<p>This convenience function will import the given certificate to a
<code>gnutls_pcert_st</code>  structure. The structure must be deinitialized
afterwards using <code>gnutls_pcert_deinit()</code> ;
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fpcert_005fimport_005fx509_005flist-1"></span><h4 class="subheading">gnutls_pcert_import_x509_list</h4>
<span id="gnutls_005fpcert_005fimport_005fx509_005flist"></span><dl>
<dt id="index-gnutls_005fpcert_005fimport_005fx509_005flist">Function: <em>int</em> <strong>gnutls_pcert_import_x509_list</strong> <em>(gnutls_pcert_st * <var>pcert_list</var>, gnutls_x509_crt_t * <var>crt</var>, unsigned * <var>ncrt</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>pcert_list</var>: The structures to store the certificates; must not contain initialized <code>gnutls_pcert_st</code>  structures.
</p>
<p><var>crt</var>: The certificates to be imported
</p>
<p><var>ncrt</var>: The number of certificates in  <code>crt</code> ; will be updated if necessary
</p>
<p><var>flags</var>: zero or <code>GNUTLS_X509_CRT_LIST_SORT</code> 
</p>
<p>This convenience function will import the given certificates to an
already allocated set of <code>gnutls_pcert_st</code>  structures. The structures must
be deinitialized afterwards using <code>gnutls_pcert_deinit()</code> .  <code>pcert_list</code> should contain space for at least  <code>ncrt</code> elements.
</p>
<p>In the case <code>GNUTLS_X509_CRT_LIST_SORT</code>  is specified and that
function cannot sort the list, <code>GNUTLS_E_CERTIFICATE_LIST_UNSORTED</code> 
will be returned. Currently sorting can fail if the list size
exceeds an internal constraint (16).
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fpcert_005fimport_005fx509_005fraw-1"></span><h4 class="subheading">gnutls_pcert_import_x509_raw</h4>
<span id="gnutls_005fpcert_005fimport_005fx509_005fraw"></span><dl>
<dt id="index-gnutls_005fpcert_005fimport_005fx509_005fraw">Function: <em>int</em> <strong>gnutls_pcert_import_x509_raw</strong> <em>(gnutls_pcert_st * <var>pcert</var>, const gnutls_datum_t * <var>cert</var>, gnutls_x509_crt_fmt_t <var>format</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>pcert</var>: The pcert structure
</p>
<p><var>cert</var>: The raw certificate to be imported
</p>
<p><var>format</var>: The format of the certificate
</p>
<p><var>flags</var>: zero for now
</p>
<p>This convenience function will import the given certificate to a
<code>gnutls_pcert_st</code>  structure. The structure must be deinitialized
afterwards using <code>gnutls_pcert_deinit()</code> ;
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fpcert_005flist_005fimport_005fx509_005ffile-1"></span><h4 class="subheading">gnutls_pcert_list_import_x509_file</h4>
<span id="gnutls_005fpcert_005flist_005fimport_005fx509_005ffile"></span><dl>
<dt id="index-gnutls_005fpcert_005flist_005fimport_005fx509_005ffile">Function: <em>int</em> <strong>gnutls_pcert_list_import_x509_file</strong> <em>(gnutls_pcert_st * <var>pcert_list</var>, unsigned * <var>pcert_list_size</var>, const char * <var>file</var>, gnutls_x509_crt_fmt_t <var>format</var>, gnutls_pin_callback_t <var>pin_fn</var>, void * <var>pin_fn_userdata</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>pcert_list</var>: The structures to store the certificates; must not contain initialized <code>gnutls_pcert_st</code>  structures.
</p>
<p><var>pcert_list_size</var>: Initially must hold the maximum number of certs. It will be updated with the number of certs available.
</p>
<p><var>file</var>: A file or supported URI with the certificates to load
</p>
<p><var>format</var>: <code>GNUTLS_X509_FMT_DER</code>  or <code>GNUTLS_X509_FMT_PEM</code>  if a file is given
</p>
<p><var>pin_fn</var>: a PIN callback if not globally set
</p>
<p><var>pin_fn_userdata</var>: parameter for the PIN callback
</p>
<p><var>flags</var>: zero or flags from <code>gnutls_certificate_import_flags</code> 
</p>
<p>This convenience function will import a certificate chain from the given
file or supported URI to <code>gnutls_pcert_st</code>  structures. The structures
must be deinitialized afterwards using <code>gnutls_pcert_deinit()</code> .
</p>
<p>This function will always return a sorted certificate chain.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value; if the  <code>pcert</code> list doesn&rsquo;t have enough space
<code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  will be returned.
</p>
<p><strong>Since:</strong> 3.6.3
</p></dd></dl>

<span id="gnutls_005fpcert_005flist_005fimport_005fx509_005fraw-1"></span><h4 class="subheading">gnutls_pcert_list_import_x509_raw</h4>
<span id="gnutls_005fpcert_005flist_005fimport_005fx509_005fraw"></span><dl>
<dt id="index-gnutls_005fpcert_005flist_005fimport_005fx509_005fraw">Function: <em>int</em> <strong>gnutls_pcert_list_import_x509_raw</strong> <em>(gnutls_pcert_st * <var>pcert_list</var>, unsigned int * <var>pcert_list_size</var>, const gnutls_datum_t * <var>data</var>, gnutls_x509_crt_fmt_t <var>format</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>pcert_list</var>: The structures to store the certificates; must not contain initialized <code>gnutls_pcert_st</code>  structures.
</p>
<p><var>pcert_list_size</var>: Initially must hold the maximum number of certs. It will be updated with the number of certs available.
</p>
<p><var>data</var>: The certificates.
</p>
<p><var>format</var>: One of DER or PEM.
</p>
<p><var>flags</var>: must be (0) or an OR&rsquo;d sequence of gnutls_certificate_import_flags.
</p>
<p>This function will import the provided DER or PEM encoded certificates to an
already allocated set of <code>gnutls_pcert_st</code>  structures. The structures must
be deinitialized afterwards using <code>gnutls_pcert_deinit()</code> .  <code>pcert_list</code> should contain space for at least  <code>pcert_list_size</code> elements.
</p>
<p>If the Certificate is PEM encoded it should have a header of &quot;X509
CERTIFICATE&quot;, or &quot;CERTIFICATE&quot;.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value; if the  <code>pcert</code> list doesn&rsquo;t have enough space
<code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  will be returned.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fprivkey_005fdecrypt_005fdata-1"></span><h4 class="subheading">gnutls_privkey_decrypt_data</h4>
<span id="gnutls_005fprivkey_005fdecrypt_005fdata"></span><dl>
<dt id="index-gnutls_005fprivkey_005fdecrypt_005fdata-1">Function: <em>int</em> <strong>gnutls_privkey_decrypt_data</strong> <em>(gnutls_privkey_t <var>key</var>, unsigned int <var>flags</var>, const gnutls_datum_t * <var>ciphertext</var>, gnutls_datum_t * <var>plaintext</var>)</em></dt>
<dd><p><var>key</var>: Holds the key
</p>
<p><var>flags</var>: zero for now
</p>
<p><var>ciphertext</var>: holds the data to be decrypted
</p>
<p><var>plaintext</var>: will contain the decrypted data, allocated with <code>gnutls_malloc()</code> 
</p>
<p>This function will decrypt the given data using the algorithm
supported by the private key.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fprivkey_005fdecrypt_005fdata2-1"></span><h4 class="subheading">gnutls_privkey_decrypt_data2</h4>
<span id="gnutls_005fprivkey_005fdecrypt_005fdata2"></span><dl>
<dt id="index-gnutls_005fprivkey_005fdecrypt_005fdata2">Function: <em>int</em> <strong>gnutls_privkey_decrypt_data2</strong> <em>(gnutls_privkey_t <var>key</var>, unsigned int <var>flags</var>, const gnutls_datum_t * <var>ciphertext</var>, unsigned char * <var>plaintext</var>, size_t <var>plaintext_size</var>)</em></dt>
<dd><p><var>key</var>: Holds the key
</p>
<p><var>flags</var>: zero for now
</p>
<p><var>ciphertext</var>: holds the data to be decrypted
</p>
<p><var>plaintext</var>: a preallocated buffer that will be filled with the plaintext
</p>
<p><var>plaintext_size</var>: in/out size of the plaintext
</p>
<p>This function will decrypt the given data using the algorithm
supported by the private key. Unlike with <code>gnutls_privkey_decrypt_data()</code> 
this function operates in constant time and constant memory access.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.6.5
</p></dd></dl>

<span id="gnutls_005fprivkey_005fdeinit-1"></span><h4 class="subheading">gnutls_privkey_deinit</h4>
<span id="gnutls_005fprivkey_005fdeinit"></span><dl>
<dt id="index-gnutls_005fprivkey_005fdeinit">Function: <em>void</em> <strong>gnutls_privkey_deinit</strong> <em>(gnutls_privkey_t <var>key</var>)</em></dt>
<dd><p><var>key</var>: The key to be deinitialized
</p>
<p>This function will deinitialize a private key structure.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fprivkey_005fexport_005fdsa_005fraw-1"></span><h4 class="subheading">gnutls_privkey_export_dsa_raw</h4>
<span id="gnutls_005fprivkey_005fexport_005fdsa_005fraw"></span><dl>
<dt id="index-gnutls_005fprivkey_005fexport_005fdsa_005fraw">Function: <em>int</em> <strong>gnutls_privkey_export_dsa_raw</strong> <em>(gnutls_privkey_t <var>key</var>, gnutls_datum_t * <var>p</var>, gnutls_datum_t * <var>q</var>, gnutls_datum_t * <var>g</var>, gnutls_datum_t * <var>y</var>, gnutls_datum_t * <var>x</var>)</em></dt>
<dd><p><var>key</var>: Holds the public key
</p>
<p><var>p</var>: will hold the p
</p>
<p><var>q</var>: will hold the q
</p>
<p><var>g</var>: will hold the g
</p>
<p><var>y</var>: will hold the y
</p>
<p><var>x</var>: will hold the x
</p>
<p>This function will export the DSA private key&rsquo;s parameters found
in the given structure. The new parameters will be allocated using
<code>gnutls_malloc()</code>  and will be stored in the appropriate datum.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fprivkey_005fexport_005fdsa_005fraw2-1"></span><h4 class="subheading">gnutls_privkey_export_dsa_raw2</h4>
<span id="gnutls_005fprivkey_005fexport_005fdsa_005fraw2"></span><dl>
<dt id="index-gnutls_005fprivkey_005fexport_005fdsa_005fraw2">Function: <em>int</em> <strong>gnutls_privkey_export_dsa_raw2</strong> <em>(gnutls_privkey_t <var>key</var>, gnutls_datum_t * <var>p</var>, gnutls_datum_t * <var>q</var>, gnutls_datum_t * <var>g</var>, gnutls_datum_t * <var>y</var>, gnutls_datum_t * <var>x</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>key</var>: Holds the public key
</p>
<p><var>p</var>: will hold the p
</p>
<p><var>q</var>: will hold the q
</p>
<p><var>g</var>: will hold the g
</p>
<p><var>y</var>: will hold the y
</p>
<p><var>x</var>: will hold the x
</p>
<p><var>flags</var>: flags from <code>gnutls_abstract_export_flags_t</code> 
</p>
<p>This function will export the DSA private key&rsquo;s parameters found
in the given structure. The new parameters will be allocated using
<code>gnutls_malloc()</code>  and will be stored in the appropriate datum.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p>
<p><strong>Since:</strong> 3.6.0
</p></dd></dl>

<span id="gnutls_005fprivkey_005fexport_005fecc_005fraw-1"></span><h4 class="subheading">gnutls_privkey_export_ecc_raw</h4>
<span id="gnutls_005fprivkey_005fexport_005fecc_005fraw"></span><dl>
<dt id="index-gnutls_005fprivkey_005fexport_005fecc_005fraw">Function: <em>int</em> <strong>gnutls_privkey_export_ecc_raw</strong> <em>(gnutls_privkey_t <var>key</var>, gnutls_ecc_curve_t * <var>curve</var>, gnutls_datum_t * <var>x</var>, gnutls_datum_t * <var>y</var>, gnutls_datum_t * <var>k</var>)</em></dt>
<dd><p><var>key</var>: Holds the public key
</p>
<p><var>curve</var>: will hold the curve
</p>
<p><var>x</var>: will hold the x-coordinate
</p>
<p><var>y</var>: will hold the y-coordinate
</p>
<p><var>k</var>: will hold the private key
</p>
<p>This function will export the ECC private key&rsquo;s parameters found
in the given structure. The new parameters will be allocated using
<code>gnutls_malloc()</code>  and will be stored in the appropriate datum.
</p>
<p>In EdDSA curves the  <code>y</code> parameter will be <code>NULL</code>  and the other parameters
will be in the native format for the curve.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fprivkey_005fexport_005fecc_005fraw2-1"></span><h4 class="subheading">gnutls_privkey_export_ecc_raw2</h4>
<span id="gnutls_005fprivkey_005fexport_005fecc_005fraw2"></span><dl>
<dt id="index-gnutls_005fprivkey_005fexport_005fecc_005fraw2">Function: <em>int</em> <strong>gnutls_privkey_export_ecc_raw2</strong> <em>(gnutls_privkey_t <var>key</var>, gnutls_ecc_curve_t * <var>curve</var>, gnutls_datum_t * <var>x</var>, gnutls_datum_t * <var>y</var>, gnutls_datum_t * <var>k</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>key</var>: Holds the public key
</p>
<p><var>curve</var>: will hold the curve
</p>
<p><var>x</var>: will hold the x-coordinate
</p>
<p><var>y</var>: will hold the y-coordinate
</p>
<p><var>k</var>: will hold the private key
</p>
<p><var>flags</var>: flags from <code>gnutls_abstract_export_flags_t</code> 
</p>
<p>This function will export the ECC private key&rsquo;s parameters found
in the given structure. The new parameters will be allocated using
<code>gnutls_malloc()</code>  and will be stored in the appropriate datum.
</p>
<p>In EdDSA curves the  <code>y</code> parameter will be <code>NULL</code>  and the other parameters
will be in the native format for the curve.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p>
<p><strong>Since:</strong> 3.6.0
</p></dd></dl>

<span id="gnutls_005fprivkey_005fexport_005fgost_005fraw2-1"></span><h4 class="subheading">gnutls_privkey_export_gost_raw2</h4>
<span id="gnutls_005fprivkey_005fexport_005fgost_005fraw2"></span><dl>
<dt id="index-gnutls_005fprivkey_005fexport_005fgost_005fraw2">Function: <em>int</em> <strong>gnutls_privkey_export_gost_raw2</strong> <em>(gnutls_privkey_t <var>key</var>, gnutls_ecc_curve_t * <var>curve</var>, gnutls_digest_algorithm_t * <var>digest</var>, gnutls_gost_paramset_t * <var>paramset</var>, gnutls_datum_t * <var>x</var>, gnutls_datum_t * <var>y</var>, gnutls_datum_t * <var>k</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>key</var>: Holds the public key
</p>
<p><var>curve</var>: will hold the curve
</p>
<p><var>digest</var>: will hold the digest
</p>
<p><var>paramset</var>: will hold the GOST parameter set ID
</p>
<p><var>x</var>: will hold the x-coordinate
</p>
<p><var>y</var>: will hold the y-coordinate
</p>
<p><var>k</var>: will hold the private key
</p>
<p><var>flags</var>: flags from <code>gnutls_abstract_export_flags_t</code> 
</p>
<p>This function will export the GOST private key&rsquo;s parameters found
in the given structure. The new parameters will be allocated using
<code>gnutls_malloc()</code>  and will be stored in the appropriate datum.
</p>
<p><strong>Note:</strong> parameters will be stored with least significant byte first. On
version 3.6.3 this was incorrectly returned in big-endian format.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p>
<p><strong>Since:</strong> 3.6.3
</p></dd></dl>

<span id="gnutls_005fprivkey_005fexport_005fopenpgp-1"></span><h4 class="subheading">gnutls_privkey_export_openpgp</h4>
<span id="gnutls_005fprivkey_005fexport_005fopenpgp"></span><dl>
<dt id="index-gnutls_005fprivkey_005fexport_005fopenpgp">Function: <em>int</em> <strong>gnutls_privkey_export_openpgp</strong> <em>(gnutls_privkey_t <var>pkey</var>, gnutls_openpgp_privkey_t * <var>key</var>)</em></dt>
<dd><p><var>pkey</var>: The private key
</p>
<p><var>key</var>: Location for the key to be exported.
</p>
<p>This function is no-op.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_UNIMPLEMENTED_FEATURE</code> .
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fprivkey_005fexport_005fpkcs11-1"></span><h4 class="subheading">gnutls_privkey_export_pkcs11</h4>
<span id="gnutls_005fprivkey_005fexport_005fpkcs11"></span><dl>
<dt id="index-gnutls_005fprivkey_005fexport_005fpkcs11">Function: <em>int</em> <strong>gnutls_privkey_export_pkcs11</strong> <em>(gnutls_privkey_t <var>pkey</var>, gnutls_pkcs11_privkey_t * <var>key</var>)</em></dt>
<dd><p><var>pkey</var>: The private key
</p>
<p><var>key</var>: Location for the key to be exported.
</p>
<p>Converts the given abstract private key to a <code>gnutls_pkcs11_privkey_t</code> 
type. The key must be of type <code>GNUTLS_PRIVKEY_PKCS11</code> . The key
returned in  <code>key</code> must be deinitialized with
<code>gnutls_pkcs11_privkey_deinit()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fprivkey_005fexport_005frsa_005fraw-1"></span><h4 class="subheading">gnutls_privkey_export_rsa_raw</h4>
<span id="gnutls_005fprivkey_005fexport_005frsa_005fraw"></span><dl>
<dt id="index-gnutls_005fprivkey_005fexport_005frsa_005fraw">Function: <em>int</em> <strong>gnutls_privkey_export_rsa_raw</strong> <em>(gnutls_privkey_t <var>key</var>, gnutls_datum_t * <var>m</var>, gnutls_datum_t * <var>e</var>, gnutls_datum_t * <var>d</var>, gnutls_datum_t * <var>p</var>, gnutls_datum_t * <var>q</var>, gnutls_datum_t * <var>u</var>, gnutls_datum_t * <var>e1</var>, gnutls_datum_t * <var>e2</var>)</em></dt>
<dd><p><var>key</var>: Holds the certificate
</p>
<p><var>m</var>: will hold the modulus
</p>
<p><var>e</var>: will hold the public exponent
</p>
<p><var>d</var>: will hold the private exponent
</p>
<p><var>p</var>: will hold the first prime (p)
</p>
<p><var>q</var>: will hold the second prime (q)
</p>
<p><var>u</var>: will hold the coefficient
</p>
<p><var>e1</var>: will hold e1 = d mod (p-1)
</p>
<p><var>e2</var>: will hold e2 = d mod (q-1)
</p>
<p>This function will export the RSA private key&rsquo;s parameters found
in the given structure. The new parameters will be allocated using
<code>gnutls_malloc()</code>  and will be stored in the appropriate datum. For
EdDSA keys, the  <code>y</code> value should be <code>NULL</code> .
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fprivkey_005fexport_005frsa_005fraw2-1"></span><h4 class="subheading">gnutls_privkey_export_rsa_raw2</h4>
<span id="gnutls_005fprivkey_005fexport_005frsa_005fraw2"></span><dl>
<dt id="index-gnutls_005fprivkey_005fexport_005frsa_005fraw2">Function: <em>int</em> <strong>gnutls_privkey_export_rsa_raw2</strong> <em>(gnutls_privkey_t <var>key</var>, gnutls_datum_t * <var>m</var>, gnutls_datum_t * <var>e</var>, gnutls_datum_t * <var>d</var>, gnutls_datum_t * <var>p</var>, gnutls_datum_t * <var>q</var>, gnutls_datum_t * <var>u</var>, gnutls_datum_t * <var>e1</var>, gnutls_datum_t * <var>e2</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>key</var>: Holds the certificate
</p>
<p><var>m</var>: will hold the modulus
</p>
<p><var>e</var>: will hold the public exponent
</p>
<p><var>d</var>: will hold the private exponent
</p>
<p><var>p</var>: will hold the first prime (p)
</p>
<p><var>q</var>: will hold the second prime (q)
</p>
<p><var>u</var>: will hold the coefficient
</p>
<p><var>e1</var>: will hold e1 = d mod (p-1)
</p>
<p><var>e2</var>: will hold e2 = d mod (q-1)
</p>
<p><var>flags</var>: flags from <code>gnutls_abstract_export_flags_t</code> 
</p>
<p>This function will export the RSA private key&rsquo;s parameters found
in the given structure. The new parameters will be allocated using
<code>gnutls_malloc()</code>  and will be stored in the appropriate datum.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p>
<p><strong>Since:</strong> 3.6.0
</p></dd></dl>

<span id="gnutls_005fprivkey_005fexport_005fx509-1"></span><h4 class="subheading">gnutls_privkey_export_x509</h4>
<span id="gnutls_005fprivkey_005fexport_005fx509"></span><dl>
<dt id="index-gnutls_005fprivkey_005fexport_005fx509">Function: <em>int</em> <strong>gnutls_privkey_export_x509</strong> <em>(gnutls_privkey_t <var>pkey</var>, gnutls_x509_privkey_t * <var>key</var>)</em></dt>
<dd><p><var>pkey</var>: The private key
</p>
<p><var>key</var>: Location for the key to be exported.
</p>
<p>Converts the given abstract private key to a <code>gnutls_x509_privkey_t</code> 
type. The abstract key must be of type <code>GNUTLS_PRIVKEY_X509</code> . The input
 <code>key</code> must not be initialized. The key returned in  <code>key</code> should be deinitialized
using <code>gnutls_x509_privkey_deinit()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fprivkey_005fgenerate-1"></span><h4 class="subheading">gnutls_privkey_generate</h4>
<span id="gnutls_005fprivkey_005fgenerate"></span><dl>
<dt id="index-gnutls_005fprivkey_005fgenerate">Function: <em>int</em> <strong>gnutls_privkey_generate</strong> <em>(gnutls_privkey_t <var>pkey</var>, gnutls_pk_algorithm_t <var>algo</var>, unsigned int <var>bits</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>pkey</var>: An initialized private key
</p>
<p><var>algo</var>: is one of the algorithms in <code>gnutls_pk_algorithm_t</code> .
</p>
<p><var>bits</var>: the size of the parameters to generate
</p>
<p><var>flags</var>: Must be zero or flags from <code>gnutls_privkey_flags_t</code> .
</p>
<p>This function will generate a random private key. Note that this
function must be called on an initialized private key.
</p>
<p>The flag <code>GNUTLS_PRIVKEY_FLAG_PROVABLE</code> 
instructs the key generation process to use algorithms like Shawe-Taylor
(from FIPS PUB186-4) which generate provable parameters out of a seed
for RSA and DSA keys. See <code>gnutls_privkey_generate2()</code>  for more
information.
</p>
<p>Note that when generating an elliptic curve key, the curve
can be substituted in the place of the bits parameter using the
<code>GNUTLS_CURVE_TO_BITS()</code>  macro. The input to the macro is any curve from
<code>gnutls_ecc_curve_t</code> .
</p>
<p>For DSA keys, if the subgroup size needs to be specified check
the <code>GNUTLS_SUBGROUP_TO_BITS()</code>  macro.
</p>
<p>It is recommended to do not set the number of  <code>bits</code> directly, use <code>gnutls_sec_param_to_pk_bits()</code>  instead .
</p>
<p>See also <code>gnutls_privkey_generate2()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fprivkey_005fgenerate2-1"></span><h4 class="subheading">gnutls_privkey_generate2</h4>
<span id="gnutls_005fprivkey_005fgenerate2"></span><dl>
<dt id="index-gnutls_005fprivkey_005fgenerate2-1">Function: <em>int</em> <strong>gnutls_privkey_generate2</strong> <em>(gnutls_privkey_t <var>pkey</var>, gnutls_pk_algorithm_t <var>algo</var>, unsigned int <var>bits</var>, unsigned int <var>flags</var>, const gnutls_keygen_data_st * <var>data</var>, unsigned <var>data_size</var>)</em></dt>
<dd><p><var>pkey</var>: The private key
</p>
<p><var>algo</var>: is one of the algorithms in <code>gnutls_pk_algorithm_t</code> .
</p>
<p><var>bits</var>: the size of the modulus
</p>
<p><var>flags</var>: Must be zero or flags from <code>gnutls_privkey_flags_t</code> .
</p>
<p><var>data</var>: Allow specifying <code>gnutls_keygen_data_st</code>  types such as the seed to be used.
</p>
<p><var>data_size</var>: The number of  <code>data</code> available.
</p>
<p>This function will generate a random private key. Note that this
function must be called on an initialized private key.
</p>
<p>The flag <code>GNUTLS_PRIVKEY_FLAG_PROVABLE</code> 
instructs the key generation process to use algorithms like Shawe-Taylor
(from FIPS PUB186-4) which generate provable parameters out of a seed
for RSA and DSA keys. On DSA keys the PQG parameters are generated using the
seed, while on RSA the two primes. To specify an explicit seed
(by default a random seed is used), use the  <code>data</code> with a <code>GNUTLS_KEYGEN_SEED</code> 
type.
</p>
<p>Note that when generating an elliptic curve key, the curve
can be substituted in the place of the bits parameter using the
<code>GNUTLS_CURVE_TO_BITS()</code>  macro.
</p>
<p>To export the generated keys in memory or in files it is recommended to use the
PKCS<code>8</code>  form as it can handle all key types, and can store additional parameters
such as the seed, in case of provable RSA or DSA keys.
Generated keys can be exported in memory using <code>gnutls_privkey_export_x509()</code> ,
and then with <code>gnutls_x509_privkey_export2_pkcs8()</code> .
</p>
<p>If key generation is part of your application, avoid setting the number
of bits directly, and instead use <code>gnutls_sec_param_to_pk_bits()</code> .
That way the generated keys will adapt to the security levels
of the underlying GnuTLS library.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.5.0
</p></dd></dl>

<span id="gnutls_005fprivkey_005fget_005fpk_005falgorithm-1"></span><h4 class="subheading">gnutls_privkey_get_pk_algorithm</h4>
<span id="gnutls_005fprivkey_005fget_005fpk_005falgorithm"></span><dl>
<dt id="index-gnutls_005fprivkey_005fget_005fpk_005falgorithm">Function: <em>int</em> <strong>gnutls_privkey_get_pk_algorithm</strong> <em>(gnutls_privkey_t <var>key</var>, unsigned int * <var>bits</var>)</em></dt>
<dd><p><var>key</var>: should contain a <code>gnutls_privkey_t</code>  type
</p>
<p><var>bits</var>: If set will return the number of bits of the parameters (may be NULL)
</p>
<p>This function will return the public key algorithm of a private
key and if possible will return a number of bits that indicates
the security parameter of the key.
</p>
<p><strong>Returns:</strong> a member of the <code>gnutls_pk_algorithm_t</code>  enumeration on
success, or a negative error code on error.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fprivkey_005fget_005fseed-1"></span><h4 class="subheading">gnutls_privkey_get_seed</h4>
<span id="gnutls_005fprivkey_005fget_005fseed"></span><dl>
<dt id="index-gnutls_005fprivkey_005fget_005fseed">Function: <em>int</em> <strong>gnutls_privkey_get_seed</strong> <em>(gnutls_privkey_t <var>key</var>, gnutls_digest_algorithm_t * <var>digest</var>, void * <var>seed</var>, size_t * <var>seed_size</var>)</em></dt>
<dd><p><var>key</var>: should contain a <code>gnutls_privkey_t</code>  type
</p>
<p><var>digest</var>: if non-NULL it will contain the digest algorithm used for key generation (if applicable)
</p>
<p><var>seed</var>: where seed will be copied to
</p>
<p><var>seed_size</var>: originally holds the size of  <code>seed</code> , will be updated with actual size
</p>
<p>This function will return the seed that was used to generate the
given private key. That function will succeed only if the key was generated
as a provable key.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.5.0
</p></dd></dl>

<span id="gnutls_005fprivkey_005fget_005fspki-1"></span><h4 class="subheading">gnutls_privkey_get_spki</h4>
<span id="gnutls_005fprivkey_005fget_005fspki"></span><dl>
<dt id="index-gnutls_005fprivkey_005fget_005fspki">Function: <em>int</em> <strong>gnutls_privkey_get_spki</strong> <em>(gnutls_privkey_t <var>privkey</var>, gnutls_x509_spki_t <var>spki</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>privkey</var>: a public key of type <code>gnutls_privkey_t</code> 
</p>
<p><var>spki</var>: a SubjectPublicKeyInfo structure of type <code>gnutls_privkey_spki_t</code> 
</p>
<p><var>flags</var>: must be zero
</p>
<p>This function will return the public key information if available.
The provided  <code>spki</code> must be initialized.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.6.0
</p></dd></dl>

<span id="gnutls_005fprivkey_005fget_005ftype-1"></span><h4 class="subheading">gnutls_privkey_get_type</h4>
<span id="gnutls_005fprivkey_005fget_005ftype"></span><dl>
<dt id="index-gnutls_005fprivkey_005fget_005ftype">Function: <em>gnutls_privkey_type_t</em> <strong>gnutls_privkey_get_type</strong> <em>(gnutls_privkey_t <var>key</var>)</em></dt>
<dd><p><var>key</var>: should contain a <code>gnutls_privkey_t</code>  type
</p>
<p>This function will return the type of the private key. This is
actually the type of the subsystem used to set this private key.
</p>
<p><strong>Returns:</strong> a member of the <code>gnutls_privkey_type_t</code>  enumeration on
success, or a negative error code on error.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fprivkey_005fimport_005fdsa_005fraw-1"></span><h4 class="subheading">gnutls_privkey_import_dsa_raw</h4>
<span id="gnutls_005fprivkey_005fimport_005fdsa_005fraw"></span><dl>
<dt id="index-gnutls_005fprivkey_005fimport_005fdsa_005fraw">Function: <em>int</em> <strong>gnutls_privkey_import_dsa_raw</strong> <em>(gnutls_privkey_t <var>key</var>, const gnutls_datum_t * <var>p</var>, const gnutls_datum_t * <var>q</var>, const gnutls_datum_t * <var>g</var>, const gnutls_datum_t * <var>y</var>, const gnutls_datum_t * <var>x</var>)</em></dt>
<dd><p><var>key</var>: The structure to store the parsed key
</p>
<p><var>p</var>: holds the p
</p>
<p><var>q</var>: holds the q
</p>
<p><var>g</var>: holds the g
</p>
<p><var>y</var>: holds the y
</p>
<p><var>x</var>: holds the x
</p>
<p>This function will convert the given DSA raw parameters to the
native <code>gnutls_privkey_t</code>  format.  The output will be stored
in  <code>key</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fprivkey_005fimport_005fecc_005fraw-1"></span><h4 class="subheading">gnutls_privkey_import_ecc_raw</h4>
<span id="gnutls_005fprivkey_005fimport_005fecc_005fraw"></span><dl>
<dt id="index-gnutls_005fprivkey_005fimport_005fecc_005fraw">Function: <em>int</em> <strong>gnutls_privkey_import_ecc_raw</strong> <em>(gnutls_privkey_t <var>key</var>, gnutls_ecc_curve_t <var>curve</var>, const gnutls_datum_t * <var>x</var>, const gnutls_datum_t * <var>y</var>, const gnutls_datum_t * <var>k</var>)</em></dt>
<dd><p><var>key</var>: The key
</p>
<p><var>curve</var>: holds the curve
</p>
<p><var>x</var>: holds the x-coordinate
</p>
<p><var>y</var>: holds the y-coordinate
</p>
<p><var>k</var>: holds the k (private key)
</p>
<p>This function will convert the given elliptic curve parameters to the
native <code>gnutls_privkey_t</code>  format.  The output will be stored
in  <code>key</code> .
</p>
<p>In EdDSA curves the  <code>y</code> parameter should be <code>NULL</code>  and the  <code>x</code> and  <code>k</code> parameters
must be in the native format for the curve.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fprivkey_005fimport_005fext-1"></span><h4 class="subheading">gnutls_privkey_import_ext</h4>
<span id="gnutls_005fprivkey_005fimport_005fext"></span><dl>
<dt id="index-gnutls_005fprivkey_005fimport_005fext">Function: <em>int</em> <strong>gnutls_privkey_import_ext</strong> <em>(gnutls_privkey_t <var>pkey</var>, gnutls_pk_algorithm_t <var>pk</var>, void * <var>userdata</var>, gnutls_privkey_sign_func <var>sign_func</var>, gnutls_privkey_decrypt_func <var>decrypt_func</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>pkey</var>: The private key
</p>
<p><var>pk</var>: The public key algorithm
</p>
<p><var>userdata</var>: private data to be provided to the callbacks
</p>
<p><var>sign_func</var>: callback for signature operations
</p>
<p><var>decrypt_func</var>: callback for decryption operations
</p>
<p><var>flags</var>: Flags for the import
</p>
<p>This function will associate the given callbacks with the
<code>gnutls_privkey_t</code>  type. At least one of the two callbacks
must be non-null.
</p>
<p>Note that the signing function is supposed to &quot;raw&quot; sign data, i.e.,
without any hashing or preprocessing. In case of RSA the DigestInfo
will be provided, and the signing function is expected to do the PKCS <code>1</code> 
1.5 padding and the exponentiation.
</p>
<p>See also <code>gnutls_privkey_import_ext3()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fprivkey_005fimport_005fext2-1"></span><h4 class="subheading">gnutls_privkey_import_ext2</h4>
<span id="gnutls_005fprivkey_005fimport_005fext2"></span><dl>
<dt id="index-gnutls_005fprivkey_005fimport_005fext2">Function: <em>int</em> <strong>gnutls_privkey_import_ext2</strong> <em>(gnutls_privkey_t <var>pkey</var>, gnutls_pk_algorithm_t <var>pk</var>, void * <var>userdata</var>, gnutls_privkey_sign_func <var>sign_fn</var>, gnutls_privkey_decrypt_func <var>decrypt_fn</var>, gnutls_privkey_deinit_func <var>deinit_fn</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>pkey</var>: The private key
</p>
<p><var>pk</var>: The public key algorithm
</p>
<p><var>userdata</var>: private data to be provided to the callbacks
</p>
<p><var>sign_fn</var>: callback for signature operations
</p>
<p><var>decrypt_fn</var>: callback for decryption operations
</p>
<p><var>deinit_fn</var>: a deinitialization function
</p>
<p><var>flags</var>: Flags for the import
</p>
<p>This function will associate the given callbacks with the
<code>gnutls_privkey_t</code>  type. At least one of the two callbacks
must be non-null. If a deinitialization function is provided
then flags is assumed to contain <code>GNUTLS_PRIVKEY_IMPORT_AUTO_RELEASE</code> .
</p>
<p>Note that the signing function is supposed to &quot;raw&quot; sign data, i.e.,
without any hashing or preprocessing. In case of RSA the DigestInfo
will be provided, and the signing function is expected to do the PKCS <code>1</code> 
1.5 padding and the exponentiation.
</p>
<p>See also <code>gnutls_privkey_import_ext3()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.1
</p></dd></dl>

<span id="gnutls_005fprivkey_005fimport_005fext3-1"></span><h4 class="subheading">gnutls_privkey_import_ext3</h4>
<span id="gnutls_005fprivkey_005fimport_005fext3"></span><dl>
<dt id="index-gnutls_005fprivkey_005fimport_005fext3">Function: <em>int</em> <strong>gnutls_privkey_import_ext3</strong> <em>(gnutls_privkey_t <var>pkey</var>, void * <var>userdata</var>, gnutls_privkey_sign_func <var>sign_fn</var>, gnutls_privkey_decrypt_func <var>decrypt_fn</var>, gnutls_privkey_deinit_func <var>deinit_fn</var>, gnutls_privkey_info_func <var>info_fn</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>pkey</var>: The private key
</p>
<p><var>userdata</var>: private data to be provided to the callbacks
</p>
<p><var>sign_fn</var>: callback for signature operations
</p>
<p><var>decrypt_fn</var>: callback for decryption operations
</p>
<p><var>deinit_fn</var>: a deinitialization function
</p>
<p><var>info_fn</var>: returns info about the public key algorithm (should not be <code>NULL</code> )
</p>
<p><var>flags</var>: Flags for the import
</p>
<p>This function will associate the given callbacks with the
<code>gnutls_privkey_t</code>  type. At least one of the two callbacks
must be non-null. If a deinitialization function is provided
then flags is assumed to contain <code>GNUTLS_PRIVKEY_IMPORT_AUTO_RELEASE</code> .
</p>
<p>Note that the signing function is supposed to &quot;raw&quot; sign data, i.e.,
without any hashing or preprocessing. In case of RSA the DigestInfo
will be provided, and the signing function is expected to do the PKCS <code>1</code> 
1.5 padding and the exponentiation.
</p>
<p>The  <code>info_fn</code> must provide information on the algorithms supported by
this private key, and should support the flags <code>GNUTLS_PRIVKEY_INFO_PK_ALGO</code>  and
<code>GNUTLS_PRIVKEY_INFO_SIGN_ALGO</code> . It must return -1 on unknown flags.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fprivkey_005fimport_005fext4-1"></span><h4 class="subheading">gnutls_privkey_import_ext4</h4>
<span id="gnutls_005fprivkey_005fimport_005fext4"></span><dl>
<dt id="index-gnutls_005fprivkey_005fimport_005fext4-1">Function: <em>int</em> <strong>gnutls_privkey_import_ext4</strong> <em>(gnutls_privkey_t <var>pkey</var>, void * <var>userdata</var>, gnutls_privkey_sign_data_func <var>sign_data_fn</var>, gnutls_privkey_sign_hash_func <var>sign_hash_fn</var>, gnutls_privkey_decrypt_func <var>decrypt_fn</var>, gnutls_privkey_deinit_func <var>deinit_fn</var>, gnutls_privkey_info_func <var>info_fn</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>pkey</var>: The private key
</p>
<p><var>userdata</var>: private data to be provided to the callbacks
</p>
<p><var>sign_data_fn</var>: callback for signature operations (may be <code>NULL</code> )
</p>
<p><var>sign_hash_fn</var>: callback for signature operations (may be <code>NULL</code> )
</p>
<p><var>decrypt_fn</var>: callback for decryption operations (may be <code>NULL</code> )
</p>
<p><var>deinit_fn</var>: a deinitialization function
</p>
<p><var>info_fn</var>: returns info about the public key algorithm (should not be <code>NULL</code> )
</p>
<p><var>flags</var>: Flags for the import
</p>
<p>This function will associate the given callbacks with the
<code>gnutls_privkey_t</code>  type. At least one of the callbacks
must be non-null. If a deinitialization function is provided
then flags is assumed to contain <code>GNUTLS_PRIVKEY_IMPORT_AUTO_RELEASE</code> .
</p>
<p>Note that in contrast with the signing function of
<code>gnutls_privkey_import_ext3()</code> , the signing functions provided to this
function take explicitly the signature algorithm as parameter and
different functions are provided to sign the data and hashes.
</p>
<p>The  <code>sign_hash_fn</code> is to be called to sign pre-hashed data. The input
to the callback is the output of the hash (such as SHA256) corresponding
to the signature algorithm. For RSA PKCS<code>1</code>  signatures, the signature
algorithm can be set to <code>GNUTLS_SIGN_RSA_RAW</code> , and in that case the data
should be handled as if they were an RSA PKCS<code>1</code>  DigestInfo structure.
</p>
<p>The  <code>sign_data_fn</code> is to be called to sign data. The input data will be
he data to be signed (and hashed), with the provided signature
algorithm. This function is to be used for signature algorithms like
Ed25519 which cannot take pre-hashed data as input.
</p>
<p>When both  <code>sign_data_fn</code> and  <code>sign_hash_fn</code> functions are provided they
must be able to operate on all the supported signature algorithms,
unless prohibited by the type of the algorithm (e.g., as with Ed25519).
</p>
<p>The  <code>info_fn</code> must provide information on the signature algorithms supported by
this private key, and should support the flags <code>GNUTLS_PRIVKEY_INFO_PK_ALGO</code> ,
<code>GNUTLS_PRIVKEY_INFO_HAVE_SIGN_ALGO</code>  and <code>GNUTLS_PRIVKEY_INFO_PK_ALGO_BITS</code> .
It must return -1 on unknown flags.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.6.0
</p></dd></dl>

<span id="gnutls_005fprivkey_005fimport_005fgost_005fraw-1"></span><h4 class="subheading">gnutls_privkey_import_gost_raw</h4>
<span id="gnutls_005fprivkey_005fimport_005fgost_005fraw"></span><dl>
<dt id="index-gnutls_005fprivkey_005fimport_005fgost_005fraw">Function: <em>int</em> <strong>gnutls_privkey_import_gost_raw</strong> <em>(gnutls_privkey_t <var>key</var>, gnutls_ecc_curve_t <var>curve</var>, gnutls_digest_algorithm_t <var>digest</var>, gnutls_gost_paramset_t <var>paramset</var>, const gnutls_datum_t * <var>x</var>, const gnutls_datum_t * <var>y</var>, const gnutls_datum_t * <var>k</var>)</em></dt>
<dd><p><var>key</var>: The key
</p>
<p><var>curve</var>: holds the curve
</p>
<p><var>digest</var>: holds the digest
</p>
<p><var>paramset</var>: holds the GOST parameter set ID
</p>
<p><var>x</var>: holds the x-coordinate
</p>
<p><var>y</var>: holds the y-coordinate
</p>
<p><var>k</var>: holds the k (private key)
</p>
<p>This function will convert the given GOST private key&rsquo;s parameters to the
native <code>gnutls_privkey_t</code>  format.  The output will be stored
in  <code>key</code> .   <code>digest</code> should be one of GNUTLS_DIG_GOSR_94,
GNUTLS_DIG_STREEBOG_256 or GNUTLS_DIG_STREEBOG_512.  If  <code>paramset</code> is set to
GNUTLS_GOST_PARAMSET_UNKNOWN default one will be selected depending on
 <code>digest</code> .
</p>
<p><strong>Note:</strong> parameters should be stored with least significant byte first. On
version 3.6.3 big-endian format was used incorrectly.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.6.3
</p></dd></dl>

<span id="gnutls_005fprivkey_005fimport_005fopenpgp-1"></span><h4 class="subheading">gnutls_privkey_import_openpgp</h4>
<span id="gnutls_005fprivkey_005fimport_005fopenpgp"></span><dl>
<dt id="index-gnutls_005fprivkey_005fimport_005fopenpgp">Function: <em>int</em> <strong>gnutls_privkey_import_openpgp</strong> <em>(gnutls_privkey_t <var>pkey</var>, gnutls_openpgp_privkey_t <var>key</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>pkey</var>: The private key
</p>
<p><var>key</var>: The private key to be imported
</p>
<p><var>flags</var>: Flags for the import
</p>
<p>This function is no-op.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_UNIMPLEMENTED_FEATURE</code> .
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fprivkey_005fimport_005fopenpgp_005fraw-1"></span><h4 class="subheading">gnutls_privkey_import_openpgp_raw</h4>
<span id="gnutls_005fprivkey_005fimport_005fopenpgp_005fraw"></span><dl>
<dt id="index-gnutls_005fprivkey_005fimport_005fopenpgp_005fraw">Function: <em>int</em> <strong>gnutls_privkey_import_openpgp_raw</strong> <em>(gnutls_privkey_t <var>pkey</var>, const gnutls_datum_t * <var>data</var>, gnutls_openpgp_crt_fmt_t           <var>format</var>, const gnutls_openpgp_keyid_t           <var>keyid</var>, const char * <var>password</var>)</em></dt>
<dd><p><var>pkey</var>: The private key
</p>
<p><var>data</var>: The private key data to be imported
</p>
<p><var>format</var>: The format of the private key
</p>
<p><var>keyid</var>: The key id to use (optional)
</p>
<p><var>password</var>: A password (optional)
</p>
<p>This function is no-op.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_UNIMPLEMENTED_FEATURE</code> .
</p>
<p><strong>Since:</strong> 3.1.0
</p></dd></dl>

<span id="gnutls_005fprivkey_005fimport_005fpkcs11-1"></span><h4 class="subheading">gnutls_privkey_import_pkcs11</h4>
<span id="gnutls_005fprivkey_005fimport_005fpkcs11"></span><dl>
<dt id="index-gnutls_005fprivkey_005fimport_005fpkcs11">Function: <em>int</em> <strong>gnutls_privkey_import_pkcs11</strong> <em>(gnutls_privkey_t <var>pkey</var>, gnutls_pkcs11_privkey_t <var>key</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>pkey</var>: The private key
</p>
<p><var>key</var>: The private key to be imported
</p>
<p><var>flags</var>: Flags for the import
</p>
<p>This function will import the given private key to the abstract
<code>gnutls_privkey_t</code>  type.
</p>
<p>The <code>gnutls_pkcs11_privkey_t</code>  object must not be deallocated
during the lifetime of this structure.
</p>
<p><code>flags</code> might be zero or one of <code>GNUTLS_PRIVKEY_IMPORT_AUTO_RELEASE</code> 
and <code>GNUTLS_PRIVKEY_IMPORT_COPY</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fprivkey_005fimport_005fpkcs11_005furl-1"></span><h4 class="subheading">gnutls_privkey_import_pkcs11_url</h4>
<span id="gnutls_005fprivkey_005fimport_005fpkcs11_005furl"></span><dl>
<dt id="index-gnutls_005fprivkey_005fimport_005fpkcs11_005furl">Function: <em>int</em> <strong>gnutls_privkey_import_pkcs11_url</strong> <em>(gnutls_privkey_t <var>key</var>, const char * <var>url</var>)</em></dt>
<dd><p><var>key</var>: A key of type <code>gnutls_pubkey_t</code> 
</p>
<p><var>url</var>: A PKCS 11 url
</p>
<p>This function will import a PKCS 11 private key to a <code>gnutls_private_key_t</code> 
type.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.1.0
</p></dd></dl>

<span id="gnutls_005fprivkey_005fimport_005frsa_005fraw-1"></span><h4 class="subheading">gnutls_privkey_import_rsa_raw</h4>
<span id="gnutls_005fprivkey_005fimport_005frsa_005fraw"></span><dl>
<dt id="index-gnutls_005fprivkey_005fimport_005frsa_005fraw">Function: <em>int</em> <strong>gnutls_privkey_import_rsa_raw</strong> <em>(gnutls_privkey_t <var>key</var>, const gnutls_datum_t * <var>m</var>, const gnutls_datum_t * <var>e</var>, const gnutls_datum_t * <var>d</var>, const gnutls_datum_t * <var>p</var>, const gnutls_datum_t * <var>q</var>, const gnutls_datum_t * <var>u</var>, const gnutls_datum_t * <var>e1</var>, const gnutls_datum_t * <var>e2</var>)</em></dt>
<dd><p><var>key</var>: The structure to store the parsed key
</p>
<p><var>m</var>: holds the modulus
</p>
<p><var>e</var>: holds the public exponent
</p>
<p><var>d</var>: holds the private exponent
</p>
<p><var>p</var>: holds the first prime (p)
</p>
<p><var>q</var>: holds the second prime (q)
</p>
<p><var>u</var>: holds the coefficient (optional)
</p>
<p><var>e1</var>: holds e1 = d mod (p-1) (optional)
</p>
<p><var>e2</var>: holds e2 = d mod (q-1) (optional)
</p>
<p>This function will convert the given RSA raw parameters to the
native <code>gnutls_privkey_t</code>  format.  The output will be stored in
 <code>key</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fprivkey_005fimport_005ftpm_005fraw-1"></span><h4 class="subheading">gnutls_privkey_import_tpm_raw</h4>
<span id="gnutls_005fprivkey_005fimport_005ftpm_005fraw"></span><dl>
<dt id="index-gnutls_005fprivkey_005fimport_005ftpm_005fraw">Function: <em>int</em> <strong>gnutls_privkey_import_tpm_raw</strong> <em>(gnutls_privkey_t <var>pkey</var>, const gnutls_datum_t * <var>fdata</var>, gnutls_tpmkey_fmt_t <var>format</var>, const char * <var>srk_password</var>, const char * <var>key_password</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>pkey</var>: The private key
</p>
<p><var>fdata</var>: The TPM key to be imported
</p>
<p><var>format</var>: The format of the private key
</p>
<p><var>srk_password</var>: The password for the SRK key (optional)
</p>
<p><var>key_password</var>: A password for the key (optional)
</p>
<p><var>flags</var>: should be zero
</p>
<p>This function will import the given private key to the abstract
<code>gnutls_privkey_t</code>  type. 
</p>
<p>With respect to passwords the same as in <code>gnutls_privkey_import_tpm_url()</code>  apply.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.1.0
</p></dd></dl>

<span id="gnutls_005fprivkey_005fimport_005ftpm_005furl-1"></span><h4 class="subheading">gnutls_privkey_import_tpm_url</h4>
<span id="gnutls_005fprivkey_005fimport_005ftpm_005furl"></span><dl>
<dt id="index-gnutls_005fprivkey_005fimport_005ftpm_005furl-1">Function: <em>int</em> <strong>gnutls_privkey_import_tpm_url</strong> <em>(gnutls_privkey_t <var>pkey</var>, const char * <var>url</var>, const char * <var>srk_password</var>, const char * <var>key_password</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>pkey</var>: The private key
</p>
<p><var>url</var>: The URL of the TPM key to be imported
</p>
<p><var>srk_password</var>: The password for the SRK key (optional)
</p>
<p><var>key_password</var>: A password for the key (optional)
</p>
<p><var>flags</var>: One of the GNUTLS_PRIVKEY_* flags
</p>
<p>This function will import the given private key to the abstract
<code>gnutls_privkey_t</code>  type.
</p>
<p>Note that unless <code>GNUTLS_PRIVKEY_DISABLE_CALLBACKS</code> 
is specified, if incorrect (or NULL) passwords are given
the PKCS11 callback functions will be used to obtain the
correct passwords. Otherwise if the SRK password is wrong
<code>GNUTLS_E_TPM_SRK_PASSWORD_ERROR</code>  is returned and if the key password
is wrong or not provided then <code>GNUTLS_E_TPM_KEY_PASSWORD_ERROR</code> 
is returned. 
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.1.0
</p></dd></dl>

<span id="gnutls_005fprivkey_005fimport_005furl-1"></span><h4 class="subheading">gnutls_privkey_import_url</h4>
<span id="gnutls_005fprivkey_005fimport_005furl"></span><dl>
<dt id="index-gnutls_005fprivkey_005fimport_005furl-1">Function: <em>int</em> <strong>gnutls_privkey_import_url</strong> <em>(gnutls_privkey_t <var>key</var>, const char * <var>url</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>key</var>: A key of type <code>gnutls_privkey_t</code> 
</p>
<p><var>url</var>: A PKCS 11 url
</p>
<p><var>flags</var>: should be zero
</p>
<p>This function will import a PKCS11 or TPM URL as a
private key. The supported URL types can be checked
using <code>gnutls_url_is_supported()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.1.0
</p></dd></dl>

<span id="gnutls_005fprivkey_005fimport_005fx509-1"></span><h4 class="subheading">gnutls_privkey_import_x509</h4>
<span id="gnutls_005fprivkey_005fimport_005fx509"></span><dl>
<dt id="index-gnutls_005fprivkey_005fimport_005fx509">Function: <em>int</em> <strong>gnutls_privkey_import_x509</strong> <em>(gnutls_privkey_t <var>pkey</var>, gnutls_x509_privkey_t <var>key</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>pkey</var>: The private key
</p>
<p><var>key</var>: The private key to be imported
</p>
<p><var>flags</var>: Flags for the import
</p>
<p>This function will import the given private key to the abstract
<code>gnutls_privkey_t</code>  type.
</p>
<p>The <code>gnutls_x509_privkey_t</code>  object must not be deallocated
during the lifetime of this structure.
</p>
<p><code>flags</code> might be zero or one of <code>GNUTLS_PRIVKEY_IMPORT_AUTO_RELEASE</code> 
and <code>GNUTLS_PRIVKEY_IMPORT_COPY</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fprivkey_005fimport_005fx509_005fraw-1"></span><h4 class="subheading">gnutls_privkey_import_x509_raw</h4>
<span id="gnutls_005fprivkey_005fimport_005fx509_005fraw"></span><dl>
<dt id="index-gnutls_005fprivkey_005fimport_005fx509_005fraw-1">Function: <em>int</em> <strong>gnutls_privkey_import_x509_raw</strong> <em>(gnutls_privkey_t <var>pkey</var>, const gnutls_datum_t * <var>data</var>, gnutls_x509_crt_fmt_t <var>format</var>, const char * <var>password</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>pkey</var>: The private key
</p>
<p><var>data</var>: The private key data to be imported
</p>
<p><var>format</var>: The format of the private key
</p>
<p><var>password</var>: A password (optional)
</p>
<p><var>flags</var>: an ORed sequence of gnutls_pkcs_encrypt_flags_t
</p>
<p>This function will import the given private key to the abstract
<code>gnutls_privkey_t</code>  type. 
</p>
<p>The supported formats are basic unencrypted key, PKCS8, PKCS12, 
and the openssl format.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.1.0
</p></dd></dl>

<span id="gnutls_005fprivkey_005finit-1"></span><h4 class="subheading">gnutls_privkey_init</h4>
<span id="gnutls_005fprivkey_005finit"></span><dl>
<dt id="index-gnutls_005fprivkey_005finit">Function: <em>int</em> <strong>gnutls_privkey_init</strong> <em>(gnutls_privkey_t * <var>key</var>)</em></dt>
<dd><p><var>key</var>: A pointer to the type to be initialized
</p>
<p>This function will initialize a private key object. The object can
be used to generate, import, and perform cryptographic operations
on the associated private key.
</p>
<p>Note that when the underlying private key is a PKCS<code>11</code>  key (i.e.,
when imported with a PKCS<code>11</code>  URI), the limitations of <code>gnutls_pkcs11_privkey_init()</code> 
apply to this object as well. In versions of GnuTLS later than 3.5.11 the object
is protected using locks and a single <code>gnutls_privkey_t</code>  can be re-used
by many threads. However, for performance it is recommended to utilize
one object per key per thread.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fprivkey_005fset_005fflags-1"></span><h4 class="subheading">gnutls_privkey_set_flags</h4>
<span id="gnutls_005fprivkey_005fset_005fflags"></span><dl>
<dt id="index-gnutls_005fprivkey_005fset_005fflags">Function: <em>void</em> <strong>gnutls_privkey_set_flags</strong> <em>(gnutls_privkey_t <var>key</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>key</var>: A key of type <code>gnutls_privkey_t</code> 
</p>
<p><var>flags</var>: flags from the <code>gnutls_privkey_flags</code> 
</p>
<p>This function will set flags for the specified private key, after
it is generated. Currently this is useful for the <code>GNUTLS_PRIVKEY_FLAG_EXPORT_COMPAT</code> 
to allow exporting a &quot;provable&quot; private key in backwards compatible way.
</p>
<p><strong>Since:</strong> 3.5.0
</p></dd></dl>

<span id="gnutls_005fprivkey_005fset_005fpin_005ffunction-1"></span><h4 class="subheading">gnutls_privkey_set_pin_function</h4>
<span id="gnutls_005fprivkey_005fset_005fpin_005ffunction"></span><dl>
<dt id="index-gnutls_005fprivkey_005fset_005fpin_005ffunction">Function: <em>void</em> <strong>gnutls_privkey_set_pin_function</strong> <em>(gnutls_privkey_t <var>key</var>, gnutls_pin_callback_t <var>fn</var>, void * <var>userdata</var>)</em></dt>
<dd><p><var>key</var>: A key of type <code>gnutls_privkey_t</code> 
</p>
<p><var>fn</var>: the callback
</p>
<p><var>userdata</var>: data associated with the callback
</p>
<p>This function will set a callback function to be used when
required to access the object. This function overrides any other
global PIN functions.
</p>
<p>Note that this function must be called right after initialization
to have effect.
</p>
<p><strong>Since:</strong> 3.1.0
</p></dd></dl>

<span id="gnutls_005fprivkey_005fset_005fspki-1"></span><h4 class="subheading">gnutls_privkey_set_spki</h4>
<span id="gnutls_005fprivkey_005fset_005fspki"></span><dl>
<dt id="index-gnutls_005fprivkey_005fset_005fspki">Function: <em>int</em> <strong>gnutls_privkey_set_spki</strong> <em>(gnutls_privkey_t <var>privkey</var>, const gnutls_x509_spki_t <var>spki</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>privkey</var>: a public key of type <code>gnutls_privkey_t</code> 
</p>
<p><var>spki</var>: a SubjectPublicKeyInfo structure of type <code>gnutls_privkey_spki_t</code> 
</p>
<p><var>flags</var>: must be zero
</p>
<p>This function will set the public key information.
The provided  <code>spki</code> must be initialized.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.6.0
</p></dd></dl>

<span id="gnutls_005fprivkey_005fsign_005fdata-1"></span><h4 class="subheading">gnutls_privkey_sign_data</h4>
<span id="gnutls_005fprivkey_005fsign_005fdata"></span><dl>
<dt id="index-gnutls_005fprivkey_005fsign_005fdata-1">Function: <em>int</em> <strong>gnutls_privkey_sign_data</strong> <em>(gnutls_privkey_t <var>signer</var>, gnutls_digest_algorithm_t <var>hash</var>, unsigned int <var>flags</var>, const gnutls_datum_t * <var>data</var>, gnutls_datum_t * <var>signature</var>)</em></dt>
<dd><p><var>signer</var>: Holds the key
</p>
<p><var>hash</var>: should be a digest algorithm
</p>
<p><var>flags</var>: Zero or one of <code>gnutls_privkey_flags_t</code> 
</p>
<p><var>data</var>: holds the data to be signed
</p>
<p><var>signature</var>: will contain the signature allocated with <code>gnutls_malloc()</code> 
</p>
<p>This function will sign the given data using a signature algorithm
supported by the private key. Signature algorithms are always used
together with a hash functions.  Different hash functions may be
used for the RSA algorithm, but only the SHA family for the DSA keys.
</p>
<p>You may use <code>gnutls_pubkey_get_preferred_hash_algorithm()</code>  to determine
the hash algorithm.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fprivkey_005fsign_005fdata2-1"></span><h4 class="subheading">gnutls_privkey_sign_data2</h4>
<span id="gnutls_005fprivkey_005fsign_005fdata2"></span><dl>
<dt id="index-gnutls_005fprivkey_005fsign_005fdata2">Function: <em>int</em> <strong>gnutls_privkey_sign_data2</strong> <em>(gnutls_privkey_t <var>signer</var>, gnutls_sign_algorithm_t <var>algo</var>, unsigned int <var>flags</var>, const gnutls_datum_t * <var>data</var>, gnutls_datum_t * <var>signature</var>)</em></dt>
<dd><p><var>signer</var>: Holds the key
</p>
<p><var>algo</var>: The signature algorithm used
</p>
<p><var>flags</var>: Zero or one of <code>gnutls_privkey_flags_t</code> 
</p>
<p><var>data</var>: holds the data to be signed
</p>
<p><var>signature</var>: will contain the signature allocated with <code>gnutls_malloc()</code> 
</p>
<p>This function will sign the given data using the specified signature
algorithm. This function is an enhancement of <code>gnutls_privkey_sign_data()</code> ,
as it allows utilizing a alternative signature algorithm where possible
(e.g, use an RSA key with RSA-PSS).
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.6.0
</p></dd></dl>

<span id="gnutls_005fprivkey_005fsign_005fhash-1"></span><h4 class="subheading">gnutls_privkey_sign_hash</h4>
<span id="gnutls_005fprivkey_005fsign_005fhash"></span><dl>
<dt id="index-gnutls_005fprivkey_005fsign_005fhash-1">Function: <em>int</em> <strong>gnutls_privkey_sign_hash</strong> <em>(gnutls_privkey_t <var>signer</var>, gnutls_digest_algorithm_t <var>hash_algo</var>, unsigned int <var>flags</var>, const gnutls_datum_t * <var>hash_data</var>, gnutls_datum_t * <var>signature</var>)</em></dt>
<dd><p><var>signer</var>: Holds the signer&rsquo;s key
</p>
<p><var>hash_algo</var>: The hash algorithm used
</p>
<p><var>flags</var>: Zero or one of <code>gnutls_privkey_flags_t</code> 
</p>
<p><var>hash_data</var>: holds the data to be signed
</p>
<p><var>signature</var>: will contain newly allocated signature
</p>
<p>This function will sign the given hashed data using a signature algorithm
supported by the private key. Signature algorithms are always used
together with a hash functions.  Different hash functions may be
used for the RSA algorithm, but only SHA-XXX for the DSA keys.
</p>
<p>You may use <code>gnutls_pubkey_get_preferred_hash_algorithm()</code>  to determine
the hash algorithm.
</p>
<p>The flags may be <code>GNUTLS_PRIVKEY_SIGN_FLAG_TLS1_RSA</code>  or <code>GNUTLS_PRIVKEY_SIGN_FLAG_RSA_PSS</code> .
In the former case this function will ignore  <code>hash_algo</code> and perform a raw PKCS1 signature,
and in the latter an RSA-PSS signature will be generated.
</p>
<p>Note that, not all algorithm support signing already hashed data. When
signing with Ed25519, <code>gnutls_privkey_sign_data()</code>  should be used.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fprivkey_005fsign_005fhash2-1"></span><h4 class="subheading">gnutls_privkey_sign_hash2</h4>
<span id="gnutls_005fprivkey_005fsign_005fhash2"></span><dl>
<dt id="index-gnutls_005fprivkey_005fsign_005fhash2">Function: <em>int</em> <strong>gnutls_privkey_sign_hash2</strong> <em>(gnutls_privkey_t <var>signer</var>, gnutls_sign_algorithm_t <var>algo</var>, unsigned int <var>flags</var>, const gnutls_datum_t * <var>hash_data</var>, gnutls_datum_t * <var>signature</var>)</em></dt>
<dd><p><var>signer</var>: Holds the signer&rsquo;s key
</p>
<p><var>algo</var>: The signature algorithm used
</p>
<p><var>flags</var>: Zero or one of <code>gnutls_privkey_flags_t</code> 
</p>
<p><var>hash_data</var>: holds the data to be signed
</p>
<p><var>signature</var>: will contain newly allocated signature
</p>
<p>This function will sign the given hashed data using a signature algorithm
supported by the private key. Signature algorithms are always used
together with a hash functions.  Different hash functions may be
used for the RSA algorithm, but only SHA-XXX for the DSA keys.
</p>
<p>You may use <code>gnutls_pubkey_get_preferred_hash_algorithm()</code>  to determine
the hash algorithm.
</p>
<p>The flags may be <code>GNUTLS_PRIVKEY_SIGN_FLAG_TLS1_RSA</code>  or <code>GNUTLS_PRIVKEY_SIGN_FLAG_RSA_PSS</code> .
In the former case this function will ignore  <code>hash_algo</code> and perform a raw PKCS1 signature,
and in the latter an RSA-PSS signature will be generated. Note that the flag
<code>GNUTLS_PRIVKEY_SIGN_FLAG_TLS1_RSA</code>  is supported since 3.6.9.
</p>
<p>Note that, not all algorithm support signing already hashed data. When
signing with Ed25519, <code>gnutls_privkey_sign_data()</code>  should be used.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.6.0
</p></dd></dl>

<span id="gnutls_005fprivkey_005fstatus-1"></span><h4 class="subheading">gnutls_privkey_status</h4>
<span id="gnutls_005fprivkey_005fstatus"></span><dl>
<dt id="index-gnutls_005fprivkey_005fstatus">Function: <em>int</em> <strong>gnutls_privkey_status</strong> <em>(gnutls_privkey_t <var>key</var>)</em></dt>
<dd><p><var>key</var>: Holds the key
</p>
<p>Checks the status of the private key token. This function
is an actual wrapper over <code>gnutls_pkcs11_privkey_status()</code> , and
if the private key is a PKCS <code>11</code>  token it will check whether
it is inserted or not.
</p>
<p><strong>Returns:</strong> this function will return non-zero if the token 
holding the private key is still available (inserted), and zero otherwise.
</p>
<p><strong>Since:</strong> 3.1.10
</p></dd></dl>

<span id="gnutls_005fprivkey_005fverify_005fparams-1"></span><h4 class="subheading">gnutls_privkey_verify_params</h4>
<span id="gnutls_005fprivkey_005fverify_005fparams"></span><dl>
<dt id="index-gnutls_005fprivkey_005fverify_005fparams">Function: <em>int</em> <strong>gnutls_privkey_verify_params</strong> <em>(gnutls_privkey_t <var>key</var>)</em></dt>
<dd><p><var>key</var>: should contain a <code>gnutls_privkey_t</code>  type
</p>
<p>This function will verify the private key parameters.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fprivkey_005fverify_005fseed-1"></span><h4 class="subheading">gnutls_privkey_verify_seed</h4>
<span id="gnutls_005fprivkey_005fverify_005fseed"></span><dl>
<dt id="index-gnutls_005fprivkey_005fverify_005fseed">Function: <em>int</em> <strong>gnutls_privkey_verify_seed</strong> <em>(gnutls_privkey_t <var>key</var>, gnutls_digest_algorithm_t <var>digest</var>, const void * <var>seed</var>, size_t <var>seed_size</var>)</em></dt>
<dd><p><var>key</var>: should contain a <code>gnutls_privkey_t</code>  type
</p>
<p><var>digest</var>: it contains the digest algorithm used for key generation (if applicable)
</p>
<p><var>seed</var>: the seed of the key to be checked with
</p>
<p><var>seed_size</var>: holds the size of  <code>seed</code> 
</p>
<p>This function will verify that the given private key was generated from
the provided seed.
</p>
<p><strong>Returns:</strong> In case of a verification failure <code>GNUTLS_E_PRIVKEY_VERIFICATION_ERROR</code> 
is returned, and zero or positive code on success.
</p>
<p><strong>Since:</strong> 3.5.0
</p></dd></dl>

<span id="gnutls_005fpubkey_005fdeinit-1"></span><h4 class="subheading">gnutls_pubkey_deinit</h4>
<span id="gnutls_005fpubkey_005fdeinit"></span><dl>
<dt id="index-gnutls_005fpubkey_005fdeinit">Function: <em>void</em> <strong>gnutls_pubkey_deinit</strong> <em>(gnutls_pubkey_t <var>key</var>)</em></dt>
<dd><p><var>key</var>: The key to be deinitialized
</p>
<p>This function will deinitialize a public key structure.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fpubkey_005fencrypt_005fdata-1"></span><h4 class="subheading">gnutls_pubkey_encrypt_data</h4>
<span id="gnutls_005fpubkey_005fencrypt_005fdata"></span><dl>
<dt id="index-gnutls_005fpubkey_005fencrypt_005fdata-1">Function: <em>int</em> <strong>gnutls_pubkey_encrypt_data</strong> <em>(gnutls_pubkey_t <var>key</var>, unsigned int <var>flags</var>, const gnutls_datum_t * <var>plaintext</var>, gnutls_datum_t * <var>ciphertext</var>)</em></dt>
<dd><p><var>key</var>: Holds the public key
</p>
<p><var>flags</var>: should be 0 for now
</p>
<p><var>plaintext</var>: The data to be encrypted
</p>
<p><var>ciphertext</var>: contains the encrypted data
</p>
<p>This function will encrypt the given data, using the public
key. On success the  <code>ciphertext</code> will be allocated using <code>gnutls_malloc()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fpubkey_005fexport-1"></span><h4 class="subheading">gnutls_pubkey_export</h4>
<span id="gnutls_005fpubkey_005fexport"></span><dl>
<dt id="index-gnutls_005fpubkey_005fexport">Function: <em>int</em> <strong>gnutls_pubkey_export</strong> <em>(gnutls_pubkey_t <var>key</var>, gnutls_x509_crt_fmt_t <var>format</var>, void * <var>output_data</var>, size_t * <var>output_data_size</var>)</em></dt>
<dd><p><var>key</var>: Holds the certificate
</p>
<p><var>format</var>: the format of output params. One of PEM or DER.
</p>
<p><var>output_data</var>: will contain a certificate PEM or DER encoded
</p>
<p><var>output_data_size</var>: holds the size of output_data (and will be
replaced by the actual size of parameters)
</p>
<p>This function will export the public key to DER or PEM format.
The contents of the exported data is the SubjectPublicKeyInfo
X.509 structure.
</p>
<p>If the buffer provided is not long enough to hold the output, then
*output_data_size is updated and <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  will
be returned.
</p>
<p>If the structure is PEM encoded, it will have a header
of &quot;BEGIN CERTIFICATE&quot;.
</p>
<p><strong>Returns:</strong> In case of failure a negative error code will be
returned, and 0 on success.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fpubkey_005fexport2-1"></span><h4 class="subheading">gnutls_pubkey_export2</h4>
<span id="gnutls_005fpubkey_005fexport2"></span><dl>
<dt id="index-gnutls_005fpubkey_005fexport2-1">Function: <em>int</em> <strong>gnutls_pubkey_export2</strong> <em>(gnutls_pubkey_t <var>key</var>, gnutls_x509_crt_fmt_t <var>format</var>, gnutls_datum_t * <var>out</var>)</em></dt>
<dd><p><var>key</var>: Holds the certificate
</p>
<p><var>format</var>: the format of output params. One of PEM or DER.
</p>
<p><var>out</var>: will contain a certificate PEM or DER encoded
</p>
<p>This function will export the public key to DER or PEM format.
The contents of the exported data is the SubjectPublicKeyInfo
X.509 structure.
</p>
<p>The output buffer will be allocated using <code>gnutls_malloc()</code> .
</p>
<p>If the structure is PEM encoded, it will have a header
of &quot;BEGIN CERTIFICATE&quot;.
</p>
<p><strong>Returns:</strong> In case of failure a negative error code will be
returned, and 0 on success.
</p>
<p><strong>Since:</strong> 3.1.3
</p></dd></dl>

<span id="gnutls_005fpubkey_005fexport_005fdsa_005fraw-1"></span><h4 class="subheading">gnutls_pubkey_export_dsa_raw</h4>
<span id="gnutls_005fpubkey_005fexport_005fdsa_005fraw"></span><dl>
<dt id="index-gnutls_005fpubkey_005fexport_005fdsa_005fraw">Function: <em>int</em> <strong>gnutls_pubkey_export_dsa_raw</strong> <em>(gnutls_pubkey_t <var>key</var>, gnutls_datum_t * <var>p</var>, gnutls_datum_t * <var>q</var>, gnutls_datum_t * <var>g</var>, gnutls_datum_t * <var>y</var>)</em></dt>
<dd><p><var>key</var>: Holds the public key
</p>
<p><var>p</var>: will hold the p (may be <code>NULL</code> )
</p>
<p><var>q</var>: will hold the q (may be <code>NULL</code> )
</p>
<p><var>g</var>: will hold the g (may be <code>NULL</code> )
</p>
<p><var>y</var>: will hold the y (may be <code>NULL</code> )
</p>
<p>This function will export the DSA public key&rsquo;s parameters found in
the given certificate.  The new parameters will be allocated using
<code>gnutls_malloc()</code>  and will be stored in the appropriate datum.
</p>
<p>This function allows for <code>NULL</code>  parameters since 3.4.1.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fpubkey_005fexport_005fdsa_005fraw2-1"></span><h4 class="subheading">gnutls_pubkey_export_dsa_raw2</h4>
<span id="gnutls_005fpubkey_005fexport_005fdsa_005fraw2"></span><dl>
<dt id="index-gnutls_005fpubkey_005fexport_005fdsa_005fraw2">Function: <em>int</em> <strong>gnutls_pubkey_export_dsa_raw2</strong> <em>(gnutls_pubkey_t <var>key</var>, gnutls_datum_t * <var>p</var>, gnutls_datum_t * <var>q</var>, gnutls_datum_t * <var>g</var>, gnutls_datum_t * <var>y</var>, unsigned <var>flags</var>)</em></dt>
<dd><p><var>key</var>: Holds the public key
</p>
<p><var>p</var>: will hold the p (may be <code>NULL</code> )
</p>
<p><var>q</var>: will hold the q (may be <code>NULL</code> )
</p>
<p><var>g</var>: will hold the g (may be <code>NULL</code> )
</p>
<p><var>y</var>: will hold the y (may be <code>NULL</code> )
</p>
<p><var>flags</var>: flags from <code>gnutls_abstract_export_flags_t</code> 
</p>
<p>This function will export the DSA public key&rsquo;s parameters found in
the given certificate.  The new parameters will be allocated using
<code>gnutls_malloc()</code>  and will be stored in the appropriate datum.
</p>
<p>This function allows for <code>NULL</code>  parameters since 3.4.1.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p>
<p><strong>Since:</strong> 3.6.0
</p></dd></dl>

<span id="gnutls_005fpubkey_005fexport_005fecc_005fraw-1"></span><h4 class="subheading">gnutls_pubkey_export_ecc_raw</h4>
<span id="gnutls_005fpubkey_005fexport_005fecc_005fraw"></span><dl>
<dt id="index-gnutls_005fpubkey_005fexport_005fecc_005fraw">Function: <em>int</em> <strong>gnutls_pubkey_export_ecc_raw</strong> <em>(gnutls_pubkey_t <var>key</var>, gnutls_ecc_curve_t * <var>curve</var>, gnutls_datum_t * <var>x</var>, gnutls_datum_t * <var>y</var>)</em></dt>
<dd><p><var>key</var>: Holds the public key
</p>
<p><var>curve</var>: will hold the curve (may be <code>NULL</code> )
</p>
<p><var>x</var>: will hold x-coordinate (may be <code>NULL</code> )
</p>
<p><var>y</var>: will hold y-coordinate (may be <code>NULL</code> )
</p>
<p>This function will export the ECC public key&rsquo;s parameters found in
the given key.  The new parameters will be allocated using
<code>gnutls_malloc()</code>  and will be stored in the appropriate datum.
</p>
<p>In EdDSA curves the  <code>y</code> parameter will be <code>NULL</code>  and the other parameters
will be in the native format for the curve.
</p>
<p>This function allows for <code>NULL</code>  parameters since 3.4.1.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fpubkey_005fexport_005fecc_005fraw2-1"></span><h4 class="subheading">gnutls_pubkey_export_ecc_raw2</h4>
<span id="gnutls_005fpubkey_005fexport_005fecc_005fraw2"></span><dl>
<dt id="index-gnutls_005fpubkey_005fexport_005fecc_005fraw2">Function: <em>int</em> <strong>gnutls_pubkey_export_ecc_raw2</strong> <em>(gnutls_pubkey_t <var>key</var>, gnutls_ecc_curve_t * <var>curve</var>, gnutls_datum_t * <var>x</var>, gnutls_datum_t * <var>y</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>key</var>: Holds the public key
</p>
<p><var>curve</var>: will hold the curve (may be <code>NULL</code> )
</p>
<p><var>x</var>: will hold x-coordinate (may be <code>NULL</code> )
</p>
<p><var>y</var>: will hold y-coordinate (may be <code>NULL</code> )
</p>
<p><var>flags</var>: flags from <code>gnutls_abstract_export_flags_t</code> 
</p>
<p>This function will export the ECC public key&rsquo;s parameters found in
the given key.  The new parameters will be allocated using
<code>gnutls_malloc()</code>  and will be stored in the appropriate datum.
</p>
<p>In EdDSA curves the  <code>y</code> parameter will be <code>NULL</code>  and the other parameters
will be in the native format for the curve.
</p>
<p>This function allows for <code>NULL</code>  parameters since 3.4.1.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p>
<p><strong>Since:</strong> 3.6.0
</p></dd></dl>

<span id="gnutls_005fpubkey_005fexport_005fecc_005fx962-1"></span><h4 class="subheading">gnutls_pubkey_export_ecc_x962</h4>
<span id="gnutls_005fpubkey_005fexport_005fecc_005fx962"></span><dl>
<dt id="index-gnutls_005fpubkey_005fexport_005fecc_005fx962">Function: <em>int</em> <strong>gnutls_pubkey_export_ecc_x962</strong> <em>(gnutls_pubkey_t <var>key</var>, gnutls_datum_t * <var>parameters</var>, gnutls_datum_t * <var>ecpoint</var>)</em></dt>
<dd><p><var>key</var>: Holds the public key
</p>
<p><var>parameters</var>: DER encoding of an ANSI X9.62 parameters
</p>
<p><var>ecpoint</var>: DER encoding of ANSI X9.62 ECPoint
</p>
<p>This function will export the ECC public key&rsquo;s parameters found in
the given certificate.  The new parameters will be allocated using
<code>gnutls_malloc()</code>  and will be stored in the appropriate datum.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fpubkey_005fexport_005fgost_005fraw2-1"></span><h4 class="subheading">gnutls_pubkey_export_gost_raw2</h4>
<span id="gnutls_005fpubkey_005fexport_005fgost_005fraw2"></span><dl>
<dt id="index-gnutls_005fpubkey_005fexport_005fgost_005fraw2">Function: <em>int</em> <strong>gnutls_pubkey_export_gost_raw2</strong> <em>(gnutls_pubkey_t <var>key</var>, gnutls_ecc_curve_t * <var>curve</var>, gnutls_digest_algorithm_t * <var>digest</var>, gnutls_gost_paramset_t * <var>paramset</var>, gnutls_datum_t * <var>x</var>, gnutls_datum_t * <var>y</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>key</var>: Holds the public key
</p>
<p><var>curve</var>: will hold the curve (may be <code>NULL</code> )
</p>
<p><var>digest</var>: will hold the curve (may be <code>NULL</code> )
</p>
<p><var>paramset</var>: will hold the parameters id (may be <code>NULL</code> )
</p>
<p><var>x</var>: will hold the x-coordinate (may be <code>NULL</code> )
</p>
<p><var>y</var>: will hold the y-coordinate (may be <code>NULL</code> )
</p>
<p><var>flags</var>: flags from <code>gnutls_abstract_export_flags_t</code> 
</p>
<p>This function will export the GOST public key&rsquo;s parameters found in
the given key.  The new parameters will be allocated using
<code>gnutls_malloc()</code>  and will be stored in the appropriate datum.
</p>
<p><strong>Note:</strong> parameters will be stored with least significant byte first. On
version 3.6.3 this was incorrectly returned in big-endian format.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p>
<p><strong>Since:</strong> 3.6.3
</p></dd></dl>

<span id="gnutls_005fpubkey_005fexport_005frsa_005fraw-1"></span><h4 class="subheading">gnutls_pubkey_export_rsa_raw</h4>
<span id="gnutls_005fpubkey_005fexport_005frsa_005fraw"></span><dl>
<dt id="index-gnutls_005fpubkey_005fexport_005frsa_005fraw">Function: <em>int</em> <strong>gnutls_pubkey_export_rsa_raw</strong> <em>(gnutls_pubkey_t <var>key</var>, gnutls_datum_t * <var>m</var>, gnutls_datum_t * <var>e</var>)</em></dt>
<dd><p><var>key</var>: Holds the certificate
</p>
<p><var>m</var>: will hold the modulus (may be <code>NULL</code> )
</p>
<p><var>e</var>: will hold the public exponent (may be <code>NULL</code> )
</p>
<p>This function will export the RSA public key&rsquo;s parameters found in
the given structure.  The new parameters will be allocated using
<code>gnutls_malloc()</code>  and will be stored in the appropriate datum.
</p>
<p>This function allows for <code>NULL</code>  parameters since 3.4.1.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fpubkey_005fexport_005frsa_005fraw2-1"></span><h4 class="subheading">gnutls_pubkey_export_rsa_raw2</h4>
<span id="gnutls_005fpubkey_005fexport_005frsa_005fraw2"></span><dl>
<dt id="index-gnutls_005fpubkey_005fexport_005frsa_005fraw2">Function: <em>int</em> <strong>gnutls_pubkey_export_rsa_raw2</strong> <em>(gnutls_pubkey_t <var>key</var>, gnutls_datum_t * <var>m</var>, gnutls_datum_t * <var>e</var>, unsigned <var>flags</var>)</em></dt>
<dd><p><var>key</var>: Holds the certificate
</p>
<p><var>m</var>: will hold the modulus (may be <code>NULL</code> )
</p>
<p><var>e</var>: will hold the public exponent (may be <code>NULL</code> )
</p>
<p><var>flags</var>: flags from <code>gnutls_abstract_export_flags_t</code> 
</p>
<p>This function will export the RSA public key&rsquo;s parameters found in
the given structure.  The new parameters will be allocated using
<code>gnutls_malloc()</code>  and will be stored in the appropriate datum.
</p>
<p>This function allows for <code>NULL</code>  parameters since 3.4.1.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p>
<p><strong>Since:</strong> 3.6.0
</p></dd></dl>

<span id="gnutls_005fpubkey_005fget_005fkey_005fid-1"></span><h4 class="subheading">gnutls_pubkey_get_key_id</h4>
<span id="gnutls_005fpubkey_005fget_005fkey_005fid"></span><dl>
<dt id="index-gnutls_005fpubkey_005fget_005fkey_005fid">Function: <em>int</em> <strong>gnutls_pubkey_get_key_id</strong> <em>(gnutls_pubkey_t <var>key</var>, unsigned int <var>flags</var>, unsigned char * <var>output_data</var>, size_t * <var>output_data_size</var>)</em></dt>
<dd><p><var>key</var>: Holds the public key
</p>
<p><var>flags</var>: should be one of the flags from <code>gnutls_keyid_flags_t</code> 
</p>
<p><var>output_data</var>: will contain the key ID
</p>
<p><var>output_data_size</var>: holds the size of output_data (and will be
replaced by the actual size of parameters)
</p>
<p>This function will return a unique ID that depends on the public
key parameters. This ID can be used in checking whether a
certificate corresponds to the given public key.
</p>
<p>If the buffer provided is not long enough to hold the output, then
*output_data_size is updated and <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>  will
be returned.  The output will normally be a SHA-1 hash output,
which is 20 bytes.
</p>
<p><strong>Returns:</strong> In case of failure a negative error code will be
returned, and 0 on success.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fpubkey_005fget_005fkey_005fusage-1"></span><h4 class="subheading">gnutls_pubkey_get_key_usage</h4>
<span id="gnutls_005fpubkey_005fget_005fkey_005fusage"></span><dl>
<dt id="index-gnutls_005fpubkey_005fget_005fkey_005fusage">Function: <em>int</em> <strong>gnutls_pubkey_get_key_usage</strong> <em>(gnutls_pubkey_t <var>key</var>, unsigned int * <var>usage</var>)</em></dt>
<dd><p><var>key</var>: should contain a <code>gnutls_pubkey_t</code>  type
</p>
<p><var>usage</var>: If set will return the number of bits of the parameters (may be NULL)
</p>
<p>This function will return the key usage of the public key.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fpubkey_005fget_005fopenpgp_005fkey_005fid-1"></span><h4 class="subheading">gnutls_pubkey_get_openpgp_key_id</h4>
<span id="gnutls_005fpubkey_005fget_005fopenpgp_005fkey_005fid"></span><dl>
<dt id="index-gnutls_005fpubkey_005fget_005fopenpgp_005fkey_005fid">Function: <em>int</em> <strong>gnutls_pubkey_get_openpgp_key_id</strong> <em>(gnutls_pubkey_t <var>key</var>, unsigned int <var>flags</var>, unsigned char * <var>output_data</var>, size_t * <var>output_data_size</var>, unsigned int * <var>subkey</var>)</em></dt>
<dd><p><var>key</var>: Holds the public key
</p>
<p><var>flags</var>: should be one of the flags from <code>gnutls_keyid_flags_t</code> 
</p>
<p><var>output_data</var>: will contain the key ID
</p>
<p><var>output_data_size</var>: holds the size of output_data (and will be
replaced by the actual size of parameters)
</p>
<p><var>subkey</var>: ignored
</p>
<p>This function is no-op.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_UNIMPLEMENTED_FEATURE</code> .
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fpubkey_005fget_005fpk_005falgorithm-1"></span><h4 class="subheading">gnutls_pubkey_get_pk_algorithm</h4>
<span id="gnutls_005fpubkey_005fget_005fpk_005falgorithm"></span><dl>
<dt id="index-gnutls_005fpubkey_005fget_005fpk_005falgorithm">Function: <em>int</em> <strong>gnutls_pubkey_get_pk_algorithm</strong> <em>(gnutls_pubkey_t <var>key</var>, unsigned int * <var>bits</var>)</em></dt>
<dd><p><var>key</var>: should contain a <code>gnutls_pubkey_t</code>  type
</p>
<p><var>bits</var>: If set will return the number of bits of the parameters (may be NULL)
</p>
<p>This function will return the public key algorithm of a public
key and if possible will return a number of bits that indicates
the security parameter of the key.
</p>
<p><strong>Returns:</strong> a member of the <code>gnutls_pk_algorithm_t</code>  enumeration on
success, or a negative error code on error.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fpubkey_005fget_005fpreferred_005fhash_005falgorithm-1"></span><h4 class="subheading">gnutls_pubkey_get_preferred_hash_algorithm</h4>
<span id="gnutls_005fpubkey_005fget_005fpreferred_005fhash_005falgorithm"></span><dl>
<dt id="index-gnutls_005fpubkey_005fget_005fpreferred_005fhash_005falgorithm">Function: <em>int</em> <strong>gnutls_pubkey_get_preferred_hash_algorithm</strong> <em>(gnutls_pubkey_t <var>key</var>, gnutls_digest_algorithm_t *         <var>hash</var>, unsigned int * <var>mand</var>)</em></dt>
<dd><p><var>key</var>: Holds the certificate
</p>
<p><var>hash</var>: The result of the call with the hash algorithm used for signature
</p>
<p><var>mand</var>: If non zero it means that the algorithm MUST use this hash. May be NULL.
</p>
<p>This function will read the certificate and return the appropriate digest
algorithm to use for signing with this certificate. Some certificates (i.e.
DSA might not be able to sign without the preferred algorithm).
</p>
<p>To get the signature algorithm instead of just the hash use <code>gnutls_pk_to_sign()</code> 
with the algorithm of the certificate/key and the provided  <code>hash</code> .
</p>
<p><strong>Returns:</strong> the 0 if the hash algorithm is found. A negative error code is
returned on error.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fpubkey_005fget_005fspki-1"></span><h4 class="subheading">gnutls_pubkey_get_spki</h4>
<span id="gnutls_005fpubkey_005fget_005fspki"></span><dl>
<dt id="index-gnutls_005fpubkey_005fget_005fspki">Function: <em>int</em> <strong>gnutls_pubkey_get_spki</strong> <em>(gnutls_pubkey_t <var>pubkey</var>, gnutls_x509_spki_t <var>spki</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>pubkey</var>: a public key of type <code>gnutls_pubkey_t</code> 
</p>
<p><var>spki</var>: a SubjectPublicKeyInfo structure of type <code>gnutls_pubkey_spki_t</code> 
</p>
<p><var>flags</var>: must be zero
</p>
<p>This function will return the public key information if available.
The provided  <code>spki</code> must be initialized.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.6.0
</p></dd></dl>

<span id="gnutls_005fpubkey_005fimport-1"></span><h4 class="subheading">gnutls_pubkey_import</h4>
<span id="gnutls_005fpubkey_005fimport"></span><dl>
<dt id="index-gnutls_005fpubkey_005fimport">Function: <em>int</em> <strong>gnutls_pubkey_import</strong> <em>(gnutls_pubkey_t <var>key</var>, const gnutls_datum_t * <var>data</var>, gnutls_x509_crt_fmt_t <var>format</var>)</em></dt>
<dd><p><var>key</var>: The public key. 
</p>
<p><var>data</var>: The DER or PEM encoded certificate. 
</p>
<p><var>format</var>: One of DER or PEM 
</p>
<p>This function will import the provided public key in
a SubjectPublicKeyInfo X.509 structure to a native
<code>gnutls_pubkey_t</code>  type. The output will be stored 
in  <code>key</code> . If the public key is PEM encoded it should have a header 
of &quot;PUBLIC KEY&quot;. 
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fpubkey_005fimport_005fdsa_005fraw-1"></span><h4 class="subheading">gnutls_pubkey_import_dsa_raw</h4>
<span id="gnutls_005fpubkey_005fimport_005fdsa_005fraw"></span><dl>
<dt id="index-gnutls_005fpubkey_005fimport_005fdsa_005fraw">Function: <em>int</em> <strong>gnutls_pubkey_import_dsa_raw</strong> <em>(gnutls_pubkey_t <var>key</var>, const gnutls_datum_t * <var>p</var>, const gnutls_datum_t * <var>q</var>, const gnutls_datum_t * <var>g</var>, const gnutls_datum_t * <var>y</var>)</em></dt>
<dd><p><var>key</var>: The structure to store the parsed key
</p>
<p><var>p</var>: holds the p
</p>
<p><var>q</var>: holds the q
</p>
<p><var>g</var>: holds the g
</p>
<p><var>y</var>: holds the y
</p>
<p>This function will convert the given DSA raw parameters to the
native <code>gnutls_pubkey_t</code>  format.  The output will be stored
in  <code>key</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fpubkey_005fimport_005fecc_005fraw-1"></span><h4 class="subheading">gnutls_pubkey_import_ecc_raw</h4>
<span id="gnutls_005fpubkey_005fimport_005fecc_005fraw"></span><dl>
<dt id="index-gnutls_005fpubkey_005fimport_005fecc_005fraw">Function: <em>int</em> <strong>gnutls_pubkey_import_ecc_raw</strong> <em>(gnutls_pubkey_t <var>key</var>, gnutls_ecc_curve_t <var>curve</var>, const gnutls_datum_t * <var>x</var>, const gnutls_datum_t * <var>y</var>)</em></dt>
<dd><p><var>key</var>: The structure to store the parsed key
</p>
<p><var>curve</var>: holds the curve
</p>
<p><var>x</var>: holds the x-coordinate
</p>
<p><var>y</var>: holds the y-coordinate
</p>
<p>This function will convert the given elliptic curve parameters to a
<code>gnutls_pubkey_t</code> .  The output will be stored in  <code>key</code> .
</p>
<p>In EdDSA curves the  <code>y</code> parameter should be <code>NULL</code>  and the  <code>x</code> parameter must
be the value in the native format for the curve.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fpubkey_005fimport_005fecc_005fx962-1"></span><h4 class="subheading">gnutls_pubkey_import_ecc_x962</h4>
<span id="gnutls_005fpubkey_005fimport_005fecc_005fx962"></span><dl>
<dt id="index-gnutls_005fpubkey_005fimport_005fecc_005fx962">Function: <em>int</em> <strong>gnutls_pubkey_import_ecc_x962</strong> <em>(gnutls_pubkey_t <var>key</var>, const gnutls_datum_t * <var>parameters</var>, const gnutls_datum_t * <var>ecpoint</var>)</em></dt>
<dd><p><var>key</var>: The structure to store the parsed key
</p>
<p><var>parameters</var>: DER encoding of an ANSI X9.62 parameters
</p>
<p><var>ecpoint</var>: DER encoding of ANSI X9.62 ECPoint
</p>
<p>This function will convert the given elliptic curve parameters to a
<code>gnutls_pubkey_t</code> .  The output will be stored in  <code>key</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fpubkey_005fimport_005fgost_005fraw-1"></span><h4 class="subheading">gnutls_pubkey_import_gost_raw</h4>
<span id="gnutls_005fpubkey_005fimport_005fgost_005fraw"></span><dl>
<dt id="index-gnutls_005fpubkey_005fimport_005fgost_005fraw">Function: <em>int</em> <strong>gnutls_pubkey_import_gost_raw</strong> <em>(gnutls_pubkey_t <var>key</var>, gnutls_ecc_curve_t <var>curve</var>, gnutls_digest_algorithm_t <var>digest</var>, gnutls_gost_paramset_t <var>paramset</var>, const gnutls_datum_t * <var>x</var>, const gnutls_datum_t * <var>y</var>)</em></dt>
<dd><p><var>key</var>: The structure to store the parsed key
</p>
<p><var>curve</var>: holds the curve
</p>
<p><var>digest</var>: holds the digest
</p>
<p><var>paramset</var>: holds the parameters id
</p>
<p><var>x</var>: holds the x-coordinate
</p>
<p><var>y</var>: holds the y-coordinate
</p>
<p>This function will convert the given GOST public key&rsquo;s parameters to a
<code>gnutls_pubkey_t</code> .  The output will be stored in  <code>key</code> .   <code>digest</code> should be
one of GNUTLS_DIG_GOSR_94, GNUTLS_DIG_STREEBOG_256 or
GNUTLS_DIG_STREEBOG_512.  If  <code>paramset</code> is set to GNUTLS_GOST_PARAMSET_UNKNOWN
default one will be selected depending on  <code>digest</code> .
</p>
<p><strong>Note:</strong> parameters should be stored with least significant byte first. On
version 3.6.3 big-endian format was used incorrectly.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.6.3
</p></dd></dl>

<span id="gnutls_005fpubkey_005fimport_005fopenpgp-1"></span><h4 class="subheading">gnutls_pubkey_import_openpgp</h4>
<span id="gnutls_005fpubkey_005fimport_005fopenpgp"></span><dl>
<dt id="index-gnutls_005fpubkey_005fimport_005fopenpgp">Function: <em>int</em> <strong>gnutls_pubkey_import_openpgp</strong> <em>(gnutls_pubkey_t <var>key</var>, gnutls_openpgp_crt_t <var>crt</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>key</var>: The public key
</p>
<p><var>crt</var>: The certificate to be imported
</p>
<p><var>flags</var>: should be zero
</p>
<p>This function is no-op.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_UNIMPLEMENTED_FEATURE</code> .
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fpubkey_005fimport_005fopenpgp_005fraw-1"></span><h4 class="subheading">gnutls_pubkey_import_openpgp_raw</h4>
<span id="gnutls_005fpubkey_005fimport_005fopenpgp_005fraw"></span><dl>
<dt id="index-gnutls_005fpubkey_005fimport_005fopenpgp_005fraw">Function: <em>int</em> <strong>gnutls_pubkey_import_openpgp_raw</strong> <em>(gnutls_pubkey_t <var>pkey</var>, const gnutls_datum_t * <var>data</var>, gnutls_openpgp_crt_fmt_t          <var>format</var>, const gnutls_openpgp_keyid_t          <var>keyid</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>pkey</var>: The public key
</p>
<p><var>data</var>: The public key data to be imported
</p>
<p><var>format</var>: The format of the public key
</p>
<p><var>keyid</var>: The key id to use (optional)
</p>
<p><var>flags</var>: Should be zero
</p>
<p>This function is no-op.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_UNIMPLEMENTED_FEATURE</code> .
</p>
<p><strong>Since:</strong> 3.1.3
</p></dd></dl>

<span id="gnutls_005fpubkey_005fimport_005fpkcs11-1"></span><h4 class="subheading">gnutls_pubkey_import_pkcs11</h4>
<span id="gnutls_005fpubkey_005fimport_005fpkcs11"></span><dl>
<dt id="index-gnutls_005fpubkey_005fimport_005fpkcs11">Function: <em>int</em> <strong>gnutls_pubkey_import_pkcs11</strong> <em>(gnutls_pubkey_t <var>key</var>, gnutls_pkcs11_obj_t <var>obj</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>key</var>: The public key
</p>
<p><var>obj</var>: The parameters to be imported
</p>
<p><var>flags</var>: should be zero
</p>
<p>Imports a public key from a pkcs11 key. This function will import
the given public key to the abstract <code>gnutls_pubkey_t</code>  type.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fpubkey_005fimport_005fprivkey-1"></span><h4 class="subheading">gnutls_pubkey_import_privkey</h4>
<span id="gnutls_005fpubkey_005fimport_005fprivkey"></span><dl>
<dt id="index-gnutls_005fpubkey_005fimport_005fprivkey">Function: <em>int</em> <strong>gnutls_pubkey_import_privkey</strong> <em>(gnutls_pubkey_t <var>key</var>, gnutls_privkey_t <var>pkey</var>, unsigned int <var>usage</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>key</var>: The public key
</p>
<p><var>pkey</var>: The private key
</p>
<p><var>usage</var>: GNUTLS_KEY_* key usage flags.
</p>
<p><var>flags</var>: should be zero
</p>
<p>Imports the public key from a private.  This function will import
the given public key to the abstract <code>gnutls_pubkey_t</code>  type.
</p>
<p>Note that in certain keys this operation may not be possible, e.g.,
in other than RSA PKCS<code>11</code>  keys.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fpubkey_005fimport_005frsa_005fraw-1"></span><h4 class="subheading">gnutls_pubkey_import_rsa_raw</h4>
<span id="gnutls_005fpubkey_005fimport_005frsa_005fraw"></span><dl>
<dt id="index-gnutls_005fpubkey_005fimport_005frsa_005fraw">Function: <em>int</em> <strong>gnutls_pubkey_import_rsa_raw</strong> <em>(gnutls_pubkey_t <var>key</var>, const gnutls_datum_t * <var>m</var>, const gnutls_datum_t * <var>e</var>)</em></dt>
<dd><p><var>key</var>: The key
</p>
<p><var>m</var>: holds the modulus
</p>
<p><var>e</var>: holds the public exponent
</p>
<p>This function will replace the parameters in the given structure.
The new parameters should be stored in the appropriate
gnutls_datum.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, or an negative error code.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fpubkey_005fimport_005ftpm_005fraw-1"></span><h4 class="subheading">gnutls_pubkey_import_tpm_raw</h4>
<span id="gnutls_005fpubkey_005fimport_005ftpm_005fraw"></span><dl>
<dt id="index-gnutls_005fpubkey_005fimport_005ftpm_005fraw">Function: <em>int</em> <strong>gnutls_pubkey_import_tpm_raw</strong> <em>(gnutls_pubkey_t <var>pkey</var>, const gnutls_datum_t * <var>fdata</var>, gnutls_tpmkey_fmt_t <var>format</var>, const char * <var>srk_password</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>pkey</var>: The public key
</p>
<p><var>fdata</var>: The TPM key to be imported
</p>
<p><var>format</var>: The format of the private key
</p>
<p><var>srk_password</var>: The password for the SRK key (optional)
</p>
<p><var>flags</var>: One of the GNUTLS_PUBKEY_* flags
</p>
<p>This function will import the public key from the provided TPM key
structure.
</p>
<p>With respect to passwords the same as in
<code>gnutls_pubkey_import_tpm_url()</code>  apply.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.1.0
</p></dd></dl>

<span id="gnutls_005fpubkey_005fimport_005ftpm_005furl-1"></span><h4 class="subheading">gnutls_pubkey_import_tpm_url</h4>
<span id="gnutls_005fpubkey_005fimport_005ftpm_005furl"></span><dl>
<dt id="index-gnutls_005fpubkey_005fimport_005ftpm_005furl-1">Function: <em>int</em> <strong>gnutls_pubkey_import_tpm_url</strong> <em>(gnutls_pubkey_t <var>pkey</var>, const char * <var>url</var>, const char * <var>srk_password</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>pkey</var>: The public key
</p>
<p><var>url</var>: The URL of the TPM key to be imported
</p>
<p><var>srk_password</var>: The password for the SRK key (optional)
</p>
<p><var>flags</var>: should be zero
</p>
<p>This function will import the given private key to the abstract
<code>gnutls_privkey_t</code>  type. 
</p>
<p>Note that unless <code>GNUTLS_PUBKEY_DISABLE_CALLBACKS</code> 
is specified, if incorrect (or NULL) passwords are given
the PKCS11 callback functions will be used to obtain the
correct passwords. Otherwise if the SRK password is wrong
<code>GNUTLS_E_TPM_SRK_PASSWORD_ERROR</code>  is returned.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.1.0
</p></dd></dl>

<span id="gnutls_005fpubkey_005fimport_005furl-1"></span><h4 class="subheading">gnutls_pubkey_import_url</h4>
<span id="gnutls_005fpubkey_005fimport_005furl"></span><dl>
<dt id="index-gnutls_005fpubkey_005fimport_005furl">Function: <em>int</em> <strong>gnutls_pubkey_import_url</strong> <em>(gnutls_pubkey_t <var>key</var>, const char * <var>url</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>key</var>: A key of type <code>gnutls_pubkey_t</code> 
</p>
<p><var>url</var>: A PKCS 11 url
</p>
<p><var>flags</var>: One of GNUTLS_PKCS11_OBJ_* flags
</p>
<p>This function will import a public key from the provided URL.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.1.0
</p></dd></dl>

<span id="gnutls_005fpubkey_005fimport_005fx509-1"></span><h4 class="subheading">gnutls_pubkey_import_x509</h4>
<span id="gnutls_005fpubkey_005fimport_005fx509"></span><dl>
<dt id="index-gnutls_005fpubkey_005fimport_005fx509">Function: <em>int</em> <strong>gnutls_pubkey_import_x509</strong> <em>(gnutls_pubkey_t <var>key</var>, gnutls_x509_crt_t <var>crt</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>key</var>: The public key
</p>
<p><var>crt</var>: The certificate to be imported
</p>
<p><var>flags</var>: should be zero
</p>
<p>This function will import the given public key to the abstract
<code>gnutls_pubkey_t</code>  type.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fpubkey_005fimport_005fx509_005fcrq-1"></span><h4 class="subheading">gnutls_pubkey_import_x509_crq</h4>
<span id="gnutls_005fpubkey_005fimport_005fx509_005fcrq"></span><dl>
<dt id="index-gnutls_005fpubkey_005fimport_005fx509_005fcrq">Function: <em>int</em> <strong>gnutls_pubkey_import_x509_crq</strong> <em>(gnutls_pubkey_t <var>key</var>, gnutls_x509_crq_t <var>crq</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>key</var>: The public key
</p>
<p><var>crq</var>: The certificate to be imported
</p>
<p><var>flags</var>: should be zero
</p>
<p>This function will import the given public key to the abstract
<code>gnutls_pubkey_t</code>  type.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.1.5
</p></dd></dl>

<span id="gnutls_005fpubkey_005fimport_005fx509_005fraw-1"></span><h4 class="subheading">gnutls_pubkey_import_x509_raw</h4>
<span id="gnutls_005fpubkey_005fimport_005fx509_005fraw"></span><dl>
<dt id="index-gnutls_005fpubkey_005fimport_005fx509_005fraw">Function: <em>int</em> <strong>gnutls_pubkey_import_x509_raw</strong> <em>(gnutls_pubkey_t <var>pkey</var>, const gnutls_datum_t * <var>data</var>, gnutls_x509_crt_fmt_t <var>format</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>pkey</var>: The public key
</p>
<p><var>data</var>: The public key data to be imported
</p>
<p><var>format</var>: The format of the public key
</p>
<p><var>flags</var>: should be zero
</p>
<p>This function will import the given public key to the abstract
<code>gnutls_pubkey_t</code>  type. 
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.1.3
</p></dd></dl>

<span id="gnutls_005fpubkey_005finit-1"></span><h4 class="subheading">gnutls_pubkey_init</h4>
<span id="gnutls_005fpubkey_005finit"></span><dl>
<dt id="index-gnutls_005fpubkey_005finit">Function: <em>int</em> <strong>gnutls_pubkey_init</strong> <em>(gnutls_pubkey_t * <var>key</var>)</em></dt>
<dd><p><var>key</var>: A pointer to the type to be initialized
</p>
<p>This function will initialize a public key.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fpubkey_005fprint-1"></span><h4 class="subheading">gnutls_pubkey_print</h4>
<span id="gnutls_005fpubkey_005fprint"></span><dl>
<dt id="index-gnutls_005fpubkey_005fprint">Function: <em>int</em> <strong>gnutls_pubkey_print</strong> <em>(gnutls_pubkey_t <var>pubkey</var>, gnutls_certificate_print_formats_t <var>format</var>, gnutls_datum_t * <var>out</var>)</em></dt>
<dd><p><var>pubkey</var>: The data to be printed
</p>
<p><var>format</var>: Indicate the format to use
</p>
<p><var>out</var>: Newly allocated datum with null terminated string.
</p>
<p>This function will pretty print public key information, suitable for
display to a human.
</p>
<p>Only <code>GNUTLS_CRT_PRINT_FULL</code>  and <code>GNUTLS_CRT_PRINT_FULL_NUMBERS</code> 
are implemented.
</p>
<p>The output  <code>out</code> needs to be deallocated using <code>gnutls_free()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.1.5
</p></dd></dl>

<span id="gnutls_005fpubkey_005fset_005fkey_005fusage-1"></span><h4 class="subheading">gnutls_pubkey_set_key_usage</h4>
<span id="gnutls_005fpubkey_005fset_005fkey_005fusage"></span><dl>
<dt id="index-gnutls_005fpubkey_005fset_005fkey_005fusage">Function: <em>int</em> <strong>gnutls_pubkey_set_key_usage</strong> <em>(gnutls_pubkey_t <var>key</var>, unsigned int <var>usage</var>)</em></dt>
<dd><p><var>key</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>usage</var>: an ORed sequence of the GNUTLS_KEY_* elements.
</p>
<p>This function will set the key usage flags of the public key. This
is only useful if the key is to be exported to a certificate or
certificate request.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fpubkey_005fset_005fpin_005ffunction-1"></span><h4 class="subheading">gnutls_pubkey_set_pin_function</h4>
<span id="gnutls_005fpubkey_005fset_005fpin_005ffunction"></span><dl>
<dt id="index-gnutls_005fpubkey_005fset_005fpin_005ffunction">Function: <em>void</em> <strong>gnutls_pubkey_set_pin_function</strong> <em>(gnutls_pubkey_t <var>key</var>, gnutls_pin_callback_t <var>fn</var>, void * <var>userdata</var>)</em></dt>
<dd><p><var>key</var>: A key of type <code>gnutls_pubkey_t</code> 
</p>
<p><var>fn</var>: the callback
</p>
<p><var>userdata</var>: data associated with the callback
</p>
<p>This function will set a callback function to be used when
required to access the object. This function overrides any other
global PIN functions.
</p>
<p>Note that this function must be called right after initialization
to have effect.
</p>
<p><strong>Since:</strong> 3.1.0
</p></dd></dl>

<span id="gnutls_005fpubkey_005fset_005fspki-1"></span><h4 class="subheading">gnutls_pubkey_set_spki</h4>
<span id="gnutls_005fpubkey_005fset_005fspki"></span><dl>
<dt id="index-gnutls_005fpubkey_005fset_005fspki">Function: <em>int</em> <strong>gnutls_pubkey_set_spki</strong> <em>(gnutls_pubkey_t <var>pubkey</var>, const gnutls_x509_spki_t <var>spki</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>pubkey</var>: a public key of type <code>gnutls_pubkey_t</code> 
</p>
<p><var>spki</var>: a SubjectPublicKeyInfo structure of type <code>gnutls_pubkey_spki_t</code> 
</p>
<p><var>flags</var>: must be zero
</p>
<p>This function will set the public key information.
The provided  <code>spki</code> must be initialized.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.6.0
</p></dd></dl>

<span id="gnutls_005fpubkey_005fverify_005fdata2-1"></span><h4 class="subheading">gnutls_pubkey_verify_data2</h4>
<span id="gnutls_005fpubkey_005fverify_005fdata2"></span><dl>
<dt id="index-gnutls_005fpubkey_005fverify_005fdata2-1">Function: <em>int</em> <strong>gnutls_pubkey_verify_data2</strong> <em>(gnutls_pubkey_t <var>pubkey</var>, gnutls_sign_algorithm_t <var>algo</var>, unsigned int <var>flags</var>, const gnutls_datum_t * <var>data</var>, const gnutls_datum_t * <var>signature</var>)</em></dt>
<dd><p><var>pubkey</var>: Holds the public key
</p>
<p><var>algo</var>: The signature algorithm used
</p>
<p><var>flags</var>: Zero or an OR list of <code>gnutls_certificate_verify_flags</code> 
</p>
<p><var>data</var>: holds the signed data
</p>
<p><var>signature</var>: contains the signature
</p>
<p>This function will verify the given signed data, using the
parameters from the certificate.
</p>
<p><strong>Returns:</strong> In case of a verification failure <code>GNUTLS_E_PK_SIG_VERIFY_FAILED</code>  
is returned, and zero or positive code on success. For known to be insecure
signatures this function will return <code>GNUTLS_E_INSUFFICIENT_SECURITY</code>  unless
the flag <code>GNUTLS_VERIFY_ALLOW_BROKEN</code>  is specified.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fpubkey_005fverify_005fhash2-1"></span><h4 class="subheading">gnutls_pubkey_verify_hash2</h4>
<span id="gnutls_005fpubkey_005fverify_005fhash2"></span><dl>
<dt id="index-gnutls_005fpubkey_005fverify_005fhash2-1">Function: <em>int</em> <strong>gnutls_pubkey_verify_hash2</strong> <em>(gnutls_pubkey_t <var>key</var>, gnutls_sign_algorithm_t <var>algo</var>, unsigned int <var>flags</var>, const gnutls_datum_t * <var>hash</var>, const gnutls_datum_t * <var>signature</var>)</em></dt>
<dd><p><var>key</var>: Holds the public key
</p>
<p><var>algo</var>: The signature algorithm used
</p>
<p><var>flags</var>: Zero or an OR list of <code>gnutls_certificate_verify_flags</code> 
</p>
<p><var>hash</var>: holds the hash digest to be verified
</p>
<p><var>signature</var>: contains the signature
</p>
<p>This function will verify the given signed digest, using the
parameters from the public key. Note that unlike <code>gnutls_privkey_sign_hash()</code> ,
this function accepts a signature algorithm instead of a digest algorithm.
You can use <code>gnutls_pk_to_sign()</code>  to get the appropriate value.
</p>
<p><strong>Returns:</strong> In case of a verification failure <code>GNUTLS_E_PK_SIG_VERIFY_FAILED</code>  
is returned, and zero or positive code on success. For known to be insecure
signatures this function will return <code>GNUTLS_E_INSUFFICIENT_SECURITY</code>  unless
the flag <code>GNUTLS_VERIFY_ALLOW_BROKEN</code>  is specified.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fpubkey_005fverify_005fparams-1"></span><h4 class="subheading">gnutls_pubkey_verify_params</h4>
<span id="gnutls_005fpubkey_005fverify_005fparams"></span><dl>
<dt id="index-gnutls_005fpubkey_005fverify_005fparams">Function: <em>int</em> <strong>gnutls_pubkey_verify_params</strong> <em>(gnutls_pubkey_t <var>key</var>)</em></dt>
<dd><p><var>key</var>: should contain a <code>gnutls_pubkey_t</code>  type
</p>
<p>This function will verify the public key parameters.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.3.0
</p></dd></dl>

<span id="gnutls_005fregister_005fcustom_005furl-1"></span><h4 class="subheading">gnutls_register_custom_url</h4>
<span id="gnutls_005fregister_005fcustom_005furl"></span><dl>
<dt id="index-gnutls_005fregister_005fcustom_005furl-1">Function: <em>int</em> <strong>gnutls_register_custom_url</strong> <em>(const gnutls_custom_url_st * <var>st</var>)</em></dt>
<dd><p><var>st</var>: A <code>gnutls_custom_url_st</code>  structure
</p>
<p>Register a custom URL. This will affect the following functions:
<code>gnutls_url_is_supported()</code> , <code>gnutls_privkey_import_url()</code> ,
gnutls_pubkey_import_url, <code>gnutls_x509_crt_import_url()</code>  
and all functions that depend on
them, e.g., <code>gnutls_certificate_set_x509_key_file2()</code> .
</p>
<p>The provided structure and callback functions must be valid throughout
the lifetime of the process. The registration of an existing URL type
will fail with <code>GNUTLS_E_INVALID_REQUEST</code> . Since GnuTLS 3.5.0 this function
can be used to override the builtin URLs.
</p>
<p>This function is not thread safe.
</p>
<p><strong>Returns:</strong> returns zero if the given structure was imported or a negative value otherwise.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fsystem_005fkey_005fadd_005fx509-1"></span><h4 class="subheading">gnutls_system_key_add_x509</h4>
<span id="gnutls_005fsystem_005fkey_005fadd_005fx509"></span><dl>
<dt id="index-gnutls_005fsystem_005fkey_005fadd_005fx509">Function: <em>int</em> <strong>gnutls_system_key_add_x509</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_x509_privkey_t <var>privkey</var>, const char * <var>label</var>, char ** <var>cert_url</var>, char ** <var>key_url</var>)</em></dt>
<dd><p><var>crt</var>: the certificate to be added
</p>
<p><var>privkey</var>: the key to be added
</p>
<p><var>label</var>: the friendly name to describe the key
</p>
<p><var>cert_url</var>: if non-NULL it will contain an allocated value with the certificate URL
</p>
<p><var>key_url</var>: if non-NULL it will contain an allocated value with the key URL
</p>
<p>This function will added the given key and certificate pair,
to the system list.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fsystem_005fkey_005fdelete-1"></span><h4 class="subheading">gnutls_system_key_delete</h4>
<span id="gnutls_005fsystem_005fkey_005fdelete"></span><dl>
<dt id="index-gnutls_005fsystem_005fkey_005fdelete">Function: <em>int</em> <strong>gnutls_system_key_delete</strong> <em>(const char * <var>cert_url</var>, const char * <var>key_url</var>)</em></dt>
<dd><p><var>cert_url</var>: the URL of the certificate
</p>
<p><var>key_url</var>: the URL of the key
</p>
<p>This function will delete the key and certificate pair.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fsystem_005fkey_005fiter_005fdeinit-1"></span><h4 class="subheading">gnutls_system_key_iter_deinit</h4>
<span id="gnutls_005fsystem_005fkey_005fiter_005fdeinit"></span><dl>
<dt id="index-gnutls_005fsystem_005fkey_005fiter_005fdeinit">Function: <em>void</em> <strong>gnutls_system_key_iter_deinit</strong> <em>(gnutls_system_key_iter_t <var>iter</var>)</em></dt>
<dd><p><var>iter</var>: an iterator of system keys
</p>
<p>This function will deinitialize the iterator.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fsystem_005fkey_005fiter_005fget_005finfo-1"></span><h4 class="subheading">gnutls_system_key_iter_get_info</h4>
<span id="gnutls_005fsystem_005fkey_005fiter_005fget_005finfo"></span><dl>
<dt id="index-gnutls_005fsystem_005fkey_005fiter_005fget_005finfo-1">Function: <em>int</em> <strong>gnutls_system_key_iter_get_info</strong> <em>(gnutls_system_key_iter_t * <var>iter</var>, unsigned <var>cert_type</var>, char ** <var>cert_url</var>, char ** <var>key_url</var>, char ** <var>label</var>, gnutls_datum_t * <var>der</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>iter</var>: an iterator of the system keys (must be set to <code>NULL</code>  initially)
</p>
<p><var>cert_type</var>: A value of gnutls_certificate_type_t which indicates the type of certificate to look for
</p>
<p><var>cert_url</var>: The certificate URL of the pair (may be <code>NULL</code> )
</p>
<p><var>key_url</var>: The key URL of the pair (may be <code>NULL</code> )
</p>
<p><var>label</var>: The friendly name (if any) of the pair (may be <code>NULL</code> )
</p>
<p><var>der</var>: if non-NULL the DER data of the certificate
</p>
<p><var>flags</var>: should be zero
</p>
<p>This function will return on each call a certificate
and key pair URLs, as well as a label associated with them,
and the DER-encoded certificate. When the iteration is complete it will
return <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> .
</p>
<p>Typically  <code>cert_type</code> should be <code>GNUTLS_CRT_X509</code> .
</p>
<p>All values set are allocated and must be cleared using <code>gnutls_free()</code> ,
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrl_005fprivkey_005fsign-1"></span><h4 class="subheading">gnutls_x509_crl_privkey_sign</h4>
<span id="gnutls_005fx509_005fcrl_005fprivkey_005fsign"></span><dl>
<dt id="index-gnutls_005fx509_005fcrl_005fprivkey_005fsign-1">Function: <em>int</em> <strong>gnutls_x509_crl_privkey_sign</strong> <em>(gnutls_x509_crl_t <var>crl</var>, gnutls_x509_crt_t <var>issuer</var>, gnutls_privkey_t <var>issuer_key</var>, gnutls_digest_algorithm_t <var>dig</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>crl</var>: should contain a gnutls_x509_crl_t type
</p>
<p><var>issuer</var>: is the certificate of the certificate issuer
</p>
<p><var>issuer_key</var>: holds the issuer&rsquo;s private key
</p>
<p><var>dig</var>: The message digest to use. GNUTLS_DIG_SHA256 is the safe choice unless you know what you&rsquo;re doing.
</p>
<p><var>flags</var>: must be 0
</p>
<p>This function will sign the CRL with the issuer&rsquo;s private key, and
will copy the issuer&rsquo;s information into the CRL.
</p>
<p>This must be the last step in a certificate CRL since all
the previously set parameters are now signed.
</p>
<p>A known limitation of this function is, that a newly-signed CRL will not
be fully functional (e.g., for signature verification), until it
is exported an re-imported.
</p>
<p>After GnuTLS 3.6.1 the value of  <code>dig</code> may be <code>GNUTLS_DIG_UNKNOWN</code> ,
and in that case, a suitable but reasonable for the key algorithm will be selected.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p>Since 2.12.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fprivkey_005fsign-1"></span><h4 class="subheading">gnutls_x509_crq_privkey_sign</h4>
<span id="gnutls_005fx509_005fcrq_005fprivkey_005fsign"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fprivkey_005fsign">Function: <em>int</em> <strong>gnutls_x509_crq_privkey_sign</strong> <em>(gnutls_x509_crq_t <var>crq</var>, gnutls_privkey_t <var>key</var>, gnutls_digest_algorithm_t <var>dig</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>key</var>: holds a private key
</p>
<p><var>dig</var>: The message digest to use, i.e., <code>GNUTLS_DIG_SHA1</code> 
</p>
<p><var>flags</var>: must be 0
</p>
<p>This function will sign the certificate request with a private key.
This must be the same key as the one used in
<code>gnutls_x509_crt_set_key()</code>  since a certificate request is self
signed.
</p>
<p>This must be the last step in a certificate request generation
since all the previously set parameters are now signed.
</p>
<p>A known limitation of this function is, that a newly-signed request will not
be fully functional (e.g., for signature verification), until it
is exported an re-imported.
</p>
<p>After GnuTLS 3.6.1 the value of  <code>dig</code> may be <code>GNUTLS_DIG_UNKNOWN</code> ,
and in that case, a suitable but reasonable for the key algorithm will be selected.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
<code>GNUTLS_E_ASN1_VALUE_NOT_FOUND</code>  is returned if you didn&rsquo;t set all
information in the certificate request (e.g., the version using
<code>gnutls_x509_crq_set_version()</code> ).
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrq_005fset_005fpubkey-1"></span><h4 class="subheading">gnutls_x509_crq_set_pubkey</h4>
<span id="gnutls_005fx509_005fcrq_005fset_005fpubkey"></span><dl>
<dt id="index-gnutls_005fx509_005fcrq_005fset_005fpubkey-1">Function: <em>int</em> <strong>gnutls_x509_crq_set_pubkey</strong> <em>(gnutls_x509_crq_t <var>crq</var>, gnutls_pubkey_t <var>key</var>)</em></dt>
<dd><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code>  type
</p>
<p><var>key</var>: holds a public key
</p>
<p>This function will set the public parameters from the given public
key to the request. The  <code>key</code> can be deallocated after that.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fprivkey_005fsign-1"></span><h4 class="subheading">gnutls_x509_crt_privkey_sign</h4>
<span id="gnutls_005fx509_005fcrt_005fprivkey_005fsign"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fprivkey_005fsign">Function: <em>int</em> <strong>gnutls_x509_crt_privkey_sign</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_x509_crt_t <var>issuer</var>, gnutls_privkey_t <var>issuer_key</var>, gnutls_digest_algorithm_t <var>dig</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> 
</p>
<p><var>issuer</var>: is the certificate of the certificate issuer
</p>
<p><var>issuer_key</var>: holds the issuer&rsquo;s private key
</p>
<p><var>dig</var>: The message digest to use, <code>GNUTLS_DIG_SHA256</code>  is a safe choice
</p>
<p><var>flags</var>: must be 0
</p>
<p>This function will sign the certificate with the issuer&rsquo;s private key, and
will copy the issuer&rsquo;s information into the certificate.
</p>
<p>This must be the last step in a certificate generation since all
the previously set parameters are now signed.
</p>
<p>A known limitation of this function is, that a newly-signed certificate will not
be fully functional (e.g., for signature verification), until it
is exported an re-imported.
</p>
<p>After GnuTLS 3.6.1 the value of  <code>dig</code> may be <code>GNUTLS_DIG_UNKNOWN</code> ,
and in that case, a suitable but reasonable for the key algorithm will be selected.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fset_005fpubkey-1"></span><h4 class="subheading">gnutls_x509_crt_set_pubkey</h4>
<span id="gnutls_005fx509_005fcrt_005fset_005fpubkey"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fset_005fpubkey-1">Function: <em>int</em> <strong>gnutls_x509_crt_set_pubkey</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_pubkey_t <var>key</var>)</em></dt>
<dd><p><var>crt</var>: should contain a <code>gnutls_x509_crt_t</code>  type
</p>
<p><var>key</var>: holds a public key
</p>
<p>This function will set the public parameters from the given public
key to the certificate. The  <code>key</code> can be deallocated after that.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>


<hr>
<span id="Socket-specific-API"></span><div class="header">
<p>
Next: <a href="#DANE-API" accesskey="n" rel="next">DANE API</a>, Previous: <a href="#Abstract-key-API" accesskey="p" rel="prev">Abstract key API</a>, Up: <a href="#API-reference" accesskey="u" rel="up">API reference</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Socket-specific-API-1"></span><h3 class="section">E.10 Socket specific API</h3>

<p>The prototypes for the following functions lie in
<samp>gnutls/socket.h</samp>.
</p>
<span id="gnutls_005ftransport_005fset_005ffastopen-1"></span><h4 class="subheading">gnutls_transport_set_fastopen</h4>
<span id="gnutls_005ftransport_005fset_005ffastopen"></span><dl>
<dt id="index-gnutls_005ftransport_005fset_005ffastopen-1">Function: <em>void</em> <strong>gnutls_transport_set_fastopen</strong> <em>(gnutls_session_t <var>session</var>, int <var>fd</var>, struct sockaddr * <var>connect_addr</var>, socklen_t <var>connect_addrlen</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p><var>fd</var>: is the session&rsquo;s socket descriptor
</p>
<p><var>connect_addr</var>: is the address we want to connect to
</p>
<p><var>connect_addrlen</var>: is the length of  <code>connect_addr</code> 
</p>
<p><var>flags</var>: must be zero
</p>
<p>Enables TCP Fast Open (TFO) for the specified TLS client session.
That means that TCP connection establishment and the transmission
of the first TLS client hello packet are combined. The
peer&rsquo;s address must be  specified in  <code>connect_addr</code> and  <code>connect_addrlen</code> ,
and the socket specified by  <code>fd</code> should not be connected.
</p>
<p>TFO only works for TCP sockets of type AF_INET and AF_INET6.
If the OS doesn&rsquo;t support TCP fast open this function will result
to gnutls using <code>connect()</code>  transparently during the first write.
</p>
<p><strong>Note:</strong> This function overrides all the transport callback functions.
If this is undesirable, TCP Fast Open must be implemented on the user
callback functions without calling this function. When using
this function, transport callbacks must not be set, and 
<code>gnutls_transport_set_ptr()</code>  or <code>gnutls_transport_set_int()</code> 
must not be called.
</p>
<p>On GNU/Linux TFO has to be enabled at the system layer, that is
in /proc/sys/net/ipv4/tcp_fastopen, bit 0 has to be set.
</p>
<p>This function has no effect on server sessions.
</p>
<p><strong>Since:</strong> 3.5.3
</p></dd></dl>


<hr>
<span id="DANE-API"></span><div class="header">
<p>
Next: <a href="#Cryptographic-API" accesskey="n" rel="next">Cryptographic API</a>, Previous: <a href="#Socket-specific-API" accesskey="p" rel="prev">Socket specific API</a>, Up: <a href="#API-reference" accesskey="u" rel="up">API reference</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="DANE-API-1"></span><h3 class="section">E.11 DANE API</h3>

<p>The following functions are to be used for DANE certificate verification.
Their prototypes lie in <samp>gnutls/dane.h</samp>. Note that you need to link
with the <code>libgnutls-dane</code> library to use them.
</p>

<span id="dane_005fcert_005ftype_005fname-1"></span><h4 class="subheading">dane_cert_type_name</h4>
<span id="dane_005fcert_005ftype_005fname"></span><dl>
<dt id="index-dane_005fcert_005ftype_005fname">Function: <em>const char *</em> <strong>dane_cert_type_name</strong> <em>(dane_cert_type_t <var>type</var>)</em></dt>
<dd><p><var>type</var>: is a DANE match type
</p>
<p>Convert a <code>dane_cert_type_t</code>  value to a string.
</p>
<p><strong>Returns:</strong> a string that contains the name of the specified
type, or <code>NULL</code> .
</p></dd></dl>

<span id="dane_005fcert_005fusage_005fname-1"></span><h4 class="subheading">dane_cert_usage_name</h4>
<span id="dane_005fcert_005fusage_005fname"></span><dl>
<dt id="index-dane_005fcert_005fusage_005fname">Function: <em>const char *</em> <strong>dane_cert_usage_name</strong> <em>(dane_cert_usage_t <var>usage</var>)</em></dt>
<dd><p><var>usage</var>: is a DANE certificate usage
</p>
<p>Convert a <code>dane_cert_usage_t</code>  value to a string.
</p>
<p><strong>Returns:</strong> a string that contains the name of the specified
type, or <code>NULL</code> .
</p></dd></dl>

<span id="dane_005fmatch_005ftype_005fname-1"></span><h4 class="subheading">dane_match_type_name</h4>
<span id="dane_005fmatch_005ftype_005fname"></span><dl>
<dt id="index-dane_005fmatch_005ftype_005fname">Function: <em>const char *</em> <strong>dane_match_type_name</strong> <em>(dane_match_type_t <var>type</var>)</em></dt>
<dd><p><var>type</var>: is a DANE match type
</p>
<p>Convert a <code>dane_match_type_t</code>  value to a string.
</p>
<p><strong>Returns:</strong> a string that contains the name of the specified
type, or <code>NULL</code> .
</p></dd></dl>

<span id="dane_005fquery_005fdata-1"></span><h4 class="subheading">dane_query_data</h4>
<span id="dane_005fquery_005fdata"></span><dl>
<dt id="index-dane_005fquery_005fdata">Function: <em>int</em> <strong>dane_query_data</strong> <em>(dane_query_t <var>q</var>, unsigned int <var>idx</var>, unsigned int * <var>usage</var>, unsigned int * <var>type</var>, unsigned int * <var>match</var>, gnutls_datum_t * <var>data</var>)</em></dt>
<dd><p><var>q</var>: The query result structure
</p>
<p><var>idx</var>: The index of the query response.
</p>
<p><var>usage</var>: The certificate usage (see <code>dane_cert_usage_t</code> )
</p>
<p><var>type</var>: The certificate type (see <code>dane_cert_type_t</code> )
</p>
<p><var>match</var>: The DANE matching type (see <code>dane_match_type_t</code> )
</p>
<p><var>data</var>: The DANE data.
</p>
<p>This function will provide the DANE data from the query
response.
</p>
<p><strong>Returns:</strong> On success, <code>DANE_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="dane_005fquery_005fdeinit-1"></span><h4 class="subheading">dane_query_deinit</h4>
<span id="dane_005fquery_005fdeinit"></span><dl>
<dt id="index-dane_005fquery_005fdeinit">Function: <em>void</em> <strong>dane_query_deinit</strong> <em>(dane_query_t <var>q</var>)</em></dt>
<dd><p><var>q</var>: The structure to be deinitialized
</p>
<p>This function will deinitialize a DANE query result structure.
</p></dd></dl>

<span id="dane_005fquery_005fentries-1"></span><h4 class="subheading">dane_query_entries</h4>
<span id="dane_005fquery_005fentries"></span><dl>
<dt id="index-dane_005fquery_005fentries">Function: <em>unsigned int</em> <strong>dane_query_entries</strong> <em>(dane_query_t <var>q</var>)</em></dt>
<dd><p><var>q</var>: The query result structure
</p>
<p>This function will return the number of entries in a query.
</p>
<p><strong>Returns:</strong> The number of entries.
</p></dd></dl>

<span id="dane_005fquery_005fstatus-1"></span><h4 class="subheading">dane_query_status</h4>
<span id="dane_005fquery_005fstatus"></span><dl>
<dt id="index-dane_005fquery_005fstatus">Function: <em>dane_query_status_t</em> <strong>dane_query_status</strong> <em>(dane_query_t <var>q</var>)</em></dt>
<dd><p><var>q</var>: The query result structure
</p>
<p>This function will return the status of the query response.
See <code>dane_query_status_t</code>  for the possible types.
</p>
<p><strong>Returns:</strong> The status type.
</p></dd></dl>

<span id="dane_005fquery_005ftlsa-1"></span><h4 class="subheading">dane_query_tlsa</h4>
<span id="dane_005fquery_005ftlsa"></span><dl>
<dt id="index-dane_005fquery_005ftlsa">Function: <em>int</em> <strong>dane_query_tlsa</strong> <em>(dane_state_t <var>s</var>, dane_query_t * <var>r</var>, const char * <var>host</var>, const char * <var>proto</var>, unsigned int <var>port</var>)</em></dt>
<dd><p><var>s</var>: The DANE state structure
</p>
<p><var>r</var>: A structure to place the result
</p>
<p><var>host</var>: The host name to resolve.
</p>
<p><var>proto</var>: The protocol type (tcp, udp, etc.)
</p>
<p><var>port</var>: The service port number (eg. 443).
</p>
<p>This function will query the DNS server for the TLSA (DANE)
data for the given host.
</p>
<p><strong>Returns:</strong> On success, <code>DANE_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="dane_005fquery_005fto_005fraw_005ftlsa-1"></span><h4 class="subheading">dane_query_to_raw_tlsa</h4>
<span id="dane_005fquery_005fto_005fraw_005ftlsa"></span><dl>
<dt id="index-dane_005fquery_005fto_005fraw_005ftlsa">Function: <em>int</em> <strong>dane_query_to_raw_tlsa</strong> <em>(dane_query_t <var>q</var>, unsigned int * <var>data_entries</var>, char *** <var>dane_data</var>, int ** <var>dane_data_len</var>, int * <var>secure</var>, int * <var>bogus</var>)</em></dt>
<dd><p><var>q</var>: The query result structure
</p>
<p><var>data_entries</var>: Pointer set to the number of entries in the query
</p>
<p><var>dane_data</var>: Pointer to contain an array of DNS rdata items, terminated with a NULL pointer;
caller must guarantee that the referenced data remains
valid until <code>dane_query_deinit()</code>  is called.
</p>
<p><var>dane_data_len</var>: Pointer to contain the length n bytes of the dane_data items
</p>
<p><var>secure</var>: Pointer set true if the result is validated securely, false if
validation failed or the domain queried has no security info
</p>
<p><var>bogus</var>: Pointer set true if the result was not secure due to a security failure
</p>
<p>This function will provide the DANE data from the query
response.
</p>
<p>The pointers dane_data and dane_data_len are allocated with <code>gnutls_malloc()</code> 
to contain the data from the query result structure (individual
 <code>dane_data</code> items simply point to the original data and are not allocated separately).
The returned  <code>dane_data</code> are only valid during the lifetime of  <code>q</code> .
</p>
<p><strong>Returns:</strong> On success, <code>DANE_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="dane_005fraw_005ftlsa-1"></span><h4 class="subheading">dane_raw_tlsa</h4>
<span id="dane_005fraw_005ftlsa"></span><dl>
<dt id="index-dane_005fraw_005ftlsa">Function: <em>int</em> <strong>dane_raw_tlsa</strong> <em>(dane_state_t <var>s</var>, dane_query_t * <var>r</var>, char *const * <var>dane_data</var>, const int * <var>dane_data_len</var>, int <var>secure</var>, int <var>bogus</var>)</em></dt>
<dd><p><var>s</var>: The DANE state structure
</p>
<p><var>r</var>: A structure to place the result
</p>
<p><var>dane_data</var>: array of DNS rdata items, terminated with a NULL pointer;
caller must guarantee that the referenced data remains
valid until <code>dane_query_deinit()</code>  is called.
</p>
<p><var>dane_data_len</var>: the length n bytes of the dane_data items
</p>
<p><var>secure</var>: true if the result is validated securely, false if
validation failed or the domain queried has no security info
</p>
<p><var>bogus</var>: if the result was not secure (secure = 0) due to a security failure,
and the result is due to a security failure, bogus is true.
</p>
<p>This function will fill in the TLSA (DANE) structure from
the given raw DNS record data. The  <code>dane_data</code> must be valid
during the lifetime of the query.
</p>
<p><strong>Returns:</strong> On success, <code>DANE_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="dane_005fstate_005fdeinit-1"></span><h4 class="subheading">dane_state_deinit</h4>
<span id="dane_005fstate_005fdeinit"></span><dl>
<dt id="index-dane_005fstate_005fdeinit">Function: <em>void</em> <strong>dane_state_deinit</strong> <em>(dane_state_t <var>s</var>)</em></dt>
<dd><p><var>s</var>: The structure to be deinitialized
</p>
<p>This function will deinitialize a DANE query structure.
</p></dd></dl>

<span id="dane_005fstate_005finit-1"></span><h4 class="subheading">dane_state_init</h4>
<span id="dane_005fstate_005finit"></span><dl>
<dt id="index-dane_005fstate_005finit">Function: <em>int</em> <strong>dane_state_init</strong> <em>(dane_state_t * <var>s</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>s</var>: The structure to be initialized
</p>
<p><var>flags</var>: flags from the <code>dane_state_flags</code>  enumeration
</p>
<p>This function will initialize the backend resolver. It is
intended to be used in scenarios where multiple resolvings
occur, to optimize against multiple re-initializations.
</p>
<p><strong>Returns:</strong> On success, <code>DANE_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="dane_005fstate_005fset_005fdlv_005ffile-1"></span><h4 class="subheading">dane_state_set_dlv_file</h4>
<span id="dane_005fstate_005fset_005fdlv_005ffile"></span><dl>
<dt id="index-dane_005fstate_005fset_005fdlv_005ffile">Function: <em>int</em> <strong>dane_state_set_dlv_file</strong> <em>(dane_state_t <var>s</var>, const char * <var>file</var>)</em></dt>
<dd><p><var>s</var>: The structure to be deinitialized
</p>
<p><var>file</var>: The file holding the DLV keys.
</p>
<p>This function will set a file with trusted keys
for DLV (DNSSEC Lookaside Validation).
</p></dd></dl>

<span id="dane_005fstrerror-1"></span><h4 class="subheading">dane_strerror</h4>
<span id="dane_005fstrerror"></span><dl>
<dt id="index-dane_005fstrerror">Function: <em>const char *</em> <strong>dane_strerror</strong> <em>(int <var>error</var>)</em></dt>
<dd><p><var>error</var>: is a DANE error code, a negative error code
</p>
<p>This function is similar to strerror.  The difference is that it
accepts an error number returned by a gnutls function; In case of
an unknown error a descriptive string is sent instead of <code>NULL</code> .
</p>
<p>Error codes are always a negative error code.
</p>
<p><strong>Returns:</strong> A string explaining the DANE error message.
</p></dd></dl>

<span id="dane_005fverification_005fstatus_005fprint-1"></span><h4 class="subheading">dane_verification_status_print</h4>
<span id="dane_005fverification_005fstatus_005fprint"></span><dl>
<dt id="index-dane_005fverification_005fstatus_005fprint">Function: <em>int</em> <strong>dane_verification_status_print</strong> <em>(unsigned int <var>status</var>, gnutls_datum_t * <var>out</var>, unsigned int <var>flags</var>)</em></dt>
<dd><p><var>status</var>: The status flags to be printed
</p>
<p><var>out</var>: Newly allocated datum with (0) terminated string.
</p>
<p><var>flags</var>: should be zero
</p>
<p>This function will pretty print the status of a verification
process &ndash; eg. the one obtained by <code>dane_verify_crt()</code> .
</p>
<p>The output  <code>out</code> needs to be deallocated using <code>gnutls_free()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p></dd></dl>

<span id="dane_005fverify_005fcrt-1"></span><h4 class="subheading">dane_verify_crt</h4>
<span id="dane_005fverify_005fcrt"></span><dl>
<dt id="index-dane_005fverify_005fcrt-1">Function: <em>int</em> <strong>dane_verify_crt</strong> <em>(dane_state_t <var>s</var>, const gnutls_datum_t * <var>chain</var>, unsigned <var>chain_size</var>, gnutls_certificate_type_t <var>chain_type</var>, const char * <var>hostname</var>, const char * <var>proto</var>, unsigned int <var>port</var>, unsigned int <var>sflags</var>, unsigned int <var>vflags</var>, unsigned int * <var>verify</var>)</em></dt>
<dd><p><var>s</var>: A DANE state structure (may be NULL)
</p>
<p><var>chain</var>: A certificate chain
</p>
<p><var>chain_size</var>: The size of the chain
</p>
<p><var>chain_type</var>: The type of the certificate chain
</p>
<p><var>hostname</var>: The hostname associated with the chain
</p>
<p><var>proto</var>: The protocol of the service connecting (e.g. tcp)
</p>
<p><var>port</var>: The port of the service connecting (e.g. 443)
</p>
<p><var>sflags</var>: Flags for the initialization of  <code>s</code> (if NULL)
</p>
<p><var>vflags</var>: Verification flags; an OR&rsquo;ed list of <code>dane_verify_flags_t</code> .
</p>
<p><var>verify</var>: An OR&rsquo;ed list of <code>dane_verify_status_t</code> .
</p>
<p>This function will verify the given certificate chain against the
CA constrains and/or the certificate available via DANE.
If no information via DANE can be obtained the flag <code>DANE_VERIFY_NO_DANE_INFO</code> 
is set. If a DNSSEC signature is not available for the DANE
record then the verify flag <code>DANE_VERIFY_NO_DNSSEC_DATA</code>  is set.
</p>
<p>Due to the many possible options of DANE, there is no single threat
model countered. When notifying the user about DANE verification results
it may be better to mention: DANE verification did not reject the certificate,
rather than mentioning a successful DANE verication.
</p>
<p>Note that this function is designed to be run in addition to
PKIX - certificate chain - verification. To be run independently
the <code>DANE_VFLAG_ONLY_CHECK_EE_USAGE</code>  flag should be specified;
then the function will check whether the key of the peer matches the
key advertized in the DANE entry.
</p>
<p><strong>Returns:</strong> a negative error code on error and <code>DANE_E_SUCCESS</code>  (0)
when the DANE entries were successfully parsed, irrespective of
whether they were verified (see  <code>verify</code> for that information). If
no usable entries were encountered <code>DANE_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
will be returned.
</p></dd></dl>

<span id="dane_005fverify_005fcrt_005fraw-1"></span><h4 class="subheading">dane_verify_crt_raw</h4>
<span id="dane_005fverify_005fcrt_005fraw"></span><dl>
<dt id="index-dane_005fverify_005fcrt_005fraw">Function: <em>int</em> <strong>dane_verify_crt_raw</strong> <em>(dane_state_t <var>s</var>, const gnutls_datum_t * <var>chain</var>, unsigned <var>chain_size</var>, gnutls_certificate_type_t <var>chain_type</var>, dane_query_t <var>r</var>, unsigned int <var>sflags</var>, unsigned int <var>vflags</var>, unsigned int * <var>verify</var>)</em></dt>
<dd><p><var>s</var>: A DANE state structure (may be NULL)
</p>
<p><var>chain</var>: A certificate chain
</p>
<p><var>chain_size</var>: The size of the chain
</p>
<p><var>chain_type</var>: The type of the certificate chain
</p>
<p><var>r</var>: DANE data to check against
</p>
<p><var>sflags</var>: Flags for the initialization of  <code>s</code> (if NULL)
</p>
<p><var>vflags</var>: Verification flags; an OR&rsquo;ed list of <code>dane_verify_flags_t</code> .
</p>
<p><var>verify</var>: An OR&rsquo;ed list of <code>dane_verify_status_t</code> .
</p>
<p>This is the low-level function of <code>dane_verify_crt()</code> . See the
high level function for documentation.
</p>
<p>This function does not perform any resolving, it utilizes
cached entries from  <code>r</code> .
</p>
<p><strong>Returns:</strong> a negative error code on error and <code>DANE_E_SUCCESS</code>  (0)
when the DANE entries were successfully parsed, irrespective of
whether they were verified (see  <code>verify</code> for that information). If
no usable entries were encountered <code>DANE_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
will be returned.
</p></dd></dl>

<span id="dane_005fverify_005fsession_005fcrt-1"></span><h4 class="subheading">dane_verify_session_crt</h4>
<span id="dane_005fverify_005fsession_005fcrt"></span><dl>
<dt id="index-dane_005fverify_005fsession_005fcrt">Function: <em>int</em> <strong>dane_verify_session_crt</strong> <em>(dane_state_t <var>s</var>, gnutls_session_t <var>session</var>, const char * <var>hostname</var>, const char * <var>proto</var>, unsigned int <var>port</var>, unsigned int <var>sflags</var>, unsigned int <var>vflags</var>, unsigned int * <var>verify</var>)</em></dt>
<dd><p><var>s</var>: A DANE state structure (may be NULL)
</p>
<p><var>session</var>: A gnutls session
</p>
<p><var>hostname</var>: The hostname associated with the chain
</p>
<p><var>proto</var>: The protocol of the service connecting (e.g. tcp)
</p>
<p><var>port</var>: The port of the service connecting (e.g. 443)
</p>
<p><var>sflags</var>: Flags for the initialization of  <code>s</code> (if NULL)
</p>
<p><var>vflags</var>: Verification flags; an OR&rsquo;ed list of <code>dane_verify_flags_t</code> .
</p>
<p><var>verify</var>: An OR&rsquo;ed list of <code>dane_verify_status_t</code> .
</p>
<p>This function will verify session&rsquo;s certificate chain against the
CA constrains and/or the certificate available via DANE.
See <code>dane_verify_crt()</code>  for more information.
</p>
<p>This will not verify the chain for validity; unless the DANE
verification is restricted to end certificates, this must be
be performed separately using <code>gnutls_certificate_verify_peers3()</code> .
</p>
<p><strong>Returns:</strong> a negative error code on error and <code>DANE_E_SUCCESS</code>  (0)
when the DANE entries were successfully parsed, irrespective of
whether they were verified (see  <code>verify</code> for that information). If
no usable entries were encountered <code>DANE_E_REQUESTED_DATA_NOT_AVAILABLE</code> 
will be returned.
</p></dd></dl>


<hr>
<span id="Cryptographic-API"></span><div class="header">
<p>
Next: <a href="#Compatibility-API" accesskey="n" rel="next">Compatibility API</a>, Previous: <a href="#DANE-API" accesskey="p" rel="prev">DANE API</a>, Up: <a href="#API-reference" accesskey="u" rel="up">API reference</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Cryptographic-API-1"></span><h3 class="section">E.12 Cryptographic API</h3>

<p>The following functions are to be used for low-level cryptographic operations.
Their prototypes lie in <samp>gnutls/crypto.h</samp>.
</p>
<p>Note that due to historic reasons several functions, (e.g.
<a href="#gnutls_005fmac_005flist">gnutls_mac_list</a>, <a href="#gnutls_005fmac_005fget_005fname">gnutls_mac_get_name</a>) of this API are part
of the <a href="#Core-TLS-API">Core TLS API</a>.
</p>

<span id="gnutls_005faead_005fcipher_005fdecrypt-1"></span><h4 class="subheading">gnutls_aead_cipher_decrypt</h4>
<span id="gnutls_005faead_005fcipher_005fdecrypt"></span><dl>
<dt id="index-gnutls_005faead_005fcipher_005fdecrypt">Function: <em>int</em> <strong>gnutls_aead_cipher_decrypt</strong> <em>(gnutls_aead_cipher_hd_t <var>handle</var>, const void * <var>nonce</var>, size_t <var>nonce_len</var>, const void * <var>auth</var>, size_t <var>auth_len</var>, size_t <var>tag_size</var>, const void * <var>ctext</var>, size_t <var>ctext_len</var>, void * <var>ptext</var>, size_t * <var>ptext_len</var>)</em></dt>
<dd><p><var>handle</var>: is a <code>gnutls_aead_cipher_hd_t</code>  type.
</p>
<p><var>nonce</var>: the nonce to set
</p>
<p><var>nonce_len</var>: The length of the nonce
</p>
<p><var>auth</var>: additional data to be authenticated
</p>
<p><var>auth_len</var>: The length of the data
</p>
<p><var>tag_size</var>: The size of the tag to use (use zero for the default)
</p>
<p><var>ctext</var>: the data to decrypt (including the authentication tag)
</p>
<p><var>ctext_len</var>: the length of data to decrypt (includes tag size)
</p>
<p><var>ptext</var>: the decrypted data
</p>
<p><var>ptext_len</var>: the length of decrypted data (initially must hold the maximum available size)
</p>
<p>This function will decrypt the given data using the algorithm
specified by the context. This function must be provided the complete
data to be decrypted, including the authentication tag. On several
AEAD ciphers, the authentication tag is appended to the ciphertext,
though this is not a general rule. This function will fail if
the tag verification fails.
</p>
<p><strong>Returns:</strong> Zero or a negative error code on verification failure or other error.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005faead_005fcipher_005fdecryptv2-1"></span><h4 class="subheading">gnutls_aead_cipher_decryptv2</h4>
<span id="gnutls_005faead_005fcipher_005fdecryptv2"></span><dl>
<dt id="index-gnutls_005faead_005fcipher_005fdecryptv2">Function: <em>int</em> <strong>gnutls_aead_cipher_decryptv2</strong> <em>(gnutls_aead_cipher_hd_t <var>handle</var>, const void * <var>nonce</var>, size_t <var>nonce_len</var>, const giovec_t * <var>auth_iov</var>, int <var>auth_iovcnt</var>, const giovec_t * <var>iov</var>, int <var>iovcnt</var>, void * <var>tag</var>, size_t <var>tag_size</var>)</em></dt>
<dd><p><var>handle</var>: is a <code>gnutls_aead_cipher_hd_t</code>  type.
</p>
<p><var>nonce</var>: the nonce to set
</p>
<p><var>nonce_len</var>: The length of the nonce
</p>
<p><var>auth_iov</var>: additional data to be authenticated
</p>
<p><var>auth_iovcnt</var>: The number of buffers in  <code>auth_iov</code> 
</p>
<p><var>iov</var>: the data to decrypt
</p>
<p><var>iovcnt</var>: The number of buffers in  <code>iov</code> 
</p>
<p><var>tag</var>: The authentication tag
</p>
<p><var>tag_size</var>: The size of the tag to use (use zero for the default)
</p>
<p>This is similar to <code>gnutls_aead_cipher_decrypt()</code> , but it performs
in-place encryption on the provided data buffers.
</p>
<p><strong>Returns:</strong> Zero or a negative error code on error.
</p>
<p><strong>Since:</strong> 3.6.10
</p></dd></dl>

<span id="gnutls_005faead_005fcipher_005fdeinit-1"></span><h4 class="subheading">gnutls_aead_cipher_deinit</h4>
<span id="gnutls_005faead_005fcipher_005fdeinit"></span><dl>
<dt id="index-gnutls_005faead_005fcipher_005fdeinit">Function: <em>void</em> <strong>gnutls_aead_cipher_deinit</strong> <em>(gnutls_aead_cipher_hd_t <var>handle</var>)</em></dt>
<dd><p><var>handle</var>: is a <code>gnutls_aead_cipher_hd_t</code>  type.
</p>
<p>This function will deinitialize all resources occupied by the given
authenticated-encryption context.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005faead_005fcipher_005fencrypt-1"></span><h4 class="subheading">gnutls_aead_cipher_encrypt</h4>
<span id="gnutls_005faead_005fcipher_005fencrypt"></span><dl>
<dt id="index-gnutls_005faead_005fcipher_005fencrypt">Function: <em>int</em> <strong>gnutls_aead_cipher_encrypt</strong> <em>(gnutls_aead_cipher_hd_t <var>handle</var>, const void * <var>nonce</var>, size_t <var>nonce_len</var>, const void * <var>auth</var>, size_t <var>auth_len</var>, size_t <var>tag_size</var>, const void * <var>ptext</var>, size_t <var>ptext_len</var>, void * <var>ctext</var>, size_t * <var>ctext_len</var>)</em></dt>
<dd><p><var>handle</var>: is a <code>gnutls_aead_cipher_hd_t</code>  type.
</p>
<p><var>nonce</var>: the nonce to set
</p>
<p><var>nonce_len</var>: The length of the nonce
</p>
<p><var>auth</var>: additional data to be authenticated
</p>
<p><var>auth_len</var>: The length of the data
</p>
<p><var>tag_size</var>: The size of the tag to use (use zero for the default)
</p>
<p><var>ptext</var>: the data to encrypt
</p>
<p><var>ptext_len</var>: The length of data to encrypt
</p>
<p><var>ctext</var>: the encrypted data including authentication tag
</p>
<p><var>ctext_len</var>: the length of encrypted data (initially must hold the maximum available size, including space for tag)
</p>
<p>This function will encrypt the given data using the algorithm
specified by the context. The output data will contain the
authentication tag.
</p>
<p><strong>Returns:</strong> Zero or a negative error code on error.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005faead_005fcipher_005fencryptv-1"></span><h4 class="subheading">gnutls_aead_cipher_encryptv</h4>
<span id="gnutls_005faead_005fcipher_005fencryptv"></span><dl>
<dt id="index-gnutls_005faead_005fcipher_005fencryptv-1">Function: <em>int</em> <strong>gnutls_aead_cipher_encryptv</strong> <em>(gnutls_aead_cipher_hd_t <var>handle</var>, const void * <var>nonce</var>, size_t <var>nonce_len</var>, const giovec_t * <var>auth_iov</var>, int <var>auth_iovcnt</var>, size_t <var>tag_size</var>, const giovec_t * <var>iov</var>, int <var>iovcnt</var>, void * <var>ctext</var>, size_t * <var>ctext_len</var>)</em></dt>
<dd><p><var>handle</var>: is a <code>gnutls_aead_cipher_hd_t</code>  type.
</p>
<p><var>nonce</var>: the nonce to set
</p>
<p><var>nonce_len</var>: The length of the nonce
</p>
<p><var>auth_iov</var>: additional data to be authenticated
</p>
<p><var>auth_iovcnt</var>: The number of buffers in  <code>auth_iov</code> 
</p>
<p><var>tag_size</var>: The size of the tag to use (use zero for the default)
</p>
<p><var>iov</var>: the data to be encrypted
</p>
<p><var>iovcnt</var>: The number of buffers in  <code>iov</code> 
</p>
<p><var>ctext</var>: the encrypted data including authentication tag
</p>
<p><var>ctext_len</var>: the length of encrypted data (initially must hold the maximum available size, including space for tag)
</p>
<p>This function will encrypt the provided data buffers using the algorithm
specified by the context. The output data will contain the
authentication tag.
</p>
<p><strong>Returns:</strong> Zero or a negative error code on error.
</p>
<p><strong>Since:</strong> 3.6.3
</p></dd></dl>

<span id="gnutls_005faead_005fcipher_005fencryptv2-1"></span><h4 class="subheading">gnutls_aead_cipher_encryptv2</h4>
<span id="gnutls_005faead_005fcipher_005fencryptv2"></span><dl>
<dt id="index-gnutls_005faead_005fcipher_005fencryptv2">Function: <em>int</em> <strong>gnutls_aead_cipher_encryptv2</strong> <em>(gnutls_aead_cipher_hd_t <var>handle</var>, const void * <var>nonce</var>, size_t <var>nonce_len</var>, const giovec_t * <var>auth_iov</var>, int <var>auth_iovcnt</var>, const giovec_t * <var>iov</var>, int <var>iovcnt</var>, void * <var>tag</var>, size_t * <var>tag_size</var>)</em></dt>
<dd><p><var>handle</var>: is a <code>gnutls_aead_cipher_hd_t</code>  type.
</p>
<p><var>nonce</var>: the nonce to set
</p>
<p><var>nonce_len</var>: The length of the nonce
</p>
<p><var>auth_iov</var>: additional data to be authenticated
</p>
<p><var>auth_iovcnt</var>: The number of buffers in  <code>auth_iov</code> 
</p>
<p><var>iov</var>: the data to be encrypted
</p>
<p><var>iovcnt</var>: The number of buffers in  <code>iov</code> 
</p>
<p><var>tag</var>: The authentication tag
</p>
<p><var>tag_size</var>: The size of the tag to use (use zero for the default)
</p>
<p>This is similar to <code>gnutls_aead_cipher_encrypt()</code> , but it performs
in-place encryption on the provided data buffers.
</p>
<p><strong>Returns:</strong> Zero or a negative error code on error.
</p>
<p><strong>Since:</strong> 3.6.10
</p></dd></dl>

<span id="gnutls_005faead_005fcipher_005finit-1"></span><h4 class="subheading">gnutls_aead_cipher_init</h4>
<span id="gnutls_005faead_005fcipher_005finit"></span><dl>
<dt id="index-gnutls_005faead_005fcipher_005finit">Function: <em>int</em> <strong>gnutls_aead_cipher_init</strong> <em>(gnutls_aead_cipher_hd_t * <var>handle</var>, gnutls_cipher_algorithm_t <var>cipher</var>, const gnutls_datum_t * <var>key</var>)</em></dt>
<dd><p><var>handle</var>: is a <code>gnutls_aead_cipher_hd_t</code>  type.
</p>
<p><var>cipher</var>: the authenticated-encryption algorithm to use
</p>
<p><var>key</var>: The key to be used for encryption
</p>
<p>This function will initialize an context that can be used for
encryption/decryption of data. This will effectively use the
current crypto backend in use by gnutls or the cryptographic
accelerator in use.
</p>
<p><strong>Returns:</strong> Zero or a negative error code on error.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fcipher_005fadd_005fauth-1"></span><h4 class="subheading">gnutls_cipher_add_auth</h4>
<span id="gnutls_005fcipher_005fadd_005fauth"></span><dl>
<dt id="index-gnutls_005fcipher_005fadd_005fauth">Function: <em>int</em> <strong>gnutls_cipher_add_auth</strong> <em>(gnutls_cipher_hd_t <var>handle</var>, const void * <var>ptext</var>, size_t <var>ptext_size</var>)</em></dt>
<dd><p><var>handle</var>: is a <code>gnutls_cipher_hd_t</code>  type
</p>
<p><var>ptext</var>: the data to be authenticated
</p>
<p><var>ptext_size</var>: the length of the data
</p>
<p>This function operates on authenticated encryption with
associated data (AEAD) ciphers and authenticate the
input data. This function can only be called once
and before any encryption operations.
</p>
<p><strong>Returns:</strong> Zero or a negative error code on error.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fcipher_005fdecrypt-1"></span><h4 class="subheading">gnutls_cipher_decrypt</h4>
<span id="gnutls_005fcipher_005fdecrypt"></span><dl>
<dt id="index-gnutls_005fcipher_005fdecrypt">Function: <em>int</em> <strong>gnutls_cipher_decrypt</strong> <em>(gnutls_cipher_hd_t <var>handle</var>, void * <var>ctext</var>, size_t <var>ctext_len</var>)</em></dt>
<dd><p><var>handle</var>: is a <code>gnutls_cipher_hd_t</code>  type
</p>
<p><var>ctext</var>: the data to decrypt
</p>
<p><var>ctext_len</var>: the length of data to decrypt
</p>
<p>This function will decrypt the given data using the algorithm
specified by the context.
</p>
<p>Note that in AEAD ciphers, this will not check the tag. You will
need to compare the tag sent with the value returned from <code>gnutls_cipher_tag()</code> .
</p>
<p><strong>Returns:</strong> Zero or a negative error code on error.
</p>
<p><strong>Since:</strong> 2.10.0
</p></dd></dl>

<span id="gnutls_005fcipher_005fdecrypt2-1"></span><h4 class="subheading">gnutls_cipher_decrypt2</h4>
<span id="gnutls_005fcipher_005fdecrypt2"></span><dl>
<dt id="index-gnutls_005fcipher_005fdecrypt2">Function: <em>int</em> <strong>gnutls_cipher_decrypt2</strong> <em>(gnutls_cipher_hd_t <var>handle</var>, const void * <var>ctext</var>, size_t <var>ctext_len</var>, void * <var>ptext</var>, size_t <var>ptext_len</var>)</em></dt>
<dd><p><var>handle</var>: is a <code>gnutls_cipher_hd_t</code>  type
</p>
<p><var>ctext</var>: the data to decrypt
</p>
<p><var>ctext_len</var>: the length of data to decrypt
</p>
<p><var>ptext</var>: the decrypted data
</p>
<p><var>ptext_len</var>: the available length for decrypted data
</p>
<p>This function will decrypt the given data using the algorithm
specified by the context. For block ciphers the  <code>ctext_len</code> must be
a multiple of the block size. For the supported ciphers the plaintext
data length will equal the ciphertext size.
</p>
<p>Note that in AEAD ciphers, this will not check the tag. You will
need to compare the tag sent with the value returned from <code>gnutls_cipher_tag()</code> .
</p>
<p><strong>Returns:</strong> Zero or a negative error code on error.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fcipher_005fdeinit-1"></span><h4 class="subheading">gnutls_cipher_deinit</h4>
<span id="gnutls_005fcipher_005fdeinit"></span><dl>
<dt id="index-gnutls_005fcipher_005fdeinit">Function: <em>void</em> <strong>gnutls_cipher_deinit</strong> <em>(gnutls_cipher_hd_t <var>handle</var>)</em></dt>
<dd><p><var>handle</var>: is a <code>gnutls_cipher_hd_t</code>  type
</p>
<p>This function will deinitialize all resources occupied by the given
encryption context.
</p>
<p><strong>Since:</strong> 2.10.0
</p></dd></dl>

<span id="gnutls_005fcipher_005fencrypt-1"></span><h4 class="subheading">gnutls_cipher_encrypt</h4>
<span id="gnutls_005fcipher_005fencrypt"></span><dl>
<dt id="index-gnutls_005fcipher_005fencrypt">Function: <em>int</em> <strong>gnutls_cipher_encrypt</strong> <em>(gnutls_cipher_hd_t <var>handle</var>, void * <var>ptext</var>, size_t <var>ptext_len</var>)</em></dt>
<dd><p><var>handle</var>: is a <code>gnutls_cipher_hd_t</code>  type
</p>
<p><var>ptext</var>: the data to encrypt
</p>
<p><var>ptext_len</var>: the length of data to encrypt
</p>
<p>This function will encrypt the given data using the algorithm
specified by the context.
</p>
<p><strong>Returns:</strong> Zero or a negative error code on error.
</p>
<p><strong>Since:</strong> 2.10.0
</p></dd></dl>

<span id="gnutls_005fcipher_005fencrypt2-1"></span><h4 class="subheading">gnutls_cipher_encrypt2</h4>
<span id="gnutls_005fcipher_005fencrypt2"></span><dl>
<dt id="index-gnutls_005fcipher_005fencrypt2">Function: <em>int</em> <strong>gnutls_cipher_encrypt2</strong> <em>(gnutls_cipher_hd_t <var>handle</var>, const void * <var>ptext</var>, size_t <var>ptext_len</var>, void * <var>ctext</var>, size_t <var>ctext_len</var>)</em></dt>
<dd><p><var>handle</var>: is a <code>gnutls_cipher_hd_t</code>  type
</p>
<p><var>ptext</var>: the data to encrypt
</p>
<p><var>ptext_len</var>: the length of data to encrypt
</p>
<p><var>ctext</var>: the encrypted data
</p>
<p><var>ctext_len</var>: the available length for encrypted data
</p>
<p>This function will encrypt the given data using the algorithm
specified by the context. For block ciphers the  <code>ptext_len</code> must be
a multiple of the block size. For the supported ciphers the encrypted
data length will equal the plaintext size.
</p>
<p><strong>Returns:</strong> Zero or a negative error code on error.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fcipher_005fget_005fblock_005fsize-1"></span><h4 class="subheading">gnutls_cipher_get_block_size</h4>
<span id="gnutls_005fcipher_005fget_005fblock_005fsize"></span><dl>
<dt id="index-gnutls_005fcipher_005fget_005fblock_005fsize">Function: <em>unsigned</em> <strong>gnutls_cipher_get_block_size</strong> <em>(gnutls_cipher_algorithm_t <var>algorithm</var>)</em></dt>
<dd><p><var>algorithm</var>: is an encryption algorithm
</p>

<p><strong>Returns:</strong> the block size of the encryption algorithm.
</p>
<p><strong>Since:</strong> 2.10.0
</p></dd></dl>

<span id="gnutls_005fcipher_005fget_005fiv_005fsize-1"></span><h4 class="subheading">gnutls_cipher_get_iv_size</h4>
<span id="gnutls_005fcipher_005fget_005fiv_005fsize"></span><dl>
<dt id="index-gnutls_005fcipher_005fget_005fiv_005fsize">Function: <em>unsigned</em> <strong>gnutls_cipher_get_iv_size</strong> <em>(gnutls_cipher_algorithm_t <var>algorithm</var>)</em></dt>
<dd><p><var>algorithm</var>: is an encryption algorithm
</p>
<p>This function returns the size of the initialization vector (IV) for the
provided algorithm. For algorithms with variable size IV (e.g., AES-CCM),
the returned size will be the one used by TLS.
</p>
<p><strong>Returns:</strong> block size for encryption algorithm.
</p>
<p><strong>Since:</strong> 3.2.0
</p></dd></dl>

<span id="gnutls_005fcipher_005fget_005ftag_005fsize-1"></span><h4 class="subheading">gnutls_cipher_get_tag_size</h4>
<span id="gnutls_005fcipher_005fget_005ftag_005fsize"></span><dl>
<dt id="index-gnutls_005fcipher_005fget_005ftag_005fsize">Function: <em>unsigned</em> <strong>gnutls_cipher_get_tag_size</strong> <em>(gnutls_cipher_algorithm_t <var>algorithm</var>)</em></dt>
<dd><p><var>algorithm</var>: is an encryption algorithm
</p>
<p>This function returns the tag size of an authenticated encryption
algorithm. For non-AEAD algorithms, it returns zero.
</p>
<p><strong>Returns:</strong> the tag size of the authenticated encryption algorithm.
</p>
<p><strong>Since:</strong> 3.2.2
</p></dd></dl>

<span id="gnutls_005fcipher_005finit-1"></span><h4 class="subheading">gnutls_cipher_init</h4>
<span id="gnutls_005fcipher_005finit"></span><dl>
<dt id="index-gnutls_005fcipher_005finit">Function: <em>int</em> <strong>gnutls_cipher_init</strong> <em>(gnutls_cipher_hd_t * <var>handle</var>, gnutls_cipher_algorithm_t <var>cipher</var>, const gnutls_datum_t * <var>key</var>, const gnutls_datum_t * <var>iv</var>)</em></dt>
<dd><p><var>handle</var>: is a <code>gnutls_cipher_hd_t</code>  type
</p>
<p><var>cipher</var>: the encryption algorithm to use
</p>
<p><var>key</var>: the key to be used for encryption/decryption
</p>
<p><var>iv</var>: the IV to use (if not applicable set NULL)
</p>
<p>This function will initialize the  <code>handle</code> context to be usable
for encryption/decryption of data. This will effectively use the
current crypto backend in use by gnutls or the cryptographic
accelerator in use.
</p>
<p><strong>Returns:</strong> Zero or a negative error code on error.
</p>
<p><strong>Since:</strong> 2.10.0
</p></dd></dl>

<span id="gnutls_005fcipher_005fset_005fiv-1"></span><h4 class="subheading">gnutls_cipher_set_iv</h4>
<span id="gnutls_005fcipher_005fset_005fiv"></span><dl>
<dt id="index-gnutls_005fcipher_005fset_005fiv">Function: <em>void</em> <strong>gnutls_cipher_set_iv</strong> <em>(gnutls_cipher_hd_t <var>handle</var>, void * <var>iv</var>, size_t <var>ivlen</var>)</em></dt>
<dd><p><var>handle</var>: is a <code>gnutls_cipher_hd_t</code>  type
</p>
<p><var>iv</var>: the IV to set
</p>
<p><var>ivlen</var>: the length of the IV
</p>
<p>This function will set the IV to be used for the next
encryption block.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fcipher_005ftag-1"></span><h4 class="subheading">gnutls_cipher_tag</h4>
<span id="gnutls_005fcipher_005ftag"></span><dl>
<dt id="index-gnutls_005fcipher_005ftag">Function: <em>int</em> <strong>gnutls_cipher_tag</strong> <em>(gnutls_cipher_hd_t <var>handle</var>, void * <var>tag</var>, size_t <var>tag_size</var>)</em></dt>
<dd><p><var>handle</var>: is a <code>gnutls_cipher_hd_t</code>  type
</p>
<p><var>tag</var>: will hold the tag
</p>
<p><var>tag_size</var>: the length of the tag to return
</p>
<p>This function operates on authenticated encryption with
associated data (AEAD) ciphers and will return the
output tag.
</p>
<p><strong>Returns:</strong> Zero or a negative error code on error.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fcrypto_005fregister_005faead_005fcipher-1"></span><h4 class="subheading">gnutls_crypto_register_aead_cipher</h4>
<span id="gnutls_005fcrypto_005fregister_005faead_005fcipher"></span><dl>
<dt id="index-gnutls_005fcrypto_005fregister_005faead_005fcipher-1">Function: <em>int</em> <strong>gnutls_crypto_register_aead_cipher</strong> <em>(gnutls_cipher_algorithm_t <var>algorithm</var>, int <var>priority</var>, gnutls_cipher_init_func <var>init</var>, gnutls_cipher_setkey_func <var>setkey</var>, gnutls_cipher_aead_encrypt_func <var>aead_encrypt</var>, gnutls_cipher_aead_decrypt_func <var>aead_decrypt</var>, gnutls_cipher_deinit_func <var>deinit</var>)</em></dt>
<dd><p><var>algorithm</var>: is the gnutls AEAD cipher identifier
</p>
<p><var>priority</var>: is the priority of the algorithm
</p>
<p><var>init</var>: A function which initializes the cipher
</p>
<p><var>setkey</var>: A function which sets the key of the cipher
</p>
<p><var>aead_encrypt</var>: Perform the AEAD encryption
</p>
<p><var>aead_decrypt</var>: Perform the AEAD decryption
</p>
<p><var>deinit</var>: A function which deinitializes the cipher
</p>
<p>This function will register a cipher algorithm to be used by
gnutls.  Any algorithm registered will override the included
algorithms and by convention kernel implemented algorithms have
priority of 90 and CPU-assisted of 80.  The algorithm with the lowest priority will be
used by gnutls.
</p>
<p>In the case the registered init or setkey functions return <code>GNUTLS_E_NEED_FALLBACK</code> ,
GnuTLS will attempt to use the next in priority registered cipher.
</p>
<p>The functions registered will be used with the new AEAD API introduced in
GnuTLS 3.4.0. Internally GnuTLS uses the new AEAD API.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fcrypto_005fregister_005fcipher-1"></span><h4 class="subheading">gnutls_crypto_register_cipher</h4>
<span id="gnutls_005fcrypto_005fregister_005fcipher"></span><dl>
<dt id="index-gnutls_005fcrypto_005fregister_005fcipher-1">Function: <em>int</em> <strong>gnutls_crypto_register_cipher</strong> <em>(gnutls_cipher_algorithm_t <var>algorithm</var>, int <var>priority</var>, gnutls_cipher_init_func <var>init</var>, gnutls_cipher_setkey_func <var>setkey</var>, gnutls_cipher_setiv_func <var>setiv</var>, gnutls_cipher_encrypt_func <var>encrypt</var>, gnutls_cipher_decrypt_func <var>decrypt</var>, gnutls_cipher_deinit_func <var>deinit</var>)</em></dt>
<dd><p><var>algorithm</var>: is the gnutls algorithm identifier
</p>
<p><var>priority</var>: is the priority of the algorithm
</p>
<p><var>init</var>: A function which initializes the cipher
</p>
<p><var>setkey</var>: A function which sets the key of the cipher
</p>
<p><var>setiv</var>: A function which sets the nonce/IV of the cipher (non-AEAD)
</p>
<p><var>encrypt</var>: A function which performs encryption (non-AEAD)
</p>
<p><var>decrypt</var>: A function which performs decryption (non-AEAD)
</p>
<p><var>deinit</var>: A function which deinitializes the cipher
</p>
<p>This function will register a cipher algorithm to be used by
gnutls.  Any algorithm registered will override the included
algorithms and by convention kernel implemented algorithms have
priority of 90 and CPU-assisted of 80.  The algorithm with the lowest priority will be
used by gnutls.
</p>
<p>In the case the registered init or setkey functions return <code>GNUTLS_E_NEED_FALLBACK</code> ,
GnuTLS will attempt to use the next in priority registered cipher.
</p>
<p>The functions which are marked as non-AEAD they are not required when
registering a cipher to be used with the new AEAD API introduced in
GnuTLS 3.4.0. Internally GnuTLS uses the new AEAD API.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fcrypto_005fregister_005fdigest-1"></span><h4 class="subheading">gnutls_crypto_register_digest</h4>
<span id="gnutls_005fcrypto_005fregister_005fdigest"></span><dl>
<dt id="index-gnutls_005fcrypto_005fregister_005fdigest-1">Function: <em>int</em> <strong>gnutls_crypto_register_digest</strong> <em>(gnutls_digest_algorithm_t <var>algorithm</var>, int <var>priority</var>, gnutls_digest_init_func <var>init</var>, gnutls_digest_hash_func <var>hash</var>, gnutls_digest_output_func <var>output</var>, gnutls_digest_deinit_func <var>deinit</var>, gnutls_digest_fast_func <var>hash_fast</var>)</em></dt>
<dd><p><var>algorithm</var>: is the gnutls digest identifier
</p>
<p><var>priority</var>: is the priority of the algorithm
</p>
<p><var>init</var>: A function which initializes the digest
</p>
<p><var>hash</var>: Perform the hash operation
</p>
<p><var>output</var>: Provide the output of the digest
</p>
<p><var>deinit</var>: A function which deinitializes the digest
</p>
<p><var>hash_fast</var>: Perform the digest operation in one go
</p>
<p>This function will register a digest algorithm to be used by gnutls.
Any algorithm registered will override the included algorithms and
by convention kernel implemented algorithms have priority of 90
and CPU-assisted of 80.
The algorithm with the lowest priority will be used by gnutls.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fcrypto_005fregister_005fmac-1"></span><h4 class="subheading">gnutls_crypto_register_mac</h4>
<span id="gnutls_005fcrypto_005fregister_005fmac"></span><dl>
<dt id="index-gnutls_005fcrypto_005fregister_005fmac-1">Function: <em>int</em> <strong>gnutls_crypto_register_mac</strong> <em>(gnutls_mac_algorithm_t <var>algorithm</var>, int <var>priority</var>, gnutls_mac_init_func <var>init</var>, gnutls_mac_setkey_func <var>setkey</var>, gnutls_mac_setnonce_func <var>setnonce</var>, gnutls_mac_hash_func <var>hash</var>, gnutls_mac_output_func <var>output</var>, gnutls_mac_deinit_func <var>deinit</var>, gnutls_mac_fast_func <var>hash_fast</var>)</em></dt>
<dd><p><var>algorithm</var>: is the gnutls MAC identifier
</p>
<p><var>priority</var>: is the priority of the algorithm
</p>
<p><var>init</var>: A function which initializes the MAC
</p>
<p><var>setkey</var>: A function which sets the key of the MAC
</p>
<p><var>setnonce</var>: A function which sets the nonce for the mac (may be <code>NULL</code>  for common MAC algorithms)
</p>
<p><var>hash</var>: Perform the hash operation
</p>
<p><var>output</var>: Provide the output of the MAC
</p>
<p><var>deinit</var>: A function which deinitializes the MAC
</p>
<p><var>hash_fast</var>: Perform the MAC operation in one go
</p>
<p>This function will register a MAC algorithm to be used by gnutls.
Any algorithm registered will override the included algorithms and
by convention kernel implemented algorithms have priority of 90
and CPU-assisted of 80.
The algorithm with the lowest priority will be used by gnutls.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code>  on success, otherwise a negative error code.
</p>
<p><strong>Since:</strong> 3.4.0
</p></dd></dl>

<span id="gnutls_005fdecode_005fber_005fdigest_005finfo-1"></span><h4 class="subheading">gnutls_decode_ber_digest_info</h4>
<span id="gnutls_005fdecode_005fber_005fdigest_005finfo"></span><dl>
<dt id="index-gnutls_005fdecode_005fber_005fdigest_005finfo">Function: <em>int</em> <strong>gnutls_decode_ber_digest_info</strong> <em>(const gnutls_datum_t * <var>info</var>, gnutls_digest_algorithm_t * <var>hash</var>, unsigned char * <var>digest</var>, unsigned int * <var>digest_size</var>)</em></dt>
<dd><p><var>info</var>: an RSA BER encoded DigestInfo structure
</p>
<p><var>hash</var>: will contain the hash algorithm of the structure
</p>
<p><var>digest</var>: will contain the hash output of the structure
</p>
<p><var>digest_size</var>: will contain the hash size of the structure; initially must hold the maximum size of  <code>digest</code> 
</p>
<p>This function will parse an RSA PKCS<code>1</code>  1.5 DigestInfo structure
and report the hash algorithm used as well as the digest data.
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p>
<p><strong>Since:</strong> 3.5.0
</p></dd></dl>

<span id="gnutls_005fdecode_005fgost_005frs_005fvalue-1"></span><h4 class="subheading">gnutls_decode_gost_rs_value</h4>
<span id="gnutls_005fdecode_005fgost_005frs_005fvalue"></span><dl>
<dt id="index-gnutls_005fdecode_005fgost_005frs_005fvalue">Function: <em>int</em> <strong>gnutls_decode_gost_rs_value</strong> <em>(const gnutls_datum_t * <var>sig_value</var>, gnutls_datum_t * <var>r</var>, gnutls_datum_t * <var>s</var>)</em></dt>
<dd><p><var>sig_value</var>: will holds a GOST signature according to RFC 4491 section 2.2.2
</p>
<p><var>r</var>: will contain the r value
</p>
<p><var>s</var>: will contain the s value
</p>
<p>This function will decode the provided  <code>sig_value</code> , into  <code>r</code> and  <code>s</code> elements.
See RFC 4491 section 2.2.2 for the format of signature value.
</p>
<p>The output values may be padded with a zero byte to prevent them
from being interpreted as negative values. The value
should be deallocated using <code>gnutls_free()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p>
<p><strong>Since:</strong> 3.6.0
</p></dd></dl>

<span id="gnutls_005fdecode_005frs_005fvalue-1"></span><h4 class="subheading">gnutls_decode_rs_value</h4>
<span id="gnutls_005fdecode_005frs_005fvalue"></span><dl>
<dt id="index-gnutls_005fdecode_005frs_005fvalue">Function: <em>int</em> <strong>gnutls_decode_rs_value</strong> <em>(const gnutls_datum_t * <var>sig_value</var>, gnutls_datum_t * <var>r</var>, gnutls_datum_t * <var>s</var>)</em></dt>
<dd><p><var>sig_value</var>: holds a Dss-Sig-Value DER or BER encoded structure
</p>
<p><var>r</var>: will contain the r value
</p>
<p><var>s</var>: will contain the s value
</p>
<p>This function will decode the provided  <code>sig_value</code> , 
into  <code>r</code> and  <code>s</code> elements. The Dss-Sig-Value is used for DSA and ECDSA
signatures.
</p>
<p>The output values may be padded with a zero byte to prevent them
from being interpreted as negative values. The value
should be deallocated using <code>gnutls_free()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p>
<p><strong>Since:</strong> 3.6.0
</p></dd></dl>

<span id="gnutls_005fencode_005fber_005fdigest_005finfo-1"></span><h4 class="subheading">gnutls_encode_ber_digest_info</h4>
<span id="gnutls_005fencode_005fber_005fdigest_005finfo"></span><dl>
<dt id="index-gnutls_005fencode_005fber_005fdigest_005finfo">Function: <em>int</em> <strong>gnutls_encode_ber_digest_info</strong> <em>(gnutls_digest_algorithm_t <var>hash</var>, const gnutls_datum_t * <var>digest</var>, gnutls_datum_t * <var>output</var>)</em></dt>
<dd><p><var>hash</var>: the hash algorithm that was used to get the digest
</p>
<p><var>digest</var>: must contain the digest data
</p>
<p><var>output</var>: will contain the allocated DigestInfo BER encoded data
</p>
<p>This function will encode the provided digest data, and its
algorithm into an RSA PKCS<code>1</code>  1.5 DigestInfo structure. 
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p>
<p><strong>Since:</strong> 3.5.0
</p></dd></dl>

<span id="gnutls_005fencode_005fgost_005frs_005fvalue-1"></span><h4 class="subheading">gnutls_encode_gost_rs_value</h4>
<span id="gnutls_005fencode_005fgost_005frs_005fvalue"></span><dl>
<dt id="index-gnutls_005fencode_005fgost_005frs_005fvalue">Function: <em>int</em> <strong>gnutls_encode_gost_rs_value</strong> <em>(gnutls_datum_t * <var>sig_value</var>, const gnutls_datum_t * <var>r</var>, const gnutls_datum_t  * <var>s</var>)</em></dt>
<dd><p><var>sig_value</var>: will hold a GOST signature according to RFC 4491 section 2.2.2
</p>
<p><var>r</var>: must contain the r value
</p>
<p><var>s</var>: must contain the s value
</p>
<p>This function will encode the provided r and s values, into binary
representation according to RFC 4491 section 2.2.2, used for GOST R
34.10-2001 (and thus also for GOST R 34.10-2012) signatures.
</p>
<p>The output value should be deallocated using <code>gnutls_free()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p>
<p><strong>Since:</strong> 3.6.0
</p></dd></dl>

<span id="gnutls_005fencode_005frs_005fvalue-1"></span><h4 class="subheading">gnutls_encode_rs_value</h4>
<span id="gnutls_005fencode_005frs_005fvalue"></span><dl>
<dt id="index-gnutls_005fencode_005frs_005fvalue">Function: <em>int</em> <strong>gnutls_encode_rs_value</strong> <em>(gnutls_datum_t * <var>sig_value</var>, const gnutls_datum_t * <var>r</var>, const gnutls_datum_t * <var>s</var>)</em></dt>
<dd><p><var>sig_value</var>: will hold a Dss-Sig-Value DER encoded structure
</p>
<p><var>r</var>: must contain the r value
</p>
<p><var>s</var>: must contain the s value
</p>
<p>This function will encode the provided r and s values, 
into a Dss-Sig-Value structure, used for DSA and ECDSA
signatures.
</p>
<p>The output value should be deallocated using <code>gnutls_free()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise
an error code is returned.
</p>
<p><strong>Since:</strong> 3.6.0
</p></dd></dl>

<span id="gnutls_005fhash-1"></span><h4 class="subheading">gnutls_hash</h4>
<span id="gnutls_005fhash"></span><dl>
<dt id="index-gnutls_005fhash">Function: <em>int</em> <strong>gnutls_hash</strong> <em>(gnutls_hash_hd_t <var>handle</var>, const void * <var>ptext</var>, size_t <var>ptext_len</var>)</em></dt>
<dd><p><var>handle</var>: is a <code>gnutls_hash_hd_t</code>  type
</p>
<p><var>ptext</var>: the data to hash
</p>
<p><var>ptext_len</var>: the length of data to hash
</p>
<p>This function will hash the given data using the algorithm
specified by the context.
</p>
<p><strong>Returns:</strong> Zero or a negative error code on error.
</p>
<p><strong>Since:</strong> 2.10.0
</p></dd></dl>

<span id="gnutls_005fhash_005fcopy-1"></span><h4 class="subheading">gnutls_hash_copy</h4>
<span id="gnutls_005fhash_005fcopy"></span><dl>
<dt id="index-gnutls_005fhash_005fcopy">Function: <em>gnutls_hash_hd_t</em> <strong>gnutls_hash_copy</strong> <em>(gnutls_hash_hd_t <var>handle</var>)</em></dt>
<dd><p><var>handle</var>: is a <code>gnutls_hash_hd_t</code>  type
</p>
<p>This function will create a copy of Message Digest context, containing all
its current state. Copying contexts for Message Digests registered using
<code>gnutls_crypto_register_digest()</code>  is not supported and will always result in
an error.
</p>
<p><strong>Returns:</strong> new Message Digest context or NULL in case of an error.
</p>
<p><strong>Since:</strong> 3.6.9
</p></dd></dl>

<span id="gnutls_005fhash_005fdeinit-1"></span><h4 class="subheading">gnutls_hash_deinit</h4>
<span id="gnutls_005fhash_005fdeinit"></span><dl>
<dt id="index-gnutls_005fhash_005fdeinit">Function: <em>void</em> <strong>gnutls_hash_deinit</strong> <em>(gnutls_hash_hd_t <var>handle</var>, void * <var>digest</var>)</em></dt>
<dd><p><var>handle</var>: is a <code>gnutls_hash_hd_t</code>  type
</p>
<p><var>digest</var>: is the output value of the hash
</p>
<p>This function will deinitialize all resources occupied by
the given hash context.
</p>
<p><strong>Since:</strong> 2.10.0
</p></dd></dl>

<span id="gnutls_005fhash_005ffast-1"></span><h4 class="subheading">gnutls_hash_fast</h4>
<span id="gnutls_005fhash_005ffast"></span><dl>
<dt id="index-gnutls_005fhash_005ffast">Function: <em>int</em> <strong>gnutls_hash_fast</strong> <em>(gnutls_digest_algorithm_t <var>algorithm</var>, const void * <var>ptext</var>, size_t <var>ptext_len</var>, void * <var>digest</var>)</em></dt>
<dd><p><var>algorithm</var>: the hash algorithm to use
</p>
<p><var>ptext</var>: the data to hash
</p>
<p><var>ptext_len</var>: the length of data to hash
</p>
<p><var>digest</var>: is the output value of the hash
</p>
<p>This convenience function will hash the given data and return output
on a single call.
</p>
<p><strong>Returns:</strong> Zero or a negative error code on error.
</p>
<p><strong>Since:</strong> 2.10.0
</p></dd></dl>

<span id="gnutls_005fhash_005fget_005flen-1"></span><h4 class="subheading">gnutls_hash_get_len</h4>
<span id="gnutls_005fhash_005fget_005flen"></span><dl>
<dt id="index-gnutls_005fhash_005fget_005flen">Function: <em>unsigned</em> <strong>gnutls_hash_get_len</strong> <em>(gnutls_digest_algorithm_t <var>algorithm</var>)</em></dt>
<dd><p><var>algorithm</var>: the hash algorithm to use
</p>
<p>This function will return the length of the output data
of the given hash algorithm.
</p>
<p><strong>Returns:</strong> The length or zero on error.
</p>
<p><strong>Since:</strong> 2.10.0
</p></dd></dl>

<span id="gnutls_005fhash_005finit-1"></span><h4 class="subheading">gnutls_hash_init</h4>
<span id="gnutls_005fhash_005finit"></span><dl>
<dt id="index-gnutls_005fhash_005finit">Function: <em>int</em> <strong>gnutls_hash_init</strong> <em>(gnutls_hash_hd_t * <var>dig</var>, gnutls_digest_algorithm_t <var>algorithm</var>)</em></dt>
<dd><p><var>dig</var>: is a <code>gnutls_hash_hd_t</code>  type
</p>
<p><var>algorithm</var>: the hash algorithm to use
</p>
<p>This function will initialize an context that can be used to
produce a Message Digest of data.  This will effectively use the
current crypto backend in use by gnutls or the cryptographic
accelerator in use.
</p>
<p><strong>Returns:</strong> Zero or a negative error code on error.
</p>
<p><strong>Since:</strong> 2.10.0
</p></dd></dl>

<span id="gnutls_005fhash_005foutput-1"></span><h4 class="subheading">gnutls_hash_output</h4>
<span id="gnutls_005fhash_005foutput"></span><dl>
<dt id="index-gnutls_005fhash_005foutput">Function: <em>void</em> <strong>gnutls_hash_output</strong> <em>(gnutls_hash_hd_t <var>handle</var>, void * <var>digest</var>)</em></dt>
<dd><p><var>handle</var>: is a <code>gnutls_hash_hd_t</code>  type
</p>
<p><var>digest</var>: is the output value of the hash
</p>
<p>This function will output the current hash value
and reset the state of the hash.
</p>
<p><strong>Since:</strong> 2.10.0
</p></dd></dl>

<span id="gnutls_005fhmac-1"></span><h4 class="subheading">gnutls_hmac</h4>
<span id="gnutls_005fhmac"></span><dl>
<dt id="index-gnutls_005fhmac">Function: <em>int</em> <strong>gnutls_hmac</strong> <em>(gnutls_hmac_hd_t <var>handle</var>, const void * <var>ptext</var>, size_t <var>ptext_len</var>)</em></dt>
<dd><p><var>handle</var>: is a <code>gnutls_hmac_hd_t</code>  type
</p>
<p><var>ptext</var>: the data to hash
</p>
<p><var>ptext_len</var>: the length of data to hash
</p>
<p>This function will hash the given data using the algorithm
specified by the context.
</p>
<p><strong>Returns:</strong> Zero or a negative error code on error.
</p>
<p><strong>Since:</strong> 2.10.0
</p></dd></dl>

<span id="gnutls_005fhmac_005fcopy-1"></span><h4 class="subheading">gnutls_hmac_copy</h4>
<span id="gnutls_005fhmac_005fcopy"></span><dl>
<dt id="index-gnutls_005fhmac_005fcopy">Function: <em>gnutls_hmac_hd_t</em> <strong>gnutls_hmac_copy</strong> <em>(gnutls_hmac_hd_t <var>handle</var>)</em></dt>
<dd><p><var>handle</var>: is a <code>gnutls_hmac_hd_t</code>  type
</p>
<p>This function will create a copy of MAC context, containing all its current
state. Copying contexts for MACs registered using
<code>gnutls_crypto_register_mac()</code>  is not supported and will always result in an
error.
</p>
<p><strong>Returns:</strong> new MAC context or NULL in case of an error.
</p>
<p><strong>Since:</strong> 3.6.9
</p></dd></dl>

<span id="gnutls_005fhmac_005fdeinit-1"></span><h4 class="subheading">gnutls_hmac_deinit</h4>
<span id="gnutls_005fhmac_005fdeinit"></span><dl>
<dt id="index-gnutls_005fhmac_005fdeinit">Function: <em>void</em> <strong>gnutls_hmac_deinit</strong> <em>(gnutls_hmac_hd_t <var>handle</var>, void * <var>digest</var>)</em></dt>
<dd><p><var>handle</var>: is a <code>gnutls_hmac_hd_t</code>  type
</p>
<p><var>digest</var>: is the output value of the MAC
</p>
<p>This function will deinitialize all resources occupied by
the given hmac context.
</p>
<p><strong>Since:</strong> 2.10.0
</p></dd></dl>

<span id="gnutls_005fhmac_005ffast-1"></span><h4 class="subheading">gnutls_hmac_fast</h4>
<span id="gnutls_005fhmac_005ffast"></span><dl>
<dt id="index-gnutls_005fhmac_005ffast">Function: <em>int</em> <strong>gnutls_hmac_fast</strong> <em>(gnutls_mac_algorithm_t <var>algorithm</var>, const void * <var>key</var>, size_t <var>keylen</var>, const void * <var>ptext</var>, size_t <var>ptext_len</var>, void * <var>digest</var>)</em></dt>
<dd><p><var>algorithm</var>: the hash algorithm to use
</p>
<p><var>key</var>: the key to use
</p>
<p><var>keylen</var>: the length of the key
</p>
<p><var>ptext</var>: the data to hash
</p>
<p><var>ptext_len</var>: the length of data to hash
</p>
<p><var>digest</var>: is the output value of the hash
</p>
<p>This convenience function will hash the given data and return output
on a single call. Note, this call will not work for MAC algorithms
that require nonce (like UMAC or GMAC).
</p>
<p><strong>Returns:</strong> Zero or a negative error code on error.
</p>
<p><strong>Since:</strong> 2.10.0
</p></dd></dl>

<span id="gnutls_005fhmac_005fget_005flen-1"></span><h4 class="subheading">gnutls_hmac_get_len</h4>
<span id="gnutls_005fhmac_005fget_005flen"></span><dl>
<dt id="index-gnutls_005fhmac_005fget_005flen">Function: <em>unsigned</em> <strong>gnutls_hmac_get_len</strong> <em>(gnutls_mac_algorithm_t <var>algorithm</var>)</em></dt>
<dd><p><var>algorithm</var>: the hmac algorithm to use
</p>
<p>This function will return the length of the output data
of the given hmac algorithm.
</p>
<p><strong>Returns:</strong> The length or zero on error.
</p>
<p><strong>Since:</strong> 2.10.0
</p></dd></dl>

<span id="gnutls_005fhmac_005finit-1"></span><h4 class="subheading">gnutls_hmac_init</h4>
<span id="gnutls_005fhmac_005finit"></span><dl>
<dt id="index-gnutls_005fhmac_005finit">Function: <em>int</em> <strong>gnutls_hmac_init</strong> <em>(gnutls_hmac_hd_t * <var>dig</var>, gnutls_mac_algorithm_t <var>algorithm</var>, const void * <var>key</var>, size_t <var>keylen</var>)</em></dt>
<dd><p><var>dig</var>: is a <code>gnutls_hmac_hd_t</code>  type
</p>
<p><var>algorithm</var>: the HMAC algorithm to use
</p>
<p><var>key</var>: the key to be used for encryption
</p>
<p><var>keylen</var>: the length of the key
</p>
<p>This function will initialize an context that can be used to
produce a Message Authentication Code (MAC) of data.  This will
effectively use the current crypto backend in use by gnutls or the
cryptographic accelerator in use.
</p>
<p>Note that despite the name of this function, it can be used
for other MAC algorithms than HMAC.
</p>
<p><strong>Returns:</strong> Zero or a negative error code on error.
</p>
<p><strong>Since:</strong> 2.10.0
</p></dd></dl>

<span id="gnutls_005fhmac_005foutput-1"></span><h4 class="subheading">gnutls_hmac_output</h4>
<span id="gnutls_005fhmac_005foutput"></span><dl>
<dt id="index-gnutls_005fhmac_005foutput">Function: <em>void</em> <strong>gnutls_hmac_output</strong> <em>(gnutls_hmac_hd_t <var>handle</var>, void * <var>digest</var>)</em></dt>
<dd><p><var>handle</var>: is a <code>gnutls_hmac_hd_t</code>  type
</p>
<p><var>digest</var>: is the output value of the MAC
</p>
<p>This function will output the current MAC value
and reset the state of the MAC.
</p>
<p><strong>Since:</strong> 2.10.0
</p></dd></dl>

<span id="gnutls_005fhmac_005fset_005fnonce-1"></span><h4 class="subheading">gnutls_hmac_set_nonce</h4>
<span id="gnutls_005fhmac_005fset_005fnonce"></span><dl>
<dt id="index-gnutls_005fhmac_005fset_005fnonce">Function: <em>void</em> <strong>gnutls_hmac_set_nonce</strong> <em>(gnutls_hmac_hd_t <var>handle</var>, const void * <var>nonce</var>, size_t <var>nonce_len</var>)</em></dt>
<dd><p><var>handle</var>: is a <code>gnutls_hmac_hd_t</code>  type
</p>
<p><var>nonce</var>: the data to set as nonce
</p>
<p><var>nonce_len</var>: the length of data
</p>
<p>This function will set the nonce in the MAC algorithm.
</p>
<p><strong>Since:</strong> 3.2.0
</p></dd></dl>

<span id="gnutls_005fmac_005fget_005fnonce_005fsize-1"></span><h4 class="subheading">gnutls_mac_get_nonce_size</h4>
<span id="gnutls_005fmac_005fget_005fnonce_005fsize"></span><dl>
<dt id="index-gnutls_005fmac_005fget_005fnonce_005fsize">Function: <em>size_t</em> <strong>gnutls_mac_get_nonce_size</strong> <em>(gnutls_mac_algorithm_t <var>algorithm</var>)</em></dt>
<dd><p><var>algorithm</var>: is an encryption algorithm
</p>
<p>Returns the size of the nonce used by the MAC in TLS.
</p>
<p><strong>Returns:</strong> length (in bytes) of the given MAC nonce size, or 0.
</p>
<p><strong>Since:</strong> 3.2.0
</p></dd></dl>

<span id="gnutls_005frnd-1"></span><h4 class="subheading">gnutls_rnd</h4>
<span id="gnutls_005frnd"></span><dl>
<dt id="index-gnutls_005frnd-1">Function: <em>int</em> <strong>gnutls_rnd</strong> <em>(gnutls_rnd_level_t <var>level</var>, void * <var>data</var>, size_t <var>len</var>)</em></dt>
<dd><p><var>level</var>: a security level
</p>
<p><var>data</var>: place to store random bytes
</p>
<p><var>len</var>: The requested size
</p>
<p>This function will generate random data and store it to output
buffer. The value of  <code>level</code> should be one of <code>GNUTLS_RND_NONCE</code> ,
<code>GNUTLS_RND_RANDOM</code>  and <code>GNUTLS_RND_KEY</code> . See the manual and
<code>gnutls_rnd_level_t</code>  for detailed information.
</p>
<p>This function is thread-safe and also fork-safe.
</p>
<p><strong>Returns:</strong> Zero on success, or a negative error code on error.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005frnd_005frefresh-1"></span><h4 class="subheading">gnutls_rnd_refresh</h4>
<span id="gnutls_005frnd_005frefresh"></span><dl>
<dt id="index-gnutls_005frnd_005frefresh">Function: <em>void</em> <strong>gnutls_rnd_refresh</strong> <em>( <var>void</var>)</em></dt>
<dd>
<p>This function refreshes the random generator state.
That is the current precise time, CPU usage, and
other values are input into its state.
</p>
<p>On a slower rate input from /dev/urandom is mixed too.
</p>
<p><strong>Since:</strong> 3.1.7
</p></dd></dl>


<hr>
<span id="Compatibility-API"></span><div class="header">
<p>
Previous: <a href="#Cryptographic-API" accesskey="p" rel="prev">Cryptographic API</a>, Up: <a href="#API-reference" accesskey="u" rel="up">API reference</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Compatibility-API-1"></span><h3 class="section">E.13 Compatibility API</h3>

<p>The following functions are carried over from old GnuTLS released. They might be removed at a later version.
Their prototypes lie in <samp>gnutls/compat.h</samp>.
</p>

<span id="gnutls_005fcompression_005fget-1"></span><h4 class="subheading">gnutls_compression_get</h4>
<span id="gnutls_005fcompression_005fget"></span><dl>
<dt id="index-gnutls_005fcompression_005fget">Function: <em>gnutls_compression_method_t</em> <strong>gnutls_compression_get</strong> <em>(gnutls_session_t <var>session</var>)</em></dt>
<dd><p><var>session</var>: is a <code>gnutls_session_t</code>  type.
</p>
<p>Get the currently used compression algorithm.
</p>
<p><strong>Returns:</strong> the currently used compression method, a
<code>gnutls_compression_method_t</code>  value.
</p></dd></dl>

<span id="gnutls_005fcompression_005fget_005fid-1"></span><h4 class="subheading">gnutls_compression_get_id</h4>
<span id="gnutls_005fcompression_005fget_005fid"></span><dl>
<dt id="index-gnutls_005fcompression_005fget_005fid">Function: <em>gnutls_compression_method_t</em> <strong>gnutls_compression_get_id</strong> <em>(const char * <var>name</var>)</em></dt>
<dd><p><var>name</var>: is a compression method name
</p>
<p>The names are compared in a case insensitive way.
</p>
<p><strong>Returns:</strong> an id of the specified in a string compression method, or
<code>GNUTLS_COMP_UNKNOWN</code>  on error.
</p></dd></dl>

<span id="gnutls_005fcompression_005fget_005fname-1"></span><h4 class="subheading">gnutls_compression_get_name</h4>
<span id="gnutls_005fcompression_005fget_005fname"></span><dl>
<dt id="index-gnutls_005fcompression_005fget_005fname">Function: <em>const char *</em> <strong>gnutls_compression_get_name</strong> <em>(gnutls_compression_method_t      <var>algorithm</var>)</em></dt>
<dd><p><var>algorithm</var>: is a Compression algorithm
</p>
<p>Convert a <code>gnutls_compression_method_t</code>  value to a string.
</p>
<p><strong>Returns:</strong> a pointer to a string that contains the name of the
specified compression algorithm, or <code>NULL</code> .
</p></dd></dl>

<span id="gnutls_005fcompression_005flist-1"></span><h4 class="subheading">gnutls_compression_list</h4>
<span id="gnutls_005fcompression_005flist"></span><dl>
<dt id="index-gnutls_005fcompression_005flist">Function: <em>const gnutls_compression_method_t *</em> <strong>gnutls_compression_list</strong> <em>( <var>void</var>)</em></dt>
<dd>
<p>Get a list of compression methods.
</p>
<p><strong>Returns:</strong> a zero-terminated list of <code>gnutls_compression_method_t</code> 
integers indicating the available compression methods.
</p></dd></dl>

<span id="gnutls_005fglobal_005fset_005fmem_005ffunctions-1"></span><h4 class="subheading">gnutls_global_set_mem_functions</h4>
<span id="gnutls_005fglobal_005fset_005fmem_005ffunctions"></span><dl>
<dt id="index-gnutls_005fglobal_005fset_005fmem_005ffunctions">Function: <em>void</em> <strong>gnutls_global_set_mem_functions</strong> <em>(gnutls_alloc_function <var>alloc_func</var>, gnutls_alloc_function <var>secure_alloc_func</var>, gnutls_is_secure_function <var>is_secure_func</var>, gnutls_realloc_function <var>realloc_func</var>, gnutls_free_function <var>free_func</var>)</em></dt>
<dd><p><var>alloc_func</var>: it&rsquo;s the default memory allocation function. Like <code>malloc()</code> .
</p>
<p><var>secure_alloc_func</var>: This is the memory allocation function that will be used for sensitive data.
</p>
<p><var>is_secure_func</var>: a function that returns 0 if the memory given is not secure. May be NULL.
</p>
<p><var>realloc_func</var>: A realloc function
</p>
<p><var>free_func</var>: The function that frees allocated data. Must accept a NULL pointer.
</p>

<p><strong>Deprecated:</strong> since 3.3.0 it is no longer possible to replace the internally used 
memory allocation functions
</p>
<p>This is the function where you set the memory allocation functions
gnutls is going to use. By default the libc&rsquo;s allocation functions
(<code>malloc()</code> , <code>free()</code> ), are used by gnutls, to allocate both sensitive
and not sensitive data.  This function is provided to set the
memory allocation functions to something other than the defaults
</p>
<p>This function must be called before <code>gnutls_global_init()</code>  is called.
This function is not thread safe.
</p></dd></dl>

<span id="gnutls_005fopenpgp_005fprivkey_005fsign_005fhash-1"></span><h4 class="subheading">gnutls_openpgp_privkey_sign_hash</h4>
<span id="gnutls_005fopenpgp_005fprivkey_005fsign_005fhash"></span><dl>
<dt id="index-gnutls_005fopenpgp_005fprivkey_005fsign_005fhash">Function: <em>int</em> <strong>gnutls_openpgp_privkey_sign_hash</strong> <em>(gnutls_openpgp_privkey_t <var>key</var>, const gnutls_datum_t * <var>hash</var>, gnutls_datum_t * <var>signature</var>)</em></dt>
<dd><p><var>key</var>: Holds the key
</p>
<p><var>hash</var>: holds the data to be signed
</p>
<p><var>signature</var>: will contain newly allocated signature
</p>
<p>This function is no-op.
</p>
<p><strong>Returns:</strong> <code>GNUTLS_E_UNIMPLEMENTED_FEATURE</code> .
</p></dd></dl>

<span id="gnutls_005fpriority_005fcompression_005flist-1"></span><h4 class="subheading">gnutls_priority_compression_list</h4>
<span id="gnutls_005fpriority_005fcompression_005flist"></span><dl>
<dt id="index-gnutls_005fpriority_005fcompression_005flist">Function: <em>int</em> <strong>gnutls_priority_compression_list</strong> <em>(gnutls_priority_t <var>pcache</var>, const unsigned int ** <var>list</var>)</em></dt>
<dd><p><var>pcache</var>: is a <code>gnutls_prioritity_t</code>  type.
</p>
<p><var>list</var>: will point to an integer list
</p>
<p>Get a list of available compression method in the priority
structure.
</p>
<p><strong>Returns:</strong> the number of methods, or an error code.
</p>
<p><strong>Since:</strong> 3.0
</p></dd></dl>

<span id="gnutls_005fx509_005fcrt_005fget_005fpreferred_005fhash_005falgorithm-1"></span><h4 class="subheading">gnutls_x509_crt_get_preferred_hash_algorithm</h4>
<span id="gnutls_005fx509_005fcrt_005fget_005fpreferred_005fhash_005falgorithm"></span><dl>
<dt id="index-gnutls_005fx509_005fcrt_005fget_005fpreferred_005fhash_005falgorithm">Function: <em>int</em> <strong>gnutls_x509_crt_get_preferred_hash_algorithm</strong> <em>(gnutls_x509_crt_t <var>crt</var>, gnutls_digest_algorithm_t *           <var>hash</var>, unsigned int * <var>mand</var>)</em></dt>
<dd><p><var>crt</var>: Holds the certificate
</p>
<p><var>hash</var>: The result of the call with the hash algorithm used for signature
</p>
<p><var>mand</var>: If non-zero it means that the algorithm MUST use this hash. May be <code>NULL</code> .
</p>
<p>This function will read the certificate and return the appropriate digest
algorithm to use for signing with this certificate. Some certificates (i.e.
DSA might not be able to sign without the preferred algorithm).
</p>
<p><strong>Deprecated:</strong> Please use <code>gnutls_pubkey_get_preferred_hash_algorithm()</code> .
</p>
<p><strong>Returns:</strong> the 0 if the hash algorithm is found. A negative error code is
returned on error.
</p>
<p><strong>Since:</strong> 2.12.0
</p></dd></dl>

<span id="gnutls_005fx509_005fprivkey_005fsign_005fhash-1"></span><h4 class="subheading">gnutls_x509_privkey_sign_hash</h4>
<span id="gnutls_005fx509_005fprivkey_005fsign_005fhash"></span><dl>
<dt id="index-gnutls_005fx509_005fprivkey_005fsign_005fhash">Function: <em>int</em> <strong>gnutls_x509_privkey_sign_hash</strong> <em>(gnutls_x509_privkey_t <var>key</var>, const gnutls_datum_t * <var>hash</var>, gnutls_datum_t * <var>signature</var>)</em></dt>
<dd><p><var>key</var>: a key
</p>
<p><var>hash</var>: holds the data to be signed
</p>
<p><var>signature</var>: will contain newly allocated signature
</p>
<p>This function will sign the given hash using the private key. Do not
use this function directly unless you know what it is. Typical signing
requires the data to be hashed and stored in special formats 
(e.g. BER Digest-Info for RSA).
</p>
<p>This API is provided only for backwards compatibility, and thus
restricted to RSA, DSA and ECDSA key types. For other key types please
use <code>gnutls_privkey_sign_hash()</code>  and <code>gnutls_privkey_sign_data()</code> .
</p>
<p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code>  (0) is returned, otherwise a
negative error value.
</p>
<p>Deprecated in: 2.12.0
</p></dd></dl>


<hr>
<span id="Copying-Information"></span><div class="header">
<p>
Next: <a href="#Bibliography" accesskey="n" rel="next">Bibliography</a>, Previous: <a href="#API-reference" accesskey="p" rel="prev">API reference</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Copying-Information-1"></span><h2 class="appendix">Appendix F Copying Information</h2>
<span id="index-FDL_002c-GNU-Free-Documentation-License"></span>

<span id="GNU-Free-Documentation-License"></span><h3 class="heading">GNU Free Documentation License</h3>

<div align="center">Version 1.3, 3 November 2008
</div>

<div class="display">
<pre class="display">Copyright &copy; 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
<a href="https://fsf.org/">https://fsf.org/</a>

Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.
</pre></div>

<ol start="0">
<li> PREAMBLE

<p>The purpose of this License is to make a manual, textbook, or other
functional and useful document <em>free</em> in the sense of freedom: to
assure everyone the effective freedom to copy and redistribute it,
with or without modifying it, either commercially or noncommercially.
Secondarily, this License preserves for the author and publisher a way
to get credit for their work, while not being considered responsible
for modifications made by others.
</p>
<p>This License is a kind of &ldquo;copyleft&rdquo;, which means that derivative
works of the document must themselves be free in the same sense.  It
complements the GNU General Public License, which is a copyleft
license designed for free software.
</p>
<p>We have designed this License in order to use it for manuals for free
software, because free software needs free documentation: a free
program should come with manuals providing the same freedoms that the
software does.  But this License is not limited to software manuals;
it can be used for any textual work, regardless of subject matter or
whether it is published as a printed book.  We recommend this License
principally for works whose purpose is instruction or reference.
</p>
</li><li> APPLICABILITY AND DEFINITIONS

<p>This License applies to any manual or other work, in any medium, that
contains a notice placed by the copyright holder saying it can be
distributed under the terms of this License.  Such a notice grants a
world-wide, royalty-free license, unlimited in duration, to use that
work under the conditions stated herein.  The &ldquo;Document&rdquo;, below,
refers to any such manual or work.  Any member of the public is a
licensee, and is addressed as &ldquo;you&rdquo;.  You accept the license if you
copy, modify or distribute the work in a way requiring permission
under copyright law.
</p>
<p>A &ldquo;Modified Version&rdquo; of the Document means any work containing the
Document or a portion of it, either copied verbatim, or with
modifications and/or translated into another language.
</p>
<p>A &ldquo;Secondary Section&rdquo; is a named appendix or a front-matter section
of the Document that deals exclusively with the relationship of the
publishers or authors of the Document to the Document&rsquo;s overall
subject (or to related matters) and contains nothing that could fall
directly within that overall subject.  (Thus, if the Document is in
part a textbook of mathematics, a Secondary Section may not explain
any mathematics.)  The relationship could be a matter of historical
connection with the subject or with related matters, or of legal,
commercial, philosophical, ethical or political position regarding
them.
</p>
<p>The &ldquo;Invariant Sections&rdquo; are certain Secondary Sections whose titles
are designated, as being those of Invariant Sections, in the notice
that says that the Document is released under this License.  If a
section does not fit the above definition of Secondary then it is not
allowed to be designated as Invariant.  The Document may contain zero
Invariant Sections.  If the Document does not identify any Invariant
Sections then there are none.
</p>
<p>The &ldquo;Cover Texts&rdquo; are certain short passages of text that are listed,
as Front-Cover Texts or Back-Cover Texts, in the notice that says that
the Document is released under this License.  A Front-Cover Text may
be at most 5 words, and a Back-Cover Text may be at most 25 words.
</p>
<p>A &ldquo;Transparent&rdquo; copy of the Document means a machine-readable copy,
represented in a format whose specification is available to the
general public, that is suitable for revising the document
straightforwardly with generic text editors or (for images composed of
pixels) generic paint programs or (for drawings) some widely available
drawing editor, and that is suitable for input to text formatters or
for automatic translation to a variety of formats suitable for input
to text formatters.  A copy made in an otherwise Transparent file
format whose markup, or absence of markup, has been arranged to thwart
or discourage subsequent modification by readers is not Transparent.
An image format is not Transparent if used for any substantial amount
of text.  A copy that is not &ldquo;Transparent&rdquo; is called &ldquo;Opaque&rdquo;.
</p>
<p>Examples of suitable formats for Transparent copies include plain
ASCII without markup, Texinfo input format, LaTeX input
format, SGML or XML using a publicly available
DTD, and standard-conforming simple HTML,
PostScript or PDF designed for human modification.  Examples
of transparent image formats include PNG, XCF and
JPG.  Opaque formats include proprietary formats that can be
read and edited only by proprietary word processors, SGML or
XML for which the DTD and/or processing tools are
not generally available, and the machine-generated HTML,
PostScript or PDF produced by some word processors for
output purposes only.
</p>
<p>The &ldquo;Title Page&rdquo; means, for a printed book, the title page itself,
plus such following pages as are needed to hold, legibly, the material
this License requires to appear in the title page.  For works in
formats which do not have any title page as such, &ldquo;Title Page&rdquo; means
the text near the most prominent appearance of the work&rsquo;s title,
preceding the beginning of the body of the text.
</p>
<p>The &ldquo;publisher&rdquo; means any person or entity that distributes copies
of the Document to the public.
</p>
<p>A section &ldquo;Entitled XYZ&rdquo; means a named subunit of the Document whose
title either is precisely XYZ or contains XYZ in parentheses following
text that translates XYZ in another language.  (Here XYZ stands for a
specific section name mentioned below, such as &ldquo;Acknowledgements&rdquo;,
&ldquo;Dedications&rdquo;, &ldquo;Endorsements&rdquo;, or &ldquo;History&rdquo;.)  To &ldquo;Preserve the Title&rdquo;
of such a section when you modify the Document means that it remains a
section &ldquo;Entitled XYZ&rdquo; according to this definition.
</p>
<p>The Document may include Warranty Disclaimers next to the notice which
states that this License applies to the Document.  These Warranty
Disclaimers are considered to be included by reference in this
License, but only as regards disclaiming warranties: any other
implication that these Warranty Disclaimers may have is void and has
no effect on the meaning of this License.
</p>
</li><li> VERBATIM COPYING

<p>You may copy and distribute the Document in any medium, either
commercially or noncommercially, provided that this License, the
copyright notices, and the license notice saying this License applies
to the Document are reproduced in all copies, and that you add no other
conditions whatsoever to those of this License.  You may not use
technical measures to obstruct or control the reading or further
copying of the copies you make or distribute.  However, you may accept
compensation in exchange for copies.  If you distribute a large enough
number of copies you must also follow the conditions in section 3.
</p>
<p>You may also lend copies, under the same conditions stated above, and
you may publicly display copies.
</p>
</li><li> COPYING IN QUANTITY

<p>If you publish printed copies (or copies in media that commonly have
printed covers) of the Document, numbering more than 100, and the
Document&rsquo;s license notice requires Cover Texts, you must enclose the
copies in covers that carry, clearly and legibly, all these Cover
Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on
the back cover.  Both covers must also clearly and legibly identify
you as the publisher of these copies.  The front cover must present
the full title with all words of the title equally prominent and
visible.  You may add other material on the covers in addition.
Copying with changes limited to the covers, as long as they preserve
the title of the Document and satisfy these conditions, can be treated
as verbatim copying in other respects.
</p>
<p>If the required texts for either cover are too voluminous to fit
legibly, you should put the first ones listed (as many as fit
reasonably) on the actual cover, and continue the rest onto adjacent
pages.
</p>
<p>If you publish or distribute Opaque copies of the Document numbering
more than 100, you must either include a machine-readable Transparent
copy along with each Opaque copy, or state in or with each Opaque copy
a computer-network location from which the general network-using
public has access to download using public-standard network protocols
a complete Transparent copy of the Document, free of added material.
If you use the latter option, you must take reasonably prudent steps,
when you begin distribution of Opaque copies in quantity, to ensure
that this Transparent copy will remain thus accessible at the stated
location until at least one year after the last time you distribute an
Opaque copy (directly or through your agents or retailers) of that
edition to the public.
</p>
<p>It is requested, but not required, that you contact the authors of the
Document well before redistributing any large number of copies, to give
them a chance to provide you with an updated version of the Document.
</p>
</li><li> MODIFICATIONS

<p>You may copy and distribute a Modified Version of the Document under
the conditions of sections 2 and 3 above, provided that you release
the Modified Version under precisely this License, with the Modified
Version filling the role of the Document, thus licensing distribution
and modification of the Modified Version to whoever possesses a copy
of it.  In addition, you must do these things in the Modified Version:
</p>
<ol type="A" start="1">
<li> Use in the Title Page (and on the covers, if any) a title distinct
from that of the Document, and from those of previous versions
(which should, if there were any, be listed in the History section
of the Document).  You may use the same title as a previous version
if the original publisher of that version gives permission.

</li><li> List on the Title Page, as authors, one or more persons or entities
responsible for authorship of the modifications in the Modified
Version, together with at least five of the principal authors of the
Document (all of its principal authors, if it has fewer than five),
unless they release you from this requirement.

</li><li> State on the Title page the name of the publisher of the
Modified Version, as the publisher.

</li><li> Preserve all the copyright notices of the Document.

</li><li> Add an appropriate copyright notice for your modifications
adjacent to the other copyright notices.

</li><li> Include, immediately after the copyright notices, a license notice
giving the public permission to use the Modified Version under the
terms of this License, in the form shown in the Addendum below.

</li><li> Preserve in that license notice the full lists of Invariant Sections
and required Cover Texts given in the Document&rsquo;s license notice.

</li><li> Include an unaltered copy of this License.

</li><li> Preserve the section Entitled &ldquo;History&rdquo;, Preserve its Title, and add
to it an item stating at least the title, year, new authors, and
publisher of the Modified Version as given on the Title Page.  If
there is no section Entitled &ldquo;History&rdquo; in the Document, create one
stating the title, year, authors, and publisher of the Document as
given on its Title Page, then add an item describing the Modified
Version as stated in the previous sentence.

</li><li> Preserve the network location, if any, given in the Document for
public access to a Transparent copy of the Document, and likewise
the network locations given in the Document for previous versions
it was based on.  These may be placed in the &ldquo;History&rdquo; section.
You may omit a network location for a work that was published at
least four years before the Document itself, or if the original
publisher of the version it refers to gives permission.

</li><li> For any section Entitled &ldquo;Acknowledgements&rdquo; or &ldquo;Dedications&rdquo;, Preserve
the Title of the section, and preserve in the section all the
substance and tone of each of the contributor acknowledgements and/or
dedications given therein.

</li><li> Preserve all the Invariant Sections of the Document,
unaltered in their text and in their titles.  Section numbers
or the equivalent are not considered part of the section titles.

</li><li> Delete any section Entitled &ldquo;Endorsements&rdquo;.  Such a section
may not be included in the Modified Version.

</li><li> Do not retitle any existing section to be Entitled &ldquo;Endorsements&rdquo; or
to conflict in title with any Invariant Section.

</li><li> Preserve any Warranty Disclaimers.
</li></ol>

<p>If the Modified Version includes new front-matter sections or
appendices that qualify as Secondary Sections and contain no material
copied from the Document, you may at your option designate some or all
of these sections as invariant.  To do this, add their titles to the
list of Invariant Sections in the Modified Version&rsquo;s license notice.
These titles must be distinct from any other section titles.
</p>
<p>You may add a section Entitled &ldquo;Endorsements&rdquo;, provided it contains
nothing but endorsements of your Modified Version by various
parties&mdash;for example, statements of peer review or that the text has
been approved by an organization as the authoritative definition of a
standard.
</p>
<p>You may add a passage of up to five words as a Front-Cover Text, and a
passage of up to 25 words as a Back-Cover Text, to the end of the list
of Cover Texts in the Modified Version.  Only one passage of
Front-Cover Text and one of Back-Cover Text may be added by (or
through arrangements made by) any one entity.  If the Document already
includes a cover text for the same cover, previously added by you or
by arrangement made by the same entity you are acting on behalf of,
you may not add another; but you may replace the old one, on explicit
permission from the previous publisher that added the old one.
</p>
<p>The author(s) and publisher(s) of the Document do not by this License
give permission to use their names for publicity for or to assert or
imply endorsement of any Modified Version.
</p>
</li><li> COMBINING DOCUMENTS

<p>You may combine the Document with other documents released under this
License, under the terms defined in section 4 above for modified
versions, provided that you include in the combination all of the
Invariant Sections of all of the original documents, unmodified, and
list them all as Invariant Sections of your combined work in its
license notice, and that you preserve all their Warranty Disclaimers.
</p>
<p>The combined work need only contain one copy of this License, and
multiple identical Invariant Sections may be replaced with a single
copy.  If there are multiple Invariant Sections with the same name but
different contents, make the title of each such section unique by
adding at the end of it, in parentheses, the name of the original
author or publisher of that section if known, or else a unique number.
Make the same adjustment to the section titles in the list of
Invariant Sections in the license notice of the combined work.
</p>
<p>In the combination, you must combine any sections Entitled &ldquo;History&rdquo;
in the various original documents, forming one section Entitled
&ldquo;History&rdquo;; likewise combine any sections Entitled &ldquo;Acknowledgements&rdquo;,
and any sections Entitled &ldquo;Dedications&rdquo;.  You must delete all
sections Entitled &ldquo;Endorsements.&rdquo;
</p>
</li><li> COLLECTIONS OF DOCUMENTS

<p>You may make a collection consisting of the Document and other documents
released under this License, and replace the individual copies of this
License in the various documents with a single copy that is included in
the collection, provided that you follow the rules of this License for
verbatim copying of each of the documents in all other respects.
</p>
<p>You may extract a single document from such a collection, and distribute
it individually under this License, provided you insert a copy of this
License into the extracted document, and follow this License in all
other respects regarding verbatim copying of that document.
</p>
</li><li> AGGREGATION WITH INDEPENDENT WORKS

<p>A compilation of the Document or its derivatives with other separate
and independent documents or works, in or on a volume of a storage or
distribution medium, is called an &ldquo;aggregate&rdquo; if the copyright
resulting from the compilation is not used to limit the legal rights
of the compilation&rsquo;s users beyond what the individual works permit.
When the Document is included in an aggregate, this License does not
apply to the other works in the aggregate which are not themselves
derivative works of the Document.
</p>
<p>If the Cover Text requirement of section 3 is applicable to these
copies of the Document, then if the Document is less than one half of
the entire aggregate, the Document&rsquo;s Cover Texts may be placed on
covers that bracket the Document within the aggregate, or the
electronic equivalent of covers if the Document is in electronic form.
Otherwise they must appear on printed covers that bracket the whole
aggregate.
</p>
</li><li> TRANSLATION

<p>Translation is considered a kind of modification, so you may
distribute translations of the Document under the terms of section 4.
Replacing Invariant Sections with translations requires special
permission from their copyright holders, but you may include
translations of some or all Invariant Sections in addition to the
original versions of these Invariant Sections.  You may include a
translation of this License, and all the license notices in the
Document, and any Warranty Disclaimers, provided that you also include
the original English version of this License and the original versions
of those notices and disclaimers.  In case of a disagreement between
the translation and the original version of this License or a notice
or disclaimer, the original version will prevail.
</p>
<p>If a section in the Document is Entitled &ldquo;Acknowledgements&rdquo;,
&ldquo;Dedications&rdquo;, or &ldquo;History&rdquo;, the requirement (section 4) to Preserve
its Title (section 1) will typically require changing the actual
title.
</p>
</li><li> TERMINATION

<p>You may not copy, modify, sublicense, or distribute the Document
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense, or distribute it is void, and
will automatically terminate your rights under this License.
</p>
<p>However, if you cease all violation of this License, then your license
from a particular copyright holder is reinstated (a) provisionally,
unless and until the copyright holder explicitly and finally
terminates your license, and (b) permanently, if the copyright holder
fails to notify you of the violation by some reasonable means prior to
60 days after the cessation.
</p>
<p>Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.
</p>
<p>Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, receipt of a copy of some or all of the same material does
not give you any rights to use it.
</p>
</li><li> FUTURE REVISIONS OF THIS LICENSE

<p>The Free Software Foundation may publish new, revised versions
of the GNU Free Documentation License from time to time.  Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns.  See
<a href="https://www.gnu.org/licenses/">https://www.gnu.org/licenses/</a>.
</p>
<p>Each version of the License is given a distinguishing version number.
If the Document specifies that a particular numbered version of this
License &ldquo;or any later version&rdquo; applies to it, you have the option of
following the terms and conditions either of that specified version or
of any later version that has been published (not as a draft) by the
Free Software Foundation.  If the Document does not specify a version
number of this License, you may choose any version ever published (not
as a draft) by the Free Software Foundation.  If the Document
specifies that a proxy can decide which future versions of this
License can be used, that proxy&rsquo;s public statement of acceptance of a
version permanently authorizes you to choose that version for the
Document.
</p>
</li><li> RELICENSING

<p>&ldquo;Massive Multiauthor Collaboration Site&rdquo; (or &ldquo;MMC Site&rdquo;) means any
World Wide Web server that publishes copyrightable works and also
provides prominent facilities for anybody to edit those works.  A
public wiki that anybody can edit is an example of such a server.  A
&ldquo;Massive Multiauthor Collaboration&rdquo; (or &ldquo;MMC&rdquo;) contained in the
site means any set of copyrightable works thus published on the MMC
site.
</p>
<p>&ldquo;CC-BY-SA&rdquo; means the Creative Commons Attribution-Share Alike 3.0
license published by Creative Commons Corporation, a not-for-profit
corporation with a principal place of business in San Francisco,
California, as well as future copyleft versions of that license
published by that same organization.
</p>
<p>&ldquo;Incorporate&rdquo; means to publish or republish a Document, in whole or
in part, as part of another Document.
</p>
<p>An MMC is &ldquo;eligible for relicensing&rdquo; if it is licensed under this
License, and if all works that were first published under this License
somewhere other than this MMC, and subsequently incorporated in whole
or in part into the MMC, (1) had no cover texts or invariant sections,
and (2) were thus incorporated prior to November 1, 2008.
</p>
<p>The operator of an MMC Site may republish an MMC contained in the site
under CC-BY-SA on the same site at any time before August 1, 2009,
provided the MMC is eligible for relicensing.
</p>
</li></ol>

<span id="ADDENDUM_003a-How-to-use-this-License-for-your-documents"></span><h3 class="heading">ADDENDUM: How to use this License for your documents</h3>

<p>To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and
license notices just after the title page:
</p>
<div class="example">
<pre class="example">  Copyright (C)  <var>year</var>  <var>your name</var>.
  Permission is granted to copy, distribute and/or modify this document
  under the terms of the GNU Free Documentation License, Version 1.3
  or any later version published by the Free Software Foundation;
  with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
  Texts.  A copy of the license is included in the section entitled ``GNU
  Free Documentation License''.
</pre></div>

<p>If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts,
replace the &ldquo;with&hellip;Texts.&rdquo; line with this:
</p>
<div class="example">
<pre class="example">    with the Invariant Sections being <var>list their titles</var>, with
    the Front-Cover Texts being <var>list</var>, and with the Back-Cover Texts
    being <var>list</var>.
</pre></div>

<p>If you have Invariant Sections without Cover Texts, or some other
combination of the three, merge those two alternatives to suit the
situation.
</p>
<p>If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of
free software license, such as the GNU General Public License,
to permit their use in free software.
</p>


<hr>
<span id="Bibliography"></span><div class="header">
<p>
Next: <a href="#Function-and-Data-Index" accesskey="n" rel="next">Function and Data Index</a>, Previous: <a href="#Copying-Information" accesskey="p" rel="prev">Copying Information</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Bibliography-1"></span><h2 class="unnumbered">Bibliography</h2>

<dl compact="compact">
<dt><span id="CBCATT"></span>[CBCATT]</dt>
<dd><p>Bodo Moeller, &quot;Security of CBC Ciphersuites in SSL/TLS: Problems and
Countermeasures&quot;, 2002, available from
<a href="https://www.openssl.org/~bodo/tls-cbc.txt">https://www.openssl.org/~bodo/tls-cbc.txt</a>.
</p>
</dd>
<dt><span id="GPGH"></span>[GPGH]</dt>
<dd><p>Mike Ashley, &quot;The GNU Privacy Handbook&quot;, 2002, available from
<a href="https://www.gnupg.org/gph/en/manual.pdf">https://www.gnupg.org/gph/en/manual.pdf</a>.
</p>
</dd>
<dt><span id="GUTPKI"></span>[GUTPKI]</dt>
<dd><p>Peter Gutmann, &quot;Everything you never wanted to know about PKI but were
forced to find out&quot;, Available from
<a href="https://www.cs.auckland.ac.nz/~pgut001/">https://www.cs.auckland.ac.nz/~pgut001/</a>.
</p>
</dd>
<dt><span id="PRNGATTACKS"></span>[PRNGATTACKS]</dt>
<dd><p>John Kelsey and Bruce Schneier, &quot;Cryptanalytic Attacks on Pseudorandom Number Generators&quot;,
Available from <a href="https://www.schneier.com/academic/paperfiles/paper-prngs.pdf">https://www.schneier.com/academic/paperfiles/paper-prngs.pdf</a>.
</p>
</dd>
<dt><span id="KEYPIN"></span>[KEYPIN]</dt>
<dd><p>Chris Evans and Chris Palmer, &quot;Public Key Pinning Extension for HTTP&quot;, 
Available from <a href="https://tools.ietf.org/html/draft-ietf-websec-key-pinning-01">https://tools.ietf.org/html/draft-ietf-websec-key-pinning-01</a>.
</p>
</dd>
<dt><span id="NISTSP80057"></span>[NISTSP80057]</dt>
<dd><p>NIST Special Publication 800-57, &quot;Recommendation for Key Management -
Part 1: General (Revised)&quot;, March 2007, available from
<a href="https://csrc.nist.gov/publications/nistpubs/800-57/sp800-57-Part1-revised2_Mar08-2007.pdf">https://csrc.nist.gov/publications/nistpubs/800-57/sp800-57-Part1-revised2_Mar08-2007.pdf</a>.
</p>
</dd>
<dt><span id="RFC7413"></span>[RFC7413]</dt>
<dd><p>Y. Cheng and J. Chu and S. Radhakrishnan and A. Jain, &quot;TCP Fast Open&quot;,
December 2014, Available from
<a href="https://www.ietf.org/rfc/rfc7413.txt">https://www.ietf.org/rfc/rfc7413.txt</a>.
</p>
</dd>
<dt><span id="RFC7918"></span>[RFC7918]</dt>
<dd><p>A. Langley, N. Modadugu, B. Moeller, &quot;Transport Layer Security (TLS) False Start&quot;,
August 2016, Available from
<a href="https://www.ietf.org/rfc/rfc7918.txt">https://www.ietf.org/rfc/rfc7918.txt</a>.
</p>
</dd>
<dt><span id="RFC6125"></span>[RFC6125]</dt>
<dd><p>Peter Saint-Andre and Jeff Hodges, &quot;Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)&quot;,
March 2011, Available from
<a href="https://www.ietf.org/rfc/rfc6125.txt">https://www.ietf.org/rfc/rfc6125.txt</a>.
</p>
</dd>
<dt><span id="RFC7685"></span>[RFC7685]</dt>
<dd><p>Adam Langley, &quot;A Transport Layer Security (TLS) ClientHello Padding Extension&quot;,
October 2015, Available from
<a href="https://www.ietf.org/rfc/rfc7685.txt">https://www.ietf.org/rfc/rfc7685.txt</a>.
</p>
</dd>
<dt><span id="RFC7613"></span>[RFC7613]</dt>
<dd><p>Peter Saint-Andre and Alexey Melnikov, &quot;Preparation, Enforcement, and Comparison of Internationalized Strings Representing Usernames and Passwords&quot;,
August 2015, Available from
<a href="https://www.ietf.org/rfc/rfc7613.txt">https://www.ietf.org/rfc/rfc7613.txt</a>.
</p>
</dd>
<dt><span id="RFC2246"></span>[RFC2246]</dt>
<dd><p>Tim Dierks and Christopher Allen, &quot;The TLS Protocol Version 1.0&quot;,
January 1999, Available from
<a href="https://www.ietf.org/rfc/rfc2246.txt">https://www.ietf.org/rfc/rfc2246.txt</a>.
</p>
</dd>
<dt><span id="RFC6083"></span>[RFC6083]</dt>
<dd><p>M. Tuexen and R. Seggelmann and E. Rescorla, &quot;Datagram Transport Layer Security (DTLS) for Stream Control Transmission Protocol (SCTP)&quot;,
January 2011, Available from
<a href="https://www.ietf.org/rfc/rfc6083.txt">https://www.ietf.org/rfc/rfc6083.txt</a>.
</p>
</dd>
<dt><span id="RFC4418"></span>[RFC4418]</dt>
<dd><p>Ted Krovetz, &quot;UMAC: Message Authentication Code using Universal Hashing&quot;,
March 2006, Available from
<a href="https://www.ietf.org/rfc/rfc4418.txt">https://www.ietf.org/rfc/rfc4418.txt</a>.
</p>
</dd>
<dt><span id="RFC4680"></span>[RFC4680]</dt>
<dd><p>S. Santesson, &quot;TLS Handshake Message for Supplemental Data&quot;,
September 2006, Available from
<a href="https://www.ietf.org/rfc/rfc4680.txt">https://www.ietf.org/rfc/rfc4680.txt</a>.
</p>
</dd>
<dt><span id="RFC7633"></span>[RFC7633]</dt>
<dd><p>P. Hallam-Baker, &quot;X.509v3 Transport Layer Security (TLS) Feature Extension&quot;,
October 2015, Available from
<a href="https://www.ietf.org/rfc/rfc7633.txt">https://www.ietf.org/rfc/rfc7633.txt</a>.
</p>
</dd>
<dt><span id="RFC7919"></span>[RFC7919]</dt>
<dd><p>D. Gillmor, &quot;Negotiated Finite Field Diffie-Hellman Ephemeral Parameters for Transport Layer Security (TLS)&quot;,
August 2016, Available from
<a href="https://www.ietf.org/rfc/rfc7919.txt">https://www.ietf.org/rfc/rfc7919.txt</a>.
</p>
</dd>
<dt><span id="RFC4514"></span>[RFC4514]</dt>
<dd><p>Kurt D.  Zeilenga, &quot;Lightweight Directory Access Protocol (LDAP): String Representation of Distinguished Names&quot;,
June 2006, Available from
<a href="https://www.ietf.org/rfc/rfc4513.txt">https://www.ietf.org/rfc/rfc4513.txt</a>.
</p>
</dd>
<dt><span id="RFC4346"></span>[RFC4346]</dt>
<dd><p>Tim Dierks and Eric Rescorla, &quot;The TLS Protocol Version 1.1&quot;, Match
2006, Available from <a href="https://www.ietf.org/rfc/rfc4346.txt">https://www.ietf.org/rfc/rfc4346.txt</a>.
</p>
</dd>
<dt><span id="RFC4347"></span>[RFC4347]</dt>
<dd><p>Eric Rescorla and Nagendra Modadugu, &quot;Datagram Transport Layer Security&quot;, April
2006, Available from <a href="https://www.ietf.org/rfc/rfc4347.txt">https://www.ietf.org/rfc/rfc4347.txt</a>.
</p>
</dd>
<dt><span id="RFC5246"></span>[RFC5246]</dt>
<dd><p>Tim Dierks and Eric Rescorla, &quot;The TLS Protocol Version 1.2&quot;, August
2008, Available from <a href="https://www.ietf.org/rfc/rfc5246.txt">https://www.ietf.org/rfc/rfc5246.txt</a>.
</p>
</dd>
<dt><span id="RFC2440"></span>[RFC2440]</dt>
<dd><p>Jon Callas, Lutz Donnerhacke, Hal Finney and Rodney Thayer, &quot;OpenPGP
Message Format&quot;, November 1998, Available from
<a href="https://www.ietf.org/rfc/rfc2440.txt">https://www.ietf.org/rfc/rfc2440.txt</a>.
</p>
</dd>
<dt><span id="RFC4880"></span>[RFC4880]</dt>
<dd><p>Jon Callas, Lutz Donnerhacke, Hal Finney, David Shaw and Rodney
Thayer, &quot;OpenPGP Message Format&quot;, November 2007, Available from
<a href="https://www.ietf.org/rfc/rfc4880.txt">https://www.ietf.org/rfc/rfc4880.txt</a>.
</p>
</dd>
<dt><span id="RFC4211"></span>[RFC4211]</dt>
<dd><p>J. Schaad, &quot;Internet X.509 Public Key Infrastructure Certificate
Request Message Format (CRMF)&quot;, September 2005, Available from
<a href="https://www.ietf.org/rfc/rfc4211.txt">https://www.ietf.org/rfc/rfc4211.txt</a>.
</p>
</dd>
<dt><span id="RFC2817"></span>[RFC2817]</dt>
<dd><p>Rohit Khare and Scott Lawrence, &quot;Upgrading to TLS Within HTTP/1.1&quot;,
May 2000, Available from <a href="https://www.ietf.org/rfc/rfc2817.txt">https://www.ietf.org/rfc/rfc2817.txt</a>
</p>
</dd>
<dt><span id="RFC2818"></span>[RFC2818]</dt>
<dd><p>Eric Rescorla, &quot;HTTP Over TLS&quot;, May 2000, Available from
<a href="https://www.ietf/rfc/rfc2818.txt">https://www.ietf/rfc/rfc2818.txt</a>.
</p>
</dd>
<dt><span id="RFC2945"></span>[RFC2945]</dt>
<dd><p>Tom Wu, &quot;The SRP Authentication and Key Exchange System&quot;, September
2000, Available from <a href="https://www.ietf.org/rfc/rfc2945.txt">https://www.ietf.org/rfc/rfc2945.txt</a>.
</p>
</dd>
<dt><span id="RFC7301"></span>[RFC7301]</dt>
<dd><p>S. Friedl, A. Popov, A. Langley, E. Stephan, &quot;Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension&quot;,
July 2014, Available from <a href="https://www.ietf.org/rfc/rfc7301.txt">https://www.ietf.org/rfc/rfc7301.txt</a>.
</p>
</dd>
<dt><span id="RFC2986"></span>[RFC2986]</dt>
<dd><p>Magnus Nystrom and Burt Kaliski, &quot;PKCS 10 v1.7: Certification Request
Syntax Specification&quot;, November 2000, Available from
<a href="https://www.ietf.org/rfc/rfc2986.txt">https://www.ietf.org/rfc/rfc2986.txt</a>.
</p>
</dd>
<dt><span id="PKIX"></span>[PKIX]</dt>
<dd><p>D. Cooper, S. Santesson, S. Farrel, S. Boeyen, R. Housley, W. Polk,
&quot;Internet X.509 Public Key Infrastructure Certificate and Certificate
Revocation List (CRL) Profile&quot;, May 2008, available from
<a href="https://www.ietf.org/rfc/rfc5280.txt">https://www.ietf.org/rfc/rfc5280.txt</a>.
</p>
</dd>
<dt><span id="RFC3749"></span>[RFC3749]</dt>
<dd><p>Scott Hollenbeck, &quot;Transport Layer Security Protocol Compression
Methods&quot;, May 2004, available from
<a href="https://www.ietf.org/rfc/rfc3749.txt">https://www.ietf.org/rfc/rfc3749.txt</a>.
</p>
</dd>
<dt><span id="RFC3820"></span>[RFC3820]</dt>
<dd><p>Steven Tuecke, Von Welch, Doug Engert, Laura Pearlman, and Mary
Thompson, &quot;Internet X.509 Public Key Infrastructure (PKI) Proxy
Certificate Profile&quot;, June 2004, available from
<a href="https://www.ietf.org/rfc/rfc3820">https://www.ietf.org/rfc/rfc3820</a>.
</p>
</dd>
<dt><span id="RFC6520"></span>[RFC6520]</dt>
<dd><p>R. Seggelmann, M. Tuexen, and M. Williams, &quot;Transport Layer Security (TLS) and
Datagram Transport Layer Security (DTLS) Heartbeat Extension&quot;, February 2012, available from
<a href="https://www.ietf.org/rfc/rfc6520">https://www.ietf.org/rfc/rfc6520</a>.
</p>

</dd>
<dt><span id="RFC5746"></span>[RFC5746]</dt>
<dd><p>E. Rescorla, M. Ray, S. Dispensa, and N. Oskov, &quot;Transport Layer
Security (TLS) Renegotiation Indication Extension&quot;, February 2010,
available from <a href="https://www.ietf.org/rfc/rfc5746">https://www.ietf.org/rfc/rfc5746</a>.
</p>
</dd>
<dt><span id="RFC5280"></span>[RFC5280]</dt>
<dd><p>D. Cooper, S. Santesson, S. Farrell, S. Boeyen, R. Housley, and
W. Polk, &quot;Internet X.509 Public Key Infrastructure Certificate and
Certificate Revocation List (CRL) Profile&quot;, May 2008, available from
<a href="https://www.ietf.org/rfc/rfc5280">https://www.ietf.org/rfc/rfc5280</a>.
</p>
</dd>
<dt><span id="TLSTKT"></span>[TLSTKT]</dt>
<dd><p>Joseph Salowey, Hao Zhou, Pasi Eronen, Hannes Tschofenig, &quot;Transport
Layer Security (TLS) Session Resumption without Server-Side State&quot;,
January 2008, available from <a href="https://www.ietf.org/rfc/rfc5077">https://www.ietf.org/rfc/rfc5077</a>.
</p>
</dd>
<dt><span id="PKCS12"></span>[PKCS12]</dt>
<dd><p>RSA Laboratories, &quot;PKCS 12 v1.0: Personal Information Exchange
Syntax&quot;, June 1999, Available from <a href="https://www.rsa.com">https://www.rsa.com</a>.
</p>
</dd>
<dt><span id="PKCS11"></span>[PKCS11]</dt>
<dd><p>RSA Laboratories, &quot;PKCS #11 Base Functionality v2.30: Cryptoki  Draft 4&quot;,
July 2009, Available from <a href="https://www.rsa.com">https://www.rsa.com</a>.
</p>
</dd>
<dt><span id="RESCORLA"></span>[RESCORLA]</dt>
<dd><p>Eric Rescorla, &quot;SSL and TLS: Designing and Building Secure Systems&quot;,
2001
</p>
</dd>
<dt><span id="SELKEY"></span>[SELKEY]</dt>
<dd><p>Arjen Lenstra and Eric Verheul, &quot;Selecting Cryptographic Key Sizes&quot;,
2003, available from <a href="https://www.win.tue.nl/~klenstra/key.pdf">https://www.win.tue.nl/~klenstra/key.pdf</a>.
</p>
</dd>
<dt><span id="SSL3"></span>[SSL3]</dt>
<dd><p>Alan Freier, Philip Karlton and Paul Kocher, &quot;The Secure Sockets Layer (SSL) Protocol Version 3.0&quot;,
August 2011, Available from <a href="https://www.ietf.org/rfc/rfc6101.txt">https://www.ietf.org/rfc/rfc6101.txt</a>.
</p>
</dd>
<dt><span id="STEVENS"></span>[STEVENS]</dt>
<dd><p>Richard Stevens, &quot;UNIX Network Programming, Volume 1&quot;, Prentice Hall
PTR, January 1998
</p>
</dd>
<dt><span id="TLSEXT"></span>[TLSEXT]</dt>
<dd><p>Simon Blake-Wilson, Magnus Nystrom, David Hopwood, Jan Mikkelsen and
Tim Wright, &quot;Transport Layer Security (TLS) Extensions&quot;, June 2003,
Available from <a href="https://www.ietf.org/rfc/rfc3546.txt">https://www.ietf.org/rfc/rfc3546.txt</a>.
</p>
</dd>
<dt><span id="TLSPGP"></span>[TLSPGP]</dt>
<dd><p>Nikos Mavrogiannopoulos, &quot;Using OpenPGP keys for TLS authentication&quot;,
January 2011. Available from
<a href="https://www.ietf.org/rfc/rfc6091.txt">https://www.ietf.org/rfc/rfc6091.txt</a>.
</p>
</dd>
<dt><span id="TLSSRP"></span>[TLSSRP]</dt>
<dd><p>David Taylor, Trevor Perrin, Tom Wu and Nikos Mavrogiannopoulos,
&quot;Using SRP for TLS Authentication&quot;, November 2007. Available from
<a href="https://www.ietf.org/rfc/rfc5054.txt">https://www.ietf.org/rfc/rfc5054.txt</a>.
</p>
</dd>
<dt><span id="TLSPSK"></span>[TLSPSK]</dt>
<dd><p>Pasi Eronen and Hannes Tschofenig, &quot;Pre-shared key Ciphersuites for
TLS&quot;, December 2005, Available from
<a href="https://www.ietf.org/rfc/rfc4279.txt">https://www.ietf.org/rfc/rfc4279.txt</a>.
</p>
</dd>
<dt><span id="TOMSRP"></span>[TOMSRP]</dt>
<dd><p>Tom Wu, &quot;The Stanford SRP Authentication Project&quot;, Available at
<a href="https://srp.stanford.edu/">https://srp.stanford.edu/</a>.
</p>
</dd>
<dt><span id="WEGER"></span>[WEGER]</dt>
<dd><p>Arjen Lenstra and Xiaoyun Wang and Benne de Weger, &quot;Colliding X.509
Certificates&quot;, Cryptology ePrint Archive, Report 2005/067, Available
at <a href="https://eprint.iacr.org/">https://eprint.iacr.org/</a>.
</p>
</dd>
<dt><span id="ECRYPT"></span>[ECRYPT]</dt>
<dd><p>European Network of Excellence in Cryptology II, &quot;ECRYPT II Yearly
Report on Algorithms and Keysizes (2009-2010)&quot;, Available
at <a href="https://www.ecrypt.eu.org/documents/D.SPA.13.pdf">https://www.ecrypt.eu.org/documents/D.SPA.13.pdf</a>.
</p>
</dd>
<dt><span id="RFC5056"></span>[RFC5056]</dt>
<dd><p>N. Williams, &quot;On the Use of Channel Bindings to Secure Channels&quot;,
November 2007, available from <a href="https://www.ietf.org/rfc/rfc5056">https://www.ietf.org/rfc/rfc5056</a>.
</p>
</dd>
<dt><span id="RFC5764"></span>[RFC5764]</dt>
<dd><p>D. McGrew, E. Rescorla, &quot;Datagram Transport Layer Security (DTLS) Extension to Establish Keys for the Secure Real-time Transport Protocol (SRTP)On the Use of Channel Bindings to Secure Channels&quot;,
May 2010, available from <a href="https://www.ietf.org/rfc/rfc5764">https://www.ietf.org/rfc/rfc5764</a>.
</p>
</dd>
<dt><span id="RFC5929"></span>[RFC5929]</dt>
<dd><p>J. Altman, N. Williams, L. Zhu, &quot;Channel Bindings for TLS&quot;, July 2010,
available from <a href="https://www.ietf.org/rfc/rfc5929">https://www.ietf.org/rfc/rfc5929</a>.
</p>
</dd>
<dt><span id="PKCS11URI"></span>[PKCS11URI]</dt>
<dd><p>J. Pechanec, D. Moffat, &quot;The PKCS#11 URI Scheme&quot;, April 2015,
available from <a href="https://www.ietf.org/rfc/rfc7512">https://www.ietf.org/rfc/rfc7512</a>.
</p>
</dd>
<dt><span id="TPMURI"></span>[TPMURI]</dt>
<dd><p>C. Latze, N. Mavrogiannopoulos, &quot;The TPMKEY URI Scheme&quot;, January 2013,
Work in progress, available from <a href="https://tools.ietf.org/html/draft-mavrogiannopoulos-tpmuri-01">https://tools.ietf.org/html/draft-mavrogiannopoulos-tpmuri-01</a>.
</p>
</dd>
<dt><span id="ANDERSON"></span>[ANDERSON]</dt>
<dd><p>R. J. Anderson, &quot;Security Engineering: A Guide to Building Dependable Distributed Systems&quot;, 
John Wiley \&amp; Sons, Inc., 2001.
</p>
</dd>
<dt><span id="RFC4821"></span>[RFC4821]</dt>
<dd><p>M. Mathis, J. Heffner, &quot;Packetization Layer Path MTU Discovery&quot;, March 2007,
available from <a href="https://www.ietf.org/rfc/rfc4821.txt">https://www.ietf.org/rfc/rfc4821.txt</a>.
</p>
</dd>
<dt><span id="RFC2560"></span>[RFC2560]</dt>
<dd><p>M. Myers et al, &quot;X.509 Internet Public Key Infrastructure Online
Certificate Status Protocol - OCSP&quot;, June 1999, Available from
<a href="https://www.ietf.org/rfc/rfc2560.txt">https://www.ietf.org/rfc/rfc2560.txt</a>.
</p>
</dd>
<dt><span id="RIVESTCRL"></span>[RIVESTCRL]</dt>
<dd><p>R. L. Rivest, &quot;Can We Eliminate Certificate Revocation Lists?&quot;,
Proceedings of Financial Cryptography &rsquo;98; Springer Lecture Notes in
Computer Science No. 1465 (Rafael Hirschfeld, ed.), February 1998),
pages 178&ndash;183, available from
<a href="https://people.csail.mit.edu/rivest/Rivest-CanWeEliminateCertificateRevocationLists.pdf">https://people.csail.mit.edu/rivest/Rivest-CanWeEliminateCertificateRevocationLists.pdf</a>.
</p>
</dd>
</dl>

<hr>
<span id="Function-and-Data-Index"></span><div class="header">
<p>
Next: <a href="#Concept-Index" accesskey="n" rel="next">Concept Index</a>, Previous: <a href="#Bibliography" accesskey="p" rel="prev">Bibliography</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Function-and-Data-Index-1"></span><h2 class="unnumbered">Function and Data Index</h2>

<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Function-and-Data-Index_fn_letter-D"><b>D</b></a>
 &nbsp; 
<a class="summary-letter" href="#Function-and-Data-Index_fn_letter-G"><b>G</b></a>
 &nbsp; 
</td></tr></table>
<table class="index-fn" border="0">
<tr><td></td><th align="left">Index Entry</th><td>&nbsp;</td><th align="left"> Section</th></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Function-and-Data-Index_fn_letter-D">D</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-dane_005fcert_005ftype_005fname"><code>dane_cert_type_name</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DANE-API">DANE API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dane_005fcert_005fusage_005fname"><code>dane_cert_usage_name</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DANE-API">DANE API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dane_005fmatch_005ftype_005fname"><code>dane_match_type_name</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DANE-API">DANE API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dane_005fquery_005fdata"><code>dane_query_data</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DANE-API">DANE API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dane_005fquery_005fdeinit"><code>dane_query_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DANE-API">DANE API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dane_005fquery_005fentries"><code>dane_query_entries</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DANE-API">DANE API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dane_005fquery_005fstatus"><code>dane_query_status</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DANE-API">DANE API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dane_005fquery_005ftlsa"><code>dane_query_tlsa</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DANE-API">DANE API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dane_005fquery_005fto_005fraw_005ftlsa"><code>dane_query_to_raw_tlsa</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DANE-API">DANE API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dane_005fraw_005ftlsa"><code>dane_raw_tlsa</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DANE-API">DANE API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dane_005fstate_005fdeinit"><code>dane_state_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DANE-API">DANE API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dane_005fstate_005finit"><code>dane_state_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DANE-API">DANE API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dane_005fstate_005fset_005fdlv_005ffile"><code>dane_state_set_dlv_file</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DANE-API">DANE API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dane_005fstrerror"><code>dane_strerror</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DANE-API">DANE API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dane_005fverification_005fstatus_005fprint"><code>dane_verification_status_print</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DANE-API">DANE API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dane_005fverify_005fcrt"><code>dane_verify_crt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Certificate-verification">Certificate verification</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dane_005fverify_005fcrt-1"><code>dane_verify_crt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DANE-API">DANE API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dane_005fverify_005fcrt_005fraw"><code>dane_verify_crt_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DANE-API">DANE API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dane_005fverify_005fsession_005fcrt"><code>dane_verify_session_crt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#DANE-API">DANE API</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Function-and-Data-Index_fn_letter-G">G</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005faead_005fcipher_005fdecrypt"><code>gnutls_aead_cipher_decrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005faead_005fcipher_005fdecryptv2"><code>gnutls_aead_cipher_decryptv2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005faead_005fcipher_005fdeinit"><code>gnutls_aead_cipher_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005faead_005fcipher_005fencrypt"><code>gnutls_aead_cipher_encrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005faead_005fcipher_005fencryptv"><code>gnutls_aead_cipher_encryptv</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Symmetric-algorithms">Symmetric algorithms</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005faead_005fcipher_005fencryptv-1"><code>gnutls_aead_cipher_encryptv</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005faead_005fcipher_005fencryptv2"><code>gnutls_aead_cipher_encryptv2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005faead_005fcipher_005finit"><code>gnutls_aead_cipher_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005falert_005fget"><code>gnutls_alert_get</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Handling-alerts">Handling alerts</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005falert_005fget-1"><code>gnutls_alert_get</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005falert_005fget_005fname"><code>gnutls_alert_get_name</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Handling-alerts">Handling alerts</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005falert_005fget_005fname-1"><code>gnutls_alert_get_name</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005falert_005fget_005fstrname"><code>gnutls_alert_get_strname</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005falert_005fsend"><code>gnutls_alert_send</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Handling-alerts">Handling alerts</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005falert_005fsend-1"><code>gnutls_alert_send</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005falert_005fsend_005fappropriate"><code>gnutls_alert_send_appropriate</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005falpn_005fget_005fselected_005fprotocol"><code>gnutls_alpn_get_selected_protocol</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005falpn_005fset_005fprotocols"><code>gnutls_alpn_set_protocols</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fanon_005fallocate_005fclient_005fcredentials"><code>gnutls_anon_allocate_client_credentials</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fanon_005fallocate_005fserver_005fcredentials"><code>gnutls_anon_allocate_server_credentials</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fanon_005ffree_005fclient_005fcredentials"><code>gnutls_anon_free_client_credentials</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fanon_005ffree_005fserver_005fcredentials"><code>gnutls_anon_free_server_credentials</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fanon_005fset_005fparams_005ffunction"><code>gnutls_anon_set_params_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fanon_005fset_005fserver_005fdh_005fparams"><code>gnutls_anon_set_server_dh_params</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fanon_005fset_005fserver_005fknown_005fdh_005fparams"><code>gnutls_anon_set_server_known_dh_params</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fanon_005fset_005fserver_005fparams_005ffunction"><code>gnutls_anon_set_server_params_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fanti_005freplay_005fdeinit"><code>gnutls_anti_replay_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fanti_005freplay_005fenable"><code>gnutls_anti_replay_enable</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fanti_005freplay_005finit"><code>gnutls_anti_replay_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fanti_005freplay_005fset_005fadd_005ffunction"><code>gnutls_anti_replay_set_add_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fanti_005freplay_005fset_005fptr"><code>gnutls_anti_replay_set_ptr</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fanti_005freplay_005fset_005fwindow"><code>gnutls_anti_replay_set_window</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fauth_005fclient_005fget_005ftype"><code>gnutls_auth_client_get_type</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fauth_005fget_005ftype"><code>gnutls_auth_get_type</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fauth_005fserver_005fget_005ftype"><code>gnutls_auth_server_get_type</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fbase64_005fdecode2"><code>gnutls_base64_decode2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fbase64_005fencode2"><code>gnutls_base64_encode2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fbuffer_005fappend_005fdata"><code>gnutls_buffer_append_data</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fbye"><code>gnutls_bye</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-transfer-and-termination">Data transfer and termination</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fbye-1"><code>gnutls_bye</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005factivation_005ftime_005fpeers"><code>gnutls_certificate_activation_time_peers</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fallocate_005fcredentials"><code>gnutls_certificate_allocate_credentials</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fclient_005fget_005frequest_005fstatus"><code>gnutls_certificate_client_get_request_status</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fexpiration_005ftime_005fpeers"><code>gnutls_certificate_expiration_time_peers</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005ffree_005fcas"><code>gnutls_certificate_free_cas</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005ffree_005fca_005fnames"><code>gnutls_certificate_free_ca_names</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005ffree_005fcredentials"><code>gnutls_certificate_free_credentials</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005ffree_005fcrls"><code>gnutls_certificate_free_crls</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005ffree_005fkeys"><code>gnutls_certificate_free_keys</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fget_005fcrt_005fraw"><code>gnutls_certificate_get_crt_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fget_005fissuer"><code>gnutls_certificate_get_issuer</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fget_005focsp_005fexpiration"><code>gnutls_certificate_get_ocsp_expiration</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-stapling">OCSP stapling</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fget_005focsp_005fexpiration-1"><code>gnutls_certificate_get_ocsp_expiration</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fget_005fours"><code>gnutls_certificate_get_ours</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fget_005fpeers"><code>gnutls_certificate_get_peers</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fget_005fpeers_005fsubkey_005fid"><code>gnutls_certificate_get_peers_subkey_id</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fget_005ftrust_005flist"><code>gnutls_certificate_get_trust_list</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fget_005fverify_005fflags"><code>gnutls_certificate_get_verify_flags</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fget_005fx509_005fcrt"><code>gnutls_certificate_get_x509_crt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fget_005fx509_005fkey"><code>gnutls_certificate_get_x509_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fsend_005fx509_005frdn_005fsequence"><code>gnutls_certificate_send_x509_rdn_sequence</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Certificate-credentials">Certificate credentials</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fsend_005fx509_005frdn_005fsequence-1"><code>gnutls_certificate_send_x509_rdn_sequence</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fserver_005fset_005frequest"><code>gnutls_certificate_server_set_request</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Certificate-credentials">Certificate credentials</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fserver_005fset_005frequest-1"><code>gnutls_certificate_server_set_request</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fset_005fdh_005fparams"><code>gnutls_certificate_set_dh_params</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fset_005fflags"><code>gnutls_certificate_set_flags</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fset_005fkey"><code>gnutls_certificate_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Certificate-credentials">Certificate credentials</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fset_005fkey-1"><code>gnutls_certificate_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fset_005fknown_005fdh_005fparams"><code>gnutls_certificate_set_known_dh_params</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fset_005focsp_005fstatus_005frequest_005ffile"><code>gnutls_certificate_set_ocsp_status_request_file</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fset_005focsp_005fstatus_005frequest_005ffile2"><code>gnutls_certificate_set_ocsp_status_request_file2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fset_005focsp_005fstatus_005frequest_005ffunction"><code>gnutls_certificate_set_ocsp_status_request_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fset_005focsp_005fstatus_005frequest_005ffunction2"><code>gnutls_certificate_set_ocsp_status_request_function2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fset_005focsp_005fstatus_005frequest_005fmem"><code>gnutls_certificate_set_ocsp_status_request_mem</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fset_005fparams_005ffunction"><code>gnutls_certificate_set_params_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fset_005fpin_005ffunction"><code>gnutls_certificate_set_pin_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Certificate-credentials">Certificate credentials</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fset_005fpin_005ffunction-1"><code>gnutls_certificate_set_pin_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fset_005frawpk_005fkey_005ffile"><code>gnutls_certificate_set_rawpk_key_file</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fset_005frawpk_005fkey_005fmem"><code>gnutls_certificate_set_rawpk_key_mem</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fset_005fretrieve_005ffunction"><code>gnutls_certificate_set_retrieve_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fset_005fretrieve_005ffunction2"><code>gnutls_certificate_set_retrieve_function2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fset_005fretrieve_005ffunction3"><code>gnutls_certificate_set_retrieve_function3</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fset_005ftrust_005flist"><code>gnutls_certificate_set_trust_list</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fset_005fverify_005fflags"><code>gnutls_certificate_set_verify_flags</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fset_005fverify_005ffunction"><code>gnutls_certificate_set_verify_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fset_005fverify_005flimits"><code>gnutls_certificate_set_verify_limits</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fset_005fx509_005fcrl"><code>gnutls_certificate_set_x509_crl</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fset_005fx509_005fcrl_005ffile"><code>gnutls_certificate_set_x509_crl_file</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fset_005fx509_005fcrl_005fmem"><code>gnutls_certificate_set_x509_crl_mem</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fset_005fx509_005fkey"><code>gnutls_certificate_set_x509_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fset_005fx509_005fkey_005ffile"><code>gnutls_certificate_set_x509_key_file</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fset_005fx509_005fkey_005ffile2"><code>gnutls_certificate_set_x509_key_file2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fset_005fx509_005fkey_005fmem"><code>gnutls_certificate_set_x509_key_mem</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fset_005fx509_005fkey_005fmem2"><code>gnutls_certificate_set_x509_key_mem2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fset_005fx509_005fsimple_005fpkcs12_005ffile"><code>gnutls_certificate_set_x509_simple_pkcs12_file</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fset_005fx509_005fsimple_005fpkcs12_005fmem"><code>gnutls_certificate_set_x509_simple_pkcs12_mem</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fset_005fx509_005fsystem_005ftrust"><code>gnutls_certificate_set_x509_system_trust</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Certificate-credentials">Certificate credentials</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fset_005fx509_005fsystem_005ftrust-1"><code>gnutls_certificate_set_x509_system_trust</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fset_005fx509_005ftrust"><code>gnutls_certificate_set_x509_trust</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fset_005fx509_005ftrust_005fdir"><code>gnutls_certificate_set_x509_trust_dir</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fset_005fx509_005ftrust_005ffile"><code>gnutls_certificate_set_x509_trust_file</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fset_005fx509_005ftrust_005fmem"><code>gnutls_certificate_set_x509_trust_mem</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005ftype_005fget"><code>gnutls_certificate_type_get</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005ftype_005fget2"><code>gnutls_certificate_type_get2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005ftype_005fget_005fid"><code>gnutls_certificate_type_get_id</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005ftype_005fget_005fname"><code>gnutls_certificate_type_get_name</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005ftype_005flist"><code>gnutls_certificate_type_list</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fverification_005fstatus_005fprint"><code>gnutls_certificate_verification_status_print</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fverify_005fflags"><code>gnutls_certificate_verify_flags</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Verifying-a-certificate-in-the-context-of-TLS-session">Verifying a certificate in the context of TLS session</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fverify_005fflags-1"><code>gnutls_certificate_verify_flags</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Certificate-verification">Certificate verification</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fverify_005fpeers"><code>gnutls_certificate_verify_peers</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fverify_005fpeers2"><code>gnutls_certificate_verify_peers2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcertificate_005fverify_005fpeers3"><code>gnutls_certificate_verify_peers3</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcheck_005fversion"><code>gnutls_check_version</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcipher_005fadd_005fauth"><code>gnutls_cipher_add_auth</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcipher_005fdecrypt"><code>gnutls_cipher_decrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcipher_005fdecrypt2"><code>gnutls_cipher_decrypt2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcipher_005fdeinit"><code>gnutls_cipher_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcipher_005fencrypt"><code>gnutls_cipher_encrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcipher_005fencrypt2"><code>gnutls_cipher_encrypt2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcipher_005fget"><code>gnutls_cipher_get</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcipher_005fget_005fblock_005fsize"><code>gnutls_cipher_get_block_size</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcipher_005fget_005fid"><code>gnutls_cipher_get_id</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcipher_005fget_005fiv_005fsize"><code>gnutls_cipher_get_iv_size</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcipher_005fget_005fkey_005fsize"><code>gnutls_cipher_get_key_size</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcipher_005fget_005fname"><code>gnutls_cipher_get_name</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcipher_005fget_005ftag_005fsize"><code>gnutls_cipher_get_tag_size</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcipher_005finit"><code>gnutls_cipher_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcipher_005flist"><code>gnutls_cipher_list</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcipher_005fset_005fiv"><code>gnutls_cipher_set_iv</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcipher_005fsuite_005fget_005fname"><code>gnutls_cipher_suite_get_name</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcipher_005fsuite_005finfo"><code>gnutls_cipher_suite_info</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcipher_005ftag"><code>gnutls_cipher_tag</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcompression_005fget"><code>gnutls_compression_get</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Compatibility-API">Compatibility API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcompression_005fget_005fid"><code>gnutls_compression_get_id</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Compatibility-API">Compatibility API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcompression_005fget_005fname"><code>gnutls_compression_get_name</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Compatibility-API">Compatibility API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcompression_005flist"><code>gnutls_compression_list</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Compatibility-API">Compatibility API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcredentials_005fclear"><code>gnutls_credentials_clear</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcredentials_005fget"><code>gnutls_credentials_get</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcredentials_005fset"><code>gnutls_credentials_set</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Session-initialization">Session initialization</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcredentials_005fset-1"><code>gnutls_credentials_set</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcrypto_005fregister_005faead_005fcipher"><code>gnutls_crypto_register_aead_cipher</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Overriding-algorithms">Overriding algorithms</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcrypto_005fregister_005faead_005fcipher-1"><code>gnutls_crypto_register_aead_cipher</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcrypto_005fregister_005fcipher"><code>gnutls_crypto_register_cipher</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Overriding-algorithms">Overriding algorithms</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcrypto_005fregister_005fcipher-1"><code>gnutls_crypto_register_cipher</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcrypto_005fregister_005fdigest"><code>gnutls_crypto_register_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Overriding-algorithms">Overriding algorithms</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcrypto_005fregister_005fdigest-1"><code>gnutls_crypto_register_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcrypto_005fregister_005fmac"><code>gnutls_crypto_register_mac</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Overriding-algorithms">Overriding algorithms</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fcrypto_005fregister_005fmac-1"><code>gnutls_crypto_register_mac</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdb_005fcheck_005fentry"><code>gnutls_db_check_entry</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdb_005fcheck_005fentry_005fexpire_005ftime"><code>gnutls_db_check_entry_expire_time</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdb_005fcheck_005fentry_005ftime"><code>gnutls_db_check_entry_time</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdb_005fget_005fdefault_005fcache_005fexpiration"><code>gnutls_db_get_default_cache_expiration</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdb_005fget_005fptr"><code>gnutls_db_get_ptr</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdb_005fremove_005fsession"><code>gnutls_db_remove_session</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdb_005fset_005fcache_005fexpiration"><code>gnutls_db_set_cache_expiration</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdb_005fset_005fptr"><code>gnutls_db_set_ptr</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdb_005fset_005fremove_005ffunction"><code>gnutls_db_set_remove_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdb_005fset_005fretrieve_005ffunction"><code>gnutls_db_set_retrieve_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdb_005fset_005fstore_005ffunction"><code>gnutls_db_set_store_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdecode_005fber_005fdigest_005finfo"><code>gnutls_decode_ber_digest_info</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdecode_005fgost_005frs_005fvalue"><code>gnutls_decode_gost_rs_value</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdecode_005frs_005fvalue"><code>gnutls_decode_rs_value</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdeinit"><code>gnutls_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-transfer-and-termination">Data transfer and termination</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdeinit-1"><code>gnutls_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdh_005fget_005fgroup"><code>gnutls_dh_get_group</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdh_005fget_005fpeers_005fpublic_005fbits"><code>gnutls_dh_get_peers_public_bits</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdh_005fget_005fprime_005fbits"><code>gnutls_dh_get_prime_bits</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdh_005fget_005fpubkey"><code>gnutls_dh_get_pubkey</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdh_005fget_005fsecret_005fbits"><code>gnutls_dh_get_secret_bits</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdh_005fparams_005fcpy"><code>gnutls_dh_params_cpy</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdh_005fparams_005fdeinit"><code>gnutls_dh_params_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdh_005fparams_005fexport2_005fpkcs3"><code>gnutls_dh_params_export2_pkcs3</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdh_005fparams_005fexport_005fpkcs3"><code>gnutls_dh_params_export_pkcs3</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdh_005fparams_005fexport_005fraw"><code>gnutls_dh_params_export_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdh_005fparams_005fgenerate2"><code>gnutls_dh_params_generate2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdh_005fparams_005fimport_005fdsa"><code>gnutls_dh_params_import_dsa</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdh_005fparams_005fimport_005fpkcs3"><code>gnutls_dh_params_import_pkcs3</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdh_005fparams_005fimport_005fraw"><code>gnutls_dh_params_import_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdh_005fparams_005fimport_005fraw2"><code>gnutls_dh_params_import_raw2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdh_005fparams_005fimport_005fraw3"><code>gnutls_dh_params_import_raw3</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdh_005fparams_005finit"><code>gnutls_dh_params_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdh_005fset_005fprime_005fbits"><code>gnutls_dh_set_prime_bits</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdigest_005fget_005fid"><code>gnutls_digest_get_id</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdigest_005fget_005fname"><code>gnutls_digest_get_name</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdigest_005fget_005foid"><code>gnutls_digest_get_oid</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdigest_005flist"><code>gnutls_digest_list</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdtls_005fcookie_005fsend"><code>gnutls_dtls_cookie_send</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Datagram-TLS-API">Datagram TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdtls_005fcookie_005fverify"><code>gnutls_dtls_cookie_verify</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Datagram-TLS-API">Datagram TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdtls_005fget_005fdata_005fmtu"><code>gnutls_dtls_get_data_mtu</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Datagram-TLS-API">Datagram TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdtls_005fget_005fmtu"><code>gnutls_dtls_get_mtu</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Datagram-TLS-API">Datagram TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdtls_005fget_005ftimeout"><code>gnutls_dtls_get_timeout</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Setting-up-the-transport-layer">Setting up the transport layer</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdtls_005fget_005ftimeout-1"><code>gnutls_dtls_get_timeout</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Datagram-TLS-API">Datagram TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdtls_005fprestate_005fset"><code>gnutls_dtls_prestate_set</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Datagram-TLS-API">Datagram TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdtls_005fset_005fdata_005fmtu"><code>gnutls_dtls_set_data_mtu</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Datagram-TLS-API">Datagram TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdtls_005fset_005fmtu"><code>gnutls_dtls_set_mtu</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Datagram-TLS-API">Datagram TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdtls_005fset_005ftimeouts"><code>gnutls_dtls_set_timeouts</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Datagram-TLS-API">Datagram TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fecc_005fcurve_005fget"><code>gnutls_ecc_curve_get</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fecc_005fcurve_005fget_005fid"><code>gnutls_ecc_curve_get_id</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fecc_005fcurve_005fget_005fname"><code>gnutls_ecc_curve_get_name</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fecc_005fcurve_005fget_005foid"><code>gnutls_ecc_curve_get_oid</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fecc_005fcurve_005fget_005fpk"><code>gnutls_ecc_curve_get_pk</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fecc_005fcurve_005fget_005fsize"><code>gnutls_ecc_curve_get_size</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fecc_005fcurve_005flist"><code>gnutls_ecc_curve_list</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fencode_005fber_005fdigest_005finfo"><code>gnutls_encode_ber_digest_info</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fencode_005fgost_005frs_005fvalue"><code>gnutls_encode_gost_rs_value</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fencode_005frs_005fvalue"><code>gnutls_encode_rs_value</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005ferror_005fis_005ffatal"><code>gnutls_error_is_fatal</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-transfer-and-termination">Data transfer and termination</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005ferror_005fis_005ffatal-1"><code>gnutls_error_is_fatal</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005ferror_005fto_005falert"><code>gnutls_error_to_alert</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Handling-alerts">Handling alerts</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005ferror_005fto_005falert-1"><code>gnutls_error_to_alert</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fest_005frecord_005foverhead_005fsize"><code>gnutls_est_record_overhead_size</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fext_005fget_005fcurrent_005fmsg"><code>gnutls_ext_get_current_msg</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fext_005fget_005fdata"><code>gnutls_ext_get_data</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fext_005fget_005fname"><code>gnutls_ext_get_name</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fext_005fraw_005fparse"><code>gnutls_ext_raw_parse</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fext_005fregister"><code>gnutls_ext_register</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fext_005fset_005fdata"><code>gnutls_ext_set_data</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005ffingerprint"><code>gnutls_fingerprint</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005ffips140_005fmode_005fenabled"><code>gnutls_fips140_mode_enabled</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005ffips140_005fset_005fmode"><code>gnutls_fips140_set_mode</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fget_005fsystem_005fconfig_005ffile"><code>gnutls_get_system_config_file</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#System_002dwide-configuration-of-the-library">System-wide configuration of the library</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fget_005fsystem_005fconfig_005ffile-1"><code>gnutls_get_system_config_file</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fglobal_005fdeinit"><code>gnutls_global_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fglobal_005finit"><code>gnutls_global_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fglobal_005fset_005faudit_005flog_005ffunction"><code>gnutls_global_set_audit_log_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Debugging-and-auditing">Debugging and auditing</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fglobal_005fset_005faudit_005flog_005ffunction-1"><code>gnutls_global_set_audit_log_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fglobal_005fset_005flog_005ffunction"><code>gnutls_global_set_log_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fglobal_005fset_005flog_005flevel"><code>gnutls_global_set_log_level</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fglobal_005fset_005fmem_005ffunctions"><code>gnutls_global_set_mem_functions</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Compatibility-API">Compatibility API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fglobal_005fset_005fmutex"><code>gnutls_global_set_mutex</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fglobal_005fset_005ftime_005ffunction"><code>gnutls_global_set_time_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fgost_005fparamset_005fget_005fname"><code>gnutls_gost_paramset_get_name</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fgost_005fparamset_005fget_005foid"><code>gnutls_gost_paramset_get_oid</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fgroup_005fget"><code>gnutls_group_get</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fgroup_005fget_005fid"><code>gnutls_group_get_id</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fgroup_005fget_005fname"><code>gnutls_group_get_name</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fgroup_005flist"><code>gnutls_group_list</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fhandshake"><code>gnutls_handshake</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#TLS-handshake">TLS handshake</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fhandshake-1"><code>gnutls_handshake</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fhandshake_005fdescription_005fget_005fname"><code>gnutls_handshake_description_get_name</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fhandshake_005fget_005flast_005fin"><code>gnutls_handshake_get_last_in</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fhandshake_005fget_005flast_005fout"><code>gnutls_handshake_get_last_out</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fhandshake_005fset_005fhook_005ffunction"><code>gnutls_handshake_set_hook_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Virtual-hosts-and-credentials">Virtual hosts and credentials</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fhandshake_005fset_005fhook_005ffunction-1"><code>gnutls_handshake_set_hook_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fhandshake_005fset_005fmax_005fpacket_005flength"><code>gnutls_handshake_set_max_packet_length</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fhandshake_005fset_005fpost_005fclient_005fhello_005ffunction"><code>gnutls_handshake_set_post_client_hello_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fhandshake_005fset_005fprivate_005fextensions"><code>gnutls_handshake_set_private_extensions</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fhandshake_005fset_005frandom"><code>gnutls_handshake_set_random</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fhandshake_005fset_005ftimeout"><code>gnutls_handshake_set_timeout</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#TLS-handshake">TLS handshake</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fhandshake_005fset_005ftimeout-1"><code>gnutls_handshake_set_timeout</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fhash"><code>gnutls_hash</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fhash_005fcopy"><code>gnutls_hash_copy</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fhash_005fdeinit"><code>gnutls_hash_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fhash_005ffast"><code>gnutls_hash_fast</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fhash_005fget_005flen"><code>gnutls_hash_get_len</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fhash_005finit"><code>gnutls_hash_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fhash_005foutput"><code>gnutls_hash_output</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fheartbeat_005fallowed"><code>gnutls_heartbeat_allowed</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fheartbeat_005fenable"><code>gnutls_heartbeat_enable</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fheartbeat_005fget_005ftimeout"><code>gnutls_heartbeat_get_timeout</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fheartbeat_005fping"><code>gnutls_heartbeat_ping</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fheartbeat_005fpong"><code>gnutls_heartbeat_pong</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fheartbeat_005fset_005ftimeouts"><code>gnutls_heartbeat_set_timeouts</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fhex2bin"><code>gnutls_hex2bin</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fhex_005fdecode"><code>gnutls_hex_decode</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fhex_005fdecode2"><code>gnutls_hex_decode2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fhex_005fencode"><code>gnutls_hex_encode</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fhex_005fencode2"><code>gnutls_hex_encode2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fhmac"><code>gnutls_hmac</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fhmac_005fcopy"><code>gnutls_hmac_copy</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fhmac_005fdeinit"><code>gnutls_hmac_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fhmac_005ffast"><code>gnutls_hmac_fast</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fhmac_005fget_005flen"><code>gnutls_hmac_get_len</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fhmac_005finit"><code>gnutls_hmac_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fhmac_005foutput"><code>gnutls_hmac_output</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fhmac_005fset_005fnonce"><code>gnutls_hmac_set_nonce</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fidna_005fmap"><code>gnutls_idna_map</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fidna_005freverse_005fmap"><code>gnutls_idna_reverse_map</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005finit"><code>gnutls_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Session-initialization">Session initialization</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005finit-1"><code>gnutls_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fkey_005fgenerate"><code>gnutls_key_generate</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fkx_005fget"><code>gnutls_kx_get</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fkx_005fget_005fid"><code>gnutls_kx_get_id</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fkx_005fget_005fname"><code>gnutls_kx_get_name</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fkx_005flist"><code>gnutls_kx_list</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fload_005ffile"><code>gnutls_load_file</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fmac_005fget"><code>gnutls_mac_get</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fmac_005fget_005fid"><code>gnutls_mac_get_id</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fmac_005fget_005fkey_005fsize"><code>gnutls_mac_get_key_size</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fmac_005fget_005fname"><code>gnutls_mac_get_name</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fmac_005fget_005fnonce_005fsize"><code>gnutls_mac_get_nonce_size</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fmac_005flist"><code>gnutls_mac_list</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fmemcmp"><code>gnutls_memcmp</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fmemset"><code>gnutls_memset</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005focsp_005freq_005fadd_005fcert"><code>gnutls_ocsp_req_add_cert</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-API">OCSP API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005focsp_005freq_005fadd_005fcert_005fid"><code>gnutls_ocsp_req_add_cert_id</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-API">OCSP API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005focsp_005freq_005fdeinit"><code>gnutls_ocsp_req_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-API">OCSP API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005focsp_005freq_005fexport"><code>gnutls_ocsp_req_export</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-API">OCSP API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005focsp_005freq_005fget_005fcert_005fid"><code>gnutls_ocsp_req_get_cert_id</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-API">OCSP API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005focsp_005freq_005fget_005fextension"><code>gnutls_ocsp_req_get_extension</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-API">OCSP API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005focsp_005freq_005fget_005fnonce"><code>gnutls_ocsp_req_get_nonce</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-API">OCSP API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005focsp_005freq_005fget_005fversion"><code>gnutls_ocsp_req_get_version</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-API">OCSP API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005focsp_005freq_005fimport"><code>gnutls_ocsp_req_import</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-API">OCSP API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005focsp_005freq_005finit"><code>gnutls_ocsp_req_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-API">OCSP API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005focsp_005freq_005fprint"><code>gnutls_ocsp_req_print</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-API">OCSP API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005focsp_005freq_005frandomize_005fnonce"><code>gnutls_ocsp_req_randomize_nonce</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-API">OCSP API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005focsp_005freq_005fset_005fextension"><code>gnutls_ocsp_req_set_extension</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-API">OCSP API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005focsp_005freq_005fset_005fnonce"><code>gnutls_ocsp_req_set_nonce</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-API">OCSP API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005focsp_005fresp_005fcheck_005fcrt"><code>gnutls_ocsp_resp_check_crt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-API">OCSP API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005focsp_005fresp_005fdeinit"><code>gnutls_ocsp_resp_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-API">OCSP API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005focsp_005fresp_005fexport"><code>gnutls_ocsp_resp_export</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-API">OCSP API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005focsp_005fresp_005fexport2"><code>gnutls_ocsp_resp_export2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-API">OCSP API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005focsp_005fresp_005fget_005fcerts"><code>gnutls_ocsp_resp_get_certs</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-API">OCSP API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005focsp_005fresp_005fget_005fextension"><code>gnutls_ocsp_resp_get_extension</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-API">OCSP API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005focsp_005fresp_005fget_005fnonce"><code>gnutls_ocsp_resp_get_nonce</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-API">OCSP API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005focsp_005fresp_005fget_005fproduced"><code>gnutls_ocsp_resp_get_produced</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-API">OCSP API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005focsp_005fresp_005fget_005fresponder"><code>gnutls_ocsp_resp_get_responder</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-API">OCSP API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005focsp_005fresp_005fget_005fresponder2"><code>gnutls_ocsp_resp_get_responder2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-API">OCSP API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005focsp_005fresp_005fget_005fresponder_005fraw_005fid"><code>gnutls_ocsp_resp_get_responder_raw_id</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-API">OCSP API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005focsp_005fresp_005fget_005fresponse"><code>gnutls_ocsp_resp_get_response</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-API">OCSP API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005focsp_005fresp_005fget_005fsignature"><code>gnutls_ocsp_resp_get_signature</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-API">OCSP API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005focsp_005fresp_005fget_005fsignature_005falgorithm"><code>gnutls_ocsp_resp_get_signature_algorithm</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-API">OCSP API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005focsp_005fresp_005fget_005fsingle"><code>gnutls_ocsp_resp_get_single</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-certificate-status-checking">OCSP certificate status checking</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005focsp_005fresp_005fget_005fsingle-1"><code>gnutls_ocsp_resp_get_single</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-API">OCSP API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005focsp_005fresp_005fget_005fstatus"><code>gnutls_ocsp_resp_get_status</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-API">OCSP API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005focsp_005fresp_005fget_005fversion"><code>gnutls_ocsp_resp_get_version</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-API">OCSP API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005focsp_005fresp_005fimport"><code>gnutls_ocsp_resp_import</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-API">OCSP API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005focsp_005fresp_005fimport2"><code>gnutls_ocsp_resp_import2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-API">OCSP API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005focsp_005fresp_005finit"><code>gnutls_ocsp_resp_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-API">OCSP API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005focsp_005fresp_005flist_005fimport2"><code>gnutls_ocsp_resp_list_import2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-API">OCSP API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005focsp_005fresp_005fprint"><code>gnutls_ocsp_resp_print</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-API">OCSP API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005focsp_005fresp_005fverify"><code>gnutls_ocsp_resp_verify</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-API">OCSP API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005focsp_005fresp_005fverify_005fdirect"><code>gnutls_ocsp_resp_verify_direct</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-API">OCSP API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005focsp_005fstatus_005frequest_005fenable_005fclient"><code>gnutls_ocsp_status_request_enable_client</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005focsp_005fstatus_005frequest_005fget"><code>gnutls_ocsp_status_request_get</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005focsp_005fstatus_005frequest_005fget2"><code>gnutls_ocsp_status_request_get2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005focsp_005fstatus_005frequest_005fis_005fchecked"><code>gnutls_ocsp_status_request_is_checked</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005foid_005fto_005fdigest"><code>gnutls_oid_to_digest</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005foid_005fto_005fecc_005fcurve"><code>gnutls_oid_to_ecc_curve</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005foid_005fto_005fgost_005fparamset"><code>gnutls_oid_to_gost_paramset</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005foid_005fto_005fmac"><code>gnutls_oid_to_mac</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005foid_005fto_005fpk"><code>gnutls_oid_to_pk</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005foid_005fto_005fsign"><code>gnutls_oid_to_sign</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fopenpgp_005fprivkey_005fsign_005fhash"><code>gnutls_openpgp_privkey_sign_hash</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Compatibility-API">Compatibility API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fopenpgp_005fsend_005fcert"><code>gnutls_openpgp_send_cert</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpacket_005fdeinit"><code>gnutls_packet_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpacket_005fget"><code>gnutls_packet_get</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpcert_005fdeinit"><code>gnutls_pcert_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpcert_005fexport_005fopenpgp"><code>gnutls_pcert_export_openpgp</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpcert_005fexport_005fx509"><code>gnutls_pcert_export_x509</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpcert_005fimport_005fopenpgp"><code>gnutls_pcert_import_openpgp</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpcert_005fimport_005fopenpgp_005fraw"><code>gnutls_pcert_import_openpgp_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpcert_005fimport_005frawpk"><code>gnutls_pcert_import_rawpk</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpcert_005fimport_005frawpk_005fraw"><code>gnutls_pcert_import_rawpk_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpcert_005fimport_005fx509"><code>gnutls_pcert_import_x509</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpcert_005fimport_005fx509_005flist"><code>gnutls_pcert_import_x509_list</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpcert_005fimport_005fx509_005fraw"><code>gnutls_pcert_import_x509_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpcert_005flist_005fimport_005fx509_005ffile"><code>gnutls_pcert_list_import_x509_file</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpcert_005flist_005fimport_005fx509_005fraw"><code>gnutls_pcert_list_import_x509_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpem_005fbase64_005fdecode"><code>gnutls_pem_base64_decode</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpem_005fbase64_005fdecode2"><code>gnutls_pem_base64_decode2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpem_005fbase64_005fencode"><code>gnutls_pem_base64_encode</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpem_005fbase64_005fencode2"><code>gnutls_pem_base64_encode2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fperror"><code>gnutls_perror</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fadd_005fprovider"><code>gnutls_pkcs11_add_provider</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS11-Manual-Initialization">PKCS11 Manual Initialization</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fadd_005fprovider-1"><code>gnutls_pkcs11_add_provider</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fcopy_005fattached_005fextension"><code>gnutls_pkcs11_copy_attached_extension</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fcopy_005fpubkey"><code>gnutls_pkcs11_copy_pubkey</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fcopy_005fsecret_005fkey"><code>gnutls_pkcs11_copy_secret_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fcopy_005fx509_005fcrt"><code>gnutls_pkcs11_copy_x509_crt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fcopy_005fx509_005fcrt2"><code>gnutls_pkcs11_copy_x509_crt2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Writing-objects">Writing objects</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fcopy_005fx509_005fcrt2-1"><code>gnutls_pkcs11_copy_x509_crt2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fcopy_005fx509_005fprivkey"><code>gnutls_pkcs11_copy_x509_privkey</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fcopy_005fx509_005fprivkey2"><code>gnutls_pkcs11_copy_x509_privkey2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Writing-objects">Writing objects</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fcopy_005fx509_005fprivkey2-1"><code>gnutls_pkcs11_copy_x509_privkey2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fcrt_005fis_005fknown"><code>gnutls_pkcs11_crt_is_known</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fdeinit"><code>gnutls_pkcs11_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fdelete_005furl"><code>gnutls_pkcs11_delete_url</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Writing-objects">Writing objects</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fdelete_005furl-1"><code>gnutls_pkcs11_delete_url</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fget_005fpin_005ffunction"><code>gnutls_pkcs11_get_pin_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fget_005fraw_005fissuer"><code>gnutls_pkcs11_get_raw_issuer</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fget_005fraw_005fissuer_005fby_005fdn"><code>gnutls_pkcs11_get_raw_issuer_by_dn</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fget_005fraw_005fissuer_005fby_005fsubject_005fkey_005fid"><code>gnutls_pkcs11_get_raw_issuer_by_subject_key_id</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005finit"><code>gnutls_pkcs11_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS11-Manual-Initialization">PKCS11 Manual Initialization</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005finit-1"><code>gnutls_pkcs11_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fobj_005fdeinit"><code>gnutls_pkcs11_obj_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fobj_005fexport"><code>gnutls_pkcs11_obj_export</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fobj_005fexport2"><code>gnutls_pkcs11_obj_export2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fobj_005fexport3"><code>gnutls_pkcs11_obj_export3</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fobj_005fexport_005furl"><code>gnutls_pkcs11_obj_export_url</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fobj_005fflags_005fget_005fstr"><code>gnutls_pkcs11_obj_flags_get_str</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fobj_005fget_005fexts"><code>gnutls_pkcs11_obj_get_exts</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fobj_005fget_005fflags"><code>gnutls_pkcs11_obj_get_flags</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fobj_005fget_005finfo"><code>gnutls_pkcs11_obj_get_info</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reading-objects">Reading objects</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fobj_005fget_005finfo-1"><code>gnutls_pkcs11_obj_get_info</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fobj_005fget_005fptr"><code>gnutls_pkcs11_obj_get_ptr</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS11-Low-Level-Access">PKCS11 Low Level Access</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fobj_005fget_005fptr-1"><code>gnutls_pkcs11_obj_get_ptr</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fobj_005fget_005ftype"><code>gnutls_pkcs11_obj_get_type</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fobj_005fimport_005furl"><code>gnutls_pkcs11_obj_import_url</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fobj_005finit"><code>gnutls_pkcs11_obj_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fobj_005flist_005fimport_005furl3"><code>gnutls_pkcs11_obj_list_import_url3</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fobj_005flist_005fimport_005furl4"><code>gnutls_pkcs11_obj_list_import_url4</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fobj_005fset_005finfo"><code>gnutls_pkcs11_obj_set_info</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fobj_005fset_005fpin_005ffunction"><code>gnutls_pkcs11_obj_set_pin_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fprivkey_005fcpy"><code>gnutls_pkcs11_privkey_cpy</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fprivkey_005fdeinit"><code>gnutls_pkcs11_privkey_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fprivkey_005fexport_005fpubkey"><code>gnutls_pkcs11_privkey_export_pubkey</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fprivkey_005fexport_005furl"><code>gnutls_pkcs11_privkey_export_url</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fprivkey_005fgenerate"><code>gnutls_pkcs11_privkey_generate</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fprivkey_005fgenerate2"><code>gnutls_pkcs11_privkey_generate2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fprivkey_005fgenerate3"><code>gnutls_pkcs11_privkey_generate3</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fprivkey_005fget_005finfo"><code>gnutls_pkcs11_privkey_get_info</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fprivkey_005fget_005fpk_005falgorithm"><code>gnutls_pkcs11_privkey_get_pk_algorithm</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fprivkey_005fimport_005furl"><code>gnutls_pkcs11_privkey_import_url</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fprivkey_005finit"><code>gnutls_pkcs11_privkey_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fprivkey_005fset_005fpin_005ffunction"><code>gnutls_pkcs11_privkey_set_pin_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fprivkey_005fstatus"><code>gnutls_pkcs11_privkey_status</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005freinit"><code>gnutls_pkcs11_reinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fset_005fpin_005ffunction"><code>gnutls_pkcs11_set_pin_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005fset_005ftoken_005ffunction"><code>gnutls_pkcs11_set_token_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005ftoken_005fcheck_005fmechanism"><code>gnutls_pkcs11_token_check_mechanism</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005ftoken_005fget_005fflags"><code>gnutls_pkcs11_token_get_flags</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005ftoken_005fget_005finfo"><code>gnutls_pkcs11_token_get_info</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005ftoken_005fget_005fmechanism"><code>gnutls_pkcs11_token_get_mechanism</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005ftoken_005fget_005fptr"><code>gnutls_pkcs11_token_get_ptr</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS11-Low-Level-Access">PKCS11 Low Level Access</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005ftoken_005fget_005fptr-1"><code>gnutls_pkcs11_token_get_ptr</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005ftoken_005fget_005frandom"><code>gnutls_pkcs11_token_get_random</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005ftoken_005fget_005furl"><code>gnutls_pkcs11_token_get_url</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005ftoken_005finit"><code>gnutls_pkcs11_token_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005ftoken_005fset_005fpin"><code>gnutls_pkcs11_token_set_pin</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs11_005ftype_005fget_005fname"><code>gnutls_pkcs11_type_get_name</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs12_005fbag_005fdecrypt"><code>gnutls_pkcs12_bag_decrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-12-API">PKCS 12 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs12_005fbag_005fdeinit"><code>gnutls_pkcs12_bag_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-12-API">PKCS 12 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs12_005fbag_005fencrypt"><code>gnutls_pkcs12_bag_encrypt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-12-API">PKCS 12 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs12_005fbag_005fenc_005finfo"><code>gnutls_pkcs12_bag_enc_info</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-12-API">PKCS 12 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs12_005fbag_005fget_005fcount"><code>gnutls_pkcs12_bag_get_count</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-12-API">PKCS 12 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs12_005fbag_005fget_005fdata"><code>gnutls_pkcs12_bag_get_data</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-12-API">PKCS 12 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs12_005fbag_005fget_005ffriendly_005fname"><code>gnutls_pkcs12_bag_get_friendly_name</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-12-API">PKCS 12 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs12_005fbag_005fget_005fkey_005fid"><code>gnutls_pkcs12_bag_get_key_id</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-12-API">PKCS 12 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs12_005fbag_005fget_005ftype"><code>gnutls_pkcs12_bag_get_type</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-12-API">PKCS 12 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs12_005fbag_005finit"><code>gnutls_pkcs12_bag_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-12-API">PKCS 12 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs12_005fbag_005fset_005fcrl"><code>gnutls_pkcs12_bag_set_crl</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-12-API">PKCS 12 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs12_005fbag_005fset_005fcrt"><code>gnutls_pkcs12_bag_set_crt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-12-API">PKCS 12 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs12_005fbag_005fset_005fdata"><code>gnutls_pkcs12_bag_set_data</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-12-API">PKCS 12 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs12_005fbag_005fset_005ffriendly_005fname"><code>gnutls_pkcs12_bag_set_friendly_name</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-12-API">PKCS 12 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs12_005fbag_005fset_005fkey_005fid"><code>gnutls_pkcs12_bag_set_key_id</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-12-API">PKCS 12 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs12_005fbag_005fset_005fprivkey"><code>gnutls_pkcs12_bag_set_privkey</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-12-API">PKCS 12 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs12_005fdeinit"><code>gnutls_pkcs12_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-12-API">PKCS 12 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs12_005fexport"><code>gnutls_pkcs12_export</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-12-API">PKCS 12 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs12_005fexport2"><code>gnutls_pkcs12_export2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-12-API">PKCS 12 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs12_005fgenerate_005fmac"><code>gnutls_pkcs12_generate_mac</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-12-API">PKCS 12 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs12_005fgenerate_005fmac2"><code>gnutls_pkcs12_generate_mac2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-12-API">PKCS 12 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs12_005fget_005fbag"><code>gnutls_pkcs12_get_bag</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-12-API">PKCS 12 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs12_005fimport"><code>gnutls_pkcs12_import</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-12-API">PKCS 12 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs12_005finit"><code>gnutls_pkcs12_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-12-API">PKCS 12 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs12_005fmac_005finfo"><code>gnutls_pkcs12_mac_info</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-12-API">PKCS 12 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs12_005fset_005fbag"><code>gnutls_pkcs12_set_bag</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-12-API">PKCS 12 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs12_005fsimple_005fparse"><code>gnutls_pkcs12_simple_parse</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Managing-encrypted-keys">Managing encrypted keys</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs12_005fsimple_005fparse-1"><code>gnutls_pkcs12_simple_parse</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-12-API">PKCS 12 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs12_005fverify_005fmac"><code>gnutls_pkcs12_verify_mac</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-12-API">PKCS 12 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs7_005fadd_005fattr"><code>gnutls_pkcs7_add_attr</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-7-API">PKCS 7 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs7_005fattrs_005fdeinit"><code>gnutls_pkcs7_attrs_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-7-API">PKCS 7 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs7_005fdeinit"><code>gnutls_pkcs7_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-7-API">PKCS 7 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs7_005fdelete_005fcrl"><code>gnutls_pkcs7_delete_crl</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-7-API">PKCS 7 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs7_005fdelete_005fcrt"><code>gnutls_pkcs7_delete_crt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-7-API">PKCS 7 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs7_005fexport"><code>gnutls_pkcs7_export</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-7-API">PKCS 7 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs7_005fexport2"><code>gnutls_pkcs7_export2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-7-API">PKCS 7 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs7_005fget_005fattr"><code>gnutls_pkcs7_get_attr</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-7-API">PKCS 7 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs7_005fget_005fcrl_005fcount"><code>gnutls_pkcs7_get_crl_count</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-7-API">PKCS 7 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs7_005fget_005fcrl_005fraw"><code>gnutls_pkcs7_get_crl_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-7-API">PKCS 7 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs7_005fget_005fcrl_005fraw2"><code>gnutls_pkcs7_get_crl_raw2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-7-API">PKCS 7 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs7_005fget_005fcrt_005fcount"><code>gnutls_pkcs7_get_crt_count</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-7-API">PKCS 7 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs7_005fget_005fcrt_005fraw"><code>gnutls_pkcs7_get_crt_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-7-API">PKCS 7 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs7_005fget_005fcrt_005fraw2"><code>gnutls_pkcs7_get_crt_raw2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-7-API">PKCS 7 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs7_005fget_005fembedded_005fdata"><code>gnutls_pkcs7_get_embedded_data</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-7-API">PKCS 7 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs7_005fget_005fembedded_005fdata_005foid"><code>gnutls_pkcs7_get_embedded_data_oid</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-7-API">PKCS 7 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs7_005fget_005fsignature_005fcount"><code>gnutls_pkcs7_get_signature_count</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-7-API">PKCS 7 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs7_005fget_005fsignature_005finfo"><code>gnutls_pkcs7_get_signature_info</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-7-API">PKCS 7 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs7_005fimport"><code>gnutls_pkcs7_import</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-7-API">PKCS 7 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs7_005finit"><code>gnutls_pkcs7_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-7-API">PKCS 7 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs7_005fprint"><code>gnutls_pkcs7_print</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-7-API">PKCS 7 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs7_005fset_005fcrl"><code>gnutls_pkcs7_set_crl</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-7-API">PKCS 7 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs7_005fset_005fcrl_005fraw"><code>gnutls_pkcs7_set_crl_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-7-API">PKCS 7 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs7_005fset_005fcrt"><code>gnutls_pkcs7_set_crt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-7-API">PKCS 7 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs7_005fset_005fcrt_005fraw"><code>gnutls_pkcs7_set_crt_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-7-API">PKCS 7 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs7_005fsign"><code>gnutls_pkcs7_sign</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-Message-Syntax-_002f-PKCS7">Cryptographic Message Syntax / PKCS7</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs7_005fsign-1"><code>gnutls_pkcs7_sign</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-7-API">PKCS 7 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs7_005fsignature_005finfo_005fdeinit"><code>gnutls_pkcs7_signature_info_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-7-API">PKCS 7 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs7_005fverify"><code>gnutls_pkcs7_verify</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-7-API">PKCS 7 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs7_005fverify_005fdirect"><code>gnutls_pkcs7_verify_direct</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-7-API">PKCS 7 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs8_005finfo"><code>gnutls_pkcs8_info</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs_005fschema_005fget_005fname"><code>gnutls_pkcs_schema_get_name</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpkcs_005fschema_005fget_005foid"><code>gnutls_pkcs_schema_get_oid</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpk_005falgorithm_005fget_005fname"><code>gnutls_pk_algorithm_get_name</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpk_005fbits_005fto_005fsec_005fparam"><code>gnutls_pk_bits_to_sec_param</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Selecting-cryptographic-key-sizes">Selecting cryptographic key sizes</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpk_005fbits_005fto_005fsec_005fparam-1"><code>gnutls_pk_bits_to_sec_param</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpk_005fget_005fid"><code>gnutls_pk_get_id</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpk_005fget_005fname"><code>gnutls_pk_get_name</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpk_005fget_005foid"><code>gnutls_pk_get_oid</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpk_005flist"><code>gnutls_pk_list</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpk_005fto_005fsign"><code>gnutls_pk_to_sign</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprf"><code>gnutls_prf</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprf_005fearly"><code>gnutls_prf_early</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprf_005fraw"><code>gnutls_prf_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprf_005frfc5705"><code>gnutls_prf_rfc5705</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Deriving-keys-for-other-applications_002fprotocols">Deriving keys for other applications/protocols</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprf_005frfc5705-1"><code>gnutls_prf_rfc5705</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpriority_005fcertificate_005ftype_005flist"><code>gnutls_priority_certificate_type_list</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpriority_005fcertificate_005ftype_005flist2"><code>gnutls_priority_certificate_type_list2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpriority_005fcipher_005flist"><code>gnutls_priority_cipher_list</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpriority_005fcompression_005flist"><code>gnutls_priority_compression_list</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Compatibility-API">Compatibility API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpriority_005fdeinit"><code>gnutls_priority_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpriority_005fecc_005fcurve_005flist"><code>gnutls_priority_ecc_curve_list</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpriority_005fget_005fcipher_005fsuite_005findex"><code>gnutls_priority_get_cipher_suite_index</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpriority_005fgroup_005flist"><code>gnutls_priority_group_list</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpriority_005finit"><code>gnutls_priority_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpriority_005finit2"><code>gnutls_priority_init2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpriority_005fkx_005flist"><code>gnutls_priority_kx_list</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpriority_005fmac_005flist"><code>gnutls_priority_mac_list</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpriority_005fprotocol_005flist"><code>gnutls_priority_protocol_list</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpriority_005fset"><code>gnutls_priority_set</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpriority_005fset_005fdirect"><code>gnutls_priority_set_direct</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpriority_005fsign_005flist"><code>gnutls_priority_sign_list</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpriority_005fstring_005flist"><code>gnutls_priority_string_list</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fdecrypt_005fdata"><code>gnutls_privkey_decrypt_data</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Operations">Operations</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fdecrypt_005fdata-1"><code>gnutls_privkey_decrypt_data</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fdecrypt_005fdata2"><code>gnutls_privkey_decrypt_data2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fdeinit"><code>gnutls_privkey_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fexport_005fdsa_005fraw"><code>gnutls_privkey_export_dsa_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fexport_005fdsa_005fraw2"><code>gnutls_privkey_export_dsa_raw2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fexport_005fecc_005fraw"><code>gnutls_privkey_export_ecc_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fexport_005fecc_005fraw2"><code>gnutls_privkey_export_ecc_raw2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fexport_005fgost_005fraw2"><code>gnutls_privkey_export_gost_raw2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fexport_005fopenpgp"><code>gnutls_privkey_export_openpgp</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fexport_005fpkcs11"><code>gnutls_privkey_export_pkcs11</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fexport_005frsa_005fraw"><code>gnutls_privkey_export_rsa_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fexport_005frsa_005fraw2"><code>gnutls_privkey_export_rsa_raw2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fexport_005fx509"><code>gnutls_privkey_export_x509</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fgenerate"><code>gnutls_privkey_generate</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fgenerate2"><code>gnutls_privkey_generate2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Public-key-algorithms">Public key algorithms</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fgenerate2-1"><code>gnutls_privkey_generate2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fget_005fpk_005falgorithm"><code>gnutls_privkey_get_pk_algorithm</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fget_005fseed"><code>gnutls_privkey_get_seed</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fget_005fspki"><code>gnutls_privkey_get_spki</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fget_005ftype"><code>gnutls_privkey_get_type</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fimport_005fdsa_005fraw"><code>gnutls_privkey_import_dsa_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fimport_005fecc_005fraw"><code>gnutls_privkey_import_ecc_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fimport_005fext"><code>gnutls_privkey_import_ext</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fimport_005fext2"><code>gnutls_privkey_import_ext2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fimport_005fext3"><code>gnutls_privkey_import_ext3</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fimport_005fext4"><code>gnutls_privkey_import_ext4</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-private-keys">Abstract private keys</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fimport_005fext4-1"><code>gnutls_privkey_import_ext4</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fimport_005fgost_005fraw"><code>gnutls_privkey_import_gost_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fimport_005fopenpgp"><code>gnutls_privkey_import_openpgp</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fimport_005fopenpgp_005fraw"><code>gnutls_privkey_import_openpgp_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fimport_005fpkcs11"><code>gnutls_privkey_import_pkcs11</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fimport_005fpkcs11_005furl"><code>gnutls_privkey_import_pkcs11_url</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fimport_005frsa_005fraw"><code>gnutls_privkey_import_rsa_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fimport_005ftpm_005fraw"><code>gnutls_privkey_import_tpm_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fimport_005ftpm_005furl"><code>gnutls_privkey_import_tpm_url</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Using-keys">Using keys</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fimport_005ftpm_005furl-1"><code>gnutls_privkey_import_tpm_url</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fimport_005furl"><code>gnutls_privkey_import_url</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-private-keys">Abstract private keys</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fimport_005furl-1"><code>gnutls_privkey_import_url</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fimport_005fx509"><code>gnutls_privkey_import_x509</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fimport_005fx509_005fraw"><code>gnutls_privkey_import_x509_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Managing-encrypted-keys">Managing encrypted keys</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fimport_005fx509_005fraw-1"><code>gnutls_privkey_import_x509_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005finit"><code>gnutls_privkey_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fset_005fflags"><code>gnutls_privkey_set_flags</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fset_005fpin_005ffunction"><code>gnutls_privkey_set_pin_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fset_005fspki"><code>gnutls_privkey_set_spki</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fsign_005fdata"><code>gnutls_privkey_sign_data</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Operations">Operations</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fsign_005fdata-1"><code>gnutls_privkey_sign_data</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fsign_005fdata2"><code>gnutls_privkey_sign_data2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fsign_005fhash"><code>gnutls_privkey_sign_hash</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Operations">Operations</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fsign_005fhash-1"><code>gnutls_privkey_sign_hash</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fsign_005fhash2"><code>gnutls_privkey_sign_hash2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fstatus"><code>gnutls_privkey_status</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fverify_005fparams"><code>gnutls_privkey_verify_params</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprivkey_005fverify_005fseed"><code>gnutls_privkey_verify_seed</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprotocol_005fget_005fid"><code>gnutls_protocol_get_id</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprotocol_005fget_005fname"><code>gnutls_protocol_get_name</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprotocol_005fget_005fversion"><code>gnutls_protocol_get_version</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fprotocol_005flist"><code>gnutls_protocol_list</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpsk_005fallocate_005fclient_005fcredentials"><code>gnutls_psk_allocate_client_credentials</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpsk_005fallocate_005fserver_005fcredentials"><code>gnutls_psk_allocate_server_credentials</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpsk_005fclient_005fget_005fhint"><code>gnutls_psk_client_get_hint</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpsk_005ffree_005fclient_005fcredentials"><code>gnutls_psk_free_client_credentials</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpsk_005ffree_005fserver_005fcredentials"><code>gnutls_psk_free_server_credentials</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpsk_005fserver_005fget_005fusername"><code>gnutls_psk_server_get_username</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpsk_005fset_005fclient_005fcredentials"><code>gnutls_psk_set_client_credentials</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpsk_005fset_005fclient_005fcredentials_005ffunction"><code>gnutls_psk_set_client_credentials_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PSK-credentials">PSK credentials</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpsk_005fset_005fclient_005fcredentials_005ffunction-1"><code>gnutls_psk_set_client_credentials_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpsk_005fset_005fparams_005ffunction"><code>gnutls_psk_set_params_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpsk_005fset_005fserver_005fcredentials_005ffile"><code>gnutls_psk_set_server_credentials_file</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PSK-credentials">PSK credentials</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpsk_005fset_005fserver_005fcredentials_005ffile-1"><code>gnutls_psk_set_server_credentials_file</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpsk_005fset_005fserver_005fcredentials_005ffunction"><code>gnutls_psk_set_server_credentials_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpsk_005fset_005fserver_005fcredentials_005fhint"><code>gnutls_psk_set_server_credentials_hint</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpsk_005fset_005fserver_005fdh_005fparams"><code>gnutls_psk_set_server_dh_params</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpsk_005fset_005fserver_005fknown_005fdh_005fparams"><code>gnutls_psk_set_server_known_dh_params</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpsk_005fset_005fserver_005fparams_005ffunction"><code>gnutls_psk_set_server_params_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005fdeinit"><code>gnutls_pubkey_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005fencrypt_005fdata"><code>gnutls_pubkey_encrypt_data</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Operations">Operations</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005fencrypt_005fdata-1"><code>gnutls_pubkey_encrypt_data</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005fexport"><code>gnutls_pubkey_export</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005fexport2"><code>gnutls_pubkey_export2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-public-keys">Abstract public keys</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005fexport2-1"><code>gnutls_pubkey_export2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005fexport_005fdsa_005fraw"><code>gnutls_pubkey_export_dsa_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005fexport_005fdsa_005fraw2"><code>gnutls_pubkey_export_dsa_raw2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005fexport_005fecc_005fraw"><code>gnutls_pubkey_export_ecc_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005fexport_005fecc_005fraw2"><code>gnutls_pubkey_export_ecc_raw2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005fexport_005fecc_005fx962"><code>gnutls_pubkey_export_ecc_x962</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005fexport_005fgost_005fraw2"><code>gnutls_pubkey_export_gost_raw2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005fexport_005frsa_005fraw"><code>gnutls_pubkey_export_rsa_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005fexport_005frsa_005fraw2"><code>gnutls_pubkey_export_rsa_raw2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005fget_005fkey_005fid"><code>gnutls_pubkey_get_key_id</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005fget_005fkey_005fusage"><code>gnutls_pubkey_get_key_usage</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005fget_005fopenpgp_005fkey_005fid"><code>gnutls_pubkey_get_openpgp_key_id</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005fget_005fpk_005falgorithm"><code>gnutls_pubkey_get_pk_algorithm</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005fget_005fpreferred_005fhash_005falgorithm"><code>gnutls_pubkey_get_preferred_hash_algorithm</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005fget_005fspki"><code>gnutls_pubkey_get_spki</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005fimport"><code>gnutls_pubkey_import</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005fimport_005fdsa_005fraw"><code>gnutls_pubkey_import_dsa_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005fimport_005fecc_005fraw"><code>gnutls_pubkey_import_ecc_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005fimport_005fecc_005fx962"><code>gnutls_pubkey_import_ecc_x962</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005fimport_005fgost_005fraw"><code>gnutls_pubkey_import_gost_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005fimport_005fopenpgp"><code>gnutls_pubkey_import_openpgp</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005fimport_005fopenpgp_005fraw"><code>gnutls_pubkey_import_openpgp_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005fimport_005fpkcs11"><code>gnutls_pubkey_import_pkcs11</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005fimport_005fprivkey"><code>gnutls_pubkey_import_privkey</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005fimport_005frsa_005fraw"><code>gnutls_pubkey_import_rsa_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005fimport_005ftpm_005fraw"><code>gnutls_pubkey_import_tpm_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005fimport_005ftpm_005furl"><code>gnutls_pubkey_import_tpm_url</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Using-keys">Using keys</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005fimport_005ftpm_005furl-1"><code>gnutls_pubkey_import_tpm_url</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005fimport_005furl"><code>gnutls_pubkey_import_url</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005fimport_005fx509"><code>gnutls_pubkey_import_x509</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005fimport_005fx509_005fcrq"><code>gnutls_pubkey_import_x509_crq</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005fimport_005fx509_005fraw"><code>gnutls_pubkey_import_x509_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005finit"><code>gnutls_pubkey_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005fprint"><code>gnutls_pubkey_print</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005fset_005fkey_005fusage"><code>gnutls_pubkey_set_key_usage</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005fset_005fpin_005ffunction"><code>gnutls_pubkey_set_pin_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005fset_005fspki"><code>gnutls_pubkey_set_spki</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005fverify_005fdata2"><code>gnutls_pubkey_verify_data2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Operations">Operations</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005fverify_005fdata2-1"><code>gnutls_pubkey_verify_data2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005fverify_005fhash2"><code>gnutls_pubkey_verify_hash2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Operations">Operations</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005fverify_005fhash2-1"><code>gnutls_pubkey_verify_hash2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fpubkey_005fverify_005fparams"><code>gnutls_pubkey_verify_params</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005frandom_005fart"><code>gnutls_random_art</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005frange_005fsplit"><code>gnutls_range_split</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005freauth"><code>gnutls_reauth</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005frecord_005fcan_005fuse_005flength_005fhiding"><code>gnutls_record_can_use_length_hiding</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005frecord_005fcheck_005fcorked"><code>gnutls_record_check_corked</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005frecord_005fcheck_005fpending"><code>gnutls_record_check_pending</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-transfer-and-termination">Data transfer and termination</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005frecord_005fcheck_005fpending-1"><code>gnutls_record_check_pending</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005frecord_005fcork"><code>gnutls_record_cork</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Buffered-data-transfer">Buffered data transfer</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005frecord_005fcork-1"><code>gnutls_record_cork</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005frecord_005fdisable_005fpadding"><code>gnutls_record_disable_padding</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005frecord_005fdiscard_005fqueued"><code>gnutls_record_discard_queued</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005frecord_005fget_005fdirection"><code>gnutls_record_get_direction</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Asynchronous-operation">Asynchronous operation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005frecord_005fget_005fdirection-1"><code>gnutls_record_get_direction</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005frecord_005fget_005fdiscarded"><code>gnutls_record_get_discarded</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Datagram-TLS-API">Datagram TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005frecord_005fget_005fmax_005fearly_005fdata_005fsize"><code>gnutls_record_get_max_early_data_size</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005frecord_005fget_005fmax_005fsize"><code>gnutls_record_get_max_size</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005frecord_005fget_005fstate"><code>gnutls_record_get_state</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005frecord_005foverhead_005fsize"><code>gnutls_record_overhead_size</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005frecord_005frecv"><code>gnutls_record_recv</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-transfer-and-termination">Data transfer and termination</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005frecord_005frecv-1"><code>gnutls_record_recv</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005frecord_005frecv_005fearly_005fdata"><code>gnutls_record_recv_early_data</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005frecord_005frecv_005fpacket"><code>gnutls_record_recv_packet</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005frecord_005frecv_005fseq"><code>gnutls_record_recv_seq</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-transfer-and-termination">Data transfer and termination</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005frecord_005frecv_005fseq-1"><code>gnutls_record_recv_seq</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005frecord_005fsend"><code>gnutls_record_send</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-transfer-and-termination">Data transfer and termination</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005frecord_005fsend-1"><code>gnutls_record_send</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005frecord_005fsend2"><code>gnutls_record_send2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#On-Record-Padding">On Record Padding</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005frecord_005fsend2-1"><code>gnutls_record_send2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005frecord_005fsend_005fearly_005fdata"><code>gnutls_record_send_early_data</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005frecord_005fsend_005frange"><code>gnutls_record_send_range</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005frecord_005fset_005fmax_005fearly_005fdata_005fsize"><code>gnutls_record_set_max_early_data_size</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005frecord_005fset_005fmax_005frecv_005fsize"><code>gnutls_record_set_max_recv_size</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005frecord_005fset_005fmax_005fsize"><code>gnutls_record_set_max_size</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005frecord_005fset_005fstate"><code>gnutls_record_set_state</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005frecord_005fset_005ftimeout"><code>gnutls_record_set_timeout</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005frecord_005funcork"><code>gnutls_record_uncork</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Buffered-data-transfer">Buffered data transfer</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005frecord_005funcork-1"><code>gnutls_record_uncork</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fregister_005fcustom_005furl"><code>gnutls_register_custom_url</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Application_002dspecific-keys">Application-specific keys</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fregister_005fcustom_005furl-1"><code>gnutls_register_custom_url</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005frehandshake"><code>gnutls_rehandshake</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#TLS-1_002e2-re_002dauthentication">TLS 1.2 re-authentication</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005frehandshake-1"><code>gnutls_rehandshake</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005frnd"><code>gnutls_rnd</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Random-number-generation">Random number generation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005frnd-1"><code>gnutls_rnd</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005frnd_005frefresh"><code>gnutls_rnd_refresh</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-API">Cryptographic API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsafe_005frenegotiation_005fstatus"><code>gnutls_safe_renegotiation_status</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#TLS-1_002e2-re_002dauthentication">TLS 1.2 re-authentication</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsafe_005frenegotiation_005fstatus-1"><code>gnutls_safe_renegotiation_status</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsec_005fparam_005fget_005fname"><code>gnutls_sec_param_get_name</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsec_005fparam_005fto_005fpk_005fbits"><code>gnutls_sec_param_to_pk_bits</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Selecting-cryptographic-key-sizes">Selecting cryptographic key sizes</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsec_005fparam_005fto_005fpk_005fbits-1"><code>gnutls_sec_param_to_pk_bits</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsec_005fparam_005fto_005fsymmetric_005fbits"><code>gnutls_sec_param_to_symmetric_bits</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fserver_005fname_005fget"><code>gnutls_server_name_get</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fserver_005fname_005fset"><code>gnutls_server_name_set</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsession_005fchannel_005fbinding"><code>gnutls_session_channel_binding</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsession_005fenable_005fcompatibility_005fmode"><code>gnutls_session_enable_compatibility_mode</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsession_005fetm_005fstatus"><code>gnutls_session_etm_status</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsession_005fext_005fmaster_005fsecret_005fstatus"><code>gnutls_session_ext_master_secret_status</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsession_005fext_005fregister"><code>gnutls_session_ext_register</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsession_005fforce_005fvalid"><code>gnutls_session_force_valid</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsession_005fget_005fdata"><code>gnutls_session_get_data</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsession_005fget_005fdata2"><code>gnutls_session_get_data2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsession_005fget_005fdesc"><code>gnutls_session_get_desc</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsession_005fget_005fflags"><code>gnutls_session_get_flags</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsession_005fget_005fid"><code>gnutls_session_get_id</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsession_005fget_005fid2"><code>gnutls_session_get_id2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Session-resumption">Session resumption</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsession_005fget_005fid2-1"><code>gnutls_session_get_id2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsession_005fget_005fmaster_005fsecret"><code>gnutls_session_get_master_secret</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsession_005fget_005fptr"><code>gnutls_session_get_ptr</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsession_005fget_005frandom"><code>gnutls_session_get_random</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsession_005fget_005fverify_005fcert_005fstatus"><code>gnutls_session_get_verify_cert_status</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsession_005fis_005fresumed"><code>gnutls_session_is_resumed</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Session-resumption">Session resumption</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsession_005fis_005fresumed-1"><code>gnutls_session_is_resumed</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsession_005fkey_005fupdate"><code>gnutls_session_key_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsession_005fresumption_005frequested"><code>gnutls_session_resumption_requested</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Session-resumption">Session resumption</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsession_005fresumption_005frequested-1"><code>gnutls_session_resumption_requested</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsession_005fset_005fdata"><code>gnutls_session_set_data</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsession_005fset_005fid"><code>gnutls_session_set_id</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsession_005fset_005fpremaster"><code>gnutls_session_set_premaster</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsession_005fset_005fptr"><code>gnutls_session_set_ptr</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsession_005fset_005fverify_005fcert"><code>gnutls_session_set_verify_cert</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Certificate-credentials">Certificate credentials</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsession_005fset_005fverify_005fcert-1"><code>gnutls_session_set_verify_cert</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsession_005fset_005fverify_005fcert2"><code>gnutls_session_set_verify_cert2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsession_005fset_005fverify_005ffunction"><code>gnutls_session_set_verify_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsession_005fsupplemental_005fregister"><code>gnutls_session_supplemental_register</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsession_005fticket_005fenable_005fclient"><code>gnutls_session_ticket_enable_client</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsession_005fticket_005fenable_005fserver"><code>gnutls_session_ticket_enable_server</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Session-resumption">Session resumption</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsession_005fticket_005fenable_005fserver-1"><code>gnutls_session_ticket_enable_server</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsession_005fticket_005fkey_005fgenerate"><code>gnutls_session_ticket_key_generate</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Session-resumption">Session resumption</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsession_005fticket_005fkey_005fgenerate-1"><code>gnutls_session_ticket_key_generate</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsession_005fticket_005fsend"><code>gnutls_session_ticket_send</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Session-resumption">Session resumption</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsession_005fticket_005fsend-1"><code>gnutls_session_ticket_send</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fset_005fdefault_005fpriority"><code>gnutls_set_default_priority</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fset_005fdefault_005fpriority_005fappend"><code>gnutls_set_default_priority_append</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsign_005falgorithm_005fget"><code>gnutls_sign_algorithm_get</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsign_005falgorithm_005fget_005fclient"><code>gnutls_sign_algorithm_get_client</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsign_005falgorithm_005fget_005frequested"><code>gnutls_sign_algorithm_get_requested</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsign_005fget_005fhash_005falgorithm"><code>gnutls_sign_get_hash_algorithm</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsign_005fget_005fid"><code>gnutls_sign_get_id</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsign_005fget_005fname"><code>gnutls_sign_get_name</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsign_005fget_005foid"><code>gnutls_sign_get_oid</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsign_005fget_005fpk_005falgorithm"><code>gnutls_sign_get_pk_algorithm</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsign_005fis_005fsecure"><code>gnutls_sign_is_secure</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsign_005fis_005fsecure2"><code>gnutls_sign_is_secure2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsign_005flist"><code>gnutls_sign_list</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsign_005fsupports_005fpk_005falgorithm"><code>gnutls_sign_supports_pk_algorithm</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsrp_005fallocate_005fclient_005fcredentials"><code>gnutls_srp_allocate_client_credentials</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsrp_005fallocate_005fserver_005fcredentials"><code>gnutls_srp_allocate_server_credentials</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsrp_005fbase64_005fdecode"><code>gnutls_srp_base64_decode</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsrp_005fbase64_005fdecode2"><code>gnutls_srp_base64_decode2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsrp_005fbase64_005fencode"><code>gnutls_srp_base64_encode</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsrp_005fbase64_005fencode2"><code>gnutls_srp_base64_encode2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsrp_005ffree_005fclient_005fcredentials"><code>gnutls_srp_free_client_credentials</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsrp_005ffree_005fserver_005fcredentials"><code>gnutls_srp_free_server_credentials</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsrp_005fserver_005fget_005fusername"><code>gnutls_srp_server_get_username</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsrp_005fset_005fclient_005fcredentials"><code>gnutls_srp_set_client_credentials</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsrp_005fset_005fclient_005fcredentials_005ffunction"><code>gnutls_srp_set_client_credentials_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#SRP-credentials">SRP credentials</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsrp_005fset_005fclient_005fcredentials_005ffunction-1"><code>gnutls_srp_set_client_credentials_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsrp_005fset_005fprime_005fbits"><code>gnutls_srp_set_prime_bits</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsrp_005fset_005fserver_005fcredentials_005ffile"><code>gnutls_srp_set_server_credentials_file</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#SRP-credentials">SRP credentials</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsrp_005fset_005fserver_005fcredentials_005ffile-1"><code>gnutls_srp_set_server_credentials_file</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsrp_005fset_005fserver_005fcredentials_005ffunction"><code>gnutls_srp_set_server_credentials_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#SRP-credentials">SRP credentials</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsrp_005fset_005fserver_005fcredentials_005ffunction-1"><code>gnutls_srp_set_server_credentials_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsrp_005fset_005fserver_005ffake_005fsalt_005fseed"><code>gnutls_srp_set_server_fake_salt_seed</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsrp_005fverifier"><code>gnutls_srp_verifier</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Authentication-using-SRP">Authentication using SRP</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsrp_005fverifier-1"><code>gnutls_srp_verifier</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsrtp_005fget_005fkeys"><code>gnutls_srtp_get_keys</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#SRTP">SRTP</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsrtp_005fget_005fkeys-1"><code>gnutls_srtp_get_keys</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsrtp_005fget_005fmki"><code>gnutls_srtp_get_mki</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsrtp_005fget_005fprofile_005fid"><code>gnutls_srtp_get_profile_id</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsrtp_005fget_005fprofile_005fname"><code>gnutls_srtp_get_profile_name</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsrtp_005fget_005fselected_005fprofile"><code>gnutls_srtp_get_selected_profile</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsrtp_005fset_005fmki"><code>gnutls_srtp_set_mki</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsrtp_005fset_005fprofile"><code>gnutls_srtp_set_profile</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsrtp_005fset_005fprofile_005fdirect"><code>gnutls_srtp_set_profile_direct</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fstore_005fcommitment"><code>gnutls_store_commitment</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Certificate-verification">Certificate verification</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fstore_005fcommitment-1"><code>gnutls_store_commitment</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fstore_005fpubkey"><code>gnutls_store_pubkey</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Certificate-verification">Certificate verification</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fstore_005fpubkey-1"><code>gnutls_store_pubkey</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fstrerror"><code>gnutls_strerror</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fstrerror_005fname"><code>gnutls_strerror_name</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsubject_005falt_005fnames_005fdeinit"><code>gnutls_subject_alt_names_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsubject_005falt_005fnames_005fget"><code>gnutls_subject_alt_names_get</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsubject_005falt_005fnames_005finit"><code>gnutls_subject_alt_names_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsubject_005falt_005fnames_005fset"><code>gnutls_subject_alt_names_set</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsupplemental_005fget_005fname"><code>gnutls_supplemental_get_name</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsupplemental_005frecv"><code>gnutls_supplemental_recv</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsupplemental_005fregister"><code>gnutls_supplemental_register</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsupplemental_005fsend"><code>gnutls_supplemental_send</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsystem_005fkey_005fadd_005fx509"><code>gnutls_system_key_add_x509</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsystem_005fkey_005fdelete"><code>gnutls_system_key_delete</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsystem_005fkey_005fiter_005fdeinit"><code>gnutls_system_key_iter_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsystem_005fkey_005fiter_005fget_005finfo"><code>gnutls_system_key_iter_get_info</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Application_002dspecific-keys">Application-specific keys</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsystem_005fkey_005fiter_005fget_005finfo-1"><code>gnutls_system_key_iter_get_info</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fsystem_005frecv_005ftimeout"><code>gnutls_system_recv_timeout</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005ftdb_005fdeinit"><code>gnutls_tdb_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005ftdb_005finit"><code>gnutls_tdb_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005ftdb_005fset_005fstore_005fcommitment_005ffunc"><code>gnutls_tdb_set_store_commitment_func</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005ftdb_005fset_005fstore_005ffunc"><code>gnutls_tdb_set_store_func</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005ftdb_005fset_005fverify_005ffunc"><code>gnutls_tdb_set_verify_func</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005ftpm_005fget_005fregistered"><code>gnutls_tpm_get_registered</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#TPM-API">TPM API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005ftpm_005fkey_005flist_005fdeinit"><code>gnutls_tpm_key_list_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#TPM-API">TPM API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005ftpm_005fkey_005flist_005fget_005furl"><code>gnutls_tpm_key_list_get_url</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#TPM-API">TPM API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005ftpm_005fprivkey_005fdelete"><code>gnutls_tpm_privkey_delete</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Key-generation">Key generation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005ftpm_005fprivkey_005fdelete-1"><code>gnutls_tpm_privkey_delete</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Using-keys">Using keys</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005ftpm_005fprivkey_005fdelete-2"><code>gnutls_tpm_privkey_delete</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#TPM-API">TPM API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005ftpm_005fprivkey_005fgenerate"><code>gnutls_tpm_privkey_generate</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Key-generation">Key generation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005ftpm_005fprivkey_005fgenerate-1"><code>gnutls_tpm_privkey_generate</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#TPM-API">TPM API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005ftransport_005fget_005fint"><code>gnutls_transport_get_int</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005ftransport_005fget_005fint2"><code>gnutls_transport_get_int2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005ftransport_005fget_005fptr"><code>gnutls_transport_get_ptr</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005ftransport_005fget_005fptr2"><code>gnutls_transport_get_ptr2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005ftransport_005fset_005ferrno"><code>gnutls_transport_set_errno</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Setting-up-the-transport-layer">Setting up the transport layer</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005ftransport_005fset_005ferrno-1"><code>gnutls_transport_set_errno</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005ftransport_005fset_005ferrno_005ffunction"><code>gnutls_transport_set_errno_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005ftransport_005fset_005ffastopen"><code>gnutls_transport_set_fastopen</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reducing-round_002dtrips">Reducing round-trips</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005ftransport_005fset_005ffastopen-1"><code>gnutls_transport_set_fastopen</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Socket-specific-API">Socket specific API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005ftransport_005fset_005fint"><code>gnutls_transport_set_int</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005ftransport_005fset_005fint2"><code>gnutls_transport_set_int2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005ftransport_005fset_005fptr"><code>gnutls_transport_set_ptr</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005ftransport_005fset_005fptr2"><code>gnutls_transport_set_ptr2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005ftransport_005fset_005fpull_005ffunction"><code>gnutls_transport_set_pull_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Setting-up-the-transport-layer">Setting up the transport layer</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005ftransport_005fset_005fpull_005ffunction-1"><code>gnutls_transport_set_pull_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005ftransport_005fset_005fpull_005ftimeout_005ffunction"><code>gnutls_transport_set_pull_timeout_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Setting-up-the-transport-layer">Setting up the transport layer</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005ftransport_005fset_005fpull_005ftimeout_005ffunction-1"><code>gnutls_transport_set_pull_timeout_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Setting-up-the-transport-layer">Setting up the transport layer</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005ftransport_005fset_005fpull_005ftimeout_005ffunction-2"><code>gnutls_transport_set_pull_timeout_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005ftransport_005fset_005fpush_005ffunction"><code>gnutls_transport_set_push_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Setting-up-the-transport-layer">Setting up the transport layer</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005ftransport_005fset_005fpush_005ffunction-1"><code>gnutls_transport_set_push_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005ftransport_005fset_005fvec_005fpush_005ffunction"><code>gnutls_transport_set_vec_push_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Setting-up-the-transport-layer">Setting up the transport layer</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005ftransport_005fset_005fvec_005fpush_005ffunction-1"><code>gnutls_transport_set_vec_push_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005furl_005fis_005fsupported"><code>gnutls_url_is_supported</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-public-keys">Abstract public keys</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005furl_005fis_005fsupported-1"><code>gnutls_url_is_supported</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005futf8_005fpassword_005fnormalize"><code>gnutls_utf8_password_normalize</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fverify_005fstored_005fpubkey"><code>gnutls_verify_stored_pubkey</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Certificate-verification">Certificate verification</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fverify_005fstored_005fpubkey-1"><code>gnutls_verify_stored_pubkey</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Core-TLS-API">Core TLS API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005faia_005fdeinit"><code>gnutls_x509_aia_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005faia_005fget"><code>gnutls_x509_aia_get</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005faia_005finit"><code>gnutls_x509_aia_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005faia_005fset"><code>gnutls_x509_aia_set</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005faki_005fdeinit"><code>gnutls_x509_aki_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005faki_005fget_005fcert_005fissuer"><code>gnutls_x509_aki_get_cert_issuer</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005faki_005fget_005fid"><code>gnutls_x509_aki_get_id</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005faki_005finit"><code>gnutls_x509_aki_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005faki_005fset_005fcert_005fissuer"><code>gnutls_x509_aki_set_cert_issuer</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005faki_005fset_005fid"><code>gnutls_x509_aki_set_id</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcidr_005fto_005frfc5280"><code>gnutls_x509_cidr_to_rfc5280</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fcheck_005fissuer"><code>gnutls_x509_crl_check_issuer</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fdeinit"><code>gnutls_x509_crl_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fdist_005fpoints_005fdeinit"><code>gnutls_x509_crl_dist_points_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fdist_005fpoints_005fget"><code>gnutls_x509_crl_dist_points_get</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fdist_005fpoints_005finit"><code>gnutls_x509_crl_dist_points_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fdist_005fpoints_005fset"><code>gnutls_x509_crl_dist_points_set</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fexport"><code>gnutls_x509_crl_export</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fexport2"><code>gnutls_x509_crl_export2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fget_005fauthority_005fkey_005fgn_005fserial"><code>gnutls_x509_crl_get_authority_key_gn_serial</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fget_005fauthority_005fkey_005fid"><code>gnutls_x509_crl_get_authority_key_id</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fget_005fcrt_005fcount"><code>gnutls_x509_crl_get_crt_count</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fget_005fcrt_005fserial"><code>gnutls_x509_crl_get_crt_serial</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKIX-certificate-revocation-lists">PKIX certificate revocation lists</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fget_005fcrt_005fserial-1"><code>gnutls_x509_crl_get_crt_serial</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fget_005fdn_005foid"><code>gnutls_x509_crl_get_dn_oid</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fget_005fextension_005fdata"><code>gnutls_x509_crl_get_extension_data</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fget_005fextension_005fdata2"><code>gnutls_x509_crl_get_extension_data2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fget_005fextension_005finfo"><code>gnutls_x509_crl_get_extension_info</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fget_005fextension_005foid"><code>gnutls_x509_crl_get_extension_oid</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fget_005fissuer_005fdn"><code>gnutls_x509_crl_get_issuer_dn</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fget_005fissuer_005fdn2"><code>gnutls_x509_crl_get_issuer_dn2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fget_005fissuer_005fdn3"><code>gnutls_x509_crl_get_issuer_dn3</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fget_005fissuer_005fdn_005fby_005foid"><code>gnutls_x509_crl_get_issuer_dn_by_oid</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fget_005fnext_005fupdate"><code>gnutls_x509_crl_get_next_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fget_005fnumber"><code>gnutls_x509_crl_get_number</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fget_005fraw_005fissuer_005fdn"><code>gnutls_x509_crl_get_raw_issuer_dn</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fget_005fsignature"><code>gnutls_x509_crl_get_signature</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fget_005fsignature_005falgorithm"><code>gnutls_x509_crl_get_signature_algorithm</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fget_005fsignature_005foid"><code>gnutls_x509_crl_get_signature_oid</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fget_005fthis_005fupdate"><code>gnutls_x509_crl_get_this_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fget_005fversion"><code>gnutls_x509_crl_get_version</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fimport"><code>gnutls_x509_crl_import</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005finit"><code>gnutls_x509_crl_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fiter_005fcrt_005fserial"><code>gnutls_x509_crl_iter_crt_serial</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fiter_005fdeinit"><code>gnutls_x509_crl_iter_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005flist_005fimport"><code>gnutls_x509_crl_list_import</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005flist_005fimport2"><code>gnutls_x509_crl_list_import2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fprint"><code>gnutls_x509_crl_print</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fprivkey_005fsign"><code>gnutls_x509_crl_privkey_sign</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKIX-certificate-revocation-lists">PKIX certificate revocation lists</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fprivkey_005fsign-1"><code>gnutls_x509_crl_privkey_sign</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fset_005fauthority_005fkey_005fid"><code>gnutls_x509_crl_set_authority_key_id</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fset_005fcrt"><code>gnutls_x509_crl_set_crt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fset_005fcrt_005fserial"><code>gnutls_x509_crl_set_crt_serial</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fset_005fnext_005fupdate"><code>gnutls_x509_crl_set_next_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fset_005fnumber"><code>gnutls_x509_crl_set_number</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fset_005fthis_005fupdate"><code>gnutls_x509_crl_set_this_update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fset_005fversion"><code>gnutls_x509_crl_set_version</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fsign"><code>gnutls_x509_crl_sign</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fsign2"><code>gnutls_x509_crl_sign2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKIX-certificate-revocation-lists">PKIX certificate revocation lists</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fsign2-1"><code>gnutls_x509_crl_sign2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrl_005fverify"><code>gnutls_x509_crl_verify</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fdeinit"><code>gnutls_x509_crq_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fexport"><code>gnutls_x509_crq_export</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fexport2"><code>gnutls_x509_crq_export2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fget_005fattribute_005fby_005foid"><code>gnutls_x509_crq_get_attribute_by_oid</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fget_005fattribute_005fdata"><code>gnutls_x509_crq_get_attribute_data</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fget_005fattribute_005finfo"><code>gnutls_x509_crq_get_attribute_info</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fget_005fbasic_005fconstraints"><code>gnutls_x509_crq_get_basic_constraints</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fget_005fchallenge_005fpassword"><code>gnutls_x509_crq_get_challenge_password</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fget_005fdn"><code>gnutls_x509_crq_get_dn</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fget_005fdn2"><code>gnutls_x509_crq_get_dn2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fget_005fdn3"><code>gnutls_x509_crq_get_dn3</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fget_005fdn_005fby_005foid"><code>gnutls_x509_crq_get_dn_by_oid</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fget_005fdn_005foid"><code>gnutls_x509_crq_get_dn_oid</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fget_005fextension_005fby_005foid"><code>gnutls_x509_crq_get_extension_by_oid</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fget_005fextension_005fby_005foid2"><code>gnutls_x509_crq_get_extension_by_oid2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fget_005fextension_005fdata"><code>gnutls_x509_crq_get_extension_data</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fget_005fextension_005fdata2"><code>gnutls_x509_crq_get_extension_data2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fget_005fextension_005finfo"><code>gnutls_x509_crq_get_extension_info</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fget_005fkey_005fid"><code>gnutls_x509_crq_get_key_id</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fget_005fkey_005fpurpose_005foid"><code>gnutls_x509_crq_get_key_purpose_oid</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fget_005fkey_005frsa_005fraw"><code>gnutls_x509_crq_get_key_rsa_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fget_005fkey_005fusage"><code>gnutls_x509_crq_get_key_usage</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fget_005fpk_005falgorithm"><code>gnutls_x509_crq_get_pk_algorithm</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fget_005fpk_005foid"><code>gnutls_x509_crq_get_pk_oid</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fget_005fprivate_005fkey_005fusage_005fperiod"><code>gnutls_x509_crq_get_private_key_usage_period</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fget_005fsignature_005falgorithm"><code>gnutls_x509_crq_get_signature_algorithm</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fget_005fsignature_005foid"><code>gnutls_x509_crq_get_signature_oid</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fget_005fspki"><code>gnutls_x509_crq_get_spki</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fget_005fsubject_005falt_005fname"><code>gnutls_x509_crq_get_subject_alt_name</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fget_005fsubject_005falt_005fothername_005foid"><code>gnutls_x509_crq_get_subject_alt_othername_oid</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fget_005ftlsfeatures"><code>gnutls_x509_crq_get_tlsfeatures</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fget_005fversion"><code>gnutls_x509_crq_get_version</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fimport"><code>gnutls_x509_crq_import</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005finit"><code>gnutls_x509_crq_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fprint"><code>gnutls_x509_crq_print</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fprivkey_005fsign"><code>gnutls_x509_crq_privkey_sign</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fset_005fattribute_005fby_005foid"><code>gnutls_x509_crq_set_attribute_by_oid</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fset_005fbasic_005fconstraints"><code>gnutls_x509_crq_set_basic_constraints</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fset_005fchallenge_005fpassword"><code>gnutls_x509_crq_set_challenge_password</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fset_005fdn"><code>gnutls_x509_crq_set_dn</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fset_005fdn_005fby_005foid"><code>gnutls_x509_crq_set_dn_by_oid</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fset_005fextension_005fby_005foid"><code>gnutls_x509_crq_set_extension_by_oid</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fset_005fkey"><code>gnutls_x509_crq_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-10-certificate-requests">PKCS 10 certificate requests</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fset_005fkey-1"><code>gnutls_x509_crq_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fset_005fkey_005fpurpose_005foid"><code>gnutls_x509_crq_set_key_purpose_oid</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fset_005fkey_005frsa_005fraw"><code>gnutls_x509_crq_set_key_rsa_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fset_005fkey_005fusage"><code>gnutls_x509_crq_set_key_usage</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fset_005fprivate_005fkey_005fusage_005fperiod"><code>gnutls_x509_crq_set_private_key_usage_period</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fset_005fpubkey"><code>gnutls_x509_crq_set_pubkey</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Operations">Operations</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fset_005fpubkey-1"><code>gnutls_x509_crq_set_pubkey</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fset_005fspki"><code>gnutls_x509_crq_set_spki</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fset_005fsubject_005falt_005fname"><code>gnutls_x509_crq_set_subject_alt_name</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fset_005fsubject_005falt_005fothername"><code>gnutls_x509_crq_set_subject_alt_othername</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fset_005ftlsfeatures"><code>gnutls_x509_crq_set_tlsfeatures</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fset_005fversion"><code>gnutls_x509_crq_set_version</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fsign"><code>gnutls_x509_crq_sign</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fsign2"><code>gnutls_x509_crq_sign2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-10-certificate-requests">PKCS 10 certificate requests</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fsign2-1"><code>gnutls_x509_crq_sign2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrq_005fverify"><code>gnutls_x509_crq_verify</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fcheck_005femail"><code>gnutls_x509_crt_check_email</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fcheck_005fhostname"><code>gnutls_x509_crt_check_hostname</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fcheck_005fhostname2"><code>gnutls_x509_crt_check_hostname2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fcheck_005fip"><code>gnutls_x509_crt_check_ip</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fcheck_005fissuer"><code>gnutls_x509_crt_check_issuer</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fcheck_005fkey_005fpurpose"><code>gnutls_x509_crt_check_key_purpose</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fcheck_005frevocation"><code>gnutls_x509_crt_check_revocation</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fcpy_005fcrl_005fdist_005fpoints"><code>gnutls_x509_crt_cpy_crl_dist_points</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fdeinit"><code>gnutls_x509_crt_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fequals"><code>gnutls_x509_crt_equals</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fequals2"><code>gnutls_x509_crt_equals2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fexport"><code>gnutls_x509_crt_export</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fexport2"><code>gnutls_x509_crt_export2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005factivation_005ftime"><code>gnutls_x509_crt_get_activation_time</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fauthority_005finfo_005faccess"><code>gnutls_x509_crt_get_authority_info_access</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fauthority_005fkey_005fgn_005fserial"><code>gnutls_x509_crt_get_authority_key_gn_serial</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fauthority_005fkey_005fid"><code>gnutls_x509_crt_get_authority_key_id</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fbasic_005fconstraints"><code>gnutls_x509_crt_get_basic_constraints</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fca_005fstatus"><code>gnutls_x509_crt_get_ca_status</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fcrl_005fdist_005fpoints"><code>gnutls_x509_crt_get_crl_dist_points</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fdn"><code>gnutls_x509_crt_get_dn</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fdn2"><code>gnutls_x509_crt_get_dn2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X_002e509-distinguished-names">X.509 distinguished names</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fdn2-1"><code>gnutls_x509_crt_get_dn2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fdn3"><code>gnutls_x509_crt_get_dn3</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fdn_005fby_005foid"><code>gnutls_x509_crt_get_dn_by_oid</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fdn_005foid"><code>gnutls_x509_crt_get_dn_oid</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fexpiration_005ftime"><code>gnutls_x509_crt_get_expiration_time</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fextension_005fby_005foid"><code>gnutls_x509_crt_get_extension_by_oid</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fextension_005fby_005foid2"><code>gnutls_x509_crt_get_extension_by_oid2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fextension_005fdata"><code>gnutls_x509_crt_get_extension_data</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fextension_005fdata2"><code>gnutls_x509_crt_get_extension_data2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fextension_005finfo"><code>gnutls_x509_crt_get_extension_info</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fextension_005foid"><code>gnutls_x509_crt_get_extension_oid</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005ffingerprint"><code>gnutls_x509_crt_get_fingerprint</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005finhibit_005fanypolicy"><code>gnutls_x509_crt_get_inhibit_anypolicy</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fissuer"><code>gnutls_x509_crt_get_issuer</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fissuer_005falt_005fname"><code>gnutls_x509_crt_get_issuer_alt_name</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fissuer_005falt_005fname2"><code>gnutls_x509_crt_get_issuer_alt_name2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fissuer_005falt_005fothername_005foid"><code>gnutls_x509_crt_get_issuer_alt_othername_oid</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fissuer_005fdn"><code>gnutls_x509_crt_get_issuer_dn</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fissuer_005fdn2"><code>gnutls_x509_crt_get_issuer_dn2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fissuer_005fdn3"><code>gnutls_x509_crt_get_issuer_dn3</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fissuer_005fdn_005fby_005foid"><code>gnutls_x509_crt_get_issuer_dn_by_oid</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fissuer_005fdn_005foid"><code>gnutls_x509_crt_get_issuer_dn_oid</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fissuer_005funique_005fid"><code>gnutls_x509_crt_get_issuer_unique_id</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fkey_005fid"><code>gnutls_x509_crt_get_key_id</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X_002e509-public-and-private-keys">X.509 public and private keys</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fkey_005fid-1"><code>gnutls_x509_crt_get_key_id</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fkey_005fpurpose_005foid"><code>gnutls_x509_crt_get_key_purpose_oid</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fkey_005fusage"><code>gnutls_x509_crt_get_key_usage</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fname_005fconstraints"><code>gnutls_x509_crt_get_name_constraints</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fpk_005falgorithm"><code>gnutls_x509_crt_get_pk_algorithm</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fpk_005fdsa_005fraw"><code>gnutls_x509_crt_get_pk_dsa_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fpk_005fecc_005fraw"><code>gnutls_x509_crt_get_pk_ecc_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fpk_005fgost_005fraw"><code>gnutls_x509_crt_get_pk_gost_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fpk_005foid"><code>gnutls_x509_crt_get_pk_oid</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fpk_005frsa_005fraw"><code>gnutls_x509_crt_get_pk_rsa_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fpolicy"><code>gnutls_x509_crt_get_policy</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fpreferred_005fhash_005falgorithm"><code>gnutls_x509_crt_get_preferred_hash_algorithm</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Compatibility-API">Compatibility API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fprivate_005fkey_005fusage_005fperiod"><code>gnutls_x509_crt_get_private_key_usage_period</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fproxy"><code>gnutls_x509_crt_get_proxy</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fraw_005fdn"><code>gnutls_x509_crt_get_raw_dn</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fraw_005fissuer_005fdn"><code>gnutls_x509_crt_get_raw_issuer_dn</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fserial"><code>gnutls_x509_crt_get_serial</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fsignature"><code>gnutls_x509_crt_get_signature</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fsignature_005falgorithm"><code>gnutls_x509_crt_get_signature_algorithm</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fsignature_005foid"><code>gnutls_x509_crt_get_signature_oid</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fspki"><code>gnutls_x509_crt_get_spki</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fsubject"><code>gnutls_x509_crt_get_subject</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fsubject_005falt_005fname"><code>gnutls_x509_crt_get_subject_alt_name</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fsubject_005falt_005fname2"><code>gnutls_x509_crt_get_subject_alt_name2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fsubject_005falt_005fothername_005foid"><code>gnutls_x509_crt_get_subject_alt_othername_oid</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fsubject_005fkey_005fid"><code>gnutls_x509_crt_get_subject_key_id</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fsubject_005funique_005fid"><code>gnutls_x509_crt_get_subject_unique_id</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005ftlsfeatures"><code>gnutls_x509_crt_get_tlsfeatures</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fget_005fversion"><code>gnutls_x509_crt_get_version</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fimport"><code>gnutls_x509_crt_import</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fimport_005fpkcs11"><code>gnutls_x509_crt_import_pkcs11</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fimport_005furl"><code>gnutls_x509_crt_import_url</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005finit"><code>gnutls_x509_crt_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005flist_005fimport"><code>gnutls_x509_crt_list_import</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005flist_005fimport2"><code>gnutls_x509_crt_list_import2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005flist_005fimport_005fpkcs11"><code>gnutls_x509_crt_list_import_pkcs11</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-11-API">PKCS 11 API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005flist_005fimport_005furl"><code>gnutls_x509_crt_list_import_url</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005flist_005fverify"><code>gnutls_x509_crt_list_verify</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fprint"><code>gnutls_x509_crt_print</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fprivkey_005fsign"><code>gnutls_x509_crt_privkey_sign</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fset_005factivation_005ftime"><code>gnutls_x509_crt_set_activation_time</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fset_005fauthority_005finfo_005faccess"><code>gnutls_x509_crt_set_authority_info_access</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fset_005fauthority_005fkey_005fid"><code>gnutls_x509_crt_set_authority_key_id</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fset_005fbasic_005fconstraints"><code>gnutls_x509_crt_set_basic_constraints</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fset_005fca_005fstatus"><code>gnutls_x509_crt_set_ca_status</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fset_005fcrl_005fdist_005fpoints"><code>gnutls_x509_crt_set_crl_dist_points</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fset_005fcrl_005fdist_005fpoints2"><code>gnutls_x509_crt_set_crl_dist_points2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fset_005fcrq"><code>gnutls_x509_crt_set_crq</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fset_005fcrq_005fextensions"><code>gnutls_x509_crt_set_crq_extensions</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fset_005fcrq_005fextension_005fby_005foid"><code>gnutls_x509_crt_set_crq_extension_by_oid</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fset_005fdn"><code>gnutls_x509_crt_set_dn</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fset_005fdn_005fby_005foid"><code>gnutls_x509_crt_set_dn_by_oid</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fset_005fexpiration_005ftime"><code>gnutls_x509_crt_set_expiration_time</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fset_005fextension_005fby_005foid"><code>gnutls_x509_crt_set_extension_by_oid</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fset_005fflags"><code>gnutls_x509_crt_set_flags</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fset_005finhibit_005fanypolicy"><code>gnutls_x509_crt_set_inhibit_anypolicy</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fset_005fissuer_005falt_005fname"><code>gnutls_x509_crt_set_issuer_alt_name</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fset_005fissuer_005falt_005fothername"><code>gnutls_x509_crt_set_issuer_alt_othername</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fset_005fissuer_005fdn"><code>gnutls_x509_crt_set_issuer_dn</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fset_005fissuer_005fdn_005fby_005foid"><code>gnutls_x509_crt_set_issuer_dn_by_oid</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fset_005fissuer_005funique_005fid"><code>gnutls_x509_crt_set_issuer_unique_id</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fset_005fkey"><code>gnutls_x509_crt_set_key</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fset_005fkey_005fpurpose_005foid"><code>gnutls_x509_crt_set_key_purpose_oid</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fset_005fkey_005fusage"><code>gnutls_x509_crt_set_key_usage</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fset_005fname_005fconstraints"><code>gnutls_x509_crt_set_name_constraints</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fset_005fpin_005ffunction"><code>gnutls_x509_crt_set_pin_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fset_005fpolicy"><code>gnutls_x509_crt_set_policy</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fset_005fprivate_005fkey_005fusage_005fperiod"><code>gnutls_x509_crt_set_private_key_usage_period</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fset_005fproxy"><code>gnutls_x509_crt_set_proxy</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fset_005fproxy_005fdn"><code>gnutls_x509_crt_set_proxy_dn</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fset_005fpubkey"><code>gnutls_x509_crt_set_pubkey</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Operations">Operations</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fset_005fpubkey-1"><code>gnutls_x509_crt_set_pubkey</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-API">Abstract key API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fset_005fserial"><code>gnutls_x509_crt_set_serial</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fset_005fspki"><code>gnutls_x509_crt_set_spki</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fset_005fsubject_005falternative_005fname"><code>gnutls_x509_crt_set_subject_alternative_name</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fset_005fsubject_005falt_005fname"><code>gnutls_x509_crt_set_subject_alt_name</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fset_005fsubject_005falt_005fothername"><code>gnutls_x509_crt_set_subject_alt_othername</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fset_005fsubject_005fkey_005fid"><code>gnutls_x509_crt_set_subject_key_id</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fset_005fsubject_005funique_005fid"><code>gnutls_x509_crt_set_subject_unique_id</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fset_005ftlsfeatures"><code>gnutls_x509_crt_set_tlsfeatures</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fset_005fversion"><code>gnutls_x509_crt_set_version</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fsign"><code>gnutls_x509_crt_sign</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fsign2"><code>gnutls_x509_crt_sign2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fverify"><code>gnutls_x509_crt_verify</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fcrt_005fverify_005fdata2"><code>gnutls_x509_crt_verify_data2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fdn_005fdeinit"><code>gnutls_x509_dn_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fdn_005fexport"><code>gnutls_x509_dn_export</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fdn_005fexport2"><code>gnutls_x509_dn_export2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fdn_005fget_005frdn_005fava"><code>gnutls_x509_dn_get_rdn_ava</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X_002e509-distinguished-names">X.509 distinguished names</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fdn_005fget_005frdn_005fava-1"><code>gnutls_x509_dn_get_rdn_ava</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fdn_005fget_005fstr"><code>gnutls_x509_dn_get_str</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fdn_005fget_005fstr2"><code>gnutls_x509_dn_get_str2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fdn_005fimport"><code>gnutls_x509_dn_import</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fdn_005finit"><code>gnutls_x509_dn_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fdn_005foid_005fknown"><code>gnutls_x509_dn_oid_known</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fdn_005foid_005fname"><code>gnutls_x509_dn_oid_name</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fdn_005fset_005fstr"><code>gnutls_x509_dn_set_str</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fext_005fdeinit"><code>gnutls_x509_ext_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fext_005fexport_005faia"><code>gnutls_x509_ext_export_aia</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fext_005fexport_005fauthority_005fkey_005fid"><code>gnutls_x509_ext_export_authority_key_id</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fext_005fexport_005fbasic_005fconstraints"><code>gnutls_x509_ext_export_basic_constraints</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fext_005fexport_005fcrl_005fdist_005fpoints"><code>gnutls_x509_ext_export_crl_dist_points</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fext_005fexport_005finhibit_005fanypolicy"><code>gnutls_x509_ext_export_inhibit_anypolicy</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fext_005fexport_005fkey_005fpurposes"><code>gnutls_x509_ext_export_key_purposes</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fext_005fexport_005fkey_005fusage"><code>gnutls_x509_ext_export_key_usage</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fext_005fexport_005fname_005fconstraints"><code>gnutls_x509_ext_export_name_constraints</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fext_005fexport_005fpolicies"><code>gnutls_x509_ext_export_policies</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fext_005fexport_005fprivate_005fkey_005fusage_005fperiod"><code>gnutls_x509_ext_export_private_key_usage_period</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fext_005fexport_005fproxy"><code>gnutls_x509_ext_export_proxy</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fext_005fexport_005fsubject_005falt_005fnames"><code>gnutls_x509_ext_export_subject_alt_names</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fext_005fexport_005fsubject_005fkey_005fid"><code>gnutls_x509_ext_export_subject_key_id</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fext_005fexport_005ftlsfeatures"><code>gnutls_x509_ext_export_tlsfeatures</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fext_005fimport_005faia"><code>gnutls_x509_ext_import_aia</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fext_005fimport_005fauthority_005fkey_005fid"><code>gnutls_x509_ext_import_authority_key_id</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fext_005fimport_005fbasic_005fconstraints"><code>gnutls_x509_ext_import_basic_constraints</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fext_005fimport_005fcrl_005fdist_005fpoints"><code>gnutls_x509_ext_import_crl_dist_points</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fext_005fimport_005finhibit_005fanypolicy"><code>gnutls_x509_ext_import_inhibit_anypolicy</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fext_005fimport_005fkey_005fpurposes"><code>gnutls_x509_ext_import_key_purposes</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fext_005fimport_005fkey_005fusage"><code>gnutls_x509_ext_import_key_usage</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fext_005fimport_005fname_005fconstraints"><code>gnutls_x509_ext_import_name_constraints</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fext_005fimport_005fpolicies"><code>gnutls_x509_ext_import_policies</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fext_005fimport_005fprivate_005fkey_005fusage_005fperiod"><code>gnutls_x509_ext_import_private_key_usage_period</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fext_005fimport_005fproxy"><code>gnutls_x509_ext_import_proxy</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fext_005fimport_005fsubject_005falt_005fnames"><code>gnutls_x509_ext_import_subject_alt_names</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fext_005fimport_005fsubject_005fkey_005fid"><code>gnutls_x509_ext_import_subject_key_id</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fext_005fimport_005ftlsfeatures"><code>gnutls_x509_ext_import_tlsfeatures</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fext_005fprint"><code>gnutls_x509_ext_print</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fkey_005fpurpose_005fdeinit"><code>gnutls_x509_key_purpose_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fkey_005fpurpose_005fget"><code>gnutls_x509_key_purpose_get</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fkey_005fpurpose_005finit"><code>gnutls_x509_key_purpose_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fkey_005fpurpose_005fset"><code>gnutls_x509_key_purpose_set</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fname_005fconstraints_005fadd_005fexcluded"><code>gnutls_x509_name_constraints_add_excluded</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fname_005fconstraints_005fadd_005fpermitted"><code>gnutls_x509_name_constraints_add_permitted</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fname_005fconstraints_005fcheck"><code>gnutls_x509_name_constraints_check</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fname_005fconstraints_005fcheck_005fcrt"><code>gnutls_x509_name_constraints_check_crt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fname_005fconstraints_005fdeinit"><code>gnutls_x509_name_constraints_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fname_005fconstraints_005fget_005fexcluded"><code>gnutls_x509_name_constraints_get_excluded</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fname_005fconstraints_005fget_005fpermitted"><code>gnutls_x509_name_constraints_get_permitted</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fname_005fconstraints_005finit"><code>gnutls_x509_name_constraints_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fothername_005fto_005fvirtual"><code>gnutls_x509_othername_to_virtual</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fpolicies_005fdeinit"><code>gnutls_x509_policies_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fpolicies_005fget"><code>gnutls_x509_policies_get</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fpolicies_005finit"><code>gnutls_x509_policies_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fpolicies_005fset"><code>gnutls_x509_policies_set</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fpolicy_005frelease"><code>gnutls_x509_policy_release</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fprivkey_005fcpy"><code>gnutls_x509_privkey_cpy</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fprivkey_005fdeinit"><code>gnutls_x509_privkey_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fprivkey_005fexport"><code>gnutls_x509_privkey_export</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fprivkey_005fexport2"><code>gnutls_x509_privkey_export2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fprivkey_005fexport2_005fpkcs8"><code>gnutls_x509_privkey_export2_pkcs8</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fprivkey_005fexport_005fdsa_005fraw"><code>gnutls_x509_privkey_export_dsa_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fprivkey_005fexport_005fecc_005fraw"><code>gnutls_x509_privkey_export_ecc_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fprivkey_005fexport_005fgost_005fraw"><code>gnutls_x509_privkey_export_gost_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fprivkey_005fexport_005fpkcs8"><code>gnutls_x509_privkey_export_pkcs8</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fprivkey_005fexport_005frsa_005fraw"><code>gnutls_x509_privkey_export_rsa_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fprivkey_005fexport_005frsa_005fraw2"><code>gnutls_x509_privkey_export_rsa_raw2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fprivkey_005ffix"><code>gnutls_x509_privkey_fix</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fprivkey_005fgenerate"><code>gnutls_x509_privkey_generate</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fprivkey_005fgenerate2"><code>gnutls_x509_privkey_generate2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fprivkey_005fget_005fkey_005fid"><code>gnutls_x509_privkey_get_key_id</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fprivkey_005fget_005fpk_005falgorithm"><code>gnutls_x509_privkey_get_pk_algorithm</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fprivkey_005fget_005fpk_005falgorithm2"><code>gnutls_x509_privkey_get_pk_algorithm2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fprivkey_005fget_005fseed"><code>gnutls_x509_privkey_get_seed</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fprivkey_005fget_005fspki"><code>gnutls_x509_privkey_get_spki</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fprivkey_005fimport"><code>gnutls_x509_privkey_import</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fprivkey_005fimport2"><code>gnutls_x509_privkey_import2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Managing-encrypted-keys">Managing encrypted keys</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fprivkey_005fimport2-1"><code>gnutls_x509_privkey_import2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fprivkey_005fimport_005fdsa_005fraw"><code>gnutls_x509_privkey_import_dsa_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fprivkey_005fimport_005fecc_005fraw"><code>gnutls_x509_privkey_import_ecc_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fprivkey_005fimport_005fgost_005fraw"><code>gnutls_x509_privkey_import_gost_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fprivkey_005fimport_005fopenssl"><code>gnutls_x509_privkey_import_openssl</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Managing-encrypted-keys">Managing encrypted keys</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fprivkey_005fimport_005fopenssl-1"><code>gnutls_x509_privkey_import_openssl</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fprivkey_005fimport_005fpkcs8"><code>gnutls_x509_privkey_import_pkcs8</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fprivkey_005fimport_005frsa_005fraw"><code>gnutls_x509_privkey_import_rsa_raw</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fprivkey_005fimport_005frsa_005fraw2"><code>gnutls_x509_privkey_import_rsa_raw2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fprivkey_005finit"><code>gnutls_x509_privkey_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fprivkey_005fsec_005fparam"><code>gnutls_x509_privkey_sec_param</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fprivkey_005fset_005fflags"><code>gnutls_x509_privkey_set_flags</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fprivkey_005fset_005fpin_005ffunction"><code>gnutls_x509_privkey_set_pin_function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fprivkey_005fset_005fspki"><code>gnutls_x509_privkey_set_spki</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fprivkey_005fsign_005fdata"><code>gnutls_x509_privkey_sign_data</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fprivkey_005fsign_005fhash"><code>gnutls_x509_privkey_sign_hash</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Compatibility-API">Compatibility API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fprivkey_005fverify_005fparams"><code>gnutls_x509_privkey_verify_params</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fprivkey_005fverify_005fseed"><code>gnutls_x509_privkey_verify_seed</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005frdn_005fget"><code>gnutls_x509_rdn_get</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005frdn_005fget2"><code>gnutls_x509_rdn_get2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005frdn_005fget_005fby_005foid"><code>gnutls_x509_rdn_get_by_oid</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005frdn_005fget_005foid"><code>gnutls_x509_rdn_get_oid</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fspki_005fdeinit"><code>gnutls_x509_spki_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fspki_005fget_005frsa_005fpss_005fparams"><code>gnutls_x509_spki_get_rsa_pss_params</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fspki_005finit"><code>gnutls_x509_spki_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005fspki_005fset_005frsa_005fpss_005fparams"><code>gnutls_x509_spki_set_rsa_pss_params</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005ftlsfeatures_005fadd"><code>gnutls_x509_tlsfeatures_add</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005ftlsfeatures_005fcheck_005fcrt"><code>gnutls_x509_tlsfeatures_check_crt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005ftlsfeatures_005fdeinit"><code>gnutls_x509_tlsfeatures_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005ftlsfeatures_005fget"><code>gnutls_x509_tlsfeatures_get</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005ftlsfeatures_005finit"><code>gnutls_x509_tlsfeatures_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005ftrust_005flist_005fadd_005fcas"><code>gnutls_x509_trust_list_add_cas</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Verifying-X_002e509-certificate-paths">Verifying X.509 certificate paths</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005ftrust_005flist_005fadd_005fcas-1"><code>gnutls_x509_trust_list_add_cas</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005ftrust_005flist_005fadd_005fcrls"><code>gnutls_x509_trust_list_add_crls</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Verifying-X_002e509-certificate-paths">Verifying X.509 certificate paths</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005ftrust_005flist_005fadd_005fcrls-1"><code>gnutls_x509_trust_list_add_crls</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005ftrust_005flist_005fadd_005fnamed_005fcrt"><code>gnutls_x509_trust_list_add_named_crt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Verifying-X_002e509-certificate-paths">Verifying X.509 certificate paths</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005ftrust_005flist_005fadd_005fnamed_005fcrt-1"><code>gnutls_x509_trust_list_add_named_crt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005ftrust_005flist_005fadd_005fsystem_005ftrust"><code>gnutls_x509_trust_list_add_system_trust</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Verifying-X_002e509-certificate-paths">Verifying X.509 certificate paths</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005ftrust_005flist_005fadd_005fsystem_005ftrust-1"><code>gnutls_x509_trust_list_add_system_trust</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005ftrust_005flist_005fadd_005ftrust_005fdir"><code>gnutls_x509_trust_list_add_trust_dir</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005ftrust_005flist_005fadd_005ftrust_005ffile"><code>gnutls_x509_trust_list_add_trust_file</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Verifying-X_002e509-certificate-paths">Verifying X.509 certificate paths</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005ftrust_005flist_005fadd_005ftrust_005ffile-1"><code>gnutls_x509_trust_list_add_trust_file</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005ftrust_005flist_005fadd_005ftrust_005fmem"><code>gnutls_x509_trust_list_add_trust_mem</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Verifying-X_002e509-certificate-paths">Verifying X.509 certificate paths</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005ftrust_005flist_005fadd_005ftrust_005fmem-1"><code>gnutls_x509_trust_list_add_trust_mem</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005ftrust_005flist_005fdeinit"><code>gnutls_x509_trust_list_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005ftrust_005flist_005fget_005fissuer"><code>gnutls_x509_trust_list_get_issuer</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005ftrust_005flist_005fget_005fissuer_005fby_005fdn"><code>gnutls_x509_trust_list_get_issuer_by_dn</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005ftrust_005flist_005fget_005fissuer_005fby_005fsubject_005fkey_005fid"><code>gnutls_x509_trust_list_get_issuer_by_subject_key_id</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005ftrust_005flist_005finit"><code>gnutls_x509_trust_list_init</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005ftrust_005flist_005fiter_005fdeinit"><code>gnutls_x509_trust_list_iter_deinit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005ftrust_005flist_005fiter_005fget_005fca"><code>gnutls_x509_trust_list_iter_get_ca</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005ftrust_005flist_005fremove_005fcas"><code>gnutls_x509_trust_list_remove_cas</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005ftrust_005flist_005fremove_005ftrust_005ffile"><code>gnutls_x509_trust_list_remove_trust_file</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005ftrust_005flist_005fremove_005ftrust_005fmem"><code>gnutls_x509_trust_list_remove_trust_mem</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005ftrust_005flist_005fverify_005fcrt"><code>gnutls_x509_trust_list_verify_crt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Verifying-X_002e509-certificate-paths">Verifying X.509 certificate paths</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005ftrust_005flist_005fverify_005fcrt-1"><code>gnutls_x509_trust_list_verify_crt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005ftrust_005flist_005fverify_005fcrt2"><code>gnutls_x509_trust_list_verify_crt2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Verifying-X_002e509-certificate-paths">Verifying X.509 certificate paths</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005ftrust_005flist_005fverify_005fcrt2-1"><code>gnutls_x509_trust_list_verify_crt2</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005ftrust_005flist_005fverify_005fnamed_005fcrt"><code>gnutls_x509_trust_list_verify_named_crt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Verifying-X_002e509-certificate-paths">Verifying X.509 certificate paths</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fx509_005ftrust_005flist_005fverify_005fnamed_005fcrt-1"><code>gnutls_x509_trust_list_verify_named_crt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
</table>
<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Function-and-Data-Index_fn_letter-D"><b>D</b></a>
 &nbsp; 
<a class="summary-letter" href="#Function-and-Data-Index_fn_letter-G"><b>G</b></a>
 &nbsp; 
</td></tr></table>

<hr>
<span id="Concept-Index"></span><div class="header">
<p>
Previous: <a href="#Function-and-Data-Index" accesskey="p" rel="prev">Function and Data Index</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-and-Data-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Concept-Index-1"></span><h2 class="unnumbered">Concept Index</h2>

<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Concept-Index_cp_letter-A"><b>A</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-B"><b>B</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-C"><b>C</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-D"><b>D</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-E"><b>E</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-F"><b>F</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-G"><b>G</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-H"><b>H</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-I"><b>I</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-K"><b>K</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-M"><b>M</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-O"><b>O</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-P"><b>P</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-R"><b>R</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-S"><b>S</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-T"><b>T</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-U"><b>U</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-V"><b>V</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-X"><b>X</b></a>
 &nbsp; 
</td></tr></table>
<table class="index-cp" border="0">
<tr><td></td><th align="left">Index Entry</th><td>&nbsp;</td><th align="left"> Section</th></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Concept-Index_cp_letter-A">A</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-abstract-types">abstract types</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstract-key-types">Abstract key types</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-alert-protocol">alert protocol</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-TLS-Alert-Protocol">The TLS Alert Protocol</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ALPN">ALPN</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Application-Layer-Protocol-Negotiation-_0028ALPN_0029">Application Layer Protocol Negotiation (ALPN)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-anonymous-authentication">anonymous authentication</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Anonymous-authentication">Anonymous authentication</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-API-reference">API reference</a>:</td><td>&nbsp;</td><td valign="top"><a href="#API-reference">API reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Application-Layer-Protocol-Negotiation">Application Layer Protocol Negotiation</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Application-Layer-Protocol-Negotiation-_0028ALPN_0029">Application Layer Protocol Negotiation (ALPN)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Application_002dspecific-keys">Application-specific keys</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Application_002dspecific-keys">Application-specific keys</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-authentication-methods">authentication methods</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Authentication-methods">Authentication methods</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Concept-Index_cp_letter-B">B</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-bad_005frecord_005fmac">bad_record_mac</a>:</td><td>&nbsp;</td><td valign="top"><a href="#On-Record-Padding">On Record Padding</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Concept-Index_cp_letter-C">C</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-callback-functions">callback functions</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Callback-functions">Callback functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-certificate-authentication">certificate authentication</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Certificate-authentication">Certificate authentication</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-certificate-authentication-1">certificate authentication</a>:</td><td>&nbsp;</td><td valign="top"><a href="#More-on-certificate-authentication">More on certificate authentication</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-certificate-requests">certificate requests</a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-10-certificate-requests">PKCS 10 certificate requests</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-certificate-revocation-lists">certificate revocation lists</a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKIX-certificate-revocation-lists">PKIX certificate revocation lists</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-certificate-status">certificate status</a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-certificate-status-checking">OCSP certificate status checking</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-certificate-status-1">certificate status</a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-stapling">OCSP stapling</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Certificate-status-request">Certificate status request</a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-status-request">OCSP status request</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Certificate-verification">Certificate verification</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Advanced-certificate-verification">Advanced certificate verification</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-certification">certification</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Certification">Certification</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-certtool"><code>certtool</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#certtool-Invocation">certtool Invocation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-certtool-help">certtool help</a>:</td><td>&nbsp;</td><td valign="top"><a href="#certtool-Invocation">certtool Invocation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-channel-bindings">channel bindings</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Channel-Bindings">Channel Bindings</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ciphersuites">ciphersuites</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Supported-ciphersuites">Supported ciphersuites</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-client-certificate-authentication">client certificate authentication</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Client-Authentication">Client Authentication</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CMS">CMS</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-Message-Syntax-_002f-PKCS7">Cryptographic Message Syntax / PKCS7</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-compression-algorithms">compression algorithms</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Compression-algorithms-and-the-record-layer">Compression algorithms and the record layer</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-contributing">contributing</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Contributing">Contributing</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-credentials">credentials</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Virtual-hosts-and-credentials">Virtual hosts and credentials</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CRL">CRL</a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKIX-certificate-revocation-lists">PKIX certificate revocation lists</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cryptographic-message-syntax">cryptographic message syntax</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-Message-Syntax-_002f-PKCS7">Cryptographic Message Syntax / PKCS7</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Concept-Index_cp_letter-D">D</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-DANE">DANE</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Verifying-a-certificate-using-DANE">Verifying a certificate using DANE</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-DANE-1">DANE</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Certificate-verification">Certificate verification</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-danetool"><code>danetool</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#danetool-Invocation">danetool Invocation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-danetool-help">danetool help</a>:</td><td>&nbsp;</td><td valign="top"><a href="#danetool-Invocation">danetool Invocation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-deriving-keys">deriving keys</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Deriving-keys-for-other-applications_002fprotocols">Deriving keys for other applications/protocols</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-digital-signatures">digital signatures</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Digital-signatures">Digital signatures</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-DNSSEC">DNSSEC</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Verifying-a-certificate-using-DANE">Verifying a certificate using DANE</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-DNSSEC-1">DNSSEC</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Certificate-verification">Certificate verification</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-download">download</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Downloading-and-installing">Downloading and installing</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Concept-Index_cp_letter-E">E</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Encrypted-keys">Encrypted keys</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Managing-encrypted-keys">Managing encrypted keys</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-error-codes">error codes</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Error-codes">Error codes</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-example-programs">example programs</a>:</td><td>&nbsp;</td><td valign="top"><a href="#GnuTLS-application-examples">GnuTLS application examples</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-examples">examples</a>:</td><td>&nbsp;</td><td valign="top"><a href="#GnuTLS-application-examples">GnuTLS application examples</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-exporting-keying-material">exporting keying material</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Deriving-keys-for-other-applications_002fprotocols">Deriving keys for other applications/protocols</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Concept-Index_cp_letter-F">F</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-False-Start">False Start</a>:</td><td>&nbsp;</td><td valign="top"><a href="#False-Start">False Start</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-FDL_002c-GNU-Free-Documentation-License">FDL, GNU Free Documentation License</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Copying-Information">Copying Information</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-file-signing">file signing</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-Message-Syntax-_002f-PKCS7">Cryptographic Message Syntax / PKCS7</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-fork">fork</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Sessions-and-fork">Sessions and fork</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Concept-Index_cp_letter-G">G</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-generating-parameters">generating parameters</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Parameter-generation">Parameter generation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-giovec_005ft">giovec_t</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Common-types">Common types</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_002dcli"><code>gnutls-cli</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#gnutls_002dcli-Invocation">gnutls-cli Invocation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_002dcli-help">gnutls-cli help</a>:</td><td>&nbsp;</td><td valign="top"><a href="#gnutls_002dcli-Invocation">gnutls-cli Invocation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_002dcli_002ddebug"><code>gnutls-cli-debug</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#gnutls_002dcli_002ddebug-Invocation">gnutls-cli-debug Invocation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_002dcli_002ddebug-help">gnutls-cli-debug help</a>:</td><td>&nbsp;</td><td valign="top"><a href="#gnutls_002dcli_002ddebug-Invocation">gnutls-cli-debug Invocation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_002dserv"><code>gnutls-serv</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#gnutls_002dserv-Invocation">gnutls-serv Invocation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_002dserv-help">gnutls-serv help</a>:</td><td>&nbsp;</td><td valign="top"><a href="#gnutls_002dserv-Invocation">gnutls-serv Invocation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gnutls_005fdatum_005ft">gnutls_datum_t</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Common-types">Common types</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Concept-Index_cp_letter-H">H</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-hacking">hacking</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Contributing">Contributing</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-handshake-protocol">handshake protocol</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-TLS-Handshake-Protocol">The TLS Handshake Protocol</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-hardware-security-modules">hardware security modules</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Smart-cards-and-HSMs">Smart cards and HSMs</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-hardware-tokens">hardware tokens</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Smart-cards-and-HSMs">Smart cards and HSMs</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-hash-functions">hash functions</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Hash-and-MAC-functions">Hash and MAC functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-heartbeat">heartbeat</a>:</td><td>&nbsp;</td><td valign="top"><a href="#HeartBeat">HeartBeat</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-HMAC-functions">HMAC functions</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Hash-and-MAC-functions">Hash and MAC functions</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Concept-Index_cp_letter-I">I</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-installation">installation</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Downloading-and-installing">Downloading and installing</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-installation-1">installation</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Installing-for-a-software-distribution">Installing for a software distribution</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-internal-architecture">internal architecture</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Internal-architecture-of-GnuTLS">Internal architecture of GnuTLS</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-isolated-mode">isolated mode</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Running-in-a-sandbox">Running in a sandbox</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Concept-Index_cp_letter-K">K</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-key-extraction">key extraction</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Deriving-keys-for-other-applications_002fprotocols">Deriving keys for other applications/protocols</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Key-pinning">Key pinning</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Verifying-a-certificate-using-trust-on-first-use-authentication">Verifying a certificate using trust on first use authentication</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Key-pinning-1">Key pinning</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Certificate-verification">Certificate verification</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-key-sizes">key sizes</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Selecting-cryptographic-key-sizes">Selecting cryptographic key sizes</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-keying-material-exporters">keying material exporters</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Deriving-keys-for-other-applications_002fprotocols">Deriving keys for other applications/protocols</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Concept-Index_cp_letter-M">M</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-MAC-functions">MAC functions</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Hash-and-MAC-functions">Hash and MAC functions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-maximum-fragment-length">maximum fragment length</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Maximum-fragment-length-negotiation">Maximum fragment length negotiation</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Concept-Index_cp_letter-O">O</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-OCSP">OCSP</a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-certificate-status-checking">OCSP certificate status checking</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-OCSP-Functions">OCSP Functions</a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-API">OCSP API</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-OCSP-stapling">OCSP stapling</a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-stapling">OCSP stapling</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-OCSP-status-request">OCSP status request</a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-status-request">OCSP status request</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ocsptool"><code>ocsptool</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ocsptool-Invocation">ocsptool Invocation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ocsptool-help">ocsptool help</a>:</td><td>&nbsp;</td><td valign="top"><a href="#ocsptool-Invocation">ocsptool Invocation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Online-Certificate-Status-Protocol">Online Certificate Status Protocol</a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-certificate-status-checking">OCSP certificate status checking</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Online-Certificate-Status-Protocol-1">Online Certificate Status Protocol</a>:</td><td>&nbsp;</td><td valign="top"><a href="#OCSP-stapling">OCSP stapling</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-OpenPGP-certificates">OpenPGP certificates</a>:</td><td>&nbsp;</td><td valign="top"><a href="#OpenPGP-certificates">OpenPGP certificates</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-OpenSSL">OpenSSL</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Compatibility-with-the-OpenSSL-library">Compatibility with the OpenSSL library</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-OpenSSL-encrypted-keys">OpenSSL encrypted keys</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Managing-encrypted-keys">Managing encrypted keys</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-overriding-algorithms">overriding algorithms</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Overriding-algorithms">Overriding algorithms</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Concept-Index_cp_letter-P">P</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-p11tool"><code>p11tool</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#p11tool-Invocation">p11tool Invocation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-p11tool-help">p11tool help</a>:</td><td>&nbsp;</td><td valign="top"><a href="#p11tool-Invocation">p11tool Invocation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-parameter-generation">parameter generation</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Parameter-generation">Parameter generation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-PCT">PCT</a>:</td><td>&nbsp;</td><td valign="top"><a href="#On-SSL-2-and-older-protocols">On SSL 2 and older protocols</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-PKCS-_002310">PKCS #10</a>:</td><td>&nbsp;</td><td valign="top"><a href="#PKCS-10-certificate-requests">PKCS 10 certificate requests</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-PKCS-_002311-tokens">PKCS #11 tokens</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Smart-cards-and-HSMs">Smart cards and HSMs</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-PKCS-_002312">PKCS #12</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Managing-encrypted-keys">Managing encrypted keys</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-PKCS-_00237">PKCS #7</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-Message-Syntax-_002f-PKCS7">Cryptographic Message Syntax / PKCS7</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-PKCS-_00238">PKCS #8</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Managing-encrypted-keys">Managing encrypted keys</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-post_002dhandshake-authentication">post-handshake authentication</a>:</td><td>&nbsp;</td><td valign="top"><a href="#TLS-1_002e3-re_002dauthentication-and-re_002dkey">TLS 1.3 re-authentication and re-key</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Priority-strings">Priority strings</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Priority-Strings">Priority Strings</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-PSK-authentication">PSK authentication</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Authentication-using-PSK">Authentication using PSK</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-psktool"><code>psktool</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#psktool-Invocation">psktool Invocation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-psktool-help">psktool help</a>:</td><td>&nbsp;</td><td valign="top"><a href="#psktool-Invocation">psktool Invocation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-public-key-algorithms">public key algorithms</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Public-key-algorithms">Public key algorithms</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-public-key-algorithms-1">public key algorithms</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Cryptographic-Message-Syntax-_002f-PKCS7">Cryptographic Message Syntax / PKCS7</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Concept-Index_cp_letter-R">R</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-random-numbers">random numbers</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Random-number-generation">Random number generation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Raw-public_002dkeys">Raw public-keys</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Raw-public_002dkeys">Raw public-keys</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-re_002dauthentication">re-authentication</a>:</td><td>&nbsp;</td><td valign="top"><a href="#TLS-1_002e2-re_002dauthentication">TLS 1.2 re-authentication</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-re_002dauthentication-1">re-authentication</a>:</td><td>&nbsp;</td><td valign="top"><a href="#TLS-1_002e3-re_002dauthentication-and-re_002dkey">TLS 1.3 re-authentication and re-key</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-re_002dkey">re-key</a>:</td><td>&nbsp;</td><td valign="top"><a href="#TLS-1_002e3-re_002dauthentication-and-re_002dkey">TLS 1.3 re-authentication and re-key</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-re_002dnegotiation">re-negotiation</a>:</td><td>&nbsp;</td><td valign="top"><a href="#TLS-1_002e2-re_002dauthentication">TLS 1.2 re-authentication</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-re_002dnegotiation-1">re-negotiation</a>:</td><td>&nbsp;</td><td valign="top"><a href="#TLS-1_002e3-re_002dauthentication-and-re_002dkey">TLS 1.3 re-authentication and re-key</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-record-padding">record padding</a>:</td><td>&nbsp;</td><td valign="top"><a href="#On-Record-Padding">On Record Padding</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-record-protocol">record protocol</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-TLS-record-protocol">The TLS record protocol</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-renegotiation">renegotiation</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Safe-renegotiation">Safe renegotiation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-reporting-bugs">reporting bugs</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Bug-Reports">Bug Reports</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-resuming-sessions">resuming sessions</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Resuming-Sessions">Resuming Sessions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-resuming-sessions-1">resuming sessions</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Session-resumption">Session resumption</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Concept-Index_cp_letter-S">S</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-safe-renegotiation">safe renegotiation</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Safe-renegotiation">Safe renegotiation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-seccomp">seccomp</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Running-in-a-sandbox">Running in a sandbox</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Secure-RTP">Secure RTP</a>:</td><td>&nbsp;</td><td valign="top"><a href="#SRTP">SRTP</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-server-name-indication">server name indication</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Server-name-indication">Server name indication</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-session-resumption">session resumption</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Resuming-Sessions">Resuming Sessions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-session-resumption-1">session resumption</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Session-resumption">Session resumption</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-session-tickets">session tickets</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Session-tickets">Session tickets</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Smart-card-example">Smart card example</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Client-using-a-smart-card-with-TLS">Client using a smart card with TLS</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-smart-cards">smart cards</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Smart-cards-and-HSMs">Smart cards and HSMs</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SRP-authentication">SRP authentication</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Authentication-using-SRP">Authentication using SRP</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-srptool"><code>srptool</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#srptool-Invocation">srptool Invocation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-srptool-help">srptool help</a>:</td><td>&nbsp;</td><td valign="top"><a href="#srptool-Invocation">srptool Invocation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SRTP">SRTP</a>:</td><td>&nbsp;</td><td valign="top"><a href="#SRTP">SRTP</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SSH_002dstyle-authentication">SSH-style authentication</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Verifying-a-certificate-using-trust-on-first-use-authentication">Verifying a certificate using trust on first use authentication</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SSH_002dstyle-authentication-1">SSH-style authentication</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Certificate-verification">Certificate verification</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SSL-2">SSL 2</a>:</td><td>&nbsp;</td><td valign="top"><a href="#On-SSL-2-and-older-protocols">On SSL 2 and older protocols</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Supplemental-data">Supplemental data</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Extensions-and-Supplemental-Data">Extensions and Supplemental Data</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-symmetric-algorithms">symmetric algorithms</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Symmetric-algorithms">Symmetric algorithms</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-symmetric-cryptography">symmetric cryptography</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Symmetric-algorithms">Symmetric algorithms</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-symmetric-encryption-algorithms">symmetric encryption algorithms</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Encryption-algorithms-used-in-the-record-layer">Encryption algorithms used in the record layer</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-System_002dspecific-keys">System-specific keys</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Application_002dspecific-keys">Application-specific keys</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-System_002dwide-configuration">System-wide configuration</a>:</td><td>&nbsp;</td><td valign="top"><a href="#System_002dwide-configuration-of-the-library">System-wide configuration of the library</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Concept-Index_cp_letter-T">T</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-thread-safety">thread safety</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Thread-safety">Thread safety</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-tickets">tickets</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Session-tickets">Session tickets</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-TLS-extensions">TLS extensions</a>:</td><td>&nbsp;</td><td valign="top"><a href="#TLS-Extensions">TLS Extensions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-TLS-extensions-1">TLS extensions</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Maximum-fragment-length-negotiation">Maximum fragment length negotiation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-TLS-extensions-2">TLS extensions</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Server-name-indication">Server name indication</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-TLS-extensions-3">TLS extensions</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Session-tickets">Session tickets</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-TLS-extensions-4">TLS extensions</a>:</td><td>&nbsp;</td><td valign="top"><a href="#HeartBeat">HeartBeat</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-TLS-False-Start">TLS False Start</a>:</td><td>&nbsp;</td><td valign="top"><a href="#False-Start">False Start</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-TLS-layers">TLS layers</a>:</td><td>&nbsp;</td><td valign="top"><a href="#TLS-layers">TLS layers</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-TPM">TPM</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trusted-Platform-Module">Trusted Platform Module</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-tpmtool"><code>tpmtool</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#tpmtool-Invocation">tpmtool Invocation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-tpmtool-help">tpmtool help</a>:</td><td>&nbsp;</td><td valign="top"><a href="#tpmtool-Invocation">tpmtool Invocation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-transport-layer">transport layer</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-transport-layer">The transport layer</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-transport-protocol">transport protocol</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-transport-layer">The transport layer</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Trust-on-first-use">Trust on first use</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Verifying-a-certificate-using-trust-on-first-use-authentication">Verifying a certificate using trust on first use authentication</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Trust-on-first-use-1">Trust on first use</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Certificate-verification">Certificate verification</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-trusted-platform-module">trusted platform module</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trusted-Platform-Module">Trusted Platform Module</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Concept-Index_cp_letter-U">U</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-upgrading">upgrading</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Upgrading-from-previous-versions">Upgrading from previous versions</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Concept-Index_cp_letter-V">V</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-verifying-certificate-paths">verifying certificate paths</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Verifying-X_002e509-certificate-paths">Verifying X.509 certificate paths</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-verifying-certificate-paths-1">verifying certificate paths</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Verifying-a-certificate-in-the-context-of-TLS-session">Verifying a certificate in the context of TLS session</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-verifying-certificate-paths-2">verifying certificate paths</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Verifying-a-certificate-using-trust-on-first-use-authentication">Verifying a certificate using trust on first use authentication</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-verifying-certificate-paths-3">verifying certificate paths</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Verifying-a-certificate-using-DANE">Verifying a certificate using DANE</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-verifying-certificate-with-pkcs11">verifying certificate with pkcs11</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Verification-using-PKCS11">Verification using PKCS11</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-virtual-hosts">virtual hosts</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Virtual-hosts-and-credentials">Virtual hosts and credentials</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Concept-Index_cp_letter-X">X</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-X_002e509-certificate-name">X.509 certificate name</a>:</td><td>&nbsp;</td><td valign="top"><a href="#X_002e509-certificate-names">X.509 certificate names</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-X_002e509-certificates">X.509 certificates</a>:</td><td>&nbsp;</td><td valign="top"><a href="#X_002e509-certificates">X.509 certificates</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-X_002e509-distinguished-name">X.509 distinguished name</a>:</td><td>&nbsp;</td><td valign="top"><a href="#X_002e509-distinguished-names">X.509 distinguished names</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-X_002e509-extensions">X.509 extensions</a>:</td><td>&nbsp;</td><td valign="top"><a href="#X_002e509-extensions">X.509 extensions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-X_002e509-Functions">X.509 Functions</a>:</td><td>&nbsp;</td><td valign="top"><a href="#X509-certificate-API">X509 certificate API</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
</table>
<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Concept-Index_cp_letter-A"><b>A</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-B"><b>B</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-C"><b>C</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-D"><b>D</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-E"><b>E</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-F"><b>F</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-G"><b>G</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-H"><b>H</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-I"><b>I</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-K"><b>K</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-M"><b>M</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-O"><b>O</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-P"><b>P</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-R"><b>R</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-S"><b>S</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-T"><b>T</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-U"><b>U</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-V"><b>V</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-X"><b>X</b></a>
 &nbsp; 
</td></tr></table>

<div class="footnote">
<hr>
<h4 class="footnotes-heading">Footnotes</h4>

<h3><a id="FOOT1" href="#DOCF1">(1)</a></h3>
<p>Needed
to use RFC6125 name comparison in internationalized domains.</p>
<h3><a id="FOOT2" href="#DOCF2">(2)</a></h3>
<p><a href="https://p11-glue.github.io/p11-glue/trust-module.html">https://p11-glue.github.io/p11-glue/trust-module.html</a></p>
<h3><a id="FOOT3" href="#DOCF3">(3)</a></h3>
<p>IETF, or Internet Engineering Task Force,
is a large open international community of network designers,
operators, vendors, and researchers concerned with the evolution of
the Internet architecture and the smooth operation of the Internet.
It is open to any interested individual.</p>
<h3><a id="FOOT4" href="#DOCF4">(4)</a></h3>
<p>In early versions of TLS compression was optionally
available as well. This is no longer the case in recent versions of the
protocol.</p>
<h3><a id="FOOT5" href="#DOCF5">(5)</a></h3>
<p>MAC stands for Message Authentication Code. It can be described as a keyed hash algorithm. See RFC2104.</p>
<h3><a id="FOOT6" href="#DOCF6">(6)</a></h3>
<p>See also the Server Name Indication extension on
<a href="#serverind">serverind</a>.</p>
<h3><a id="FOOT7" href="#DOCF7">(7)</a></h3>
<p>See LDAP, IMAP etc.</p>
<h3><a id="FOOT8" href="#DOCF8">(8)</a></h3>
<p>see <a href="https://p11-glue.github.io/p11-glue/trust-module.html">https://p11-glue.github.io/p11-glue/trust-module.html</a>.</p>
<h3><a id="FOOT9" href="#DOCF9">(9)</a></h3>
<p>For example, OpenSC-supported cards.</p>
<h3><a id="FOOT10" href="#DOCF10">(10)</a></h3>
<p><a href="https://p11-glue.github.io/p11-glue/p11-kit.html">https://p11-glue.github.io/p11-glue/p11-kit.html</a></p>
<h3><a id="FOOT11" href="#DOCF11">(11)</a></h3>
<p>For
example when an open session is to be reinitialized, but the PIN is not available
to GnuTLS (e.g., it was entered at a pinpad).</p>
<h3><a id="FOOT12" href="#DOCF12">(12)</a></h3>
<p><a href="https://p11-glue.github.io/p11-glue/trust-module.html">https://p11-glue.github.io/p11-glue/trust-module.html</a></p>
<h3><a id="FOOT13" href="#DOCF13">(13)</a></h3>
<p>See
the &rsquo;Restricting the scope of CA certificates&rsquo; post at <a href="https://nmav.gnutls.org/2016/06/restricting-scope-of-ca-certificates.html">https://nmav.gnutls.org/2016/06/restricting-scope-of-ca-certificates.html</a></p>
<h3><a id="FOOT14" href="#DOCF14">(14)</a></h3>
<p><a href="https://github.com/google/chaps-linux">https://github.com/google/chaps-linux</a></p>
<h3><a id="FOOT15" href="#DOCF15">(15)</a></h3>
<p><a href="https://sourceforge.net/projects/opencryptoki/">https://sourceforge.net/projects/opencryptoki/</a></p>
<h3><a id="FOOT16" href="#DOCF16">(16)</a></h3>
<p>The first message in a <acronym>TLS</acronym> handshake</p>
<h3><a id="FOOT17" href="#DOCF17">(17)</a></h3>
<p>On special systems
you could manually specify the locking system using
the function <a href="#gnutls_005fglobal_005fset_005fmutex">gnutls_global_set_mutex</a> before calling any other
GnuTLS function. Setting mutexes manually is not recommended.</p>
<h3><a id="FOOT18" href="#DOCF18">(18)</a></h3>
<p>The original behavior of requiring explicit initialization can obtained by setting the
GNUTLS_NO_EXPLICIT_INIT environment variable to 1, or by using the macro GNUTLS_SKIP_GLOBAL_INIT
in a global section of your program &ndash;the latter works in systems with
support for weak symbols only.</p>
<h3><a id="FOOT19" href="#DOCF19">(19)</a></h3>
<p>A key of 128 bits or 16 bytes should be sufficient for this purpose.</p>
<h3><a id="FOOT20" href="#DOCF20">(20)</a></h3>
<p>It depends on the group in use.  Groups with
less bits are always faster, but the number of bits ties with the security
parameter.  See <a href="#Selecting-cryptographic-key-sizes">Selecting cryptographic key sizes</a>
for the acceptable security levels.</p>
<h3><a id="FOOT21" href="#DOCF21">(21)</a></h3>
<p>See <a href="https://www.lysator.liu.se/~nisse/nettle/">https://www.lysator.liu.se/~nisse/nettle/</a>.</p>
<h3><a id="FOOT22" href="#DOCF22">(22)</a></h3>
<p>See the nettle manual <a href="https://www.lysator.liu.se/~nisse/nettle/nettle.html">https://www.lysator.liu.se/~nisse/nettle/nettle.html</a></p>
<h3><a id="FOOT23" href="#DOCF23">(23)</a></h3>
<p>such as the
<code>gnutls_certificate_credentials_t</code> structures</p>
<h3><a id="FOOT24" href="#DOCF24">(24)</a></h3>
<p>See
<a href="https://lists.gnu.org/archive/html/gnutls-devel/2011-02/msg00079.html">https://lists.gnu.org/archive/html/gnutls-devel/2011-02/msg00079.html</a>.</p>
<h3><a id="FOOT25" href="#DOCF25">(25)</a></h3>
<p>Check <a href="https://home.gna.org/cryptodev-linux/">https://home.gna.org/cryptodev-linux/</a>
for the Linux kernel implementation of <code>/dev/crypto</code>.</p>
</div>
<hr>



</body>
</html>
